import "./chunk-5WRI5ZAA.js";

// node_modules/dddice-js/dddice-latest.web.mjs
var t = { 7526: (t6, e2) => {
  e2.byteLength = function(t7) {
    var e3 = a2(t7), i3 = e3[0], n3 = e3[1];
    return 3 * (i3 + n3) / 4 - n3;
  }, e2.toByteArray = function(t7) {
    var e3, i3, s3 = a2(t7), o3 = s3[0], l3 = s3[1], c2 = new r2((function(t8, e4, i4) {
      return 3 * (e4 + i4) / 4 - i4;
    })(0, o3, l3)), h2 = 0, u2 = l3 > 0 ? o3 - 4 : o3;
    for (i3 = 0; i3 < u2; i3 += 4) e3 = n2[t7.charCodeAt(i3)] << 18 | n2[t7.charCodeAt(i3 + 1)] << 12 | n2[t7.charCodeAt(i3 + 2)] << 6 | n2[t7.charCodeAt(i3 + 3)], c2[h2++] = e3 >> 16 & 255, c2[h2++] = e3 >> 8 & 255, c2[h2++] = 255 & e3;
    2 === l3 && (e3 = n2[t7.charCodeAt(i3)] << 2 | n2[t7.charCodeAt(i3 + 1)] >> 4, c2[h2++] = 255 & e3);
    1 === l3 && (e3 = n2[t7.charCodeAt(i3)] << 10 | n2[t7.charCodeAt(i3 + 1)] << 4 | n2[t7.charCodeAt(i3 + 2)] >> 2, c2[h2++] = e3 >> 8 & 255, c2[h2++] = 255 & e3);
    return c2;
  }, e2.fromByteArray = function(t7) {
    for (var e3, n3 = t7.length, r3 = n3 % 3, s3 = [], o3 = 16383, a3 = 0, c2 = n3 - r3; a3 < c2; a3 += o3) s3.push(l2(t7, a3, a3 + o3 > c2 ? c2 : a3 + o3));
    1 === r3 ? (e3 = t7[n3 - 1], s3.push(i2[e3 >> 2] + i2[e3 << 4 & 63] + "==")) : 2 === r3 && (e3 = (t7[n3 - 2] << 8) + t7[n3 - 1], s3.push(i2[e3 >> 10] + i2[e3 >> 4 & 63] + i2[e3 << 2 & 63] + "="));
    return s3.join("");
  };
  for (var i2 = [], n2 = [], r2 = "undefined" != typeof Uint8Array ? Uint8Array : Array, s2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", o2 = 0; o2 < 64; ++o2) i2[o2] = s2[o2], n2[s2.charCodeAt(o2)] = o2;
  function a2(t7) {
    var e3 = t7.length;
    if (e3 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var i3 = t7.indexOf("=");
    return -1 === i3 && (i3 = e3), [i3, i3 === e3 ? 0 : 4 - i3 % 4];
  }
  function l2(t7, e3, n3) {
    for (var r3, s3, o3 = [], a3 = e3; a3 < n3; a3 += 3) r3 = (t7[a3] << 16 & 16711680) + (t7[a3 + 1] << 8 & 65280) + (255 & t7[a3 + 2]), o3.push(i2[(s3 = r3) >> 18 & 63] + i2[s3 >> 12 & 63] + i2[s3 >> 6 & 63] + i2[63 & s3]);
    return o3.join("");
  }
  n2["-".charCodeAt(0)] = 62, n2["_".charCodeAt(0)] = 63;
}, 8287: (t6, e2, i2) => {
  var n2 = i2(7526), r2 = i2(251), s2 = i2(5336);
  function o2() {
    return l2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
  }
  function a2(t7, e3) {
    if (o2() < e3) throw new RangeError("Invalid typed array length");
    return l2.TYPED_ARRAY_SUPPORT ? (t7 = new Uint8Array(e3)).__proto__ = l2.prototype : (null === t7 && (t7 = new l2(e3)), t7.length = e3), t7;
  }
  function l2(t7, e3, i3) {
    if (!(l2.TYPED_ARRAY_SUPPORT || this instanceof l2)) return new l2(t7, e3, i3);
    if ("number" == typeof t7) {
      if ("string" == typeof e3) throw new Error("If encoding is specified then the first argument must be a string");
      return u2(this, t7);
    }
    return c2(this, t7, e3, i3);
  }
  function c2(t7, e3, i3, n3) {
    if ("number" == typeof e3) throw new TypeError('"value" argument must not be a number');
    return "undefined" != typeof ArrayBuffer && e3 instanceof ArrayBuffer ? (function(t8, e4, i4, n4) {
      if (e4.byteLength, i4 < 0 || e4.byteLength < i4) throw new RangeError("'offset' is out of bounds");
      if (e4.byteLength < i4 + (n4 || 0)) throw new RangeError("'length' is out of bounds");
      e4 = void 0 === i4 && void 0 === n4 ? new Uint8Array(e4) : void 0 === n4 ? new Uint8Array(e4, i4) : new Uint8Array(e4, i4, n4);
      l2.TYPED_ARRAY_SUPPORT ? (t8 = e4).__proto__ = l2.prototype : t8 = d2(t8, e4);
      return t8;
    })(t7, e3, i3, n3) : "string" == typeof e3 ? (function(t8, e4, i4) {
      "string" == typeof i4 && "" !== i4 || (i4 = "utf8");
      if (!l2.isEncoding(i4)) throw new TypeError('"encoding" must be a valid string encoding');
      var n4 = 0 | f2(e4, i4);
      t8 = a2(t8, n4);
      var r3 = t8.write(e4, i4);
      r3 !== n4 && (t8 = t8.slice(0, r3));
      return t8;
    })(t7, e3, i3) : (function(t8, e4) {
      if (l2.isBuffer(e4)) {
        var i4 = 0 | p2(e4.length);
        return 0 === (t8 = a2(t8, i4)).length || e4.copy(t8, 0, 0, i4), t8;
      }
      if (e4) {
        if ("undefined" != typeof ArrayBuffer && e4.buffer instanceof ArrayBuffer || "length" in e4) return "number" != typeof e4.length || (n4 = e4.length) != n4 ? a2(t8, 0) : d2(t8, e4);
        if ("Buffer" === e4.type && s2(e4.data)) return d2(t8, e4.data);
      }
      var n4;
      throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
    })(t7, e3);
  }
  function h2(t7) {
    if ("number" != typeof t7) throw new TypeError('"size" argument must be a number');
    if (t7 < 0) throw new RangeError('"size" argument must not be negative');
  }
  function u2(t7, e3) {
    if (h2(e3), t7 = a2(t7, e3 < 0 ? 0 : 0 | p2(e3)), !l2.TYPED_ARRAY_SUPPORT) for (var i3 = 0; i3 < e3; ++i3) t7[i3] = 0;
    return t7;
  }
  function d2(t7, e3) {
    var i3 = e3.length < 0 ? 0 : 0 | p2(e3.length);
    t7 = a2(t7, i3);
    for (var n3 = 0; n3 < i3; n3 += 1) t7[n3] = 255 & e3[n3];
    return t7;
  }
  function p2(t7) {
    if (t7 >= o2()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o2().toString(16) + " bytes");
    return 0 | t7;
  }
  function f2(t7, e3) {
    if (l2.isBuffer(t7)) return t7.length;
    if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(t7) || t7 instanceof ArrayBuffer)) return t7.byteLength;
    "string" != typeof t7 && (t7 = "" + t7);
    var i3 = t7.length;
    if (0 === i3) return 0;
    for (var n3 = false; ; ) switch (e3) {
      case "ascii":
      case "latin1":
      case "binary":
        return i3;
      case "utf8":
      case "utf-8":
      case void 0:
        return H2(t7).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return 2 * i3;
      case "hex":
        return i3 >>> 1;
      case "base64":
        return V2(t7).length;
      default:
        if (n3) return H2(t7).length;
        e3 = ("" + e3).toLowerCase(), n3 = true;
    }
  }
  function m2(t7, e3, i3) {
    var n3 = false;
    if ((void 0 === e3 || e3 < 0) && (e3 = 0), e3 > this.length) return "";
    if ((void 0 === i3 || i3 > this.length) && (i3 = this.length), i3 <= 0) return "";
    if ((i3 >>>= 0) <= (e3 >>>= 0)) return "";
    for (t7 || (t7 = "utf8"); ; ) switch (t7) {
      case "hex":
        return P2(this, e3, i3);
      case "utf8":
      case "utf-8":
        return E2(this, e3, i3);
      case "ascii":
        return C2(this, e3, i3);
      case "latin1":
      case "binary":
        return R2(this, e3, i3);
      case "base64":
        return T2(this, e3, i3);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return L2(this, e3, i3);
      default:
        if (n3) throw new TypeError("Unknown encoding: " + t7);
        t7 = (t7 + "").toLowerCase(), n3 = true;
    }
  }
  function g2(t7, e3, i3) {
    var n3 = t7[e3];
    t7[e3] = t7[i3], t7[i3] = n3;
  }
  function v2(t7, e3, i3, n3, r3) {
    if (0 === t7.length) return -1;
    if ("string" == typeof i3 ? (n3 = i3, i3 = 0) : i3 > 2147483647 ? i3 = 2147483647 : i3 < -2147483648 && (i3 = -2147483648), i3 = +i3, isNaN(i3) && (i3 = r3 ? 0 : t7.length - 1), i3 < 0 && (i3 = t7.length + i3), i3 >= t7.length) {
      if (r3) return -1;
      i3 = t7.length - 1;
    } else if (i3 < 0) {
      if (!r3) return -1;
      i3 = 0;
    }
    if ("string" == typeof e3 && (e3 = l2.from(e3, n3)), l2.isBuffer(e3)) return 0 === e3.length ? -1 : y2(t7, e3, i3, n3, r3);
    if ("number" == typeof e3) return e3 &= 255, l2.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? r3 ? Uint8Array.prototype.indexOf.call(t7, e3, i3) : Uint8Array.prototype.lastIndexOf.call(t7, e3, i3) : y2(t7, [e3], i3, n3, r3);
    throw new TypeError("val must be string, number or Buffer");
  }
  function y2(t7, e3, i3, n3, r3) {
    var s3, o3 = 1, a3 = t7.length, l3 = e3.length;
    if (void 0 !== n3 && ("ucs2" === (n3 = String(n3).toLowerCase()) || "ucs-2" === n3 || "utf16le" === n3 || "utf-16le" === n3)) {
      if (t7.length < 2 || e3.length < 2) return -1;
      o3 = 2, a3 /= 2, l3 /= 2, i3 /= 2;
    }
    function c3(t8, e4) {
      return 1 === o3 ? t8[e4] : t8.readUInt16BE(e4 * o3);
    }
    if (r3) {
      var h3 = -1;
      for (s3 = i3; s3 < a3; s3++) if (c3(t7, s3) === c3(e3, -1 === h3 ? 0 : s3 - h3)) {
        if (-1 === h3 && (h3 = s3), s3 - h3 + 1 === l3) return h3 * o3;
      } else -1 !== h3 && (s3 -= s3 - h3), h3 = -1;
    } else for (i3 + l3 > a3 && (i3 = a3 - l3), s3 = i3; s3 >= 0; s3--) {
      for (var u3 = true, d3 = 0; d3 < l3; d3++) if (c3(t7, s3 + d3) !== c3(e3, d3)) {
        u3 = false;
        break;
      }
      if (u3) return s3;
    }
    return -1;
  }
  function x2(t7, e3, i3, n3) {
    i3 = Number(i3) || 0;
    var r3 = t7.length - i3;
    n3 ? (n3 = Number(n3)) > r3 && (n3 = r3) : n3 = r3;
    var s3 = e3.length;
    if (s3 % 2 != 0) throw new TypeError("Invalid hex string");
    n3 > s3 / 2 && (n3 = s3 / 2);
    for (var o3 = 0; o3 < n3; ++o3) {
      var a3 = parseInt(e3.substr(2 * o3, 2), 16);
      if (isNaN(a3)) return o3;
      t7[i3 + o3] = a3;
    }
    return o3;
  }
  function b2(t7, e3, i3, n3) {
    return j2(H2(e3, t7.length - i3), t7, i3, n3);
  }
  function w2(t7, e3, i3, n3) {
    return j2((function(t8) {
      for (var e4 = [], i4 = 0; i4 < t8.length; ++i4) e4.push(255 & t8.charCodeAt(i4));
      return e4;
    })(e3), t7, i3, n3);
  }
  function _2(t7, e3, i3, n3) {
    return w2(t7, e3, i3, n3);
  }
  function S2(t7, e3, i3, n3) {
    return j2(V2(e3), t7, i3, n3);
  }
  function M2(t7, e3, i3, n3) {
    return j2((function(t8, e4) {
      for (var i4, n4, r3, s3 = [], o3 = 0; o3 < t8.length && !((e4 -= 2) < 0); ++o3) n4 = (i4 = t8.charCodeAt(o3)) >> 8, r3 = i4 % 256, s3.push(r3), s3.push(n4);
      return s3;
    })(e3, t7.length - i3), t7, i3, n3);
  }
  function T2(t7, e3, i3) {
    return 0 === e3 && i3 === t7.length ? n2.fromByteArray(t7) : n2.fromByteArray(t7.slice(e3, i3));
  }
  function E2(t7, e3, i3) {
    i3 = Math.min(t7.length, i3);
    for (var n3 = [], r3 = e3; r3 < i3; ) {
      var s3, o3, a3, l3, c3 = t7[r3], h3 = null, u3 = c3 > 239 ? 4 : c3 > 223 ? 3 : c3 > 191 ? 2 : 1;
      if (r3 + u3 <= i3) switch (u3) {
        case 1:
          c3 < 128 && (h3 = c3);
          break;
        case 2:
          128 == (192 & (s3 = t7[r3 + 1])) && (l3 = (31 & c3) << 6 | 63 & s3) > 127 && (h3 = l3);
          break;
        case 3:
          s3 = t7[r3 + 1], o3 = t7[r3 + 2], 128 == (192 & s3) && 128 == (192 & o3) && (l3 = (15 & c3) << 12 | (63 & s3) << 6 | 63 & o3) > 2047 && (l3 < 55296 || l3 > 57343) && (h3 = l3);
          break;
        case 4:
          s3 = t7[r3 + 1], o3 = t7[r3 + 2], a3 = t7[r3 + 3], 128 == (192 & s3) && 128 == (192 & o3) && 128 == (192 & a3) && (l3 = (15 & c3) << 18 | (63 & s3) << 12 | (63 & o3) << 6 | 63 & a3) > 65535 && l3 < 1114112 && (h3 = l3);
      }
      null === h3 ? (h3 = 65533, u3 = 1) : h3 > 65535 && (h3 -= 65536, n3.push(h3 >>> 10 & 1023 | 55296), h3 = 56320 | 1023 & h3), n3.push(h3), r3 += u3;
    }
    return (function(t8) {
      var e4 = t8.length;
      if (e4 <= A2) return String.fromCharCode.apply(String, t8);
      var i4 = "", n4 = 0;
      for (; n4 < e4; ) i4 += String.fromCharCode.apply(String, t8.slice(n4, n4 += A2));
      return i4;
    })(n3);
  }
  e2.hp = l2, e2.IS = 50, l2.TYPED_ARRAY_SUPPORT = void 0 !== i2.g.TYPED_ARRAY_SUPPORT ? i2.g.TYPED_ARRAY_SUPPORT : (function() {
    try {
      var t7 = new Uint8Array(1);
      return t7.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
        return 42;
      } }, 42 === t7.foo() && "function" == typeof t7.subarray && 0 === t7.subarray(1, 1).byteLength;
    } catch (t8) {
      return false;
    }
  })(), o2(), l2.poolSize = 8192, l2._augment = function(t7) {
    return t7.__proto__ = l2.prototype, t7;
  }, l2.from = function(t7, e3, i3) {
    return c2(null, t7, e3, i3);
  }, l2.TYPED_ARRAY_SUPPORT && (l2.prototype.__proto__ = Uint8Array.prototype, l2.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && l2[Symbol.species] === l2 && Object.defineProperty(l2, Symbol.species, { value: null, configurable: true })), l2.alloc = function(t7, e3, i3) {
    return (function(t8, e4, i4, n3) {
      return h2(e4), e4 <= 0 ? a2(t8, e4) : void 0 !== i4 ? "string" == typeof n3 ? a2(t8, e4).fill(i4, n3) : a2(t8, e4).fill(i4) : a2(t8, e4);
    })(null, t7, e3, i3);
  }, l2.allocUnsafe = function(t7) {
    return u2(null, t7);
  }, l2.allocUnsafeSlow = function(t7) {
    return u2(null, t7);
  }, l2.isBuffer = function(t7) {
    return !(null == t7 || !t7._isBuffer);
  }, l2.compare = function(t7, e3) {
    if (!l2.isBuffer(t7) || !l2.isBuffer(e3)) throw new TypeError("Arguments must be Buffers");
    if (t7 === e3) return 0;
    for (var i3 = t7.length, n3 = e3.length, r3 = 0, s3 = Math.min(i3, n3); r3 < s3; ++r3) if (t7[r3] !== e3[r3]) {
      i3 = t7[r3], n3 = e3[r3];
      break;
    }
    return i3 < n3 ? -1 : n3 < i3 ? 1 : 0;
  }, l2.isEncoding = function(t7) {
    switch (String(t7).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, l2.concat = function(t7, e3) {
    if (!s2(t7)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (0 === t7.length) return l2.alloc(0);
    var i3;
    if (void 0 === e3) for (e3 = 0, i3 = 0; i3 < t7.length; ++i3) e3 += t7[i3].length;
    var n3 = l2.allocUnsafe(e3), r3 = 0;
    for (i3 = 0; i3 < t7.length; ++i3) {
      var o3 = t7[i3];
      if (!l2.isBuffer(o3)) throw new TypeError('"list" argument must be an Array of Buffers');
      o3.copy(n3, r3), r3 += o3.length;
    }
    return n3;
  }, l2.byteLength = f2, l2.prototype._isBuffer = true, l2.prototype.swap16 = function() {
    var t7 = this.length;
    if (t7 % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var e3 = 0; e3 < t7; e3 += 2) g2(this, e3, e3 + 1);
    return this;
  }, l2.prototype.swap32 = function() {
    var t7 = this.length;
    if (t7 % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var e3 = 0; e3 < t7; e3 += 4) g2(this, e3, e3 + 3), g2(this, e3 + 1, e3 + 2);
    return this;
  }, l2.prototype.swap64 = function() {
    var t7 = this.length;
    if (t7 % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var e3 = 0; e3 < t7; e3 += 8) g2(this, e3, e3 + 7), g2(this, e3 + 1, e3 + 6), g2(this, e3 + 2, e3 + 5), g2(this, e3 + 3, e3 + 4);
    return this;
  }, l2.prototype.toString = function() {
    var t7 = 0 | this.length;
    return 0 === t7 ? "" : 0 === arguments.length ? E2(this, 0, t7) : m2.apply(this, arguments);
  }, l2.prototype.equals = function(t7) {
    if (!l2.isBuffer(t7)) throw new TypeError("Argument must be a Buffer");
    return this === t7 || 0 === l2.compare(this, t7);
  }, l2.prototype.inspect = function() {
    var t7 = "", i3 = e2.IS;
    return this.length > 0 && (t7 = this.toString("hex", 0, i3).match(/.{2}/g).join(" "), this.length > i3 && (t7 += " ... ")), "<Buffer " + t7 + ">";
  }, l2.prototype.compare = function(t7, e3, i3, n3, r3) {
    if (!l2.isBuffer(t7)) throw new TypeError("Argument must be a Buffer");
    if (void 0 === e3 && (e3 = 0), void 0 === i3 && (i3 = t7 ? t7.length : 0), void 0 === n3 && (n3 = 0), void 0 === r3 && (r3 = this.length), e3 < 0 || i3 > t7.length || n3 < 0 || r3 > this.length) throw new RangeError("out of range index");
    if (n3 >= r3 && e3 >= i3) return 0;
    if (n3 >= r3) return -1;
    if (e3 >= i3) return 1;
    if (this === t7) return 0;
    for (var s3 = (r3 >>>= 0) - (n3 >>>= 0), o3 = (i3 >>>= 0) - (e3 >>>= 0), a3 = Math.min(s3, o3), c3 = this.slice(n3, r3), h3 = t7.slice(e3, i3), u3 = 0; u3 < a3; ++u3) if (c3[u3] !== h3[u3]) {
      s3 = c3[u3], o3 = h3[u3];
      break;
    }
    return s3 < o3 ? -1 : o3 < s3 ? 1 : 0;
  }, l2.prototype.includes = function(t7, e3, i3) {
    return -1 !== this.indexOf(t7, e3, i3);
  }, l2.prototype.indexOf = function(t7, e3, i3) {
    return v2(this, t7, e3, i3, true);
  }, l2.prototype.lastIndexOf = function(t7, e3, i3) {
    return v2(this, t7, e3, i3, false);
  }, l2.prototype.write = function(t7, e3, i3, n3) {
    if (void 0 === e3) n3 = "utf8", i3 = this.length, e3 = 0;
    else if (void 0 === i3 && "string" == typeof e3) n3 = e3, i3 = this.length, e3 = 0;
    else {
      if (!isFinite(e3)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      e3 |= 0, isFinite(i3) ? (i3 |= 0, void 0 === n3 && (n3 = "utf8")) : (n3 = i3, i3 = void 0);
    }
    var r3 = this.length - e3;
    if ((void 0 === i3 || i3 > r3) && (i3 = r3), t7.length > 0 && (i3 < 0 || e3 < 0) || e3 > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    n3 || (n3 = "utf8");
    for (var s3 = false; ; ) switch (n3) {
      case "hex":
        return x2(this, t7, e3, i3);
      case "utf8":
      case "utf-8":
        return b2(this, t7, e3, i3);
      case "ascii":
        return w2(this, t7, e3, i3);
      case "latin1":
      case "binary":
        return _2(this, t7, e3, i3);
      case "base64":
        return S2(this, t7, e3, i3);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return M2(this, t7, e3, i3);
      default:
        if (s3) throw new TypeError("Unknown encoding: " + n3);
        n3 = ("" + n3).toLowerCase(), s3 = true;
    }
  }, l2.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  var A2 = 4096;
  function C2(t7, e3, i3) {
    var n3 = "";
    i3 = Math.min(t7.length, i3);
    for (var r3 = e3; r3 < i3; ++r3) n3 += String.fromCharCode(127 & t7[r3]);
    return n3;
  }
  function R2(t7, e3, i3) {
    var n3 = "";
    i3 = Math.min(t7.length, i3);
    for (var r3 = e3; r3 < i3; ++r3) n3 += String.fromCharCode(t7[r3]);
    return n3;
  }
  function P2(t7, e3, i3) {
    var n3 = t7.length;
    (!e3 || e3 < 0) && (e3 = 0), (!i3 || i3 < 0 || i3 > n3) && (i3 = n3);
    for (var r3 = "", s3 = e3; s3 < i3; ++s3) r3 += U2(t7[s3]);
    return r3;
  }
  function L2(t7, e3, i3) {
    for (var n3 = t7.slice(e3, i3), r3 = "", s3 = 0; s3 < n3.length; s3 += 2) r3 += String.fromCharCode(n3[s3] + 256 * n3[s3 + 1]);
    return r3;
  }
  function I2(t7, e3, i3) {
    if (t7 % 1 != 0 || t7 < 0) throw new RangeError("offset is not uint");
    if (t7 + e3 > i3) throw new RangeError("Trying to access beyond buffer length");
  }
  function D2(t7, e3, i3, n3, r3, s3) {
    if (!l2.isBuffer(t7)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (e3 > r3 || e3 < s3) throw new RangeError('"value" argument is out of bounds');
    if (i3 + n3 > t7.length) throw new RangeError("Index out of range");
  }
  function O2(t7, e3, i3, n3) {
    e3 < 0 && (e3 = 65535 + e3 + 1);
    for (var r3 = 0, s3 = Math.min(t7.length - i3, 2); r3 < s3; ++r3) t7[i3 + r3] = (e3 & 255 << 8 * (n3 ? r3 : 1 - r3)) >>> 8 * (n3 ? r3 : 1 - r3);
  }
  function z2(t7, e3, i3, n3) {
    e3 < 0 && (e3 = 4294967295 + e3 + 1);
    for (var r3 = 0, s3 = Math.min(t7.length - i3, 4); r3 < s3; ++r3) t7[i3 + r3] = e3 >>> 8 * (n3 ? r3 : 3 - r3) & 255;
  }
  function F2(t7, e3, i3, n3, r3, s3) {
    if (i3 + n3 > t7.length) throw new RangeError("Index out of range");
    if (i3 < 0) throw new RangeError("Index out of range");
  }
  function N2(t7, e3, i3, n3, s3) {
    return s3 || F2(t7, 0, i3, 4), r2.write(t7, e3, i3, n3, 23, 4), i3 + 4;
  }
  function B2(t7, e3, i3, n3, s3) {
    return s3 || F2(t7, 0, i3, 8), r2.write(t7, e3, i3, n3, 52, 8), i3 + 8;
  }
  l2.prototype.slice = function(t7, e3) {
    var i3, n3 = this.length;
    if ((t7 = ~~t7) < 0 ? (t7 += n3) < 0 && (t7 = 0) : t7 > n3 && (t7 = n3), (e3 = void 0 === e3 ? n3 : ~~e3) < 0 ? (e3 += n3) < 0 && (e3 = 0) : e3 > n3 && (e3 = n3), e3 < t7 && (e3 = t7), l2.TYPED_ARRAY_SUPPORT) (i3 = this.subarray(t7, e3)).__proto__ = l2.prototype;
    else {
      var r3 = e3 - t7;
      i3 = new l2(r3, void 0);
      for (var s3 = 0; s3 < r3; ++s3) i3[s3] = this[s3 + t7];
    }
    return i3;
  }, l2.prototype.readUIntLE = function(t7, e3, i3) {
    t7 |= 0, e3 |= 0, i3 || I2(t7, e3, this.length);
    for (var n3 = this[t7], r3 = 1, s3 = 0; ++s3 < e3 && (r3 *= 256); ) n3 += this[t7 + s3] * r3;
    return n3;
  }, l2.prototype.readUIntBE = function(t7, e3, i3) {
    t7 |= 0, e3 |= 0, i3 || I2(t7, e3, this.length);
    for (var n3 = this[t7 + --e3], r3 = 1; e3 > 0 && (r3 *= 256); ) n3 += this[t7 + --e3] * r3;
    return n3;
  }, l2.prototype.readUInt8 = function(t7, e3) {
    return e3 || I2(t7, 1, this.length), this[t7];
  }, l2.prototype.readUInt16LE = function(t7, e3) {
    return e3 || I2(t7, 2, this.length), this[t7] | this[t7 + 1] << 8;
  }, l2.prototype.readUInt16BE = function(t7, e3) {
    return e3 || I2(t7, 2, this.length), this[t7] << 8 | this[t7 + 1];
  }, l2.prototype.readUInt32LE = function(t7, e3) {
    return e3 || I2(t7, 4, this.length), (this[t7] | this[t7 + 1] << 8 | this[t7 + 2] << 16) + 16777216 * this[t7 + 3];
  }, l2.prototype.readUInt32BE = function(t7, e3) {
    return e3 || I2(t7, 4, this.length), 16777216 * this[t7] + (this[t7 + 1] << 16 | this[t7 + 2] << 8 | this[t7 + 3]);
  }, l2.prototype.readIntLE = function(t7, e3, i3) {
    t7 |= 0, e3 |= 0, i3 || I2(t7, e3, this.length);
    for (var n3 = this[t7], r3 = 1, s3 = 0; ++s3 < e3 && (r3 *= 256); ) n3 += this[t7 + s3] * r3;
    return n3 >= (r3 *= 128) && (n3 -= Math.pow(2, 8 * e3)), n3;
  }, l2.prototype.readIntBE = function(t7, e3, i3) {
    t7 |= 0, e3 |= 0, i3 || I2(t7, e3, this.length);
    for (var n3 = e3, r3 = 1, s3 = this[t7 + --n3]; n3 > 0 && (r3 *= 256); ) s3 += this[t7 + --n3] * r3;
    return s3 >= (r3 *= 128) && (s3 -= Math.pow(2, 8 * e3)), s3;
  }, l2.prototype.readInt8 = function(t7, e3) {
    return e3 || I2(t7, 1, this.length), 128 & this[t7] ? -1 * (255 - this[t7] + 1) : this[t7];
  }, l2.prototype.readInt16LE = function(t7, e3) {
    e3 || I2(t7, 2, this.length);
    var i3 = this[t7] | this[t7 + 1] << 8;
    return 32768 & i3 ? 4294901760 | i3 : i3;
  }, l2.prototype.readInt16BE = function(t7, e3) {
    e3 || I2(t7, 2, this.length);
    var i3 = this[t7 + 1] | this[t7] << 8;
    return 32768 & i3 ? 4294901760 | i3 : i3;
  }, l2.prototype.readInt32LE = function(t7, e3) {
    return e3 || I2(t7, 4, this.length), this[t7] | this[t7 + 1] << 8 | this[t7 + 2] << 16 | this[t7 + 3] << 24;
  }, l2.prototype.readInt32BE = function(t7, e3) {
    return e3 || I2(t7, 4, this.length), this[t7] << 24 | this[t7 + 1] << 16 | this[t7 + 2] << 8 | this[t7 + 3];
  }, l2.prototype.readFloatLE = function(t7, e3) {
    return e3 || I2(t7, 4, this.length), r2.read(this, t7, true, 23, 4);
  }, l2.prototype.readFloatBE = function(t7, e3) {
    return e3 || I2(t7, 4, this.length), r2.read(this, t7, false, 23, 4);
  }, l2.prototype.readDoubleLE = function(t7, e3) {
    return e3 || I2(t7, 8, this.length), r2.read(this, t7, true, 52, 8);
  }, l2.prototype.readDoubleBE = function(t7, e3) {
    return e3 || I2(t7, 8, this.length), r2.read(this, t7, false, 52, 8);
  }, l2.prototype.writeUIntLE = function(t7, e3, i3, n3) {
    (t7 = +t7, e3 |= 0, i3 |= 0, n3) || D2(this, t7, e3, i3, Math.pow(2, 8 * i3) - 1, 0);
    var r3 = 1, s3 = 0;
    for (this[e3] = 255 & t7; ++s3 < i3 && (r3 *= 256); ) this[e3 + s3] = t7 / r3 & 255;
    return e3 + i3;
  }, l2.prototype.writeUIntBE = function(t7, e3, i3, n3) {
    (t7 = +t7, e3 |= 0, i3 |= 0, n3) || D2(this, t7, e3, i3, Math.pow(2, 8 * i3) - 1, 0);
    var r3 = i3 - 1, s3 = 1;
    for (this[e3 + r3] = 255 & t7; --r3 >= 0 && (s3 *= 256); ) this[e3 + r3] = t7 / s3 & 255;
    return e3 + i3;
  }, l2.prototype.writeUInt8 = function(t7, e3, i3) {
    return t7 = +t7, e3 |= 0, i3 || D2(this, t7, e3, 1, 255, 0), l2.TYPED_ARRAY_SUPPORT || (t7 = Math.floor(t7)), this[e3] = 255 & t7, e3 + 1;
  }, l2.prototype.writeUInt16LE = function(t7, e3, i3) {
    return t7 = +t7, e3 |= 0, i3 || D2(this, t7, e3, 2, 65535, 0), l2.TYPED_ARRAY_SUPPORT ? (this[e3] = 255 & t7, this[e3 + 1] = t7 >>> 8) : O2(this, t7, e3, true), e3 + 2;
  }, l2.prototype.writeUInt16BE = function(t7, e3, i3) {
    return t7 = +t7, e3 |= 0, i3 || D2(this, t7, e3, 2, 65535, 0), l2.TYPED_ARRAY_SUPPORT ? (this[e3] = t7 >>> 8, this[e3 + 1] = 255 & t7) : O2(this, t7, e3, false), e3 + 2;
  }, l2.prototype.writeUInt32LE = function(t7, e3, i3) {
    return t7 = +t7, e3 |= 0, i3 || D2(this, t7, e3, 4, 4294967295, 0), l2.TYPED_ARRAY_SUPPORT ? (this[e3 + 3] = t7 >>> 24, this[e3 + 2] = t7 >>> 16, this[e3 + 1] = t7 >>> 8, this[e3] = 255 & t7) : z2(this, t7, e3, true), e3 + 4;
  }, l2.prototype.writeUInt32BE = function(t7, e3, i3) {
    return t7 = +t7, e3 |= 0, i3 || D2(this, t7, e3, 4, 4294967295, 0), l2.TYPED_ARRAY_SUPPORT ? (this[e3] = t7 >>> 24, this[e3 + 1] = t7 >>> 16, this[e3 + 2] = t7 >>> 8, this[e3 + 3] = 255 & t7) : z2(this, t7, e3, false), e3 + 4;
  }, l2.prototype.writeIntLE = function(t7, e3, i3, n3) {
    if (t7 = +t7, e3 |= 0, !n3) {
      var r3 = Math.pow(2, 8 * i3 - 1);
      D2(this, t7, e3, i3, r3 - 1, -r3);
    }
    var s3 = 0, o3 = 1, a3 = 0;
    for (this[e3] = 255 & t7; ++s3 < i3 && (o3 *= 256); ) t7 < 0 && 0 === a3 && 0 !== this[e3 + s3 - 1] && (a3 = 1), this[e3 + s3] = (t7 / o3 | 0) - a3 & 255;
    return e3 + i3;
  }, l2.prototype.writeIntBE = function(t7, e3, i3, n3) {
    if (t7 = +t7, e3 |= 0, !n3) {
      var r3 = Math.pow(2, 8 * i3 - 1);
      D2(this, t7, e3, i3, r3 - 1, -r3);
    }
    var s3 = i3 - 1, o3 = 1, a3 = 0;
    for (this[e3 + s3] = 255 & t7; --s3 >= 0 && (o3 *= 256); ) t7 < 0 && 0 === a3 && 0 !== this[e3 + s3 + 1] && (a3 = 1), this[e3 + s3] = (t7 / o3 | 0) - a3 & 255;
    return e3 + i3;
  }, l2.prototype.writeInt8 = function(t7, e3, i3) {
    return t7 = +t7, e3 |= 0, i3 || D2(this, t7, e3, 1, 127, -128), l2.TYPED_ARRAY_SUPPORT || (t7 = Math.floor(t7)), t7 < 0 && (t7 = 255 + t7 + 1), this[e3] = 255 & t7, e3 + 1;
  }, l2.prototype.writeInt16LE = function(t7, e3, i3) {
    return t7 = +t7, e3 |= 0, i3 || D2(this, t7, e3, 2, 32767, -32768), l2.TYPED_ARRAY_SUPPORT ? (this[e3] = 255 & t7, this[e3 + 1] = t7 >>> 8) : O2(this, t7, e3, true), e3 + 2;
  }, l2.prototype.writeInt16BE = function(t7, e3, i3) {
    return t7 = +t7, e3 |= 0, i3 || D2(this, t7, e3, 2, 32767, -32768), l2.TYPED_ARRAY_SUPPORT ? (this[e3] = t7 >>> 8, this[e3 + 1] = 255 & t7) : O2(this, t7, e3, false), e3 + 2;
  }, l2.prototype.writeInt32LE = function(t7, e3, i3) {
    return t7 = +t7, e3 |= 0, i3 || D2(this, t7, e3, 4, 2147483647, -2147483648), l2.TYPED_ARRAY_SUPPORT ? (this[e3] = 255 & t7, this[e3 + 1] = t7 >>> 8, this[e3 + 2] = t7 >>> 16, this[e3 + 3] = t7 >>> 24) : z2(this, t7, e3, true), e3 + 4;
  }, l2.prototype.writeInt32BE = function(t7, e3, i3) {
    return t7 = +t7, e3 |= 0, i3 || D2(this, t7, e3, 4, 2147483647, -2147483648), t7 < 0 && (t7 = 4294967295 + t7 + 1), l2.TYPED_ARRAY_SUPPORT ? (this[e3] = t7 >>> 24, this[e3 + 1] = t7 >>> 16, this[e3 + 2] = t7 >>> 8, this[e3 + 3] = 255 & t7) : z2(this, t7, e3, false), e3 + 4;
  }, l2.prototype.writeFloatLE = function(t7, e3, i3) {
    return N2(this, t7, e3, true, i3);
  }, l2.prototype.writeFloatBE = function(t7, e3, i3) {
    return N2(this, t7, e3, false, i3);
  }, l2.prototype.writeDoubleLE = function(t7, e3, i3) {
    return B2(this, t7, e3, true, i3);
  }, l2.prototype.writeDoubleBE = function(t7, e3, i3) {
    return B2(this, t7, e3, false, i3);
  }, l2.prototype.copy = function(t7, e3, i3, n3) {
    if (i3 || (i3 = 0), n3 || 0 === n3 || (n3 = this.length), e3 >= t7.length && (e3 = t7.length), e3 || (e3 = 0), n3 > 0 && n3 < i3 && (n3 = i3), n3 === i3) return 0;
    if (0 === t7.length || 0 === this.length) return 0;
    if (e3 < 0) throw new RangeError("targetStart out of bounds");
    if (i3 < 0 || i3 >= this.length) throw new RangeError("sourceStart out of bounds");
    if (n3 < 0) throw new RangeError("sourceEnd out of bounds");
    n3 > this.length && (n3 = this.length), t7.length - e3 < n3 - i3 && (n3 = t7.length - e3 + i3);
    var r3, s3 = n3 - i3;
    if (this === t7 && i3 < e3 && e3 < n3) for (r3 = s3 - 1; r3 >= 0; --r3) t7[r3 + e3] = this[r3 + i3];
    else if (s3 < 1e3 || !l2.TYPED_ARRAY_SUPPORT) for (r3 = 0; r3 < s3; ++r3) t7[r3 + e3] = this[r3 + i3];
    else Uint8Array.prototype.set.call(t7, this.subarray(i3, i3 + s3), e3);
    return s3;
  }, l2.prototype.fill = function(t7, e3, i3, n3) {
    if ("string" == typeof t7) {
      if ("string" == typeof e3 ? (n3 = e3, e3 = 0, i3 = this.length) : "string" == typeof i3 && (n3 = i3, i3 = this.length), 1 === t7.length) {
        var r3 = t7.charCodeAt(0);
        r3 < 256 && (t7 = r3);
      }
      if (void 0 !== n3 && "string" != typeof n3) throw new TypeError("encoding must be a string");
      if ("string" == typeof n3 && !l2.isEncoding(n3)) throw new TypeError("Unknown encoding: " + n3);
    } else "number" == typeof t7 && (t7 &= 255);
    if (e3 < 0 || this.length < e3 || this.length < i3) throw new RangeError("Out of range index");
    if (i3 <= e3) return this;
    var s3;
    if (e3 >>>= 0, i3 = void 0 === i3 ? this.length : i3 >>> 0, t7 || (t7 = 0), "number" == typeof t7) for (s3 = e3; s3 < i3; ++s3) this[s3] = t7;
    else {
      var o3 = l2.isBuffer(t7) ? t7 : H2(new l2(t7, n3).toString()), a3 = o3.length;
      for (s3 = 0; s3 < i3 - e3; ++s3) this[s3 + e3] = o3[s3 % a3];
    }
    return this;
  };
  var k2 = /[^+\/0-9A-Za-z-_]/g;
  function U2(t7) {
    return t7 < 16 ? "0" + t7.toString(16) : t7.toString(16);
  }
  function H2(t7, e3) {
    var i3;
    e3 = e3 || 1 / 0;
    for (var n3 = t7.length, r3 = null, s3 = [], o3 = 0; o3 < n3; ++o3) {
      if ((i3 = t7.charCodeAt(o3)) > 55295 && i3 < 57344) {
        if (!r3) {
          if (i3 > 56319) {
            (e3 -= 3) > -1 && s3.push(239, 191, 189);
            continue;
          }
          if (o3 + 1 === n3) {
            (e3 -= 3) > -1 && s3.push(239, 191, 189);
            continue;
          }
          r3 = i3;
          continue;
        }
        if (i3 < 56320) {
          (e3 -= 3) > -1 && s3.push(239, 191, 189), r3 = i3;
          continue;
        }
        i3 = 65536 + (r3 - 55296 << 10 | i3 - 56320);
      } else r3 && (e3 -= 3) > -1 && s3.push(239, 191, 189);
      if (r3 = null, i3 < 128) {
        if ((e3 -= 1) < 0) break;
        s3.push(i3);
      } else if (i3 < 2048) {
        if ((e3 -= 2) < 0) break;
        s3.push(i3 >> 6 | 192, 63 & i3 | 128);
      } else if (i3 < 65536) {
        if ((e3 -= 3) < 0) break;
        s3.push(i3 >> 12 | 224, i3 >> 6 & 63 | 128, 63 & i3 | 128);
      } else {
        if (!(i3 < 1114112)) throw new Error("Invalid code point");
        if ((e3 -= 4) < 0) break;
        s3.push(i3 >> 18 | 240, i3 >> 12 & 63 | 128, i3 >> 6 & 63 | 128, 63 & i3 | 128);
      }
    }
    return s3;
  }
  function V2(t7) {
    return n2.toByteArray((function(t8) {
      if ((t8 = (function(t9) {
        return t9.trim ? t9.trim() : t9.replace(/^\s+|\s+$/g, "");
      })(t8).replace(k2, "")).length < 2) return "";
      for (; t8.length % 4 != 0; ) t8 += "=";
      return t8;
    })(t7));
  }
  function j2(t7, e3, i3, n3) {
    for (var r3 = 0; r3 < n3 && !(r3 + i3 >= e3.length || r3 >= t7.length); ++r3) e3[r3 + i3] = t7[r3];
    return r3;
  }
}, 5336: (t6) => {
  var e2 = {}.toString;
  t6.exports = Array.isArray || function(t7) {
    return "[object Array]" == e2.call(t7);
  };
}, 7833: (t6, e2, i2) => {
  var n2 = i2(5606);
  e2.formatArgs = function(e3) {
    if (e3[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e3[0] + (this.useColors ? "%c " : " ") + "+" + t6.exports.humanize(this.diff), !this.useColors) return;
    const i3 = "color: " + this.color;
    e3.splice(1, 0, i3, "color: inherit");
    let n3 = 0, r3 = 0;
    e3[0].replace(/%[a-zA-Z%]/g, ((t7) => {
      "%%" !== t7 && (n3++, "%c" === t7 && (r3 = n3));
    })), e3.splice(r3, 0, i3);
  }, e2.save = function(t7) {
    try {
      t7 ? e2.storage.setItem("debug", t7) : e2.storage.removeItem("debug");
    } catch (t8) {
    }
  }, e2.load = function() {
    let t7;
    try {
      t7 = e2.storage.getItem("debug");
    } catch (t8) {
    }
    !t7 && void 0 !== n2 && "env" in n2 && (t7 = n2.env.DEBUG);
    return t7;
  }, e2.useColors = function() {
    if ("undefined" != typeof window && window.process && ("renderer" === window.process.type || window.process.__nwjs)) return true;
    if ("undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
    return "undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }, e2.storage = (function() {
    try {
      return localStorage;
    } catch (t7) {
    }
  })(), e2.destroy = /* @__PURE__ */ (() => {
    let t7 = false;
    return () => {
      t7 || (t7 = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), e2.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], e2.log = console.debug || console.log || (() => {
  }), t6.exports = i2(736)(e2);
  const { formatters: r2 } = t6.exports;
  r2.j = function(t7) {
    try {
      return JSON.stringify(t7);
    } catch (t8) {
      return "[UnexpectedJSONParseError]: " + t8.message;
    }
  };
}, 736: (t6, e2, i2) => {
  t6.exports = function(t7) {
    function e3(t8) {
      let i3, r3, s2, o2 = null;
      function a2(...t9) {
        if (!a2.enabled) return;
        const n3 = a2, r4 = Number(/* @__PURE__ */ new Date()), s3 = r4 - (i3 || r4);
        n3.diff = s3, n3.prev = i3, n3.curr = r4, i3 = r4, t9[0] = e3.coerce(t9[0]), "string" != typeof t9[0] && t9.unshift("%O");
        let o3 = 0;
        t9[0] = t9[0].replace(/%([a-zA-Z%])/g, ((i4, r5) => {
          if ("%%" === i4) return "%";
          o3++;
          const s4 = e3.formatters[r5];
          if ("function" == typeof s4) {
            const e4 = t9[o3];
            i4 = s4.call(n3, e4), t9.splice(o3, 1), o3--;
          }
          return i4;
        })), e3.formatArgs.call(n3, t9);
        (n3.log || e3.log).apply(n3, t9);
      }
      return a2.namespace = t8, a2.useColors = e3.useColors(), a2.color = e3.selectColor(t8), a2.extend = n2, a2.destroy = e3.destroy, Object.defineProperty(a2, "enabled", { enumerable: true, configurable: false, get: () => null !== o2 ? o2 : (r3 !== e3.namespaces && (r3 = e3.namespaces, s2 = e3.enabled(t8)), s2), set: (t9) => {
        o2 = t9;
      } }), "function" == typeof e3.init && e3.init(a2), a2;
    }
    function n2(t8, i3) {
      const n3 = e3(this.namespace + (void 0 === i3 ? ":" : i3) + t8);
      return n3.log = this.log, n3;
    }
    function r2(t8) {
      return t8.toString().substring(2, t8.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    return e3.debug = e3, e3.default = e3, e3.coerce = function(t8) {
      if (t8 instanceof Error) return t8.stack || t8.message;
      return t8;
    }, e3.disable = function() {
      const t8 = [...e3.names.map(r2), ...e3.skips.map(r2).map(((t9) => "-" + t9))].join(",");
      return e3.enable(""), t8;
    }, e3.enable = function(t8) {
      let i3;
      e3.save(t8), e3.namespaces = t8, e3.names = [], e3.skips = [];
      const n3 = ("string" == typeof t8 ? t8 : "").split(/[\s,]+/), r3 = n3.length;
      for (i3 = 0; i3 < r3; i3++) n3[i3] && ("-" === (t8 = n3[i3].replace(/\*/g, ".*?"))[0] ? e3.skips.push(new RegExp("^" + t8.slice(1) + "$")) : e3.names.push(new RegExp("^" + t8 + "$")));
    }, e3.enabled = function(t8) {
      if ("*" === t8[t8.length - 1]) return true;
      let i3, n3;
      for (i3 = 0, n3 = e3.skips.length; i3 < n3; i3++) if (e3.skips[i3].test(t8)) return false;
      for (i3 = 0, n3 = e3.names.length; i3 < n3; i3++) if (e3.names[i3].test(t8)) return true;
      return false;
    }, e3.humanize = i2(6585), e3.destroy = function() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }, Object.keys(t7).forEach(((i3) => {
      e3[i3] = t7[i3];
    })), e3.names = [], e3.skips = [], e3.formatters = {}, e3.selectColor = function(t8) {
      let i3 = 0;
      for (let e4 = 0; e4 < t8.length; e4++) i3 = (i3 << 5) - i3 + t8.charCodeAt(e4), i3 |= 0;
      return e3.colors[Math.abs(i3) % e3.colors.length];
    }, e3.enable(e3.load()), e3;
  };
}, 251: (t6, e2) => {
  e2.read = function(t7, e3, i2, n2, r2) {
    var s2, o2, a2 = 8 * r2 - n2 - 1, l2 = (1 << a2) - 1, c2 = l2 >> 1, h2 = -7, u2 = i2 ? r2 - 1 : 0, d2 = i2 ? -1 : 1, p2 = t7[e3 + u2];
    for (u2 += d2, s2 = p2 & (1 << -h2) - 1, p2 >>= -h2, h2 += a2; h2 > 0; s2 = 256 * s2 + t7[e3 + u2], u2 += d2, h2 -= 8) ;
    for (o2 = s2 & (1 << -h2) - 1, s2 >>= -h2, h2 += n2; h2 > 0; o2 = 256 * o2 + t7[e3 + u2], u2 += d2, h2 -= 8) ;
    if (0 === s2) s2 = 1 - c2;
    else {
      if (s2 === l2) return o2 ? NaN : 1 / 0 * (p2 ? -1 : 1);
      o2 += Math.pow(2, n2), s2 -= c2;
    }
    return (p2 ? -1 : 1) * o2 * Math.pow(2, s2 - n2);
  }, e2.write = function(t7, e3, i2, n2, r2, s2) {
    var o2, a2, l2, c2 = 8 * s2 - r2 - 1, h2 = (1 << c2) - 1, u2 = h2 >> 1, d2 = 23 === r2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p2 = n2 ? 0 : s2 - 1, f2 = n2 ? 1 : -1, m2 = e3 < 0 || 0 === e3 && 1 / e3 < 0 ? 1 : 0;
    for (e3 = Math.abs(e3), isNaN(e3) || e3 === 1 / 0 ? (a2 = isNaN(e3) ? 1 : 0, o2 = h2) : (o2 = Math.floor(Math.log(e3) / Math.LN2), e3 * (l2 = Math.pow(2, -o2)) < 1 && (o2--, l2 *= 2), (e3 += o2 + u2 >= 1 ? d2 / l2 : d2 * Math.pow(2, 1 - u2)) * l2 >= 2 && (o2++, l2 /= 2), o2 + u2 >= h2 ? (a2 = 0, o2 = h2) : o2 + u2 >= 1 ? (a2 = (e3 * l2 - 1) * Math.pow(2, r2), o2 += u2) : (a2 = e3 * Math.pow(2, u2 - 1) * Math.pow(2, r2), o2 = 0)); r2 >= 8; t7[i2 + p2] = 255 & a2, p2 += f2, a2 /= 256, r2 -= 8) ;
    for (o2 = o2 << r2 | a2, c2 += r2; c2 > 0; t7[i2 + p2] = 255 & o2, p2 += f2, o2 /= 256, c2 -= 8) ;
    t7[i2 + p2 - f2] |= 128 * m2;
  };
}, 1873: (t6, e2, i2) => {
  var n2 = i2(9325).Symbol;
  t6.exports = n2;
}, 695: (t6, e2, i2) => {
  var n2 = i2(8096), r2 = i2(2428), s2 = i2(6449), o2 = i2(3656), a2 = i2(361), l2 = i2(7167), c2 = Object.prototype.hasOwnProperty;
  t6.exports = function(t7, e3) {
    var i3 = s2(t7), h2 = !i3 && r2(t7), u2 = !i3 && !h2 && o2(t7), d2 = !i3 && !h2 && !u2 && l2(t7), p2 = i3 || h2 || u2 || d2, f2 = p2 ? n2(t7.length, String) : [], m2 = f2.length;
    for (var g2 in t7) !e3 && !c2.call(t7, g2) || p2 && ("length" == g2 || u2 && ("offset" == g2 || "parent" == g2) || d2 && ("buffer" == g2 || "byteLength" == g2 || "byteOffset" == g2) || a2(g2, m2)) || f2.push(g2);
    return f2;
  };
}, 4932: (t6) => {
  t6.exports = function(t7, e2) {
    for (var i2 = -1, n2 = null == t7 ? 0 : t7.length, r2 = Array(n2); ++i2 < n2; ) r2[i2] = e2(t7[i2], i2, t7);
    return r2;
  };
}, 3390: (t6, e2, i2) => {
  var n2 = i2(3195);
  t6.exports = function(t7) {
    var e3 = t7.length;
    return e3 ? t7[n2(0, e3 - 1)] : void 0;
  };
}, 2552: (t6, e2, i2) => {
  var n2 = i2(1873), r2 = i2(659), s2 = i2(9350), o2 = n2 ? n2.toStringTag : void 0;
  t6.exports = function(t7) {
    return null == t7 ? void 0 === t7 ? "[object Undefined]" : "[object Null]" : o2 && o2 in Object(t7) ? r2(t7) : s2(t7);
  };
}, 7534: (t6, e2, i2) => {
  var n2 = i2(2552), r2 = i2(346);
  t6.exports = function(t7) {
    return r2(t7) && "[object Arguments]" == n2(t7);
  };
}, 4901: (t6, e2, i2) => {
  var n2 = i2(2552), r2 = i2(294), s2 = i2(346), o2 = {};
  o2["[object Float32Array]"] = o2["[object Float64Array]"] = o2["[object Int8Array]"] = o2["[object Int16Array]"] = o2["[object Int32Array]"] = o2["[object Uint8Array]"] = o2["[object Uint8ClampedArray]"] = o2["[object Uint16Array]"] = o2["[object Uint32Array]"] = true, o2["[object Arguments]"] = o2["[object Array]"] = o2["[object ArrayBuffer]"] = o2["[object Boolean]"] = o2["[object DataView]"] = o2["[object Date]"] = o2["[object Error]"] = o2["[object Function]"] = o2["[object Map]"] = o2["[object Number]"] = o2["[object Object]"] = o2["[object RegExp]"] = o2["[object Set]"] = o2["[object String]"] = o2["[object WeakMap]"] = false, t6.exports = function(t7) {
    return s2(t7) && r2(t7.length) && !!o2[n2(t7)];
  };
}, 8984: (t6, e2, i2) => {
  var n2 = i2(5527), r2 = i2(3650), s2 = Object.prototype.hasOwnProperty;
  t6.exports = function(t7) {
    if (!n2(t7)) return r2(t7);
    var e3 = [];
    for (var i3 in Object(t7)) s2.call(t7, i3) && "constructor" != i3 && e3.push(i3);
    return e3;
  };
}, 3195: (t6) => {
  var e2 = Math.floor, i2 = Math.random;
  t6.exports = function(t7, n2) {
    return t7 + e2(i2() * (n2 - t7 + 1));
  };
}, 8170: (t6, e2, i2) => {
  var n2 = i2(3390), r2 = i2(5880);
  t6.exports = function(t7) {
    return n2(r2(t7));
  };
}, 8096: (t6) => {
  t6.exports = function(t7, e2) {
    for (var i2 = -1, n2 = Array(t7); ++i2 < t7; ) n2[i2] = e2(i2);
    return n2;
  };
}, 7301: (t6) => {
  t6.exports = function(t7) {
    return function(e2) {
      return t7(e2);
    };
  };
}, 514: (t6, e2, i2) => {
  var n2 = i2(4932);
  t6.exports = function(t7, e3) {
    return n2(e3, (function(e4) {
      return t7[e4];
    }));
  };
}, 4840: (t6, e2, i2) => {
  var n2 = "object" == typeof i2.g && i2.g && i2.g.Object === Object && i2.g;
  t6.exports = n2;
}, 659: (t6, e2, i2) => {
  var n2 = i2(1873), r2 = Object.prototype, s2 = r2.hasOwnProperty, o2 = r2.toString, a2 = n2 ? n2.toStringTag : void 0;
  t6.exports = function(t7) {
    var e3 = s2.call(t7, a2), i3 = t7[a2];
    try {
      t7[a2] = void 0;
      var n3 = true;
    } catch (t8) {
    }
    var r3 = o2.call(t7);
    return n3 && (e3 ? t7[a2] = i3 : delete t7[a2]), r3;
  };
}, 361: (t6) => {
  var e2 = /^(?:0|[1-9]\d*)$/;
  t6.exports = function(t7, i2) {
    var n2 = typeof t7;
    return !!(i2 = null == i2 ? 9007199254740991 : i2) && ("number" == n2 || "symbol" != n2 && e2.test(t7)) && t7 > -1 && t7 % 1 == 0 && t7 < i2;
  };
}, 5527: (t6) => {
  var e2 = Object.prototype;
  t6.exports = function(t7) {
    var i2 = t7 && t7.constructor;
    return t7 === ("function" == typeof i2 && i2.prototype || e2);
  };
}, 3650: (t6, e2, i2) => {
  var n2 = i2(4335)(Object.keys, Object);
  t6.exports = n2;
}, 6009: (t6, e2, i2) => {
  t6 = i2.nmd(t6);
  var n2 = i2(4840), r2 = e2 && !e2.nodeType && e2, s2 = r2 && t6 && !t6.nodeType && t6, o2 = s2 && s2.exports === r2 && n2.process, a2 = (function() {
    try {
      var t7 = s2 && s2.require && s2.require("util").types;
      return t7 || o2 && o2.binding && o2.binding("util");
    } catch (t8) {
    }
  })();
  t6.exports = a2;
}, 9350: (t6) => {
  var e2 = Object.prototype.toString;
  t6.exports = function(t7) {
    return e2.call(t7);
  };
}, 4335: (t6) => {
  t6.exports = function(t7, e2) {
    return function(i2) {
      return t7(e2(i2));
    };
  };
}, 9325: (t6, e2, i2) => {
  var n2 = i2(4840), r2 = "object" == typeof self && self && self.Object === Object && self, s2 = n2 || r2 || Function("return this")();
  t6.exports = s2;
}, 2428: (t6, e2, i2) => {
  var n2 = i2(7534), r2 = i2(346), s2 = Object.prototype, o2 = s2.hasOwnProperty, a2 = s2.propertyIsEnumerable, l2 = n2(/* @__PURE__ */ (function() {
    return arguments;
  })()) ? n2 : function(t7) {
    return r2(t7) && o2.call(t7, "callee") && !a2.call(t7, "callee");
  };
  t6.exports = l2;
}, 6449: (t6) => {
  var e2 = Array.isArray;
  t6.exports = e2;
}, 4894: (t6, e2, i2) => {
  var n2 = i2(1882), r2 = i2(294);
  t6.exports = function(t7) {
    return null != t7 && r2(t7.length) && !n2(t7);
  };
}, 3656: (t6, e2, i2) => {
  t6 = i2.nmd(t6);
  var n2 = i2(9325), r2 = i2(9935), s2 = e2 && !e2.nodeType && e2, o2 = s2 && t6 && !t6.nodeType && t6, a2 = o2 && o2.exports === s2 ? n2.Buffer : void 0, l2 = (a2 ? a2.isBuffer : void 0) || r2;
  t6.exports = l2;
}, 1882: (t6, e2, i2) => {
  var n2 = i2(2552), r2 = i2(3805);
  t6.exports = function(t7) {
    if (!r2(t7)) return false;
    var e3 = n2(t7);
    return "[object Function]" == e3 || "[object GeneratorFunction]" == e3 || "[object AsyncFunction]" == e3 || "[object Proxy]" == e3;
  };
}, 294: (t6) => {
  t6.exports = function(t7) {
    return "number" == typeof t7 && t7 > -1 && t7 % 1 == 0 && t7 <= 9007199254740991;
  };
}, 8023: (t6, e2, i2) => {
  var n2 = i2(2552), r2 = i2(346);
  t6.exports = function(t7) {
    return "number" == typeof t7 || r2(t7) && "[object Number]" == n2(t7);
  };
}, 3805: (t6) => {
  t6.exports = function(t7) {
    var e2 = typeof t7;
    return null != t7 && ("object" == e2 || "function" == e2);
  };
}, 346: (t6) => {
  t6.exports = function(t7) {
    return null != t7 && "object" == typeof t7;
  };
}, 7167: (t6, e2, i2) => {
  var n2 = i2(4901), r2 = i2(7301), s2 = i2(6009), o2 = s2 && s2.isTypedArray, a2 = o2 ? r2(o2) : n2;
  t6.exports = a2;
}, 5950: (t6, e2, i2) => {
  var n2 = i2(695), r2 = i2(8984), s2 = i2(4894);
  t6.exports = function(t7) {
    return s2(t7) ? n2(t7) : r2(t7);
  };
}, 5620: (t6, e2, i2) => {
  var n2 = i2(3390), r2 = i2(8170), s2 = i2(6449);
  t6.exports = function(t7) {
    return (s2(t7) ? n2 : r2)(t7);
  };
}, 9935: (t6) => {
  t6.exports = function() {
    return false;
  };
}, 5880: (t6, e2, i2) => {
  var n2 = i2(514), r2 = i2(5950);
  t6.exports = function(t7) {
    return null == t7 ? [] : n2(t7, r2(t7));
  };
}, 6585: (t6) => {
  var e2 = 1e3, i2 = 60 * e2, n2 = 60 * i2, r2 = 24 * n2, s2 = 7 * r2, o2 = 365.25 * r2;
  function a2(t7, e3, i3, n3) {
    var r3 = e3 >= 1.5 * i3;
    return Math.round(t7 / i3) + " " + n3 + (r3 ? "s" : "");
  }
  t6.exports = function(t7, l2) {
    l2 = l2 || {};
    var c2 = typeof t7;
    if ("string" === c2 && t7.length > 0) return (function(t8) {
      if ((t8 = String(t8)).length > 100) return;
      var a3 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(t8);
      if (!a3) return;
      var l3 = parseFloat(a3[1]);
      switch ((a3[2] || "ms").toLowerCase()) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return l3 * o2;
        case "weeks":
        case "week":
        case "w":
          return l3 * s2;
        case "days":
        case "day":
        case "d":
          return l3 * r2;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return l3 * n2;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return l3 * i2;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return l3 * e2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return l3;
        default:
          return;
      }
    })(t7);
    if ("number" === c2 && isFinite(t7)) return l2.long ? (function(t8) {
      var s3 = Math.abs(t8);
      if (s3 >= r2) return a2(t8, s3, r2, "day");
      if (s3 >= n2) return a2(t8, s3, n2, "hour");
      if (s3 >= i2) return a2(t8, s3, i2, "minute");
      if (s3 >= e2) return a2(t8, s3, e2, "second");
      return t8 + " ms";
    })(t7) : (function(t8) {
      var s3 = Math.abs(t8);
      if (s3 >= r2) return Math.round(t8 / r2) + "d";
      if (s3 >= n2) return Math.round(t8 / n2) + "h";
      if (s3 >= i2) return Math.round(t8 / i2) + "m";
      if (s3 >= e2) return Math.round(t8 / e2) + "s";
      return t8 + "ms";
    })(t7);
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(t7));
  };
}, 5606: (t6) => {
  var e2, i2, n2 = t6.exports = {};
  function r2() {
    throw new Error("setTimeout has not been defined");
  }
  function s2() {
    throw new Error("clearTimeout has not been defined");
  }
  function o2(t7) {
    if (e2 === setTimeout) return setTimeout(t7, 0);
    if ((e2 === r2 || !e2) && setTimeout) return e2 = setTimeout, setTimeout(t7, 0);
    try {
      return e2(t7, 0);
    } catch (i3) {
      try {
        return e2.call(null, t7, 0);
      } catch (i4) {
        return e2.call(this, t7, 0);
      }
    }
  }
  !(function() {
    try {
      e2 = "function" == typeof setTimeout ? setTimeout : r2;
    } catch (t7) {
      e2 = r2;
    }
    try {
      i2 = "function" == typeof clearTimeout ? clearTimeout : s2;
    } catch (t7) {
      i2 = s2;
    }
  })();
  var a2, l2 = [], c2 = false, h2 = -1;
  function u2() {
    c2 && a2 && (c2 = false, a2.length ? l2 = a2.concat(l2) : h2 = -1, l2.length && d2());
  }
  function d2() {
    if (!c2) {
      var t7 = o2(u2);
      c2 = true;
      for (var e3 = l2.length; e3; ) {
        for (a2 = l2, l2 = []; ++h2 < e3; ) a2 && a2[h2].run();
        h2 = -1, e3 = l2.length;
      }
      a2 = null, c2 = false, (function(t8) {
        if (i2 === clearTimeout) return clearTimeout(t8);
        if ((i2 === s2 || !i2) && clearTimeout) return i2 = clearTimeout, clearTimeout(t8);
        try {
          return i2(t8);
        } catch (e4) {
          try {
            return i2.call(null, t8);
          } catch (e5) {
            return i2.call(this, t8);
          }
        }
      })(t7);
    }
  }
  function p2(t7, e3) {
    this.fun = t7, this.array = e3;
  }
  function f2() {
  }
  n2.nextTick = function(t7) {
    var e3 = new Array(arguments.length - 1);
    if (arguments.length > 1) for (var i3 = 1; i3 < arguments.length; i3++) e3[i3 - 1] = arguments[i3];
    l2.push(new p2(t7, e3)), 1 !== l2.length || c2 || o2(d2);
  }, p2.prototype.run = function() {
    this.fun.apply(null, this.array);
  }, n2.title = "browser", n2.browser = true, n2.env = {}, n2.argv = [], n2.version = "", n2.versions = {}, n2.on = f2, n2.addListener = f2, n2.once = f2, n2.off = f2, n2.removeListener = f2, n2.removeAllListeners = f2, n2.emit = f2, n2.prependListener = f2, n2.prependOnceListener = f2, n2.listeners = function(t7) {
    return [];
  }, n2.binding = function(t7) {
    throw new Error("process.binding is not supported");
  }, n2.cwd = function() {
    return "/";
  }, n2.chdir = function(t7) {
    throw new Error("process.chdir is not supported");
  }, n2.umask = function() {
    return 0;
  };
}, 6479: (t6) => {
  var e2;
  window, e2 = function() {
    return (function(t7) {
      var e3 = {};
      function i2(n2) {
        if (e3[n2]) return e3[n2].exports;
        var r2 = e3[n2] = { i: n2, l: false, exports: {} };
        return t7[n2].call(r2.exports, r2, r2.exports, i2), r2.l = true, r2.exports;
      }
      return i2.m = t7, i2.c = e3, i2.d = function(t8, e4, n2) {
        i2.o(t8, e4) || Object.defineProperty(t8, e4, { enumerable: true, get: n2 });
      }, i2.r = function(t8) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t8, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t8, "__esModule", { value: true });
      }, i2.t = function(t8, e4) {
        if (1 & e4 && (t8 = i2(t8)), 8 & e4) return t8;
        if (4 & e4 && "object" == typeof t8 && t8 && t8.__esModule) return t8;
        var n2 = /* @__PURE__ */ Object.create(null);
        if (i2.r(n2), Object.defineProperty(n2, "default", { enumerable: true, value: t8 }), 2 & e4 && "string" != typeof t8) for (var r2 in t8) i2.d(n2, r2, (function(e5) {
          return t8[e5];
        }).bind(null, r2));
        return n2;
      }, i2.n = function(t8) {
        var e4 = t8 && t8.__esModule ? function() {
          return t8.default;
        } : function() {
          return t8;
        };
        return i2.d(e4, "a", e4), e4;
      }, i2.o = function(t8, e4) {
        return Object.prototype.hasOwnProperty.call(t8, e4);
      }, i2.p = "", i2(i2.s = 2);
    })([function(t7, e3, i2) {
      var n2, r2 = this && this.__extends || (n2 = function(t8, e4) {
        return n2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t9, e5) {
          t9.__proto__ = e5;
        } || function(t9, e5) {
          for (var i3 in e5) e5.hasOwnProperty(i3) && (t9[i3] = e5[i3]);
        }, n2(t8, e4);
      }, function(t8, e4) {
        function i3() {
          this.constructor = t8;
        }
        n2(t8, e4), t8.prototype = null === e4 ? Object.create(e4) : (i3.prototype = e4.prototype, new i3());
      });
      Object.defineProperty(e3, "__esModule", { value: true });
      var s2 = 256, o2 = (function() {
        function t8(t9) {
          void 0 === t9 && (t9 = "="), this._paddingCharacter = t9;
        }
        return t8.prototype.encodedLength = function(t9) {
          return this._paddingCharacter ? (t9 + 2) / 3 * 4 | 0 : (8 * t9 + 5) / 6 | 0;
        }, t8.prototype.encode = function(t9) {
          for (var e4 = "", i3 = 0; i3 < t9.length - 2; i3 += 3) {
            var n3 = t9[i3] << 16 | t9[i3 + 1] << 8 | t9[i3 + 2];
            e4 += this._encodeByte(n3 >>> 18 & 63), e4 += this._encodeByte(n3 >>> 12 & 63), e4 += this._encodeByte(n3 >>> 6 & 63), e4 += this._encodeByte(n3 >>> 0 & 63);
          }
          var r3 = t9.length - i3;
          return r3 > 0 && (n3 = t9[i3] << 16 | (2 === r3 ? t9[i3 + 1] << 8 : 0), e4 += this._encodeByte(n3 >>> 18 & 63), e4 += this._encodeByte(n3 >>> 12 & 63), e4 += 2 === r3 ? this._encodeByte(n3 >>> 6 & 63) : this._paddingCharacter || "", e4 += this._paddingCharacter || ""), e4;
        }, t8.prototype.maxDecodedLength = function(t9) {
          return this._paddingCharacter ? t9 / 4 * 3 | 0 : (6 * t9 + 7) / 8 | 0;
        }, t8.prototype.decodedLength = function(t9) {
          return this.maxDecodedLength(t9.length - this._getPaddingLength(t9));
        }, t8.prototype.decode = function(t9) {
          if (0 === t9.length) return new Uint8Array(0);
          for (var e4 = this._getPaddingLength(t9), i3 = t9.length - e4, n3 = new Uint8Array(this.maxDecodedLength(i3)), r3 = 0, o3 = 0, a3 = 0, l3 = 0, c3 = 0, h2 = 0, u2 = 0; o3 < i3 - 4; o3 += 4) l3 = this._decodeChar(t9.charCodeAt(o3 + 0)), c3 = this._decodeChar(t9.charCodeAt(o3 + 1)), h2 = this._decodeChar(t9.charCodeAt(o3 + 2)), u2 = this._decodeChar(t9.charCodeAt(o3 + 3)), n3[r3++] = l3 << 2 | c3 >>> 4, n3[r3++] = c3 << 4 | h2 >>> 2, n3[r3++] = h2 << 6 | u2, a3 |= l3 & s2, a3 |= c3 & s2, a3 |= h2 & s2, a3 |= u2 & s2;
          if (o3 < i3 - 1 && (l3 = this._decodeChar(t9.charCodeAt(o3)), c3 = this._decodeChar(t9.charCodeAt(o3 + 1)), n3[r3++] = l3 << 2 | c3 >>> 4, a3 |= l3 & s2, a3 |= c3 & s2), o3 < i3 - 2 && (h2 = this._decodeChar(t9.charCodeAt(o3 + 2)), n3[r3++] = c3 << 4 | h2 >>> 2, a3 |= h2 & s2), o3 < i3 - 3 && (u2 = this._decodeChar(t9.charCodeAt(o3 + 3)), n3[r3++] = h2 << 6 | u2, a3 |= u2 & s2), 0 !== a3) throw new Error("Base64Coder: incorrect characters for decoding");
          return n3;
        }, t8.prototype._encodeByte = function(t9) {
          var e4 = t9;
          return e4 += 65, e4 += 25 - t9 >>> 8 & 6, e4 += 51 - t9 >>> 8 & -75, e4 += 61 - t9 >>> 8 & -15, e4 += 62 - t9 >>> 8 & 3, String.fromCharCode(e4);
        }, t8.prototype._decodeChar = function(t9) {
          var e4 = s2;
          return e4 += (42 - t9 & t9 - 44) >>> 8 & -256 + t9 - 43 + 62, e4 += (46 - t9 & t9 - 48) >>> 8 & -256 + t9 - 47 + 63, e4 += (47 - t9 & t9 - 58) >>> 8 & -256 + t9 - 48 + 52, e4 += (64 - t9 & t9 - 91) >>> 8 & -256 + t9 - 65 + 0, e4 += (96 - t9 & t9 - 123) >>> 8 & -256 + t9 - 97 + 26;
        }, t8.prototype._getPaddingLength = function(t9) {
          var e4 = 0;
          if (this._paddingCharacter) {
            for (var i3 = t9.length - 1; i3 >= 0 && t9[i3] === this._paddingCharacter; i3--) e4++;
            if (t9.length < 4 || e4 > 2) throw new Error("Base64Coder: incorrect padding");
          }
          return e4;
        }, t8;
      })();
      e3.Coder = o2;
      var a2 = new o2();
      e3.encode = function(t8) {
        return a2.encode(t8);
      }, e3.decode = function(t8) {
        return a2.decode(t8);
      };
      var l2 = (function(t8) {
        function e4() {
          return null !== t8 && t8.apply(this, arguments) || this;
        }
        return r2(e4, t8), e4.prototype._encodeByte = function(t9) {
          var e5 = t9;
          return e5 += 65, e5 += 25 - t9 >>> 8 & 6, e5 += 51 - t9 >>> 8 & -75, e5 += 61 - t9 >>> 8 & -13, e5 += 62 - t9 >>> 8 & 49, String.fromCharCode(e5);
        }, e4.prototype._decodeChar = function(t9) {
          var e5 = s2;
          return e5 += (44 - t9 & t9 - 46) >>> 8 & -256 + t9 - 45 + 62, e5 += (94 - t9 & t9 - 96) >>> 8 & -256 + t9 - 95 + 63, e5 += (47 - t9 & t9 - 58) >>> 8 & -256 + t9 - 48 + 52, e5 += (64 - t9 & t9 - 91) >>> 8 & -256 + t9 - 65 + 0, e5 += (96 - t9 & t9 - 123) >>> 8 & -256 + t9 - 97 + 26;
        }, e4;
      })(o2);
      e3.URLSafeCoder = l2;
      var c2 = new l2();
      e3.encodeURLSafe = function(t8) {
        return c2.encode(t8);
      }, e3.decodeURLSafe = function(t8) {
        return c2.decode(t8);
      }, e3.encodedLength = function(t8) {
        return a2.encodedLength(t8);
      }, e3.maxDecodedLength = function(t8) {
        return a2.maxDecodedLength(t8);
      }, e3.decodedLength = function(t8) {
        return a2.decodedLength(t8);
      };
    }, function(t7, e3, i2) {
      Object.defineProperty(e3, "__esModule", { value: true });
      var n2 = "utf8: invalid string", r2 = "utf8: invalid source encoding";
      function s2(t8) {
        for (var e4 = 0, i3 = 0; i3 < t8.length; i3++) {
          var r3 = t8.charCodeAt(i3);
          if (r3 < 128) e4 += 1;
          else if (r3 < 2048) e4 += 2;
          else if (r3 < 55296) e4 += 3;
          else {
            if (!(r3 <= 57343)) throw new Error(n2);
            if (i3 >= t8.length - 1) throw new Error(n2);
            i3++, e4 += 4;
          }
        }
        return e4;
      }
      e3.encode = function(t8) {
        for (var e4 = new Uint8Array(s2(t8)), i3 = 0, n3 = 0; n3 < t8.length; n3++) {
          var r3 = t8.charCodeAt(n3);
          r3 < 128 ? e4[i3++] = r3 : r3 < 2048 ? (e4[i3++] = 192 | r3 >> 6, e4[i3++] = 128 | 63 & r3) : r3 < 55296 ? (e4[i3++] = 224 | r3 >> 12, e4[i3++] = 128 | r3 >> 6 & 63, e4[i3++] = 128 | 63 & r3) : (n3++, r3 = (1023 & r3) << 10, r3 |= 1023 & t8.charCodeAt(n3), r3 += 65536, e4[i3++] = 240 | r3 >> 18, e4[i3++] = 128 | r3 >> 12 & 63, e4[i3++] = 128 | r3 >> 6 & 63, e4[i3++] = 128 | 63 & r3);
        }
        return e4;
      }, e3.encodedLength = s2, e3.decode = function(t8) {
        for (var e4 = [], i3 = 0; i3 < t8.length; i3++) {
          var n3 = t8[i3];
          if (128 & n3) {
            var s3 = void 0;
            if (n3 < 224) {
              if (i3 >= t8.length) throw new Error(r2);
              if (128 != (192 & (o2 = t8[++i3]))) throw new Error(r2);
              n3 = (31 & n3) << 6 | 63 & o2, s3 = 128;
            } else if (n3 < 240) {
              if (i3 >= t8.length - 1) throw new Error(r2);
              var o2 = t8[++i3], a2 = t8[++i3];
              if (128 != (192 & o2) || 128 != (192 & a2)) throw new Error(r2);
              n3 = (15 & n3) << 12 | (63 & o2) << 6 | 63 & a2, s3 = 2048;
            } else {
              if (!(n3 < 248)) throw new Error(r2);
              if (i3 >= t8.length - 2) throw new Error(r2);
              o2 = t8[++i3], a2 = t8[++i3];
              var l2 = t8[++i3];
              if (128 != (192 & o2) || 128 != (192 & a2) || 128 != (192 & l2)) throw new Error(r2);
              n3 = (15 & n3) << 18 | (63 & o2) << 12 | (63 & a2) << 6 | 63 & l2, s3 = 65536;
            }
            if (n3 < s3 || n3 >= 55296 && n3 <= 57343) throw new Error(r2);
            if (n3 >= 65536) {
              if (n3 > 1114111) throw new Error(r2);
              n3 -= 65536, e4.push(String.fromCharCode(55296 | n3 >> 10)), n3 = 56320 | 1023 & n3;
            }
          }
          e4.push(String.fromCharCode(n3));
        }
        return e4.join("");
      };
    }, function(t7, e3, i2) {
      t7.exports = i2(3).default;
    }, function(t7, e3, i2) {
      i2.r(e3);
      class n2 {
        constructor(t8, e4) {
          this.lastId = 0, this.prefix = t8, this.name = e4;
        }
        create(t8) {
          this.lastId++;
          var e4 = this.lastId, i3 = this.prefix + e4, n3 = this.name + "[" + e4 + "]", r3 = false, s3 = function() {
            r3 || (t8.apply(null, arguments), r3 = true);
          };
          return this[e4] = s3, { number: e4, id: i3, name: n3, callback: s3 };
        }
        remove(t8) {
          delete this[t8.number];
        }
      }
      var r2 = new n2("_pusher_script_", "Pusher.ScriptReceivers"), s2 = { VERSION: "8.4.0", PROTOCOL: 7, wsPort: 80, wssPort: 443, wsPath: "", httpHost: "sockjs.pusher.com", httpPort: 80, httpsPort: 443, httpPath: "/pusher", stats_host: "stats.pusher.com", authEndpoint: "/pusher/auth", authTransport: "ajax", activityTimeout: 12e4, pongTimeout: 3e4, unavailableTimeout: 1e4, userAuthentication: { endpoint: "/pusher/user-auth", transport: "ajax" }, channelAuthorization: { endpoint: "/pusher/auth", transport: "ajax" }, cdn_http: "http://js.pusher.com", cdn_https: "https://js.pusher.com", dependency_suffix: "" }, o2 = new n2("_pusher_dependencies", "Pusher.DependenciesReceivers"), a2 = new class {
        constructor(t8) {
          this.options = t8, this.receivers = t8.receivers || r2, this.loading = {};
        }
        load(t8, e4, i3) {
          var n3 = this;
          if (n3.loading[t8] && n3.loading[t8].length > 0) n3.loading[t8].push(i3);
          else {
            n3.loading[t8] = [i3];
            var r3 = pe2.createScriptRequest(n3.getPath(t8, e4)), s3 = n3.receivers.create((function(e5) {
              if (n3.receivers.remove(s3), n3.loading[t8]) {
                var i4 = n3.loading[t8];
                delete n3.loading[t8];
                for (var o3 = function(t9) {
                  t9 || r3.cleanup();
                }, a3 = 0; a3 < i4.length; a3++) i4[a3](e5, o3);
              }
            }));
            r3.send(s3);
          }
        }
        getRoot(t8) {
          var e4 = pe2.getDocument().location.protocol;
          return (t8 && t8.useTLS || "https:" === e4 ? this.options.cdn_https : this.options.cdn_http).replace(/\/*$/, "") + "/" + this.options.version;
        }
        getPath(t8, e4) {
          return this.getRoot(e4) + "/" + t8 + this.options.suffix + ".js";
        }
      }({ cdn_http: s2.cdn_http, cdn_https: s2.cdn_https, version: s2.VERSION, suffix: s2.dependency_suffix, receivers: o2 });
      const l2 = { baseUrl: "https://pusher.com", urls: { authenticationEndpoint: { path: "/docs/channels/server_api/authenticating_users" }, authorizationEndpoint: { path: "/docs/channels/server_api/authorizing-users/" }, javascriptQuickStart: { path: "/docs/javascript_quick_start" }, triggeringClientEvents: { path: "/docs/client_api_guide/client_events#trigger-events" }, encryptedChannelSupport: { fullUrl: "https://github.com/pusher/pusher-js/tree/cc491015371a4bde5743d1c87a0fbac0feb53195#encrypted-channel-support" } } };
      var c2, h2 = function(t8) {
        const e4 = l2.urls[t8];
        if (!e4) return "";
        let i3;
        return e4.fullUrl ? i3 = e4.fullUrl : e4.path && (i3 = l2.baseUrl + e4.path), i3 ? `See: ${i3}` : "";
      };
      !(function(t8) {
        t8.UserAuthentication = "user-authentication", t8.ChannelAuthorization = "channel-authorization";
      })(c2 || (c2 = {}));
      class u2 extends Error {
        constructor(t8) {
          super(t8), Object.setPrototypeOf(this, new.target.prototype);
        }
      }
      class d2 extends Error {
        constructor(t8) {
          super(t8), Object.setPrototypeOf(this, new.target.prototype);
        }
      }
      class p2 extends Error {
        constructor(t8) {
          super(t8), Object.setPrototypeOf(this, new.target.prototype);
        }
      }
      class f2 extends Error {
        constructor(t8) {
          super(t8), Object.setPrototypeOf(this, new.target.prototype);
        }
      }
      class m2 extends Error {
        constructor(t8) {
          super(t8), Object.setPrototypeOf(this, new.target.prototype);
        }
      }
      class g2 extends Error {
        constructor(t8) {
          super(t8), Object.setPrototypeOf(this, new.target.prototype);
        }
      }
      class v2 extends Error {
        constructor(t8) {
          super(t8), Object.setPrototypeOf(this, new.target.prototype);
        }
      }
      class y2 extends Error {
        constructor(t8) {
          super(t8), Object.setPrototypeOf(this, new.target.prototype);
        }
      }
      class x2 extends Error {
        constructor(t8, e4) {
          super(e4), this.status = t8, Object.setPrototypeOf(this, new.target.prototype);
        }
      }
      for (var b2 = function(t8, e4, i3, n3, r3) {
        const s3 = pe2.createXHR();
        for (var o3 in s3.open("POST", i3.endpoint, true), s3.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), i3.headers) s3.setRequestHeader(o3, i3.headers[o3]);
        if (null != i3.headersProvider) {
          let t9 = i3.headersProvider();
          for (var o3 in t9) s3.setRequestHeader(o3, t9[o3]);
        }
        return s3.onreadystatechange = function() {
          if (4 === s3.readyState) if (200 === s3.status) {
            let t9, e5 = false;
            try {
              t9 = JSON.parse(s3.responseText), e5 = true;
            } catch (t10) {
              r3(new x2(200, `JSON returned from ${n3.toString()} endpoint was invalid, yet status code was 200. Data was: ${s3.responseText}`), null);
            }
            e5 && r3(null, t9);
          } else {
            let t9 = "";
            switch (n3) {
              case c2.UserAuthentication:
                t9 = h2("authenticationEndpoint");
                break;
              case c2.ChannelAuthorization:
                t9 = `Clients must be authorized to join private or presence channels. ${h2("authorizationEndpoint")}`;
            }
            r3(new x2(s3.status, `Unable to retrieve auth string from ${n3.toString()} endpoint - received status: ${s3.status} from ${i3.endpoint}. ${t9}`), null);
          }
        }, s3.send(e4), s3;
      }, w2 = String.fromCharCode, _2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", S2 = {}, M2 = 0; M2 < 64; M2++) S2[_2.charAt(M2)] = M2;
      var T2 = function(t8) {
        var e4 = t8.charCodeAt(0);
        return e4 < 128 ? t8 : e4 < 2048 ? w2(192 | e4 >>> 6) + w2(128 | 63 & e4) : w2(224 | e4 >>> 12 & 15) + w2(128 | e4 >>> 6 & 63) + w2(128 | 63 & e4);
      }, E2 = function(t8) {
        return t8.replace(/[^\x00-\x7F]/g, T2);
      }, A2 = function(t8) {
        var e4 = [0, 2, 1][t8.length % 3], i3 = t8.charCodeAt(0) << 16 | (t8.length > 1 ? t8.charCodeAt(1) : 0) << 8 | (t8.length > 2 ? t8.charCodeAt(2) : 0);
        return [_2.charAt(i3 >>> 18), _2.charAt(i3 >>> 12 & 63), e4 >= 2 ? "=" : _2.charAt(i3 >>> 6 & 63), e4 >= 1 ? "=" : _2.charAt(63 & i3)].join("");
      }, C2 = window.btoa || function(t8) {
        return t8.replace(/[\s\S]{1,3}/g, A2);
      }, R2 = class {
        constructor(t8, e4, i3, n3) {
          this.clear = e4, this.timer = t8((() => {
            this.timer && (this.timer = n3(this.timer));
          }), i3);
        }
        isRunning() {
          return null !== this.timer;
        }
        ensureAborted() {
          this.timer && (this.clear(this.timer), this.timer = null);
        }
      };
      function P2(t8) {
        window.clearTimeout(t8);
      }
      function L2(t8) {
        window.clearInterval(t8);
      }
      class I2 extends R2 {
        constructor(t8, e4) {
          super(setTimeout, P2, t8, (function(t9) {
            return e4(), null;
          }));
        }
      }
      class D2 extends R2 {
        constructor(t8, e4) {
          super(setInterval, L2, t8, (function(t9) {
            return e4(), t9;
          }));
        }
      }
      var O2 = { now: () => Date.now ? Date.now() : (/* @__PURE__ */ new Date()).valueOf(), defer: (t8) => new I2(0, t8), method(t8, ...e4) {
        var i3 = Array.prototype.slice.call(arguments, 1);
        return function(e5) {
          return e5[t8].apply(e5, i3.concat(arguments));
        };
      } }, z2 = O2;
      function F2(t8, ...e4) {
        for (var i3 = 0; i3 < e4.length; i3++) {
          var n3 = e4[i3];
          for (var r3 in n3) n3[r3] && n3[r3].constructor && n3[r3].constructor === Object ? t8[r3] = F2(t8[r3] || {}, n3[r3]) : t8[r3] = n3[r3];
        }
        return t8;
      }
      function N2() {
        for (var t8 = ["Pusher"], e4 = 0; e4 < arguments.length; e4++) "string" == typeof arguments[e4] ? t8.push(arguments[e4]) : t8.push(Y2(arguments[e4]));
        return t8.join(" : ");
      }
      function B2(t8, e4) {
        var i3 = Array.prototype.indexOf;
        if (null === t8) return -1;
        if (i3 && t8.indexOf === i3) return t8.indexOf(e4);
        for (var n3 = 0, r3 = t8.length; n3 < r3; n3++) if (t8[n3] === e4) return n3;
        return -1;
      }
      function k2(t8, e4) {
        for (var i3 in t8) Object.prototype.hasOwnProperty.call(t8, i3) && e4(t8[i3], i3, t8);
      }
      function U2(t8) {
        var e4 = [];
        return k2(t8, (function(t9, i3) {
          e4.push(i3);
        })), e4;
      }
      function H2(t8, e4, i3) {
        for (var n3 = 0; n3 < t8.length; n3++) e4.call(i3 || window, t8[n3], n3, t8);
      }
      function V2(t8, e4) {
        for (var i3 = [], n3 = 0; n3 < t8.length; n3++) i3.push(e4(t8[n3], n3, t8, i3));
        return i3;
      }
      function j2(t8, e4) {
        e4 = e4 || function(t9) {
          return !!t9;
        };
        for (var i3 = [], n3 = 0; n3 < t8.length; n3++) e4(t8[n3], n3, t8, i3) && i3.push(t8[n3]);
        return i3;
      }
      function G2(t8, e4) {
        var i3 = {};
        return k2(t8, (function(n3, r3) {
          (e4 && e4(n3, r3, t8, i3) || Boolean(n3)) && (i3[r3] = n3);
        })), i3;
      }
      function W2(t8, e4) {
        for (var i3 = 0; i3 < t8.length; i3++) if (e4(t8[i3], i3, t8)) return true;
        return false;
      }
      function q2(t8) {
        return e4 = function(t9) {
          return "object" == typeof t9 && (t9 = Y2(t9)), encodeURIComponent((e5 = t9.toString(), C2(E2(e5))));
          var e5;
        }, i3 = {}, k2(t8, (function(t9, n3) {
          i3[n3] = e4(t9);
        })), i3;
        var e4, i3;
      }
      function X2(t8) {
        var e4, i3, n3 = G2(t8, (function(t9) {
          return void 0 !== t9;
        }));
        return V2((e4 = q2(n3), i3 = [], k2(e4, (function(t9, e5) {
          i3.push([e5, t9]);
        })), i3), z2.method("join", "=")).join("&");
      }
      function Y2(t8) {
        try {
          return JSON.stringify(t8);
        } catch (n3) {
          return JSON.stringify((e4 = [], i3 = [], (function t9(n4, r3) {
            var s3, o3, a3;
            switch (typeof n4) {
              case "object":
                if (!n4) return null;
                for (s3 = 0; s3 < e4.length; s3 += 1) if (e4[s3] === n4) return { $ref: i3[s3] };
                if (e4.push(n4), i3.push(r3), "[object Array]" === Object.prototype.toString.apply(n4)) for (a3 = [], s3 = 0; s3 < n4.length; s3 += 1) a3[s3] = t9(n4[s3], r3 + "[" + s3 + "]");
                else for (o3 in a3 = {}, n4) Object.prototype.hasOwnProperty.call(n4, o3) && (a3[o3] = t9(n4[o3], r3 + "[" + JSON.stringify(o3) + "]"));
                return a3;
              case "number":
              case "string":
              case "boolean":
                return n4;
            }
          })(t8, "$")));
        }
        var e4, i3;
      }
      var Z2 = new class {
        constructor() {
          this.globalLog = (t8) => {
            window.console && window.console.log && window.console.log(t8);
          };
        }
        debug(...t8) {
          this.log(this.globalLog, t8);
        }
        warn(...t8) {
          this.log(this.globalLogWarn, t8);
        }
        error(...t8) {
          this.log(this.globalLogError, t8);
        }
        globalLogWarn(t8) {
          window.console && window.console.warn ? window.console.warn(t8) : this.globalLog(t8);
        }
        globalLogError(t8) {
          window.console && window.console.error ? window.console.error(t8) : this.globalLogWarn(t8);
        }
        log(t8, ...e4) {
          var i3 = N2.apply(this, arguments);
          Oe2.log ? Oe2.log(i3) : Oe2.logToConsole && t8.bind(this)(i3);
        }
      }(), J2 = function(t8, e4, i3, n3, r3) {
        void 0 === i3.headers && null == i3.headersProvider || Z2.warn(`To send headers with the ${n3.toString()} request, you must use AJAX, rather than JSONP.`);
        var s3 = t8.nextAuthCallbackID.toString();
        t8.nextAuthCallbackID++;
        var o3 = t8.getDocument(), a3 = o3.createElement("script");
        t8.auth_callbacks[s3] = function(t9) {
          r3(null, t9);
        };
        var l3 = "Pusher.auth_callbacks['" + s3 + "']";
        a3.src = i3.endpoint + "?callback=" + encodeURIComponent(l3) + "&" + e4;
        var c3 = o3.getElementsByTagName("head")[0] || o3.documentElement;
        c3.insertBefore(a3, c3.firstChild);
      };
      class K2 {
        constructor(t8) {
          this.src = t8;
        }
        send(t8) {
          var e4 = this, i3 = "Error loading " + e4.src;
          e4.script = document.createElement("script"), e4.script.id = t8.id, e4.script.src = e4.src, e4.script.type = "text/javascript", e4.script.charset = "UTF-8", e4.script.addEventListener ? (e4.script.onerror = function() {
            t8.callback(i3);
          }, e4.script.onload = function() {
            t8.callback(null);
          }) : e4.script.onreadystatechange = function() {
            "loaded" !== e4.script.readyState && "complete" !== e4.script.readyState || t8.callback(null);
          }, void 0 === e4.script.async && document.attachEvent && /opera/i.test(navigator.userAgent) ? (e4.errorScript = document.createElement("script"), e4.errorScript.id = t8.id + "_error", e4.errorScript.text = t8.name + "('" + i3 + "');", e4.script.async = e4.errorScript.async = false) : e4.script.async = true;
          var n3 = document.getElementsByTagName("head")[0];
          n3.insertBefore(e4.script, n3.firstChild), e4.errorScript && n3.insertBefore(e4.errorScript, e4.script.nextSibling);
        }
        cleanup() {
          this.script && (this.script.onload = this.script.onerror = null, this.script.onreadystatechange = null), this.script && this.script.parentNode && this.script.parentNode.removeChild(this.script), this.errorScript && this.errorScript.parentNode && this.errorScript.parentNode.removeChild(this.errorScript), this.script = null, this.errorScript = null;
        }
      }
      class $2 {
        constructor(t8, e4) {
          this.url = t8, this.data = e4;
        }
        send(t8) {
          if (!this.request) {
            var e4 = X2(this.data), i3 = this.url + "/" + t8.number + "?" + e4;
            this.request = pe2.createScriptRequest(i3), this.request.send(t8);
          }
        }
        cleanup() {
          this.request && this.request.cleanup();
        }
      }
      var Q2 = { name: "jsonp", getAgent: function(t8, e4) {
        return function(i3, n3) {
          var s3 = "http" + (e4 ? "s" : "") + "://" + (t8.host || t8.options.host) + t8.options.path, o3 = pe2.createJSONPRequest(s3, i3), a3 = pe2.ScriptReceivers.create((function(e5, i4) {
            r2.remove(a3), o3.cleanup(), i4 && i4.host && (t8.host = i4.host), n3 && n3(e5, i4);
          }));
          o3.send(a3);
        };
      } };
      function tt2(t8, e4, i3) {
        return t8 + (e4.useTLS ? "s" : "") + "://" + (e4.useTLS ? e4.hostTLS : e4.hostNonTLS) + i3;
      }
      function et2(t8, e4) {
        return "/app/" + t8 + "?protocol=" + s2.PROTOCOL + "&client=js&version=" + s2.VERSION + (e4 ? "&" + e4 : "");
      }
      var it2 = { getInitial: function(t8, e4) {
        return tt2("ws", e4, (e4.httpPath || "") + et2(t8, "flash=false"));
      } }, nt2 = { getInitial: function(t8, e4) {
        return tt2("http", e4, (e4.httpPath || "/pusher") + et2(t8));
      } }, rt2 = { getInitial: function(t8, e4) {
        return tt2("http", e4, e4.httpPath || "/pusher");
      }, getPath: function(t8, e4) {
        return et2(t8);
      } };
      class st2 {
        constructor() {
          this._callbacks = {};
        }
        get(t8) {
          return this._callbacks[ot2(t8)];
        }
        add(t8, e4, i3) {
          var n3 = ot2(t8);
          this._callbacks[n3] = this._callbacks[n3] || [], this._callbacks[n3].push({ fn: e4, context: i3 });
        }
        remove(t8, e4, i3) {
          if (t8 || e4 || i3) {
            var n3 = t8 ? [ot2(t8)] : U2(this._callbacks);
            e4 || i3 ? this.removeCallback(n3, e4, i3) : this.removeAllCallbacks(n3);
          } else this._callbacks = {};
        }
        removeCallback(t8, e4, i3) {
          H2(t8, (function(t9) {
            this._callbacks[t9] = j2(this._callbacks[t9] || [], (function(t10) {
              return e4 && e4 !== t10.fn || i3 && i3 !== t10.context;
            })), 0 === this._callbacks[t9].length && delete this._callbacks[t9];
          }), this);
        }
        removeAllCallbacks(t8) {
          H2(t8, (function(t9) {
            delete this._callbacks[t9];
          }), this);
        }
      }
      function ot2(t8) {
        return "_" + t8;
      }
      class at2 {
        constructor(t8) {
          this.callbacks = new st2(), this.global_callbacks = [], this.failThrough = t8;
        }
        bind(t8, e4, i3) {
          return this.callbacks.add(t8, e4, i3), this;
        }
        bind_global(t8) {
          return this.global_callbacks.push(t8), this;
        }
        unbind(t8, e4, i3) {
          return this.callbacks.remove(t8, e4, i3), this;
        }
        unbind_global(t8) {
          return t8 ? (this.global_callbacks = j2(this.global_callbacks || [], ((e4) => e4 !== t8)), this) : (this.global_callbacks = [], this);
        }
        unbind_all() {
          return this.unbind(), this.unbind_global(), this;
        }
        emit(t8, e4, i3) {
          for (var n3 = 0; n3 < this.global_callbacks.length; n3++) this.global_callbacks[n3](t8, e4);
          var r3 = this.callbacks.get(t8), s3 = [];
          if (i3 ? s3.push(e4, i3) : e4 && s3.push(e4), r3 && r3.length > 0) for (n3 = 0; n3 < r3.length; n3++) r3[n3].fn.apply(r3[n3].context || window, s3);
          else this.failThrough && this.failThrough(t8, e4);
          return this;
        }
      }
      class lt2 extends at2 {
        constructor(t8, e4, i3, n3, r3) {
          super(), this.initialize = pe2.transportConnectionInitializer, this.hooks = t8, this.name = e4, this.priority = i3, this.key = n3, this.options = r3, this.state = "new", this.timeline = r3.timeline, this.activityTimeout = r3.activityTimeout, this.id = this.timeline.generateUniqueID();
        }
        handlesActivityChecks() {
          return Boolean(this.hooks.handlesActivityChecks);
        }
        supportsPing() {
          return Boolean(this.hooks.supportsPing);
        }
        connect() {
          if (this.socket || "initialized" !== this.state) return false;
          var t8 = this.hooks.urls.getInitial(this.key, this.options);
          try {
            this.socket = this.hooks.getSocket(t8, this.options);
          } catch (t9) {
            return z2.defer((() => {
              this.onError(t9), this.changeState("closed");
            })), false;
          }
          return this.bindListeners(), Z2.debug("Connecting", { transport: this.name, url: t8 }), this.changeState("connecting"), true;
        }
        close() {
          return !!this.socket && (this.socket.close(), true);
        }
        send(t8) {
          return "open" === this.state && (z2.defer((() => {
            this.socket && this.socket.send(t8);
          })), true);
        }
        ping() {
          "open" === this.state && this.supportsPing() && this.socket.ping();
        }
        onOpen() {
          this.hooks.beforeOpen && this.hooks.beforeOpen(this.socket, this.hooks.urls.getPath(this.key, this.options)), this.changeState("open"), this.socket.onopen = void 0;
        }
        onError(t8) {
          this.emit("error", { type: "WebSocketError", error: t8 }), this.timeline.error(this.buildTimelineMessage({ error: t8.toString() }));
        }
        onClose(t8) {
          t8 ? this.changeState("closed", { code: t8.code, reason: t8.reason, wasClean: t8.wasClean }) : this.changeState("closed"), this.unbindListeners(), this.socket = void 0;
        }
        onMessage(t8) {
          this.emit("message", t8);
        }
        onActivity() {
          this.emit("activity");
        }
        bindListeners() {
          this.socket.onopen = () => {
            this.onOpen();
          }, this.socket.onerror = (t8) => {
            this.onError(t8);
          }, this.socket.onclose = (t8) => {
            this.onClose(t8);
          }, this.socket.onmessage = (t8) => {
            this.onMessage(t8);
          }, this.supportsPing() && (this.socket.onactivity = () => {
            this.onActivity();
          });
        }
        unbindListeners() {
          this.socket && (this.socket.onopen = void 0, this.socket.onerror = void 0, this.socket.onclose = void 0, this.socket.onmessage = void 0, this.supportsPing() && (this.socket.onactivity = void 0));
        }
        changeState(t8, e4) {
          this.state = t8, this.timeline.info(this.buildTimelineMessage({ state: t8, params: e4 })), this.emit(t8, e4);
        }
        buildTimelineMessage(t8) {
          return F2({ cid: this.id }, t8);
        }
      }
      class ct2 {
        constructor(t8) {
          this.hooks = t8;
        }
        isSupported(t8) {
          return this.hooks.isSupported(t8);
        }
        createConnection(t8, e4, i3, n3) {
          return new lt2(this.hooks, t8, e4, i3, n3);
        }
      }
      var ht2 = new ct2({ urls: it2, handlesActivityChecks: false, supportsPing: false, isInitialized: function() {
        return Boolean(pe2.getWebSocketAPI());
      }, isSupported: function() {
        return Boolean(pe2.getWebSocketAPI());
      }, getSocket: function(t8) {
        return pe2.createWebSocket(t8);
      } }), ut2 = { urls: nt2, handlesActivityChecks: false, supportsPing: true, isInitialized: function() {
        return true;
      } }, dt2 = F2({ getSocket: function(t8) {
        return pe2.HTTPFactory.createStreamingSocket(t8);
      } }, ut2), pt2 = F2({ getSocket: function(t8) {
        return pe2.HTTPFactory.createPollingSocket(t8);
      } }, ut2), ft2 = { isSupported: function() {
        return pe2.isXHRSupported();
      } }, mt2 = { ws: ht2, xhr_streaming: new ct2(F2({}, dt2, ft2)), xhr_polling: new ct2(F2({}, pt2, ft2)) }, gt2 = new ct2({ file: "sockjs", urls: rt2, handlesActivityChecks: true, supportsPing: false, isSupported: function() {
        return true;
      }, isInitialized: function() {
        return void 0 !== window.SockJS;
      }, getSocket: function(t8, e4) {
        return new window.SockJS(t8, null, { js_path: a2.getPath("sockjs", { useTLS: e4.useTLS }), ignore_null_origin: e4.ignoreNullOrigin });
      }, beforeOpen: function(t8, e4) {
        t8.send(JSON.stringify({ path: e4 }));
      } }), vt2 = { isSupported: function(t8) {
        return pe2.isXDRSupported(t8.useTLS);
      } }, yt2 = new ct2(F2({}, dt2, vt2)), xt2 = new ct2(F2({}, pt2, vt2));
      mt2.xdr_streaming = yt2, mt2.xdr_polling = xt2, mt2.sockjs = gt2;
      var bt2 = mt2, wt2 = new class extends at2 {
        constructor() {
          super();
          var t8 = this;
          void 0 !== window.addEventListener && (window.addEventListener("online", (function() {
            t8.emit("online");
          }), false), window.addEventListener("offline", (function() {
            t8.emit("offline");
          }), false));
        }
        isOnline() {
          return void 0 === window.navigator.onLine || window.navigator.onLine;
        }
      }();
      class _t2 {
        constructor(t8, e4, i3) {
          this.manager = t8, this.transport = e4, this.minPingDelay = i3.minPingDelay, this.maxPingDelay = i3.maxPingDelay, this.pingDelay = void 0;
        }
        createConnection(t8, e4, i3, n3) {
          n3 = F2({}, n3, { activityTimeout: this.pingDelay });
          var r3 = this.transport.createConnection(t8, e4, i3, n3), s3 = null, o3 = function() {
            r3.unbind("open", o3), r3.bind("closed", a3), s3 = z2.now();
          }, a3 = (t9) => {
            if (r3.unbind("closed", a3), 1002 === t9.code || 1003 === t9.code) this.manager.reportDeath();
            else if (!t9.wasClean && s3) {
              var e5 = z2.now() - s3;
              e5 < 2 * this.maxPingDelay && (this.manager.reportDeath(), this.pingDelay = Math.max(e5 / 2, this.minPingDelay));
            }
          };
          return r3.bind("open", o3), r3;
        }
        isSupported(t8) {
          return this.manager.isAlive() && this.transport.isSupported(t8);
        }
      }
      const St2 = { decodeMessage: function(t8) {
        try {
          var e4 = JSON.parse(t8.data), i3 = e4.data;
          if ("string" == typeof i3) try {
            i3 = JSON.parse(e4.data);
          } catch (t9) {
          }
          var n3 = { event: e4.event, channel: e4.channel, data: i3 };
          return e4.user_id && (n3.user_id = e4.user_id), n3;
        } catch (e5) {
          throw { type: "MessageParseError", error: e5, data: t8.data };
        }
      }, encodeMessage: function(t8) {
        return JSON.stringify(t8);
      }, processHandshake: function(t8) {
        var e4 = St2.decodeMessage(t8);
        if ("pusher:connection_established" === e4.event) {
          if (!e4.data.activity_timeout) throw "No activity timeout specified in handshake";
          return { action: "connected", id: e4.data.socket_id, activityTimeout: 1e3 * e4.data.activity_timeout };
        }
        if ("pusher:error" === e4.event) return { action: this.getCloseAction(e4.data), error: this.getCloseError(e4.data) };
        throw "Invalid handshake";
      }, getCloseAction: function(t8) {
        return t8.code < 4e3 ? t8.code >= 1002 && t8.code <= 1004 ? "backoff" : null : 4e3 === t8.code ? "tls_only" : t8.code < 4100 ? "refused" : t8.code < 4200 ? "backoff" : t8.code < 4300 ? "retry" : "refused";
      }, getCloseError: function(t8) {
        return 1e3 !== t8.code && 1001 !== t8.code ? { type: "PusherError", data: { code: t8.code, message: t8.reason || t8.message } } : null;
      } };
      var Mt2 = St2;
      class Tt2 extends at2 {
        constructor(t8, e4) {
          super(), this.id = t8, this.transport = e4, this.activityTimeout = e4.activityTimeout, this.bindListeners();
        }
        handlesActivityChecks() {
          return this.transport.handlesActivityChecks();
        }
        send(t8) {
          return this.transport.send(t8);
        }
        send_event(t8, e4, i3) {
          var n3 = { event: t8, data: e4 };
          return i3 && (n3.channel = i3), Z2.debug("Event sent", n3), this.send(Mt2.encodeMessage(n3));
        }
        ping() {
          this.transport.supportsPing() ? this.transport.ping() : this.send_event("pusher:ping", {});
        }
        close() {
          this.transport.close();
        }
        bindListeners() {
          var t8 = { message: (t9) => {
            var e5;
            try {
              e5 = Mt2.decodeMessage(t9);
            } catch (e6) {
              this.emit("error", { type: "MessageParseError", error: e6, data: t9.data });
            }
            if (void 0 !== e5) {
              switch (Z2.debug("Event recd", e5), e5.event) {
                case "pusher:error":
                  this.emit("error", { type: "PusherError", data: e5.data });
                  break;
                case "pusher:ping":
                  this.emit("ping");
                  break;
                case "pusher:pong":
                  this.emit("pong");
              }
              this.emit("message", e5);
            }
          }, activity: () => {
            this.emit("activity");
          }, error: (t9) => {
            this.emit("error", t9);
          }, closed: (t9) => {
            e4(), t9 && t9.code && this.handleCloseEvent(t9), this.transport = null, this.emit("closed");
          } }, e4 = () => {
            k2(t8, ((t9, e5) => {
              this.transport.unbind(e5, t9);
            }));
          };
          k2(t8, ((t9, e5) => {
            this.transport.bind(e5, t9);
          }));
        }
        handleCloseEvent(t8) {
          var e4 = Mt2.getCloseAction(t8), i3 = Mt2.getCloseError(t8);
          i3 && this.emit("error", i3), e4 && this.emit(e4, { action: e4, error: i3 });
        }
      }
      class Et2 {
        constructor(t8, e4) {
          this.transport = t8, this.callback = e4, this.bindListeners();
        }
        close() {
          this.unbindListeners(), this.transport.close();
        }
        bindListeners() {
          this.onMessage = (t8) => {
            var e4;
            this.unbindListeners();
            try {
              e4 = Mt2.processHandshake(t8);
            } catch (t9) {
              return this.finish("error", { error: t9 }), void this.transport.close();
            }
            "connected" === e4.action ? this.finish("connected", { connection: new Tt2(e4.id, this.transport), activityTimeout: e4.activityTimeout }) : (this.finish(e4.action, { error: e4.error }), this.transport.close());
          }, this.onClosed = (t8) => {
            this.unbindListeners();
            var e4 = Mt2.getCloseAction(t8) || "backoff", i3 = Mt2.getCloseError(t8);
            this.finish(e4, { error: i3 });
          }, this.transport.bind("message", this.onMessage), this.transport.bind("closed", this.onClosed);
        }
        unbindListeners() {
          this.transport.unbind("message", this.onMessage), this.transport.unbind("closed", this.onClosed);
        }
        finish(t8, e4) {
          this.callback(F2({ transport: this.transport, action: t8 }, e4));
        }
      }
      class At2 {
        constructor(t8, e4) {
          this.timeline = t8, this.options = e4 || {};
        }
        send(t8, e4) {
          this.timeline.isEmpty() || this.timeline.send(pe2.TimelineTransport.getAgent(this, t8), e4);
        }
      }
      class Ct2 extends at2 {
        constructor(t8, e4) {
          super((function(e5, i3) {
            Z2.debug("No callbacks on " + t8 + " for " + e5);
          })), this.name = t8, this.pusher = e4, this.subscribed = false, this.subscriptionPending = false, this.subscriptionCancelled = false;
        }
        authorize(t8, e4) {
          return e4(null, { auth: "" });
        }
        trigger(t8, e4) {
          if (0 !== t8.indexOf("client-")) throw new u2("Event '" + t8 + "' does not start with 'client-'");
          if (!this.subscribed) {
            var i3 = h2("triggeringClientEvents");
            Z2.warn(`Client event triggered before channel 'subscription_succeeded' event . ${i3}`);
          }
          return this.pusher.send_event(t8, e4, this.name);
        }
        disconnect() {
          this.subscribed = false, this.subscriptionPending = false;
        }
        handleEvent(t8) {
          var e4 = t8.event, i3 = t8.data;
          "pusher_internal:subscription_succeeded" === e4 ? this.handleSubscriptionSucceededEvent(t8) : "pusher_internal:subscription_count" === e4 ? this.handleSubscriptionCountEvent(t8) : 0 !== e4.indexOf("pusher_internal:") && this.emit(e4, i3, {});
        }
        handleSubscriptionSucceededEvent(t8) {
          this.subscriptionPending = false, this.subscribed = true, this.subscriptionCancelled ? this.pusher.unsubscribe(this.name) : this.emit("pusher:subscription_succeeded", t8.data);
        }
        handleSubscriptionCountEvent(t8) {
          t8.data.subscription_count && (this.subscriptionCount = t8.data.subscription_count), this.emit("pusher:subscription_count", t8.data);
        }
        subscribe() {
          this.subscribed || (this.subscriptionPending = true, this.subscriptionCancelled = false, this.authorize(this.pusher.connection.socket_id, ((t8, e4) => {
            t8 ? (this.subscriptionPending = false, Z2.error(t8.toString()), this.emit("pusher:subscription_error", Object.assign({}, { type: "AuthError", error: t8.message }, t8 instanceof x2 ? { status: t8.status } : {}))) : this.pusher.send_event("pusher:subscribe", { auth: e4.auth, channel_data: e4.channel_data, channel: this.name });
          })));
        }
        unsubscribe() {
          this.subscribed = false, this.pusher.send_event("pusher:unsubscribe", { channel: this.name });
        }
        cancelSubscription() {
          this.subscriptionCancelled = true;
        }
        reinstateSubscription() {
          this.subscriptionCancelled = false;
        }
      }
      class Rt2 extends Ct2 {
        authorize(t8, e4) {
          return this.pusher.config.channelAuthorizer({ channelName: this.name, socketId: t8 }, e4);
        }
      }
      class Pt2 {
        constructor() {
          this.reset();
        }
        get(t8) {
          return Object.prototype.hasOwnProperty.call(this.members, t8) ? { id: t8, info: this.members[t8] } : null;
        }
        each(t8) {
          k2(this.members, ((e4, i3) => {
            t8(this.get(i3));
          }));
        }
        setMyID(t8) {
          this.myID = t8;
        }
        onSubscription(t8) {
          this.members = t8.presence.hash, this.count = t8.presence.count, this.me = this.get(this.myID);
        }
        addMember(t8) {
          return null === this.get(t8.user_id) && this.count++, this.members[t8.user_id] = t8.user_info, this.get(t8.user_id);
        }
        removeMember(t8) {
          var e4 = this.get(t8.user_id);
          return e4 && (delete this.members[t8.user_id], this.count--), e4;
        }
        reset() {
          this.members = {}, this.count = 0, this.myID = null, this.me = null;
        }
      }
      var Lt2 = function(t8, e4, i3, n3) {
        return new (i3 || (i3 = Promise))((function(r3, s3) {
          function o3(t9) {
            try {
              l3(n3.next(t9));
            } catch (t10) {
              s3(t10);
            }
          }
          function a3(t9) {
            try {
              l3(n3.throw(t9));
            } catch (t10) {
              s3(t10);
            }
          }
          function l3(t9) {
            var e5;
            t9.done ? r3(t9.value) : (e5 = t9.value, e5 instanceof i3 ? e5 : new i3((function(t10) {
              t10(e5);
            }))).then(o3, a3);
          }
          l3((n3 = n3.apply(t8, e4 || [])).next());
        }));
      };
      class It2 extends Rt2 {
        constructor(t8, e4) {
          super(t8, e4), this.members = new Pt2();
        }
        authorize(t8, e4) {
          super.authorize(t8, ((t9, i3) => Lt2(this, void 0, void 0, (function* () {
            if (!t9) if (null != i3.channel_data) {
              var n3 = JSON.parse(i3.channel_data);
              this.members.setMyID(n3.user_id);
            } else {
              if (yield this.pusher.user.signinDonePromise, null == this.pusher.user.user_data) {
                let t10 = h2("authorizationEndpoint");
                return Z2.error(`Invalid auth response for channel '${this.name}', expected 'channel_data' field. ${t10}, or the user should be signed in.`), void e4("Invalid auth response");
              }
              this.members.setMyID(this.pusher.user.user_data.id);
            }
            e4(t9, i3);
          }))));
        }
        handleEvent(t8) {
          var e4 = t8.event;
          if (0 === e4.indexOf("pusher_internal:")) this.handleInternalEvent(t8);
          else {
            var i3 = t8.data, n3 = {};
            t8.user_id && (n3.user_id = t8.user_id), this.emit(e4, i3, n3);
          }
        }
        handleInternalEvent(t8) {
          var e4 = t8.event, i3 = t8.data;
          switch (e4) {
            case "pusher_internal:subscription_succeeded":
              this.handleSubscriptionSucceededEvent(t8);
              break;
            case "pusher_internal:subscription_count":
              this.handleSubscriptionCountEvent(t8);
              break;
            case "pusher_internal:member_added":
              var n3 = this.members.addMember(i3);
              this.emit("pusher:member_added", n3);
              break;
            case "pusher_internal:member_removed":
              var r3 = this.members.removeMember(i3);
              r3 && this.emit("pusher:member_removed", r3);
          }
        }
        handleSubscriptionSucceededEvent(t8) {
          this.subscriptionPending = false, this.subscribed = true, this.subscriptionCancelled ? this.pusher.unsubscribe(this.name) : (this.members.onSubscription(t8.data), this.emit("pusher:subscription_succeeded", this.members));
        }
        disconnect() {
          this.members.reset(), super.disconnect();
        }
      }
      var Dt2 = i2(1), Ot2 = i2(0);
      class zt2 extends Rt2 {
        constructor(t8, e4, i3) {
          super(t8, e4), this.key = null, this.nacl = i3;
        }
        authorize(t8, e4) {
          super.authorize(t8, ((t9, i3) => {
            if (t9) return void e4(t9, i3);
            let n3 = i3.shared_secret;
            n3 ? (this.key = Object(Ot2.decode)(n3), delete i3.shared_secret, e4(null, i3)) : e4(new Error(`No shared_secret key in auth payload for encrypted channel: ${this.name}`), null);
          }));
        }
        trigger(t8, e4) {
          throw new g2("Client events are not currently supported for encrypted channels");
        }
        handleEvent(t8) {
          var e4 = t8.event, i3 = t8.data;
          0 !== e4.indexOf("pusher_internal:") && 0 !== e4.indexOf("pusher:") ? this.handleEncryptedEvent(e4, i3) : super.handleEvent(t8);
        }
        handleEncryptedEvent(t8, e4) {
          if (!this.key) return void Z2.debug("Received encrypted event before key has been retrieved from the authEndpoint");
          if (!e4.ciphertext || !e4.nonce) return void Z2.error("Unexpected format for encrypted event, expected object with `ciphertext` and `nonce` fields, got: " + e4);
          let i3 = Object(Ot2.decode)(e4.ciphertext);
          if (i3.length < this.nacl.secretbox.overheadLength) return void Z2.error(`Expected encrypted event ciphertext length to be ${this.nacl.secretbox.overheadLength}, got: ${i3.length}`);
          let n3 = Object(Ot2.decode)(e4.nonce);
          if (n3.length < this.nacl.secretbox.nonceLength) return void Z2.error(`Expected encrypted event nonce length to be ${this.nacl.secretbox.nonceLength}, got: ${n3.length}`);
          let r3 = this.nacl.secretbox.open(i3, n3, this.key);
          if (null === r3) return Z2.debug("Failed to decrypt an event, probably because it was encrypted with a different key. Fetching a new key from the authEndpoint..."), void this.authorize(this.pusher.connection.socket_id, ((e5, s3) => {
            e5 ? Z2.error(`Failed to make a request to the authEndpoint: ${s3}. Unable to fetch new key, so dropping encrypted event`) : (r3 = this.nacl.secretbox.open(i3, n3, this.key), null !== r3 ? this.emit(t8, this.getDataToEmit(r3)) : Z2.error("Failed to decrypt event with new key. Dropping encrypted event"));
          }));
          this.emit(t8, this.getDataToEmit(r3));
        }
        getDataToEmit(t8) {
          let e4 = Object(Dt2.decode)(t8);
          try {
            return JSON.parse(e4);
          } catch (t9) {
            return e4;
          }
        }
      }
      class Ft2 extends at2 {
        constructor(t8, e4) {
          super(), this.state = "initialized", this.connection = null, this.key = t8, this.options = e4, this.timeline = this.options.timeline, this.usingTLS = this.options.useTLS, this.errorCallbacks = this.buildErrorCallbacks(), this.connectionCallbacks = this.buildConnectionCallbacks(this.errorCallbacks), this.handshakeCallbacks = this.buildHandshakeCallbacks(this.errorCallbacks);
          var i3 = pe2.getNetwork();
          i3.bind("online", (() => {
            this.timeline.info({ netinfo: "online" }), "connecting" !== this.state && "unavailable" !== this.state || this.retryIn(0);
          })), i3.bind("offline", (() => {
            this.timeline.info({ netinfo: "offline" }), this.connection && this.sendActivityCheck();
          })), this.updateStrategy();
        }
        connect() {
          this.connection || this.runner || (this.strategy.isSupported() ? (this.updateState("connecting"), this.startConnecting(), this.setUnavailableTimer()) : this.updateState("failed"));
        }
        send(t8) {
          return !!this.connection && this.connection.send(t8);
        }
        send_event(t8, e4, i3) {
          return !!this.connection && this.connection.send_event(t8, e4, i3);
        }
        disconnect() {
          this.disconnectInternally(), this.updateState("disconnected");
        }
        isUsingTLS() {
          return this.usingTLS;
        }
        startConnecting() {
          var t8 = (e4, i3) => {
            e4 ? this.runner = this.strategy.connect(0, t8) : "error" === i3.action ? (this.emit("error", { type: "HandshakeError", error: i3.error }), this.timeline.error({ handshakeError: i3.error })) : (this.abortConnecting(), this.handshakeCallbacks[i3.action](i3));
          };
          this.runner = this.strategy.connect(0, t8);
        }
        abortConnecting() {
          this.runner && (this.runner.abort(), this.runner = null);
        }
        disconnectInternally() {
          this.abortConnecting(), this.clearRetryTimer(), this.clearUnavailableTimer(), this.connection && this.abandonConnection().close();
        }
        updateStrategy() {
          this.strategy = this.options.getStrategy({ key: this.key, timeline: this.timeline, useTLS: this.usingTLS });
        }
        retryIn(t8) {
          this.timeline.info({ action: "retry", delay: t8 }), t8 > 0 && this.emit("connecting_in", Math.round(t8 / 1e3)), this.retryTimer = new I2(t8 || 0, (() => {
            this.disconnectInternally(), this.connect();
          }));
        }
        clearRetryTimer() {
          this.retryTimer && (this.retryTimer.ensureAborted(), this.retryTimer = null);
        }
        setUnavailableTimer() {
          this.unavailableTimer = new I2(this.options.unavailableTimeout, (() => {
            this.updateState("unavailable");
          }));
        }
        clearUnavailableTimer() {
          this.unavailableTimer && this.unavailableTimer.ensureAborted();
        }
        sendActivityCheck() {
          this.stopActivityCheck(), this.connection.ping(), this.activityTimer = new I2(this.options.pongTimeout, (() => {
            this.timeline.error({ pong_timed_out: this.options.pongTimeout }), this.retryIn(0);
          }));
        }
        resetActivityCheck() {
          this.stopActivityCheck(), this.connection && !this.connection.handlesActivityChecks() && (this.activityTimer = new I2(this.activityTimeout, (() => {
            this.sendActivityCheck();
          })));
        }
        stopActivityCheck() {
          this.activityTimer && this.activityTimer.ensureAborted();
        }
        buildConnectionCallbacks(t8) {
          return F2({}, t8, { message: (t9) => {
            this.resetActivityCheck(), this.emit("message", t9);
          }, ping: () => {
            this.send_event("pusher:pong", {});
          }, activity: () => {
            this.resetActivityCheck();
          }, error: (t9) => {
            this.emit("error", t9);
          }, closed: () => {
            this.abandonConnection(), this.shouldRetry() && this.retryIn(1e3);
          } });
        }
        buildHandshakeCallbacks(t8) {
          return F2({}, t8, { connected: (t9) => {
            this.activityTimeout = Math.min(this.options.activityTimeout, t9.activityTimeout, t9.connection.activityTimeout || 1 / 0), this.clearUnavailableTimer(), this.setConnection(t9.connection), this.socket_id = this.connection.id, this.updateState("connected", { socket_id: this.socket_id });
          } });
        }
        buildErrorCallbacks() {
          let t8 = (t9) => (e4) => {
            e4.error && this.emit("error", { type: "WebSocketError", error: e4.error }), t9(e4);
          };
          return { tls_only: t8((() => {
            this.usingTLS = true, this.updateStrategy(), this.retryIn(0);
          })), refused: t8((() => {
            this.disconnect();
          })), backoff: t8((() => {
            this.retryIn(1e3);
          })), retry: t8((() => {
            this.retryIn(0);
          })) };
        }
        setConnection(t8) {
          for (var e4 in this.connection = t8, this.connectionCallbacks) this.connection.bind(e4, this.connectionCallbacks[e4]);
          this.resetActivityCheck();
        }
        abandonConnection() {
          if (this.connection) {
            for (var t8 in this.stopActivityCheck(), this.connectionCallbacks) this.connection.unbind(t8, this.connectionCallbacks[t8]);
            var e4 = this.connection;
            return this.connection = null, e4;
          }
        }
        updateState(t8, e4) {
          var i3 = this.state;
          if (this.state = t8, i3 !== t8) {
            var n3 = t8;
            "connected" === n3 && (n3 += " with new socket ID " + e4.socket_id), Z2.debug("State changed", i3 + " -> " + n3), this.timeline.info({ state: t8, params: e4 }), this.emit("state_change", { previous: i3, current: t8 }), this.emit(t8, e4);
          }
        }
        shouldRetry() {
          return "connecting" === this.state || "connected" === this.state;
        }
      }
      class Nt2 {
        constructor() {
          this.channels = {};
        }
        add(t8, e4) {
          return this.channels[t8] || (this.channels[t8] = (function(t9, e5) {
            if (0 === t9.indexOf("private-encrypted-")) {
              if (e5.config.nacl) return kt2.createEncryptedChannel(t9, e5, e5.config.nacl);
              let i3 = "Tried to subscribe to a private-encrypted- channel but no nacl implementation available", n3 = h2("encryptedChannelSupport");
              throw new g2(`${i3}. ${n3}`);
            }
            if (0 === t9.indexOf("private-")) return kt2.createPrivateChannel(t9, e5);
            if (0 === t9.indexOf("presence-")) return kt2.createPresenceChannel(t9, e5);
            if (0 === t9.indexOf("#")) throw new d2('Cannot create a channel with name "' + t9 + '".');
            return kt2.createChannel(t9, e5);
          })(t8, e4)), this.channels[t8];
        }
        all() {
          return (function(t8) {
            var e4 = [];
            return k2(t8, (function(t9) {
              e4.push(t9);
            })), e4;
          })(this.channels);
        }
        find(t8) {
          return this.channels[t8];
        }
        remove(t8) {
          var e4 = this.channels[t8];
          return delete this.channels[t8], e4;
        }
        disconnect() {
          k2(this.channels, (function(t8) {
            t8.disconnect();
          }));
        }
      }
      var Bt2 = { createChannels: () => new Nt2(), createConnectionManager: (t8, e4) => new Ft2(t8, e4), createChannel: (t8, e4) => new Ct2(t8, e4), createPrivateChannel: (t8, e4) => new Rt2(t8, e4), createPresenceChannel: (t8, e4) => new It2(t8, e4), createEncryptedChannel: (t8, e4, i3) => new zt2(t8, e4, i3), createTimelineSender: (t8, e4) => new At2(t8, e4), createHandshake: (t8, e4) => new Et2(t8, e4), createAssistantToTheTransportManager: (t8, e4, i3) => new _t2(t8, e4, i3) }, kt2 = Bt2;
      class Ut2 {
        constructor(t8) {
          this.options = t8 || {}, this.livesLeft = this.options.lives || 1 / 0;
        }
        getAssistant(t8) {
          return kt2.createAssistantToTheTransportManager(this, t8, { minPingDelay: this.options.minPingDelay, maxPingDelay: this.options.maxPingDelay });
        }
        isAlive() {
          return this.livesLeft > 0;
        }
        reportDeath() {
          this.livesLeft -= 1;
        }
      }
      class Ht2 {
        constructor(t8, e4) {
          this.strategies = t8, this.loop = Boolean(e4.loop), this.failFast = Boolean(e4.failFast), this.timeout = e4.timeout, this.timeoutLimit = e4.timeoutLimit;
        }
        isSupported() {
          return W2(this.strategies, z2.method("isSupported"));
        }
        connect(t8, e4) {
          var i3 = this.strategies, n3 = 0, r3 = this.timeout, s3 = null, o3 = (a3, l3) => {
            l3 ? e4(null, l3) : (n3 += 1, this.loop && (n3 %= i3.length), n3 < i3.length ? (r3 && (r3 *= 2, this.timeoutLimit && (r3 = Math.min(r3, this.timeoutLimit))), s3 = this.tryStrategy(i3[n3], t8, { timeout: r3, failFast: this.failFast }, o3)) : e4(true));
          };
          return s3 = this.tryStrategy(i3[n3], t8, { timeout: r3, failFast: this.failFast }, o3), { abort: function() {
            s3.abort();
          }, forceMinPriority: function(e5) {
            t8 = e5, s3 && s3.forceMinPriority(e5);
          } };
        }
        tryStrategy(t8, e4, i3, n3) {
          var r3 = null, s3 = null;
          return i3.timeout > 0 && (r3 = new I2(i3.timeout, (function() {
            s3.abort(), n3(true);
          }))), s3 = t8.connect(e4, (function(t9, e5) {
            t9 && r3 && r3.isRunning() && !i3.failFast || (r3 && r3.ensureAborted(), n3(t9, e5));
          })), { abort: function() {
            r3 && r3.ensureAborted(), s3.abort();
          }, forceMinPriority: function(t9) {
            s3.forceMinPriority(t9);
          } };
        }
      }
      class Vt2 {
        constructor(t8) {
          this.strategies = t8;
        }
        isSupported() {
          return W2(this.strategies, z2.method("isSupported"));
        }
        connect(t8, e4) {
          return (function(t9, e5, i3) {
            var n3 = V2(t9, (function(t10, n4, r3, s3) {
              return t10.connect(e5, i3(n4, s3));
            }));
            return { abort: function() {
              H2(n3, jt2);
            }, forceMinPriority: function(t10) {
              H2(n3, (function(e6) {
                e6.forceMinPriority(t10);
              }));
            } };
          })(this.strategies, t8, (function(t9, i3) {
            return function(n3, r3) {
              i3[t9].error = n3, n3 ? (function(t10) {
                return (function(t11, e5) {
                  for (var i4 = 0; i4 < t11.length; i4++) if (!e5(t11[i4], i4, t11)) return false;
                  return true;
                })(t10, (function(t11) {
                  return Boolean(t11.error);
                }));
              })(i3) && e4(true) : (H2(i3, (function(t10) {
                t10.forceMinPriority(r3.transport.priority);
              })), e4(null, r3));
            };
          }));
        }
      }
      function jt2(t8) {
        t8.error || t8.aborted || (t8.abort(), t8.aborted = true);
      }
      class Gt2 {
        constructor(t8, e4, i3) {
          this.strategy = t8, this.transports = e4, this.ttl = i3.ttl || 18e5, this.usingTLS = i3.useTLS, this.timeline = i3.timeline;
        }
        isSupported() {
          return this.strategy.isSupported();
        }
        connect(t8, e4) {
          var i3 = this.usingTLS, n3 = (function(t9) {
            var e5 = pe2.getLocalStorage();
            if (e5) try {
              var i4 = e5[Wt2(t9)];
              if (i4) return JSON.parse(i4);
            } catch (e6) {
              qt2(t9);
            }
            return null;
          })(i3), r3 = n3 && n3.cacheSkipCount ? n3.cacheSkipCount : 0, s3 = [this.strategy];
          if (n3 && n3.timestamp + this.ttl >= z2.now()) {
            var o3 = this.transports[n3.transport];
            o3 && (["ws", "wss"].includes(n3.transport) || r3 > 3 ? (this.timeline.info({ cached: true, transport: n3.transport, latency: n3.latency }), s3.push(new Ht2([o3], { timeout: 2 * n3.latency + 1e3, failFast: true }))) : r3++);
          }
          var a3 = z2.now(), l3 = s3.pop().connect(t8, (function n4(o4, c3) {
            o4 ? (qt2(i3), s3.length > 0 ? (a3 = z2.now(), l3 = s3.pop().connect(t8, n4)) : e4(o4)) : ((function(t9, e5, i4, n5) {
              var r4 = pe2.getLocalStorage();
              if (r4) try {
                r4[Wt2(t9)] = Y2({ timestamp: z2.now(), transport: e5, latency: i4, cacheSkipCount: n5 });
              } catch (t10) {
              }
            })(i3, c3.transport.name, z2.now() - a3, r3), e4(null, c3));
          }));
          return { abort: function() {
            l3.abort();
          }, forceMinPriority: function(e5) {
            t8 = e5, l3 && l3.forceMinPriority(e5);
          } };
        }
      }
      function Wt2(t8) {
        return "pusherTransport" + (t8 ? "TLS" : "NonTLS");
      }
      function qt2(t8) {
        var e4 = pe2.getLocalStorage();
        if (e4) try {
          delete e4[Wt2(t8)];
        } catch (t9) {
        }
      }
      class Xt2 {
        constructor(t8, { delay: e4 }) {
          this.strategy = t8, this.options = { delay: e4 };
        }
        isSupported() {
          return this.strategy.isSupported();
        }
        connect(t8, e4) {
          var i3, n3 = this.strategy, r3 = new I2(this.options.delay, (function() {
            i3 = n3.connect(t8, e4);
          }));
          return { abort: function() {
            r3.ensureAborted(), i3 && i3.abort();
          }, forceMinPriority: function(e5) {
            t8 = e5, i3 && i3.forceMinPriority(e5);
          } };
        }
      }
      class Yt2 {
        constructor(t8, e4, i3) {
          this.test = t8, this.trueBranch = e4, this.falseBranch = i3;
        }
        isSupported() {
          return (this.test() ? this.trueBranch : this.falseBranch).isSupported();
        }
        connect(t8, e4) {
          return (this.test() ? this.trueBranch : this.falseBranch).connect(t8, e4);
        }
      }
      class Zt2 {
        constructor(t8) {
          this.strategy = t8;
        }
        isSupported() {
          return this.strategy.isSupported();
        }
        connect(t8, e4) {
          var i3 = this.strategy.connect(t8, (function(t9, n3) {
            n3 && i3.abort(), e4(t9, n3);
          }));
          return i3;
        }
      }
      function Jt2(t8) {
        return function() {
          return t8.isSupported();
        };
      }
      var Kt2, $t2 = function(t8, e4, i3) {
        var n3 = {};
        function r3(e5, r4, s4, o4, a4) {
          var l4 = i3(t8, e5, r4, s4, o4, a4);
          return n3[e5] = l4, l4;
        }
        var s3, o3 = Object.assign({}, e4, { hostNonTLS: t8.wsHost + ":" + t8.wsPort, hostTLS: t8.wsHost + ":" + t8.wssPort, httpPath: t8.wsPath }), a3 = Object.assign({}, o3, { useTLS: true }), l3 = Object.assign({}, e4, { hostNonTLS: t8.httpHost + ":" + t8.httpPort, hostTLS: t8.httpHost + ":" + t8.httpsPort, httpPath: t8.httpPath }), c3 = { loop: true, timeout: 15e3, timeoutLimit: 6e4 }, h3 = new Ut2({ minPingDelay: 1e4, maxPingDelay: t8.activityTimeout }), u3 = new Ut2({ lives: 2, minPingDelay: 1e4, maxPingDelay: t8.activityTimeout }), d3 = r3("ws", "ws", 3, o3, h3), p3 = r3("wss", "ws", 3, a3, h3), f3 = r3("sockjs", "sockjs", 1, l3), m3 = r3("xhr_streaming", "xhr_streaming", 1, l3, u3), g3 = r3("xdr_streaming", "xdr_streaming", 1, l3, u3), v3 = r3("xhr_polling", "xhr_polling", 1, l3), y3 = r3("xdr_polling", "xdr_polling", 1, l3), x3 = new Ht2([d3], c3), b3 = new Ht2([p3], c3), w3 = new Ht2([f3], c3), _3 = new Ht2([new Yt2(Jt2(m3), m3, g3)], c3), S3 = new Ht2([new Yt2(Jt2(v3), v3, y3)], c3), M3 = new Ht2([new Yt2(Jt2(_3), new Vt2([_3, new Xt2(S3, { delay: 4e3 })]), S3)], c3), T3 = new Yt2(Jt2(M3), M3, w3);
        return s3 = e4.useTLS ? new Vt2([x3, new Xt2(T3, { delay: 2e3 })]) : new Vt2([x3, new Xt2(b3, { delay: 2e3 }), new Xt2(T3, { delay: 5e3 })]), new Gt2(new Zt2(new Yt2(Jt2(d3), s3, T3)), n3, { ttl: 18e5, timeline: e4.timeline, useTLS: e4.useTLS });
      }, Qt2 = { getRequest: function(t8) {
        var e4 = new window.XDomainRequest();
        return e4.ontimeout = function() {
          t8.emit("error", new p2()), t8.close();
        }, e4.onerror = function(e5) {
          t8.emit("error", e5), t8.close();
        }, e4.onprogress = function() {
          e4.responseText && e4.responseText.length > 0 && t8.onChunk(200, e4.responseText);
        }, e4.onload = function() {
          e4.responseText && e4.responseText.length > 0 && t8.onChunk(200, e4.responseText), t8.emit("finished", 200), t8.close();
        }, e4;
      }, abortRequest: function(t8) {
        t8.ontimeout = t8.onerror = t8.onprogress = t8.onload = null, t8.abort();
      } };
      class te2 extends at2 {
        constructor(t8, e4, i3) {
          super(), this.hooks = t8, this.method = e4, this.url = i3;
        }
        start(t8) {
          this.position = 0, this.xhr = this.hooks.getRequest(this), this.unloader = () => {
            this.close();
          }, pe2.addUnloadListener(this.unloader), this.xhr.open(this.method, this.url, true), this.xhr.setRequestHeader && this.xhr.setRequestHeader("Content-Type", "application/json"), this.xhr.send(t8);
        }
        close() {
          this.unloader && (pe2.removeUnloadListener(this.unloader), this.unloader = null), this.xhr && (this.hooks.abortRequest(this.xhr), this.xhr = null);
        }
        onChunk(t8, e4) {
          for (; ; ) {
            var i3 = this.advanceBuffer(e4);
            if (!i3) break;
            this.emit("chunk", { status: t8, data: i3 });
          }
          this.isBufferTooLong(e4) && this.emit("buffer_too_long");
        }
        advanceBuffer(t8) {
          var e4 = t8.slice(this.position), i3 = e4.indexOf("\n");
          return -1 !== i3 ? (this.position += i3 + 1, e4.slice(0, i3)) : null;
        }
        isBufferTooLong(t8) {
          return this.position === t8.length && t8.length > 262144;
        }
      }
      !(function(t8) {
        t8[t8.CONNECTING = 0] = "CONNECTING", t8[t8.OPEN = 1] = "OPEN", t8[t8.CLOSED = 3] = "CLOSED";
      })(Kt2 || (Kt2 = {}));
      var ee2 = Kt2, ie2 = 1;
      function ne2(t8) {
        var e4 = -1 === t8.indexOf("?") ? "?" : "&";
        return t8 + e4 + "t=" + +/* @__PURE__ */ new Date() + "&n=" + ie2++;
      }
      function re2(t8) {
        return pe2.randomInt(t8);
      }
      var se2, oe2 = class {
        constructor(t8, e4) {
          this.hooks = t8, this.session = re2(1e3) + "/" + (function(t9) {
            for (var e5 = [], i3 = 0; i3 < t9; i3++) e5.push(re2(32).toString(32));
            return e5.join("");
          })(8), this.location = (function(t9) {
            var e5 = /([^\?]*)\/*(\??.*)/.exec(t9);
            return { base: e5[1], queryString: e5[2] };
          })(e4), this.readyState = ee2.CONNECTING, this.openStream();
        }
        send(t8) {
          return this.sendRaw(JSON.stringify([t8]));
        }
        ping() {
          this.hooks.sendHeartbeat(this);
        }
        close(t8, e4) {
          this.onClose(t8, e4, true);
        }
        sendRaw(t8) {
          if (this.readyState !== ee2.OPEN) return false;
          try {
            return pe2.createSocketRequest("POST", ne2((e4 = this.location, i3 = this.session, e4.base + "/" + i3 + "/xhr_send"))).start(t8), true;
          } catch (t9) {
            return false;
          }
          var e4, i3;
        }
        reconnect() {
          this.closeStream(), this.openStream();
        }
        onClose(t8, e4, i3) {
          this.closeStream(), this.readyState = ee2.CLOSED, this.onclose && this.onclose({ code: t8, reason: e4, wasClean: i3 });
        }
        onChunk(t8) {
          var e4;
          if (200 === t8.status) switch (this.readyState === ee2.OPEN && this.onActivity(), t8.data.slice(0, 1)) {
            case "o":
              e4 = JSON.parse(t8.data.slice(1) || "{}"), this.onOpen(e4);
              break;
            case "a":
              e4 = JSON.parse(t8.data.slice(1) || "[]");
              for (var i3 = 0; i3 < e4.length; i3++) this.onEvent(e4[i3]);
              break;
            case "m":
              e4 = JSON.parse(t8.data.slice(1) || "null"), this.onEvent(e4);
              break;
            case "h":
              this.hooks.onHeartbeat(this);
              break;
            case "c":
              e4 = JSON.parse(t8.data.slice(1) || "[]"), this.onClose(e4[0], e4[1], true);
          }
        }
        onOpen(t8) {
          var e4, i3, n3;
          this.readyState === ee2.CONNECTING ? (t8 && t8.hostname && (this.location.base = (e4 = this.location.base, i3 = t8.hostname, (n3 = /(https?:\/\/)([^\/:]+)((\/|:)?.*)/.exec(e4))[1] + i3 + n3[3])), this.readyState = ee2.OPEN, this.onopen && this.onopen()) : this.onClose(1006, "Server lost session", true);
        }
        onEvent(t8) {
          this.readyState === ee2.OPEN && this.onmessage && this.onmessage({ data: t8 });
        }
        onActivity() {
          this.onactivity && this.onactivity();
        }
        onError(t8) {
          this.onerror && this.onerror(t8);
        }
        openStream() {
          this.stream = pe2.createSocketRequest("POST", ne2(this.hooks.getReceiveURL(this.location, this.session))), this.stream.bind("chunk", ((t8) => {
            this.onChunk(t8);
          })), this.stream.bind("finished", ((t8) => {
            this.hooks.onFinished(this, t8);
          })), this.stream.bind("buffer_too_long", (() => {
            this.reconnect();
          }));
          try {
            this.stream.start();
          } catch (t8) {
            z2.defer((() => {
              this.onError(t8), this.onClose(1006, "Could not start streaming", false);
            }));
          }
        }
        closeStream() {
          this.stream && (this.stream.unbind_all(), this.stream.close(), this.stream = null);
        }
      }, ae2 = { getReceiveURL: function(t8, e4) {
        return t8.base + "/" + e4 + "/xhr_streaming" + t8.queryString;
      }, onHeartbeat: function(t8) {
        t8.sendRaw("[]");
      }, sendHeartbeat: function(t8) {
        t8.sendRaw("[]");
      }, onFinished: function(t8, e4) {
        t8.onClose(1006, "Connection interrupted (" + e4 + ")", false);
      } }, le2 = { getReceiveURL: function(t8, e4) {
        return t8.base + "/" + e4 + "/xhr" + t8.queryString;
      }, onHeartbeat: function() {
      }, sendHeartbeat: function(t8) {
        t8.sendRaw("[]");
      }, onFinished: function(t8, e4) {
        200 === e4 ? t8.reconnect() : t8.onClose(1006, "Connection interrupted (" + e4 + ")", false);
      } }, ce2 = { getRequest: function(t8) {
        var e4 = new (pe2.getXHRAPI())();
        return e4.onreadystatechange = e4.onprogress = function() {
          switch (e4.readyState) {
            case 3:
              e4.responseText && e4.responseText.length > 0 && t8.onChunk(e4.status, e4.responseText);
              break;
            case 4:
              e4.responseText && e4.responseText.length > 0 && t8.onChunk(e4.status, e4.responseText), t8.emit("finished", e4.status), t8.close();
          }
        }, e4;
      }, abortRequest: function(t8) {
        t8.onreadystatechange = null, t8.abort();
      } }, he2 = ce2, ue2 = { createStreamingSocket(t8) {
        return this.createSocket(ae2, t8);
      }, createPollingSocket(t8) {
        return this.createSocket(le2, t8);
      }, createSocket: (t8, e4) => new oe2(t8, e4), createXHR(t8, e4) {
        return this.createRequest(he2, t8, e4);
      }, createRequest: (t8, e4, i3) => new te2(t8, e4, i3), createXDR: function(t8, e4) {
        return this.createRequest(Qt2, t8, e4);
      } }, de2 = { nextAuthCallbackID: 1, auth_callbacks: {}, ScriptReceivers: r2, DependenciesReceivers: o2, getDefaultStrategy: $t2, Transports: bt2, transportConnectionInitializer: function() {
        var t8 = this;
        t8.timeline.info(t8.buildTimelineMessage({ transport: t8.name + (t8.options.useTLS ? "s" : "") })), t8.hooks.isInitialized() ? t8.changeState("initialized") : t8.hooks.file ? (t8.changeState("initializing"), a2.load(t8.hooks.file, { useTLS: t8.options.useTLS }, (function(e4, i3) {
          t8.hooks.isInitialized() ? (t8.changeState("initialized"), i3(true)) : (e4 && t8.onError(e4), t8.onClose(), i3(false));
        }))) : t8.onClose();
      }, HTTPFactory: ue2, TimelineTransport: Q2, getXHRAPI: () => window.XMLHttpRequest, getWebSocketAPI: () => window.WebSocket || window.MozWebSocket, setup(t8) {
        window.Pusher = t8;
        var e4 = () => {
          this.onDocumentBody(t8.ready);
        };
        window.JSON ? e4() : a2.load("json2", {}, e4);
      }, getDocument: () => document, getProtocol() {
        return this.getDocument().location.protocol;
      }, getAuthorizers: () => ({ ajax: b2, jsonp: J2 }), onDocumentBody(t8) {
        document.body ? t8() : setTimeout((() => {
          this.onDocumentBody(t8);
        }), 0);
      }, createJSONPRequest: (t8, e4) => new $2(t8, e4), createScriptRequest: (t8) => new K2(t8), getLocalStorage() {
        try {
          return window.localStorage;
        } catch (t8) {
          return;
        }
      }, createXHR() {
        return this.getXHRAPI() ? this.createXMLHttpRequest() : this.createMicrosoftXHR();
      }, createXMLHttpRequest() {
        return new (this.getXHRAPI())();
      }, createMicrosoftXHR: () => new ActiveXObject("Microsoft.XMLHTTP"), getNetwork: () => wt2, createWebSocket(t8) {
        return new (this.getWebSocketAPI())(t8);
      }, createSocketRequest(t8, e4) {
        if (this.isXHRSupported()) return this.HTTPFactory.createXHR(t8, e4);
        if (this.isXDRSupported(0 === e4.indexOf("https:"))) return this.HTTPFactory.createXDR(t8, e4);
        throw "Cross-origin HTTP requests are not supported";
      }, isXHRSupported() {
        var t8 = this.getXHRAPI();
        return Boolean(t8) && void 0 !== new t8().withCredentials;
      }, isXDRSupported(t8) {
        var e4 = t8 ? "https:" : "http:", i3 = this.getProtocol();
        return Boolean(window.XDomainRequest) && i3 === e4;
      }, addUnloadListener(t8) {
        void 0 !== window.addEventListener ? window.addEventListener("unload", t8, false) : void 0 !== window.attachEvent && window.attachEvent("onunload", t8);
      }, removeUnloadListener(t8) {
        void 0 !== window.addEventListener ? window.removeEventListener("unload", t8, false) : void 0 !== window.detachEvent && window.detachEvent("onunload", t8);
      }, randomInt: (t8) => Math.floor((window.crypto || window.msCrypto).getRandomValues(new Uint32Array(1))[0] / Math.pow(2, 32) * t8) }, pe2 = de2;
      !(function(t8) {
        t8[t8.ERROR = 3] = "ERROR", t8[t8.INFO = 6] = "INFO", t8[t8.DEBUG = 7] = "DEBUG";
      })(se2 || (se2 = {}));
      var fe2 = se2;
      class me2 {
        constructor(t8, e4, i3) {
          this.key = t8, this.session = e4, this.events = [], this.options = i3 || {}, this.sent = 0, this.uniqueID = 0;
        }
        log(t8, e4) {
          t8 <= this.options.level && (this.events.push(F2({}, e4, { timestamp: z2.now() })), this.options.limit && this.events.length > this.options.limit && this.events.shift());
        }
        error(t8) {
          this.log(fe2.ERROR, t8);
        }
        info(t8) {
          this.log(fe2.INFO, t8);
        }
        debug(t8) {
          this.log(fe2.DEBUG, t8);
        }
        isEmpty() {
          return 0 === this.events.length;
        }
        send(t8, e4) {
          var i3 = F2({ session: this.session, bundle: this.sent + 1, key: this.key, lib: "js", version: this.options.version, cluster: this.options.cluster, features: this.options.features, timeline: this.events }, this.options.params);
          return this.events = [], t8(i3, ((t9, i4) => {
            t9 || this.sent++, e4 && e4(t9, i4);
          })), true;
        }
        generateUniqueID() {
          return this.uniqueID++, this.uniqueID;
        }
      }
      class ge2 {
        constructor(t8, e4, i3, n3) {
          this.name = t8, this.priority = e4, this.transport = i3, this.options = n3 || {};
        }
        isSupported() {
          return this.transport.isSupported({ useTLS: this.options.useTLS });
        }
        connect(t8, e4) {
          if (!this.isSupported()) return ve2(new y2(), e4);
          if (this.priority < t8) return ve2(new f2(), e4);
          var i3 = false, n3 = this.transport.createConnection(this.name, this.priority, this.options.key, this.options), r3 = null, s3 = function() {
            n3.unbind("initialized", s3), n3.connect();
          }, o3 = function() {
            r3 = kt2.createHandshake(n3, (function(t9) {
              i3 = true, c3(), e4(null, t9);
            }));
          }, a3 = function(t9) {
            c3(), e4(t9);
          }, l3 = function() {
            var t9;
            c3(), t9 = Y2(n3), e4(new m2(t9));
          }, c3 = function() {
            n3.unbind("initialized", s3), n3.unbind("open", o3), n3.unbind("error", a3), n3.unbind("closed", l3);
          };
          return n3.bind("initialized", s3), n3.bind("open", o3), n3.bind("error", a3), n3.bind("closed", l3), n3.initialize(), { abort: () => {
            i3 || (c3(), r3 ? r3.close() : n3.close());
          }, forceMinPriority: (t9) => {
            i3 || this.priority < t9 && (r3 ? r3.close() : n3.close());
          } };
        }
      }
      function ve2(t8, e4) {
        return z2.defer((function() {
          e4(t8);
        })), { abort: function() {
        }, forceMinPriority: function() {
        } };
      }
      const { Transports: ye2 } = pe2;
      var xe2 = function(t8, e4, i3, n3, r3, s3) {
        var o3, a3 = ye2[i3];
        if (!a3) throw new v2(i3);
        return t8.enabledTransports && -1 === B2(t8.enabledTransports, e4) || t8.disabledTransports && -1 !== B2(t8.disabledTransports, e4) ? o3 = be2 : (r3 = Object.assign({ ignoreNullOrigin: t8.ignoreNullOrigin }, r3), o3 = new ge2(e4, n3, s3 ? s3.getAssistant(a3) : a3, r3)), o3;
      }, be2 = { isSupported: function() {
        return false;
      }, connect: function(t8, e4) {
        var i3 = z2.defer((function() {
          e4(new y2());
        }));
        return { abort: function() {
          i3.ensureAborted();
        }, forceMinPriority: function() {
        } };
      } }, we2 = (t8) => {
        if (void 0 === pe2.getAuthorizers()[t8.transport]) throw `'${t8.transport}' is not a recognized auth transport`;
        return (e4, i3) => {
          const n3 = ((t9, e5) => {
            var i4 = "socket_id=" + encodeURIComponent(t9.socketId);
            for (var n4 in e5.params) i4 += "&" + encodeURIComponent(n4) + "=" + encodeURIComponent(e5.params[n4]);
            if (null != e5.paramsProvider) {
              let t10 = e5.paramsProvider();
              for (var n4 in t10) i4 += "&" + encodeURIComponent(n4) + "=" + encodeURIComponent(t10[n4]);
            }
            return i4;
          })(e4, t8);
          pe2.getAuthorizers()[t8.transport](pe2, n3, t8, c2.UserAuthentication, i3);
        };
      }, _e2 = (t8) => {
        if (void 0 === pe2.getAuthorizers()[t8.transport]) throw `'${t8.transport}' is not a recognized auth transport`;
        return (e4, i3) => {
          const n3 = ((t9, e5) => {
            var i4 = "socket_id=" + encodeURIComponent(t9.socketId);
            for (var n4 in i4 += "&channel_name=" + encodeURIComponent(t9.channelName), e5.params) i4 += "&" + encodeURIComponent(n4) + "=" + encodeURIComponent(e5.params[n4]);
            if (null != e5.paramsProvider) {
              let t10 = e5.paramsProvider();
              for (var n4 in t10) i4 += "&" + encodeURIComponent(n4) + "=" + encodeURIComponent(t10[n4]);
            }
            return i4;
          })(e4, t8);
          pe2.getAuthorizers()[t8.transport](pe2, n3, t8, c2.ChannelAuthorization, i3);
        };
      };
      const Se2 = (t8, e4, i3) => {
        const n3 = { authTransport: e4.transport, authEndpoint: e4.endpoint, auth: { params: e4.params, headers: e4.headers } };
        return (e5, r3) => {
          const s3 = t8.channel(e5.channelName);
          i3(s3, n3).authorize(e5.socketId, r3);
        };
      };
      function Me2(t8) {
        return t8.httpHost ? t8.httpHost : t8.cluster ? `sockjs-${t8.cluster}.pusher.com` : s2.httpHost;
      }
      function Te2(t8) {
        return t8.wsHost ? t8.wsHost : `ws-${t8.cluster}.pusher.com`;
      }
      function Ee2(t8) {
        return "https:" === pe2.getProtocol() || false !== t8.forceTLS;
      }
      function Ae2(t8) {
        return "enableStats" in t8 ? t8.enableStats : "disableStats" in t8 && !t8.disableStats;
      }
      function Ce2(t8) {
        const e4 = Object.assign(Object.assign({}, s2.userAuthentication), t8.userAuthentication);
        return "customHandler" in e4 && null != e4.customHandler ? e4.customHandler : we2(e4);
      }
      function Re2(t8, e4) {
        const i3 = (function(t9, e5) {
          let i4;
          return "channelAuthorization" in t9 ? i4 = Object.assign(Object.assign({}, s2.channelAuthorization), t9.channelAuthorization) : (i4 = { transport: t9.authTransport || s2.authTransport, endpoint: t9.authEndpoint || s2.authEndpoint }, "auth" in t9 && ("params" in t9.auth && (i4.params = t9.auth.params), "headers" in t9.auth && (i4.headers = t9.auth.headers)), "authorizer" in t9 && (i4.customHandler = Se2(e5, i4, t9.authorizer))), i4;
        })(t8, e4);
        return "customHandler" in i3 && null != i3.customHandler ? i3.customHandler : _e2(i3);
      }
      class Pe2 extends at2 {
        constructor(t8) {
          super((function(t9, e4) {
            Z2.debug(`No callbacks on watchlist events for ${t9}`);
          })), this.pusher = t8, this.bindWatchlistInternalEvent();
        }
        handleEvent(t8) {
          t8.data.events.forEach(((t9) => {
            this.emit(t9.name, t9);
          }));
        }
        bindWatchlistInternalEvent() {
          this.pusher.connection.bind("message", ((t8) => {
            "pusher_internal:watchlist_events" === t8.event && this.handleEvent(t8);
          }));
        }
      }
      var Le2 = function() {
        let t8, e4;
        return { promise: new Promise(((i3, n3) => {
          t8 = i3, e4 = n3;
        })), resolve: t8, reject: e4 };
      };
      class Ie2 extends at2 {
        constructor(t8) {
          super((function(t9, e4) {
            Z2.debug("No callbacks on user for " + t9);
          })), this.signin_requested = false, this.user_data = null, this.serverToUserChannel = null, this.signinDonePromise = null, this._signinDoneResolve = null, this._onAuthorize = (t9, e4) => {
            if (t9) return Z2.warn(`Error during signin: ${t9}`), void this._cleanup();
            this.pusher.send_event("pusher:signin", { auth: e4.auth, user_data: e4.user_data });
          }, this.pusher = t8, this.pusher.connection.bind("state_change", (({ previous: t9, current: e4 }) => {
            "connected" !== t9 && "connected" === e4 && this._signin(), "connected" === t9 && "connected" !== e4 && (this._cleanup(), this._newSigninPromiseIfNeeded());
          })), this.watchlist = new Pe2(t8), this.pusher.connection.bind("message", ((t9) => {
            "pusher:signin_success" === t9.event && this._onSigninSuccess(t9.data), this.serverToUserChannel && this.serverToUserChannel.name === t9.channel && this.serverToUserChannel.handleEvent(t9);
          }));
        }
        signin() {
          this.signin_requested || (this.signin_requested = true, this._signin());
        }
        _signin() {
          this.signin_requested && (this._newSigninPromiseIfNeeded(), "connected" === this.pusher.connection.state && this.pusher.config.userAuthenticator({ socketId: this.pusher.connection.socket_id }, this._onAuthorize));
        }
        _onSigninSuccess(t8) {
          try {
            this.user_data = JSON.parse(t8.user_data);
          } catch (e4) {
            return Z2.error(`Failed parsing user data after signin: ${t8.user_data}`), void this._cleanup();
          }
          if ("string" != typeof this.user_data.id || "" === this.user_data.id) return Z2.error(`user_data doesn't contain an id. user_data: ${this.user_data}`), void this._cleanup();
          this._signinDoneResolve(), this._subscribeChannels();
        }
        _subscribeChannels() {
          this.serverToUserChannel = new Ct2(`#server-to-user-${this.user_data.id}`, this.pusher), this.serverToUserChannel.bind_global(((t8, e4) => {
            0 !== t8.indexOf("pusher_internal:") && 0 !== t8.indexOf("pusher:") && this.emit(t8, e4);
          })), ((t8) => {
            t8.subscriptionPending && t8.subscriptionCancelled ? t8.reinstateSubscription() : t8.subscriptionPending || "connected" !== this.pusher.connection.state || t8.subscribe();
          })(this.serverToUserChannel);
        }
        _cleanup() {
          this.user_data = null, this.serverToUserChannel && (this.serverToUserChannel.unbind_all(), this.serverToUserChannel.disconnect(), this.serverToUserChannel = null), this.signin_requested && this._signinDoneResolve();
        }
        _newSigninPromiseIfNeeded() {
          if (!this.signin_requested) return;
          if (this.signinDonePromise && !this.signinDonePromise.done) return;
          const { promise: t8, resolve: e4, reject: i3 } = Le2();
          t8.done = false;
          const n3 = () => {
            t8.done = true;
          };
          t8.then(n3).catch(n3), this.signinDonePromise = t8, this._signinDoneResolve = e4;
        }
      }
      class De2 {
        static ready() {
          De2.isReady = true;
          for (var t8 = 0, e4 = De2.instances.length; t8 < e4; t8++) De2.instances[t8].connect();
        }
        static getClientFeatures() {
          return U2(G2({ ws: pe2.Transports.ws }, (function(t8) {
            return t8.isSupported({});
          })));
        }
        constructor(t8, e4) {
          !(function(t9) {
            if (null == t9) throw "You must pass your app key when you instantiate Pusher.";
          })(t8), (function(t9) {
            if (null == t9) throw "You must pass an options object";
            if (null == t9.cluster) throw "Options object must provide a cluster";
            "disableStats" in t9 && Z2.warn("The disableStats option is deprecated in favor of enableStats");
          })(e4), this.key = t8, this.config = (function(t9, e5) {
            let i3 = { activityTimeout: t9.activityTimeout || s2.activityTimeout, cluster: t9.cluster, httpPath: t9.httpPath || s2.httpPath, httpPort: t9.httpPort || s2.httpPort, httpsPort: t9.httpsPort || s2.httpsPort, pongTimeout: t9.pongTimeout || s2.pongTimeout, statsHost: t9.statsHost || s2.stats_host, unavailableTimeout: t9.unavailableTimeout || s2.unavailableTimeout, wsPath: t9.wsPath || s2.wsPath, wsPort: t9.wsPort || s2.wsPort, wssPort: t9.wssPort || s2.wssPort, enableStats: Ae2(t9), httpHost: Me2(t9), useTLS: Ee2(t9), wsHost: Te2(t9), userAuthenticator: Ce2(t9), channelAuthorizer: Re2(t9, e5) };
            return "disabledTransports" in t9 && (i3.disabledTransports = t9.disabledTransports), "enabledTransports" in t9 && (i3.enabledTransports = t9.enabledTransports), "ignoreNullOrigin" in t9 && (i3.ignoreNullOrigin = t9.ignoreNullOrigin), "timelineParams" in t9 && (i3.timelineParams = t9.timelineParams), "nacl" in t9 && (i3.nacl = t9.nacl), i3;
          })(e4, this), this.channels = kt2.createChannels(), this.global_emitter = new at2(), this.sessionID = pe2.randomInt(1e9), this.timeline = new me2(this.key, this.sessionID, { cluster: this.config.cluster, features: De2.getClientFeatures(), params: this.config.timelineParams || {}, limit: 50, level: fe2.INFO, version: s2.VERSION }), this.config.enableStats && (this.timelineSender = kt2.createTimelineSender(this.timeline, { host: this.config.statsHost, path: "/timeline/v2/" + pe2.TimelineTransport.name })), this.connection = kt2.createConnectionManager(this.key, { getStrategy: (t9) => pe2.getDefaultStrategy(this.config, t9, xe2), timeline: this.timeline, activityTimeout: this.config.activityTimeout, pongTimeout: this.config.pongTimeout, unavailableTimeout: this.config.unavailableTimeout, useTLS: Boolean(this.config.useTLS) }), this.connection.bind("connected", (() => {
            this.subscribeAll(), this.timelineSender && this.timelineSender.send(this.connection.isUsingTLS());
          })), this.connection.bind("message", ((t9) => {
            var e5 = 0 === t9.event.indexOf("pusher_internal:");
            if (t9.channel) {
              var i3 = this.channel(t9.channel);
              i3 && i3.handleEvent(t9);
            }
            e5 || this.global_emitter.emit(t9.event, t9.data);
          })), this.connection.bind("connecting", (() => {
            this.channels.disconnect();
          })), this.connection.bind("disconnected", (() => {
            this.channels.disconnect();
          })), this.connection.bind("error", ((t9) => {
            Z2.warn(t9);
          })), De2.instances.push(this), this.timeline.info({ instances: De2.instances.length }), this.user = new Ie2(this), De2.isReady && this.connect();
        }
        channel(t8) {
          return this.channels.find(t8);
        }
        allChannels() {
          return this.channels.all();
        }
        connect() {
          if (this.connection.connect(), this.timelineSender && !this.timelineSenderTimer) {
            var t8 = this.connection.isUsingTLS(), e4 = this.timelineSender;
            this.timelineSenderTimer = new D2(6e4, (function() {
              e4.send(t8);
            }));
          }
        }
        disconnect() {
          this.connection.disconnect(), this.timelineSenderTimer && (this.timelineSenderTimer.ensureAborted(), this.timelineSenderTimer = null);
        }
        bind(t8, e4, i3) {
          return this.global_emitter.bind(t8, e4, i3), this;
        }
        unbind(t8, e4, i3) {
          return this.global_emitter.unbind(t8, e4, i3), this;
        }
        bind_global(t8) {
          return this.global_emitter.bind_global(t8), this;
        }
        unbind_global(t8) {
          return this.global_emitter.unbind_global(t8), this;
        }
        unbind_all(t8) {
          return this.global_emitter.unbind_all(), this;
        }
        subscribeAll() {
          var t8;
          for (t8 in this.channels.channels) this.channels.channels.hasOwnProperty(t8) && this.subscribe(t8);
        }
        subscribe(t8) {
          var e4 = this.channels.add(t8, this);
          return e4.subscriptionPending && e4.subscriptionCancelled ? e4.reinstateSubscription() : e4.subscriptionPending || "connected" !== this.connection.state || e4.subscribe(), e4;
        }
        unsubscribe(t8) {
          var e4 = this.channels.find(t8);
          e4 && e4.subscriptionPending ? e4.cancelSubscription() : (e4 = this.channels.remove(t8)) && e4.subscribed && e4.unsubscribe();
        }
        send_event(t8, e4, i3) {
          return this.connection.send_event(t8, e4, i3);
        }
        shouldUseTLS() {
          return this.config.useTLS;
        }
        signin() {
          this.user.signin();
        }
      }
      De2.instances = [], De2.isReady = false, De2.logToConsole = false, De2.Runtime = pe2, De2.ScriptReceivers = pe2.ScriptReceivers, De2.DependenciesReceivers = pe2.DependenciesReceivers, De2.auth_callbacks = pe2.auth_callbacks;
      var Oe2 = e3.default = De2;
      pe2.setup(De2);
    }]);
  }, t6.exports = e2();
}, 4801: function(t6, e2, i2) {
  var n2;
  t6 = i2.nmd(t6), (function(t7, r2, s2, o2, a2, l2, c2, h2, u2) {
    var d2 = s2.pow(o2, 6), p2 = s2.pow(2, 52), f2 = 2 * p2, m2 = 255, g2 = s2["seed" + u2] = function(e3, i3, n3) {
      var a3 = [], l3 = x2(y2(i3 ? [e3, b2(r2)] : null == e3 ? (function(e4) {
        try {
          return t7.crypto.getRandomValues(e4 = new Uint8Array(o2)), b2(e4);
        } catch (i4) {
          return [+/* @__PURE__ */ new Date(), t7, (e4 = t7.navigator) && e4.plugins, t7.screen, b2(r2)];
        }
      })() : e3, 3), a3), c3 = new v2(a3);
      return x2(b2(c3.S), r2), (n3 || function(t8, e4, i4) {
        return i4 ? (s2[u2] = t8, e4) : t8;
      })((function() {
        for (var t8 = c3.g(6), e4 = d2, i4 = 0; t8 < p2; ) t8 = (t8 + i4) * o2, e4 *= o2, i4 = c3.g(1);
        for (; t8 >= f2; ) t8 /= 2, e4 /= 2, i4 >>>= 1;
        return (t8 + i4) / e4;
      }), l3, this == s2);
    };
    function v2(t8) {
      var e3, i3 = t8.length, n3 = this, r3 = 0, s3 = n3.i = n3.j = 0, a3 = n3.S = [];
      for (i3 || (t8 = [i3++]); r3 < o2; ) a3[r3] = r3++;
      for (r3 = 0; r3 < o2; r3++) a3[r3] = a3[s3 = m2 & s3 + t8[r3 % i3] + (e3 = a3[r3])], a3[s3] = e3;
      (n3.g = function(t9) {
        for (var e4, i4 = 0, r4 = n3.i, s4 = n3.j, a4 = n3.S; t9--; ) e4 = a4[r4 = m2 & r4 + 1], i4 = i4 * o2 + a4[m2 & (a4[r4] = a4[s4 = m2 & s4 + e4]) + (a4[s4] = e4)];
        return n3.i = r4, n3.j = s4, i4;
      })(o2);
    }
    function y2(t8, e3) {
      var i3, n3 = [], r3 = typeof t8;
      if (e3 && "object" == r3) for (i3 in t8) try {
        n3.push(y2(t8[i3], e3 - 1));
      } catch (t9) {
      }
      return n3.length ? n3 : "string" == r3 ? t8 : t8 + "\0";
    }
    function x2(t8, e3) {
      for (var i3, n3 = t8 + "", r3 = 0; r3 < n3.length; ) e3[m2 & r3] = m2 & (i3 ^= 19 * e3[m2 & r3]) + n3.charCodeAt(r3++);
      return b2(e3);
    }
    function b2(t8) {
      return String.fromCharCode.apply(0, t8);
    }
    x2(s2[u2](), r2), c2 && c2.exports ? c2.exports = g2 : i2.amdD && i2.amdO && (void 0 === (n2 = (function() {
      return g2;
    }).call(e2, i2, e2, c2)) || (c2.exports = n2));
  })(this, [], Math, 256, 0, 0, t6, i2.amdD, "random");
}, 6571: function(t6) {
  var e2;
  t6.exports = (e2 = function() {
    function t7(t8) {
      return r2.appendChild(t8.dom), t8;
    }
    function i2(t8) {
      for (var e3 = 0; e3 < r2.children.length; e3++) r2.children[e3].style.display = e3 === t8 ? "block" : "none";
      n2 = t8;
    }
    var n2 = 0, r2 = document.createElement("div");
    r2.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", r2.addEventListener("click", (function(t8) {
      t8.preventDefault(), i2(++n2 % r2.children.length);
    }), false);
    var s2 = (performance || Date).now(), o2 = s2, a2 = 0, l2 = t7(new e2.Panel("FPS", "#0ff", "#002")), c2 = t7(new e2.Panel("MS", "#0f0", "#020"));
    if (self.performance && self.performance.memory) var h2 = t7(new e2.Panel("MB", "#f08", "#201"));
    return i2(0), { REVISION: 16, dom: r2, addPanel: t7, showPanel: i2, begin: function() {
      s2 = (performance || Date).now();
    }, end: function() {
      a2++;
      var t8 = (performance || Date).now();
      if (c2.update(t8 - s2, 200), t8 > o2 + 1e3 && (l2.update(1e3 * a2 / (t8 - o2), 100), o2 = t8, a2 = 0, h2)) {
        var e3 = performance.memory;
        h2.update(e3.usedJSHeapSize / 1048576, e3.jsHeapSizeLimit / 1048576);
      }
      return t8;
    }, update: function() {
      s2 = this.end();
    }, domElement: r2, setMode: i2 };
  }, e2.Panel = function(t7, e3, i2) {
    var n2 = 1 / 0, r2 = 0, s2 = Math.round, o2 = s2(window.devicePixelRatio || 1), a2 = 80 * o2, l2 = 48 * o2, c2 = 3 * o2, h2 = 2 * o2, u2 = 3 * o2, d2 = 15 * o2, p2 = 74 * o2, f2 = 30 * o2, m2 = document.createElement("canvas");
    m2.width = a2, m2.height = l2, m2.style.cssText = "width:80px;height:48px";
    var g2 = m2.getContext("2d");
    return g2.font = "bold " + 9 * o2 + "px Helvetica,Arial,sans-serif", g2.textBaseline = "top", g2.fillStyle = i2, g2.fillRect(0, 0, a2, l2), g2.fillStyle = e3, g2.fillText(t7, c2, h2), g2.fillRect(u2, d2, p2, f2), g2.fillStyle = i2, g2.globalAlpha = 0.9, g2.fillRect(u2, d2, p2, f2), { dom: m2, update: function(l3, v2) {
      n2 = Math.min(n2, l3), r2 = Math.max(r2, l3), g2.fillStyle = i2, g2.globalAlpha = 1, g2.fillRect(0, 0, a2, d2), g2.fillStyle = e3, g2.fillText(s2(l3) + " " + t7 + " (" + s2(n2) + "-" + s2(r2) + ")", c2, h2), g2.drawImage(m2, u2 + o2, d2, p2 - o2, f2, u2, d2, p2 - o2, f2), g2.fillRect(u2 + p2 - o2, d2, o2, f2), g2.fillStyle = i2, g2.globalAlpha = 0.9, g2.fillRect(u2 + p2 - o2, d2, o2, s2((1 - l3 / v2) * f2));
    } };
  }, e2);
}, 4795: (t6) => {
  for (var e2 = [], i2 = 0; i2 < 256; ++i2) e2[i2] = (i2 + 256).toString(16).substr(1);
  t6.exports = function(t7, i3) {
    var n2 = i3 || 0, r2 = e2;
    return [r2[t7[n2++]], r2[t7[n2++]], r2[t7[n2++]], r2[t7[n2++]], "-", r2[t7[n2++]], r2[t7[n2++]], "-", r2[t7[n2++]], r2[t7[n2++]], "-", r2[t7[n2++]], r2[t7[n2++]], "-", r2[t7[n2++]], r2[t7[n2++]], r2[t7[n2++]], r2[t7[n2++]], r2[t7[n2++]], r2[t7[n2++]]].join("");
  };
}, 6210: (t6) => {
  var e2 = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof window.msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto);
  if (e2) {
    var i2 = new Uint8Array(16);
    t6.exports = function() {
      return e2(i2), i2;
    };
  } else {
    var n2 = new Array(16);
    t6.exports = function() {
      for (var t7, e3 = 0; e3 < 16; e3++) 3 & e3 || (t7 = 4294967296 * Math.random()), n2[e3] = t7 >>> ((3 & e3) << 3) & 255;
      return n2;
    };
  }
}, 8389: (t6, e2, i2) => {
  var n2, r2, s2 = i2(6210), o2 = i2(4795), a2 = 0, l2 = 0;
  t6.exports = function(t7, e3, i3) {
    var c2 = e3 && i3 || 0, h2 = e3 || [], u2 = (t7 = t7 || {}).node || n2, d2 = void 0 !== t7.clockseq ? t7.clockseq : r2;
    if (null == u2 || null == d2) {
      var p2 = s2();
      null == u2 && (u2 = n2 = [1 | p2[0], p2[1], p2[2], p2[3], p2[4], p2[5]]), null == d2 && (d2 = r2 = 16383 & (p2[6] << 8 | p2[7]));
    }
    var f2 = void 0 !== t7.msecs ? t7.msecs : (/* @__PURE__ */ new Date()).getTime(), m2 = void 0 !== t7.nsecs ? t7.nsecs : l2 + 1, g2 = f2 - a2 + (m2 - l2) / 1e4;
    if (g2 < 0 && void 0 === t7.clockseq && (d2 = d2 + 1 & 16383), (g2 < 0 || f2 > a2) && void 0 === t7.nsecs && (m2 = 0), m2 >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    a2 = f2, l2 = m2, r2 = d2;
    var v2 = (1e4 * (268435455 & (f2 += 122192928e5)) + m2) % 4294967296;
    h2[c2++] = v2 >>> 24 & 255, h2[c2++] = v2 >>> 16 & 255, h2[c2++] = v2 >>> 8 & 255, h2[c2++] = 255 & v2;
    var y2 = f2 / 4294967296 * 1e4 & 268435455;
    h2[c2++] = y2 >>> 8 & 255, h2[c2++] = 255 & y2, h2[c2++] = y2 >>> 24 & 15 | 16, h2[c2++] = y2 >>> 16 & 255, h2[c2++] = d2 >>> 8 | 128, h2[c2++] = 255 & d2;
    for (var x2 = 0; x2 < 6; ++x2) h2[c2 + x2] = u2[x2];
    return e3 || o2(h2);
  };
} };
var e = {};
function i(n2) {
  var r2 = e[n2];
  if (void 0 !== r2) return r2.exports;
  var s2 = e[n2] = { id: n2, loaded: false, exports: {} };
  return t[n2].call(s2.exports, s2, s2.exports, i), s2.loaded = true, s2.exports;
}
i.amdD = function() {
  throw new Error("define cannot be used indirect");
}, i.amdO = {}, i.n = (t6) => {
  var e2 = t6 && t6.__esModule ? () => t6.default : () => t6;
  return i.d(e2, { a: e2 }), e2;
}, i.d = (t6, e2) => {
  for (var n2 in e2) i.o(e2, n2) && !i.o(t6, n2) && Object.defineProperty(t6, n2, { enumerable: true, get: e2[n2] });
}, i.g = (function() {
  if ("object" == typeof globalThis) return globalThis;
  try {
    return this || new Function("return this")();
  } catch (t6) {
    if ("object" == typeof window) return window;
  }
})(), i.o = (t6, e2) => Object.prototype.hasOwnProperty.call(t6, e2), i.r = (t6) => {
  "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t6, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t6, "__esModule", { value: true });
}, i.nmd = (t6) => (t6.paths = [], t6.children || (t6.children = []), t6);
var n = {};
i.d(n, { JX: () => ui, LG: () => hi, YL: () => di, zt: () => Si, s2: () => Ei, PA: () => _i, af: () => Mi, xu: () => Ti, ll: () => EI, QH: () => Ai, P5: () => wi, MZ: () => pi, $C: () => bi, jB: () => fi, wA: () => MI, KR: () => Ci, kS: () => xi, cL: () => SI, Hu: () => vi, RN: () => yi, JY: () => AI });
var r = {};
i.r(r), i.d(r, { hasBrowserEnv: () => St, hasStandardBrowserEnv: () => Tt, hasStandardBrowserWebWorkerEnv: () => Et, navigator: () => Mt, origin: () => At });
var s = {};
i.r(s), i.d(s, { ACESFilmicToneMapping: () => lr, AddEquation: () => Ln, AddOperation: () => nr, AdditiveAnimationBlendMode: () => Os, AdditiveBlending: () => An, AlphaFormat: () => Ur, AlwaysDepth: () => Yn, AlwaysStencilFunc: () => co, AmbientLight: () => ng, AmbientLightProbe: () => bg, AnimationClip: () => Am, AnimationLoader: () => Fm, AnimationMixer: () => Jg, AnimationObjectGroup: () => Xg, AnimationUtils: () => fm, ArcCurve: () => Pp, ArrayCamera: () => ld, ArrowHelper: () => Hv, Audio: () => Ig, AudioAnalyser: () => Bg, AudioContext: () => vg, AudioListener: () => Lg, AudioLoader: () => yg, AxesHelper: () => Vv, BackSide: () => wn, BasicDepthPacking: () => Us, BasicShadowMap: () => gn, Bone: () => Zd, BooleanKeyframeTrack: () => bm, Box2: () => lv, Box3: () => ga, Box3Helper: () => Fv, BoxBufferGeometry: () => gc, BoxGeometry: () => gc, BoxHelper: () => zv, BufferAttribute: () => Il, BufferGeometry: () => Jl, BufferGeometryLoader: () => hg, ByteType: () => Pr, Cache: () => Rm, Camera: () => wc, CameraHelper: () => Iv, CanvasTexture: () => Ap, CapsuleBufferGeometry: () => Kp, CapsuleGeometry: () => Kp, CatmullRomCurve3: () => Fp, CineonToneMapping: () => ar, CircleBufferGeometry: () => $p, CircleGeometry: () => $p, ClampToEdgeWrapping: () => vr, Clock: () => Tg, Color: () => $o, ColorKeyframeTrack: () => wm, ColorManagement: () => Wo, CompressedTexture: () => Ep, CompressedTextureLoader: () => Nm, ConeBufferGeometry: () => tf, ConeGeometry: () => tf, CubeCamera: () => Mc, CubeReflectionMapping: () => ur, CubeRefractionMapping: () => dr, CubeTexture: () => Tc, CubeTextureLoader: () => km, CubeUVReflectionMapping: () => mr, CubicBezierCurve: () => Up, CubicBezierCurve3: () => Hp, CubicInterpolant: () => gm, CullFaceBack: () => pn, CullFaceFront: () => fn, CullFaceFrontBack: () => mn, CullFaceNone: () => dn, Curve: () => Cp, CurvePath: () => Yp, CustomBlending: () => Pn, CustomToneMapping: () => cr, CylinderBufferGeometry: () => Qp, CylinderGeometry: () => Qp, Cylindrical: () => ov, Data3DTexture: () => ca, DataArrayTexture: () => aa, DataTexture: () => Jd, DataTexture2DArray: () => Qv, DataTexture3D: () => ty, DataTextureLoader: () => Um, DataUtils: () => qv, DecrementStencilOp: () => Ks, DecrementWrapStencilOp: () => Qs, DefaultLoadingManager: () => Lm, DepthFormat: () => Wr, DepthStencilFormat: () => qr, DepthTexture: () => dd, DirectionalLight: () => ig, DirectionalLightHelper: () => Rv, DiscreteInterpolant: () => ym, DodecahedronBufferGeometry: () => nf, DodecahedronGeometry: () => nf, DoubleSide: () => _n, DstAlphaFactor: () => Vn, DstColorFactor: () => Gn, DynamicCopyUsage: () => yo, DynamicDrawUsage: () => uo, DynamicReadUsage: () => mo, EdgesGeometry: () => lf, EllipseCurve: () => Rp, EqualDepth: () => Kn, EqualStencilFunc: () => ro, EquirectangularReflectionMapping: () => pr, EquirectangularRefractionMapping: () => fr, Euler: () => tl, EventDispatcher: () => So, ExtrudeBufferGeometry: () => Bf, ExtrudeGeometry: () => Bf, FileLoader: () => zm, FlatShading: () => Sn, Float16BufferAttribute: () => Ul, Float32BufferAttribute: () => Hl, Float64BufferAttribute: () => Vl, FloatType: () => zr, Fog: () => xd, FogExp2: () => yd, Font: () => Jv, FontLoader: () => Zv, FramebufferTexture: () => Tp, FrontSide: () => bn, Frustum: () => Dc, GLBufferAttribute: () => ev, GLSL1: () => bo, GLSL3: () => wo, GreaterDepth: () => Qn, GreaterEqualDepth: () => $n, GreaterEqualStencilFunc: () => lo, GreaterStencilFunc: () => oo, GridHelper: () => Mv, Group: () => cd, HalfFloatType: () => Fr, HemisphereLight: () => jm, HemisphereLightHelper: () => Sv, HemisphereLightProbe: () => xg, IcosahedronBufferGeometry: () => Uf, IcosahedronGeometry: () => Uf, ImageBitmapLoader: () => mg, ImageLoader: () => Bm, ImageUtils: () => ta, ImmediateRenderObject: () => Kv, IncrementStencilOp: () => Js, IncrementWrapStencilOp: () => $s, InstancedBufferAttribute: () => tp, InstancedBufferGeometry: () => cg, InstancedInterleavedBuffer: () => tv, InstancedMesh: () => sp, Int16BufferAttribute: () => Fl, Int32BufferAttribute: () => Bl, Int8BufferAttribute: () => Dl, IntType: () => Dr, InterleavedBuffer: () => wd, InterleavedBufferAttribute: () => Sd, Interpolant: () => mm, InterpolateDiscrete: () => As, InterpolateLinear: () => Cs, InterpolateSmooth: () => Rs, InvertStencilOp: () => to, KeepStencilOp: () => Ys, KeyframeTrack: () => xm, LOD: () => Vd, LatheBufferGeometry: () => Jp, LatheGeometry: () => Jp, Layers: () => el, LessDepth: () => Zn, LessEqualDepth: () => Jn, LessEqualStencilFunc: () => so, LessStencilFunc: () => no, Light: () => Vm, LightProbe: () => og, Line: () => dp, Line3: () => uv, LineBasicMaterial: () => op, LineCurve: () => Vp, LineCurve3: () => jp, LineDashedMaterial: () => am, LineLoop: () => gp, LineSegments: () => mp, LinearEncoding: () => Bs, LinearFilter: () => Mr, LinearInterpolant: () => vm, LinearMipMapLinearFilter: () => Cr, LinearMipMapNearestFilter: () => Er, LinearMipmapLinearFilter: () => Ar, LinearMipmapNearestFilter: () => Tr, LinearSRGBColorSpace: () => qs, LinearToneMapping: () => sr, Loader: () => Im, LoaderUtils: () => lg, LoadingManager: () => Pm, LoopOnce: () => Ms, LoopPingPong: () => Es, LoopRepeat: () => Ts, LuminanceAlphaFormat: () => Gr, LuminanceFormat: () => jr, MOUSE: () => hn, Material: () => Cl, MaterialLoader: () => ag, MathUtils: () => zo, Matrix3: () => No, Matrix4: () => Ga, MaxEquation: () => zn, Mesh: () => fc, MeshBasicMaterial: () => Rl, MeshDepthMaterial: () => td, MeshDistanceMaterial: () => ed, MeshLambertMaterial: () => sm, MeshMatcapMaterial: () => om, MeshNormalMaterial: () => rm, MeshPhongMaterial: () => im, MeshPhysicalMaterial: () => em, MeshStandardMaterial: () => tm, MeshToonMaterial: () => nm, MinEquation: () => On, MirroredRepeatWrapping: () => yr, MixOperation: () => ir, MultiplyBlending: () => Rn, MultiplyOperation: () => er, NearestFilter: () => xr, NearestMipMapLinearFilter: () => Sr, NearestMipMapNearestFilter: () => wr, NearestMipmapLinearFilter: () => _r, NearestMipmapNearestFilter: () => br, NeverDepth: () => Xn, NeverStencilFunc: () => eo, NoBlending: () => Tn, NoColorSpace: () => Gs, NoToneMapping: () => rr, NormalAnimationBlendMode: () => Ds, NormalBlending: () => En, NotEqualDepth: () => tr, NotEqualStencilFunc: () => ao, NumberKeyframeTrack: () => _m, Object3D: () => ml, ObjectLoader: () => ug, ObjectSpaceNormalMap: () => js, OctahedronBufferGeometry: () => Hf, OctahedronGeometry: () => Hf, OneFactor: () => Nn, OneMinusDstAlphaFactor: () => jn, OneMinusDstColorFactor: () => Wn, OneMinusSrcAlphaFactor: () => Hn, OneMinusSrcColorFactor: () => kn, OrthographicCamera: () => qc, PCFShadowMap: () => vn, PCFSoftShadowMap: () => yn, PMREMGenerator: () => eh, ParametricGeometry: () => Xv, Path: () => Zp, PerspectiveCamera: () => _c, Plane: () => Pc, PlaneBufferGeometry: () => Fc, PlaneGeometry: () => Fc, PlaneHelper: () => Nv, PointLight: () => tg, PointLightHelper: () => xv, Points: () => _p, PointsMaterial: () => vp, PolarGridHelper: () => Tv, PolyhedronBufferGeometry: () => ef, PolyhedronGeometry: () => ef, PositionalAudio: () => Ng, PropertyBinding: () => qg, PropertyMixer: () => kg, QuadraticBezierCurve: () => Gp, QuadraticBezierCurve3: () => Wp, Quaternion: () => da, QuaternionKeyframeTrack: () => Mm, QuaternionLinearInterpolant: () => Sm, REVISION: () => cn, RGBADepthPacking: () => Hs, RGBAFormat: () => Vr, RGBAIntegerFormat: () => Kr, RGBA_ASTC_10x10_Format: () => bs, RGBA_ASTC_10x5_Format: () => vs, RGBA_ASTC_10x6_Format: () => ys, RGBA_ASTC_10x8_Format: () => xs, RGBA_ASTC_12x10_Format: () => ws, RGBA_ASTC_12x12_Format: () => _s, RGBA_ASTC_4x4_Format: () => cs, RGBA_ASTC_5x4_Format: () => hs, RGBA_ASTC_5x5_Format: () => us, RGBA_ASTC_6x5_Format: () => ds, RGBA_ASTC_6x6_Format: () => ps, RGBA_ASTC_8x5_Format: () => fs, RGBA_ASTC_8x6_Format: () => ms, RGBA_ASTC_8x8_Format: () => gs, RGBA_BPTC_Format: () => Ss, RGBA_ETC2_EAC_Format: () => ls, RGBA_PVRTC_2BPPV1_Format: () => ss, RGBA_PVRTC_4BPPV1_Format: () => rs, RGBA_S3TC_DXT1_Format: () => Qr, RGBA_S3TC_DXT3_Format: () => ts, RGBA_S3TC_DXT5_Format: () => es, RGBFormat: () => Hr, RGB_ETC1_Format: () => os, RGB_ETC2_Format: () => as, RGB_PVRTC_2BPPV1_Format: () => ns, RGB_PVRTC_4BPPV1_Format: () => is, RGB_S3TC_DXT1_Format: () => $r, RGFormat: () => Zr, RGIntegerFormat: () => Jr, RawShaderMaterial: () => Qf, Ray: () => ja, Raycaster: () => iv, RectAreaLight: () => rg, RedFormat: () => Xr, RedIntegerFormat: () => Yr, ReinhardToneMapping: () => or, RepeatWrapping: () => gr, ReplaceStencilOp: () => Zs, ReverseSubtractEquation: () => Dn, RingBufferGeometry: () => Vf, RingGeometry: () => Vf, SRGBColorSpace: () => Ws, Scene: () => bd, ShaderChunk: () => Nc, ShaderLib: () => kc, ShaderMaterial: () => bc, ShadowMaterial: () => $f, Shape: () => cf, ShapeBufferGeometry: () => jf, ShapeGeometry: () => jf, ShapePath: () => jv, ShapeUtils: () => zf, ShortType: () => Lr, Skeleton: () => Qd, SkeletonHelper: () => vv, SkinnedMesh: () => Yd, SmoothShading: () => Mn, Source: () => ea, Sphere: () => za, SphereBufferGeometry: () => Gf, SphereGeometry: () => Gf, Spherical: () => sv, SphericalHarmonics3: () => sg, SplineCurve: () => qp, SpotLight: () => Zm, SpotLightHelper: () => pv, Sprite: () => Bd, SpriteMaterial: () => Md, SrcAlphaFactor: () => Un, SrcAlphaSaturateFactor: () => qn, SrcColorFactor: () => Bn, StaticCopyUsage: () => vo, StaticDrawUsage: () => ho, StaticReadUsage: () => fo, StereoCamera: () => Mg, StreamCopyUsage: () => xo, StreamDrawUsage: () => po, StreamReadUsage: () => go, StringKeyframeTrack: () => Tm, SubtractEquation: () => In, SubtractiveBlending: () => Cn, TOUCH: () => un, TangentSpaceNormalMap: () => Vs, TetrahedronBufferGeometry: () => Wf, TetrahedronGeometry: () => Wf, TextGeometry: () => Yv, Texture: () => ra, TextureLoader: () => Hm, TorusBufferGeometry: () => qf, TorusGeometry: () => qf, TorusKnotBufferGeometry: () => Xf, TorusKnotGeometry: () => Xf, Triangle: () => El, TriangleFanDrawMode: () => Ns, TriangleStripDrawMode: () => Fs, TrianglesDrawMode: () => zs, TubeBufferGeometry: () => Yf, TubeGeometry: () => Yf, UVMapping: () => hr, Uint16BufferAttribute: () => Nl, Uint32BufferAttribute: () => kl, Uint8BufferAttribute: () => Ol, Uint8ClampedBufferAttribute: () => zl, Uniform: () => Kg, UniformsGroup: () => Qg, UniformsLib: () => Bc, UniformsUtils: () => xc, UnsignedByteType: () => Rr, UnsignedInt248Type: () => kr, UnsignedIntType: () => Or, UnsignedShort4444Type: () => Nr, UnsignedShort5551Type: () => Br, UnsignedShortType: () => Ir, VSMShadowMap: () => xn, Vector2: () => Fo, Vector3: () => pa, Vector4: () => sa, VectorKeyframeTrack: () => Em, VideoTexture: () => Mp, WebGL1Renderer: () => vd, WebGL3DRenderTarget: () => ha, WebGLArrayRenderTarget: () => la, WebGLCubeRenderTarget: () => Ec, WebGLMultipleRenderTargets: () => ua, WebGLMultisampleRenderTarget: () => $v, WebGLRenderTarget: () => oa, WebGLRenderer: () => gd, WebGLUtils: () => ad, WireframeGeometry: () => Zf, WrapAroundEnding: () => Is, ZeroCurvatureEnding: () => Ps, ZeroFactor: () => Fn, ZeroSlopeEnding: () => Ls, ZeroStencilOp: () => Xs, _SRGBAFormat: () => _o, sRGBEncoding: () => ks });
var o = {};
i.r(o), i.d(o, { AsyncCompress: () => bw, AsyncDecompress: () => Fw, AsyncDeflate: () => dw, AsyncGunzip: () => Mw, AsyncGzip: () => bw, AsyncInflate: () => gw, AsyncUnzipInflate: () => c_, AsyncUnzlib: () => Iw, AsyncZipDeflate: () => n_, AsyncZlib: () => Cw, Compress: () => xw, DecodeUTF8: () => Gw, Decompress: () => zw, Deflate: () => uw, EncodeUTF8: () => Ww, Gunzip: () => Sw, Gzip: () => xw, Inflate: () => mw, Unzip: () => h_, UnzipInflate: () => l_, UnzipPassThrough: () => a_, Unzlib: () => Lw, Zip: () => r_, ZipDeflate: () => i_, ZipPassThrough: () => e_, Zlib: () => Aw, compress: () => ww, compressSync: () => _w, decompress: () => Nw, decompressSync: () => Bw, deflate: () => pw, deflateSync: () => fw, gunzip: () => Tw, gunzipSync: () => Ew, gzip: () => ww, gzipSync: () => _w, inflate: () => vw, inflateSync: () => yw, strFromU8: () => Xw, strToU8: () => qw, unzip: () => u_, unzipSync: () => d_, unzlib: () => Dw, unzlibSync: () => Ow, zip: () => s_, zipSync: () => o_, zlib: () => Rw, zlibSync: () => Pw });
var a = {};
i.r(a), i.d(a, { BoxZone: () => GP, LineZone: () => WP, MeshZone: () => qP, PointZone: () => XP, ScreenZone: () => YP, SphereZone: () => tL });
var l = {};
i.r(l), i.d(l, { Body: () => PP, BodySprite: () => BP, InitializerUtil: () => UP, Life: () => HP, Mass: () => VP, PolarVelocity: () => cL, Position: () => iL, RadialVelocity: () => hL, Radius: () => nL, Rate: () => rL, Texture: () => aL, VectorVelocity: () => uL });
var c = {};
i.r(c), i.d(c, { Alpha: () => xL, Attraction: () => bL, Behaviour: () => yL, Collision: () => wL, Color: () => _L, CrossZone: () => SL, Force: () => ML, Gravity: () => TL, RandomDrift: () => EL, Repulsion: () => AL, Rotate: () => CL, Scale: () => RL, Spring: () => PL });
var h = i(6479);
var u = i.n(h);
function d(t6, e2) {
  return function() {
    return t6.apply(e2, arguments);
  };
}
var p = i(5606);
var { toString: f } = Object.prototype;
var { getPrototypeOf: m } = Object;
var g = (v = /* @__PURE__ */ Object.create(null), (t6) => {
  const e2 = f.call(t6);
  return v[e2] || (v[e2] = e2.slice(8, -1).toLowerCase());
});
var v;
var y = (t6) => (t6 = t6.toLowerCase(), (e2) => g(e2) === t6);
var x = (t6) => (e2) => typeof e2 === t6;
var { isArray: b } = Array;
var w = x("undefined");
var _ = y("ArrayBuffer");
var S = x("string");
var M = x("function");
var T = x("number");
var E = (t6) => null !== t6 && "object" == typeof t6;
var A = (t6) => {
  if ("object" !== g(t6)) return false;
  const e2 = m(t6);
  return !(null !== e2 && e2 !== Object.prototype && null !== Object.getPrototypeOf(e2) || Symbol.toStringTag in t6 || Symbol.iterator in t6);
};
var C = y("Date");
var R = y("File");
var P = y("Blob");
var L = y("FileList");
var I = y("URLSearchParams");
var [D, O, z, F] = ["ReadableStream", "Request", "Response", "Headers"].map(y);
function N(t6, e2, { allOwnKeys: i2 = false } = {}) {
  if (null == t6) return;
  let n2, r2;
  if ("object" != typeof t6 && (t6 = [t6]), b(t6)) for (n2 = 0, r2 = t6.length; n2 < r2; n2++) e2.call(null, t6[n2], n2, t6);
  else {
    const r3 = i2 ? Object.getOwnPropertyNames(t6) : Object.keys(t6), s2 = r3.length;
    let o2;
    for (n2 = 0; n2 < s2; n2++) o2 = r3[n2], e2.call(null, t6[o2], o2, t6);
  }
}
function B(t6, e2) {
  e2 = e2.toLowerCase();
  const i2 = Object.keys(t6);
  let n2, r2 = i2.length;
  for (; r2-- > 0; ) if (n2 = i2[r2], e2 === n2.toLowerCase()) return n2;
  return null;
}
var k = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : global;
var U = (t6) => !w(t6) && t6 !== k;
var H = (V = "undefined" != typeof Uint8Array && m(Uint8Array), (t6) => V && t6 instanceof V);
var V;
var j = y("HTMLFormElement");
var G = (({ hasOwnProperty: t6 }) => (e2, i2) => t6.call(e2, i2))(Object.prototype);
var W = y("RegExp");
var q = (t6, e2) => {
  const i2 = Object.getOwnPropertyDescriptors(t6), n2 = {};
  N(i2, ((i3, r2) => {
    let s2;
    false !== (s2 = e2(i3, r2, t6)) && (n2[r2] = s2 || i3);
  })), Object.defineProperties(t6, n2);
};
var X = "abcdefghijklmnopqrstuvwxyz";
var Y = "0123456789";
var Z = { DIGIT: Y, ALPHA: X, ALPHA_DIGIT: X + X.toUpperCase() + Y };
var J = y("AsyncFunction");
var K = ($ = "function" == typeof setImmediate, Q = M(k.postMessage), $ ? setImmediate : Q ? (tt = `axios@${Math.random()}`, et = [], k.addEventListener("message", (({ source: t6, data: e2 }) => {
  t6 === k && e2 === tt && et.length && et.shift()();
}), false), (t6) => {
  et.push(t6), k.postMessage(tt, "*");
}) : (t6) => setTimeout(t6));
var $;
var Q;
var tt;
var et;
var it = "undefined" != typeof queueMicrotask ? queueMicrotask.bind(k) : void 0 !== p && p.nextTick || K;
var nt = { isArray: b, isArrayBuffer: _, isBuffer: function(t6) {
  return null !== t6 && !w(t6) && null !== t6.constructor && !w(t6.constructor) && M(t6.constructor.isBuffer) && t6.constructor.isBuffer(t6);
}, isFormData: (t6) => {
  let e2;
  return t6 && ("function" == typeof FormData && t6 instanceof FormData || M(t6.append) && ("formdata" === (e2 = g(t6)) || "object" === e2 && M(t6.toString) && "[object FormData]" === t6.toString()));
}, isArrayBufferView: function(t6) {
  let e2;
  return e2 = "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(t6) : t6 && t6.buffer && _(t6.buffer), e2;
}, isString: S, isNumber: T, isBoolean: (t6) => true === t6 || false === t6, isObject: E, isPlainObject: A, isReadableStream: D, isRequest: O, isResponse: z, isHeaders: F, isUndefined: w, isDate: C, isFile: R, isBlob: P, isRegExp: W, isFunction: M, isStream: (t6) => E(t6) && M(t6.pipe), isURLSearchParams: I, isTypedArray: H, isFileList: L, forEach: N, merge: function t2() {
  const { caseless: e2 } = U(this) && this || {}, i2 = {}, n2 = (n3, r2) => {
    const s2 = e2 && B(i2, r2) || r2;
    A(i2[s2]) && A(n3) ? i2[s2] = t2(i2[s2], n3) : A(n3) ? i2[s2] = t2({}, n3) : b(n3) ? i2[s2] = n3.slice() : i2[s2] = n3;
  };
  for (let t6 = 0, e3 = arguments.length; t6 < e3; t6++) arguments[t6] && N(arguments[t6], n2);
  return i2;
}, extend: (t6, e2, i2, { allOwnKeys: n2 } = {}) => (N(e2, ((e3, n3) => {
  i2 && M(e3) ? t6[n3] = d(e3, i2) : t6[n3] = e3;
}), { allOwnKeys: n2 }), t6), trim: (t6) => t6.trim ? t6.trim() : t6.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), stripBOM: (t6) => (65279 === t6.charCodeAt(0) && (t6 = t6.slice(1)), t6), inherits: (t6, e2, i2, n2) => {
  t6.prototype = Object.create(e2.prototype, n2), t6.prototype.constructor = t6, Object.defineProperty(t6, "super", { value: e2.prototype }), i2 && Object.assign(t6.prototype, i2);
}, toFlatObject: (t6, e2, i2, n2) => {
  let r2, s2, o2;
  const a2 = {};
  if (e2 = e2 || {}, null == t6) return e2;
  do {
    for (r2 = Object.getOwnPropertyNames(t6), s2 = r2.length; s2-- > 0; ) o2 = r2[s2], n2 && !n2(o2, t6, e2) || a2[o2] || (e2[o2] = t6[o2], a2[o2] = true);
    t6 = false !== i2 && m(t6);
  } while (t6 && (!i2 || i2(t6, e2)) && t6 !== Object.prototype);
  return e2;
}, kindOf: g, kindOfTest: y, endsWith: (t6, e2, i2) => {
  t6 = String(t6), (void 0 === i2 || i2 > t6.length) && (i2 = t6.length), i2 -= e2.length;
  const n2 = t6.indexOf(e2, i2);
  return -1 !== n2 && n2 === i2;
}, toArray: (t6) => {
  if (!t6) return null;
  if (b(t6)) return t6;
  let e2 = t6.length;
  if (!T(e2)) return null;
  const i2 = new Array(e2);
  for (; e2-- > 0; ) i2[e2] = t6[e2];
  return i2;
}, forEachEntry: (t6, e2) => {
  const i2 = (t6 && t6[Symbol.iterator]).call(t6);
  let n2;
  for (; (n2 = i2.next()) && !n2.done; ) {
    const i3 = n2.value;
    e2.call(t6, i3[0], i3[1]);
  }
}, matchAll: (t6, e2) => {
  let i2;
  const n2 = [];
  for (; null !== (i2 = t6.exec(e2)); ) n2.push(i2);
  return n2;
}, isHTMLForm: j, hasOwnProperty: G, hasOwnProp: G, reduceDescriptors: q, freezeMethods: (t6) => {
  q(t6, ((e2, i2) => {
    if (M(t6) && -1 !== ["arguments", "caller", "callee"].indexOf(i2)) return false;
    const n2 = t6[i2];
    M(n2) && (e2.enumerable = false, "writable" in e2 ? e2.writable = false : e2.set || (e2.set = () => {
      throw Error("Can not rewrite read-only method '" + i2 + "'");
    }));
  }));
}, toObjectSet: (t6, e2) => {
  const i2 = {}, n2 = (t7) => {
    t7.forEach(((t8) => {
      i2[t8] = true;
    }));
  };
  return b(t6) ? n2(t6) : n2(String(t6).split(e2)), i2;
}, toCamelCase: (t6) => t6.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, (function(t7, e2, i2) {
  return e2.toUpperCase() + i2;
})), noop: () => {
}, toFiniteNumber: (t6, e2) => null != t6 && Number.isFinite(t6 = +t6) ? t6 : e2, findKey: B, global: k, isContextDefined: U, ALPHABET: Z, generateString: (t6 = 16, e2 = Z.ALPHA_DIGIT) => {
  let i2 = "";
  const { length: n2 } = e2;
  for (; t6--; ) i2 += e2[Math.random() * n2 | 0];
  return i2;
}, isSpecCompliantForm: function(t6) {
  return !!(t6 && M(t6.append) && "FormData" === t6[Symbol.toStringTag] && t6[Symbol.iterator]);
}, toJSONObject: (t6) => {
  const e2 = new Array(10), i2 = (t7, n2) => {
    if (E(t7)) {
      if (e2.indexOf(t7) >= 0) return;
      if (!("toJSON" in t7)) {
        e2[n2] = t7;
        const r2 = b(t7) ? [] : {};
        return N(t7, ((t8, e3) => {
          const s2 = i2(t8, n2 + 1);
          !w(s2) && (r2[e3] = s2);
        })), e2[n2] = void 0, r2;
      }
    }
    return t7;
  };
  return i2(t6, 0);
}, isAsyncFn: J, isThenable: (t6) => t6 && (E(t6) || M(t6)) && M(t6.then) && M(t6.catch), setImmediate: K, asap: it };
function rt(t6, e2, i2, n2, r2) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t6, this.name = "AxiosError", e2 && (this.code = e2), i2 && (this.config = i2), n2 && (this.request = n2), r2 && (this.response = r2, this.status = r2.status ? r2.status : null);
}
nt.inherits(rt, Error, { toJSON: function() {
  return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: nt.toJSONObject(this.config), code: this.code, status: this.status };
} });
var st = rt.prototype;
var ot = {};
["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(((t6) => {
  ot[t6] = { value: t6 };
})), Object.defineProperties(rt, ot), Object.defineProperty(st, "isAxiosError", { value: true }), rt.from = (t6, e2, i2, n2, r2, s2) => {
  const o2 = Object.create(st);
  return nt.toFlatObject(t6, o2, (function(t7) {
    return t7 !== Error.prototype;
  }), ((t7) => "isAxiosError" !== t7)), rt.call(o2, t6.message, e2, i2, n2, r2), o2.cause = t6, o2.name = t6.name, s2 && Object.assign(o2, s2), o2;
};
var at = rt;
var lt = i(8287).hp;
function ct(t6) {
  return nt.isPlainObject(t6) || nt.isArray(t6);
}
function ht(t6) {
  return nt.endsWith(t6, "[]") ? t6.slice(0, -2) : t6;
}
function ut(t6, e2, i2) {
  return t6 ? t6.concat(e2).map((function(t7, e3) {
    return t7 = ht(t7), !i2 && e3 ? "[" + t7 + "]" : t7;
  })).join(i2 ? "." : "") : e2;
}
var dt = nt.toFlatObject(nt, {}, null, (function(t6) {
  return /^is[A-Z]/.test(t6);
}));
var pt = function(t6, e2, i2) {
  if (!nt.isObject(t6)) throw new TypeError("target must be an object");
  e2 = e2 || new FormData();
  const n2 = (i2 = nt.toFlatObject(i2, { metaTokens: true, dots: false, indexes: false }, false, (function(t7, e3) {
    return !nt.isUndefined(e3[t7]);
  }))).metaTokens, r2 = i2.visitor || c2, s2 = i2.dots, o2 = i2.indexes, a2 = (i2.Blob || "undefined" != typeof Blob && Blob) && nt.isSpecCompliantForm(e2);
  if (!nt.isFunction(r2)) throw new TypeError("visitor must be a function");
  function l2(t7) {
    if (null === t7) return "";
    if (nt.isDate(t7)) return t7.toISOString();
    if (!a2 && nt.isBlob(t7)) throw new at("Blob is not supported. Use a Buffer instead.");
    return nt.isArrayBuffer(t7) || nt.isTypedArray(t7) ? a2 && "function" == typeof Blob ? new Blob([t7]) : lt.from(t7) : t7;
  }
  function c2(t7, i3, r3) {
    let a3 = t7;
    if (t7 && !r3 && "object" == typeof t7) {
      if (nt.endsWith(i3, "{}")) i3 = n2 ? i3 : i3.slice(0, -2), t7 = JSON.stringify(t7);
      else if (nt.isArray(t7) && (function(t8) {
        return nt.isArray(t8) && !t8.some(ct);
      })(t7) || (nt.isFileList(t7) || nt.endsWith(i3, "[]")) && (a3 = nt.toArray(t7))) return i3 = ht(i3), a3.forEach((function(t8, n3) {
        !nt.isUndefined(t8) && null !== t8 && e2.append(true === o2 ? ut([i3], n3, s2) : null === o2 ? i3 : i3 + "[]", l2(t8));
      })), false;
    }
    return !!ct(t7) || (e2.append(ut(r3, i3, s2), l2(t7)), false);
  }
  const h2 = [], u2 = Object.assign(dt, { defaultVisitor: c2, convertValue: l2, isVisitable: ct });
  if (!nt.isObject(t6)) throw new TypeError("data must be an object");
  return (function t7(i3, n3) {
    if (!nt.isUndefined(i3)) {
      if (-1 !== h2.indexOf(i3)) throw Error("Circular reference detected in " + n3.join("."));
      h2.push(i3), nt.forEach(i3, (function(i4, s3) {
        true === (!(nt.isUndefined(i4) || null === i4) && r2.call(e2, i4, nt.isString(s3) ? s3.trim() : s3, n3, u2)) && t7(i4, n3 ? n3.concat(s3) : [s3]);
      })), h2.pop();
    }
  })(t6), e2;
};
function ft(t6) {
  const e2 = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" };
  return encodeURIComponent(t6).replace(/[!'()~]|%20|%00/g, (function(t7) {
    return e2[t7];
  }));
}
function mt(t6, e2) {
  this._pairs = [], t6 && pt(t6, this, e2);
}
var gt = mt.prototype;
gt.append = function(t6, e2) {
  this._pairs.push([t6, e2]);
}, gt.toString = function(t6) {
  const e2 = t6 ? function(e3) {
    return t6.call(this, e3, ft);
  } : ft;
  return this._pairs.map((function(t7) {
    return e2(t7[0]) + "=" + e2(t7[1]);
  }), "").join("&");
};
var vt = mt;
function yt(t6) {
  return encodeURIComponent(t6).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function xt(t6, e2, i2) {
  if (!e2) return t6;
  const n2 = i2 && i2.encode || yt;
  nt.isFunction(i2) && (i2 = { serialize: i2 });
  const r2 = i2 && i2.serialize;
  let s2;
  if (s2 = r2 ? r2(e2, i2) : nt.isURLSearchParams(e2) ? e2.toString() : new vt(e2, i2).toString(n2), s2) {
    const e3 = t6.indexOf("#");
    -1 !== e3 && (t6 = t6.slice(0, e3)), t6 += (-1 === t6.indexOf("?") ? "?" : "&") + s2;
  }
  return t6;
}
var bt = class {
  constructor() {
    this.handlers = [];
  }
  use(t6, e2, i2) {
    return this.handlers.push({ fulfilled: t6, rejected: e2, synchronous: !!i2 && i2.synchronous, runWhen: i2 ? i2.runWhen : null }), this.handlers.length - 1;
  }
  eject(t6) {
    this.handlers[t6] && (this.handlers[t6] = null);
  }
  clear() {
    this.handlers && (this.handlers = []);
  }
  forEach(t6) {
    nt.forEach(this.handlers, (function(e2) {
      null !== e2 && t6(e2);
    }));
  }
};
var wt = { silentJSONParsing: true, forcedJSONParsing: true, clarifyTimeoutError: false };
var _t = { isBrowser: true, classes: { URLSearchParams: "undefined" != typeof URLSearchParams ? URLSearchParams : vt, FormData: "undefined" != typeof FormData ? FormData : null, Blob: "undefined" != typeof Blob ? Blob : null }, protocols: ["http", "https", "file", "blob", "url", "data"] };
var St = "undefined" != typeof window && "undefined" != typeof document;
var Mt = "object" == typeof navigator && navigator || void 0;
var Tt = St && (!Mt || ["ReactNative", "NativeScript", "NS"].indexOf(Mt.product) < 0);
var Et = "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" == typeof self.importScripts;
var At = St && window.location.href || "http://localhost";
var Ct = { ...r, ..._t };
var Rt = function(t6) {
  function e2(t7, i2, n2, r2) {
    let s2 = t7[r2++];
    if ("__proto__" === s2) return true;
    const o2 = Number.isFinite(+s2), a2 = r2 >= t7.length;
    if (s2 = !s2 && nt.isArray(n2) ? n2.length : s2, a2) return nt.hasOwnProp(n2, s2) ? n2[s2] = [n2[s2], i2] : n2[s2] = i2, !o2;
    n2[s2] && nt.isObject(n2[s2]) || (n2[s2] = []);
    return e2(t7, i2, n2[s2], r2) && nt.isArray(n2[s2]) && (n2[s2] = (function(t8) {
      const e3 = {}, i3 = Object.keys(t8);
      let n3;
      const r3 = i3.length;
      let s3;
      for (n3 = 0; n3 < r3; n3++) s3 = i3[n3], e3[s3] = t8[s3];
      return e3;
    })(n2[s2])), !o2;
  }
  if (nt.isFormData(t6) && nt.isFunction(t6.entries)) {
    const i2 = {};
    return nt.forEachEntry(t6, ((t7, n2) => {
      e2((function(t8) {
        return nt.matchAll(/\w+|\[(\w*)]/g, t8).map(((t9) => "[]" === t9[0] ? "" : t9[1] || t9[0]));
      })(t7), n2, i2, 0);
    })), i2;
  }
  return null;
};
var Pt = { transitional: wt, adapter: ["xhr", "http", "fetch"], transformRequest: [function(t6, e2) {
  const i2 = e2.getContentType() || "", n2 = i2.indexOf("application/json") > -1, r2 = nt.isObject(t6);
  r2 && nt.isHTMLForm(t6) && (t6 = new FormData(t6));
  if (nt.isFormData(t6)) return n2 ? JSON.stringify(Rt(t6)) : t6;
  if (nt.isArrayBuffer(t6) || nt.isBuffer(t6) || nt.isStream(t6) || nt.isFile(t6) || nt.isBlob(t6) || nt.isReadableStream(t6)) return t6;
  if (nt.isArrayBufferView(t6)) return t6.buffer;
  if (nt.isURLSearchParams(t6)) return e2.setContentType("application/x-www-form-urlencoded;charset=utf-8", false), t6.toString();
  let s2;
  if (r2) {
    if (i2.indexOf("application/x-www-form-urlencoded") > -1) return (function(t7, e3) {
      return pt(t7, new Ct.classes.URLSearchParams(), Object.assign({ visitor: function(t8, e4, i3, n3) {
        return Ct.isNode && nt.isBuffer(t8) ? (this.append(e4, t8.toString("base64")), false) : n3.defaultVisitor.apply(this, arguments);
      } }, e3));
    })(t6, this.formSerializer).toString();
    if ((s2 = nt.isFileList(t6)) || i2.indexOf("multipart/form-data") > -1) {
      const e3 = this.env && this.env.FormData;
      return pt(s2 ? { "files[]": t6 } : t6, e3 && new e3(), this.formSerializer);
    }
  }
  return r2 || n2 ? (e2.setContentType("application/json", false), (function(t7, e3, i3) {
    if (nt.isString(t7)) try {
      return (e3 || JSON.parse)(t7), nt.trim(t7);
    } catch (t8) {
      if ("SyntaxError" !== t8.name) throw t8;
    }
    return (i3 || JSON.stringify)(t7);
  })(t6)) : t6;
}], transformResponse: [function(t6) {
  const e2 = this.transitional || Pt.transitional, i2 = e2 && e2.forcedJSONParsing, n2 = "json" === this.responseType;
  if (nt.isResponse(t6) || nt.isReadableStream(t6)) return t6;
  if (t6 && nt.isString(t6) && (i2 && !this.responseType || n2)) {
    const i3 = !(e2 && e2.silentJSONParsing) && n2;
    try {
      return JSON.parse(t6);
    } catch (t7) {
      if (i3) {
        if ("SyntaxError" === t7.name) throw at.from(t7, at.ERR_BAD_RESPONSE, this, null, this.response);
        throw t7;
      }
    }
  }
  return t6;
}], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: Ct.classes.FormData, Blob: Ct.classes.Blob }, validateStatus: function(t6) {
  return t6 >= 200 && t6 < 300;
}, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } };
nt.forEach(["delete", "get", "head", "post", "put", "patch"], ((t6) => {
  Pt.headers[t6] = {};
}));
var Lt = Pt;
var It = nt.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]);
var Dt = /* @__PURE__ */ Symbol("internals");
function Ot(t6) {
  return t6 && String(t6).trim().toLowerCase();
}
function zt(t6) {
  return false === t6 || null == t6 ? t6 : nt.isArray(t6) ? t6.map(zt) : String(t6);
}
function Ft(t6, e2, i2, n2, r2) {
  return nt.isFunction(n2) ? n2.call(this, e2, i2) : (r2 && (e2 = i2), nt.isString(e2) ? nt.isString(n2) ? -1 !== e2.indexOf(n2) : nt.isRegExp(n2) ? n2.test(e2) : void 0 : void 0);
}
var Nt = class {
  constructor(t6) {
    t6 && this.set(t6);
  }
  set(t6, e2, i2) {
    const n2 = this;
    function r2(t7, e3, i3) {
      const r3 = Ot(e3);
      if (!r3) throw new Error("header name must be a non-empty string");
      const s3 = nt.findKey(n2, r3);
      (!s3 || void 0 === n2[s3] || true === i3 || void 0 === i3 && false !== n2[s3]) && (n2[s3 || e3] = zt(t7));
    }
    const s2 = (t7, e3) => nt.forEach(t7, ((t8, i3) => r2(t8, i3, e3)));
    if (nt.isPlainObject(t6) || t6 instanceof this.constructor) s2(t6, e2);
    else if (nt.isString(t6) && (t6 = t6.trim()) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t6.trim())) s2(((t7) => {
      const e3 = {};
      let i3, n3, r3;
      return t7 && t7.split("\n").forEach((function(t8) {
        r3 = t8.indexOf(":"), i3 = t8.substring(0, r3).trim().toLowerCase(), n3 = t8.substring(r3 + 1).trim(), !i3 || e3[i3] && It[i3] || ("set-cookie" === i3 ? e3[i3] ? e3[i3].push(n3) : e3[i3] = [n3] : e3[i3] = e3[i3] ? e3[i3] + ", " + n3 : n3);
      })), e3;
    })(t6), e2);
    else if (nt.isHeaders(t6)) for (const [e3, n3] of t6.entries()) r2(n3, e3, i2);
    else null != t6 && r2(e2, t6, i2);
    return this;
  }
  get(t6, e2) {
    if (t6 = Ot(t6)) {
      const i2 = nt.findKey(this, t6);
      if (i2) {
        const t7 = this[i2];
        if (!e2) return t7;
        if (true === e2) return (function(t8) {
          const e3 = /* @__PURE__ */ Object.create(null), i3 = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
          let n2;
          for (; n2 = i3.exec(t8); ) e3[n2[1]] = n2[2];
          return e3;
        })(t7);
        if (nt.isFunction(e2)) return e2.call(this, t7, i2);
        if (nt.isRegExp(e2)) return e2.exec(t7);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t6, e2) {
    if (t6 = Ot(t6)) {
      const i2 = nt.findKey(this, t6);
      return !(!i2 || void 0 === this[i2] || e2 && !Ft(0, this[i2], i2, e2));
    }
    return false;
  }
  delete(t6, e2) {
    const i2 = this;
    let n2 = false;
    function r2(t7) {
      if (t7 = Ot(t7)) {
        const r3 = nt.findKey(i2, t7);
        !r3 || e2 && !Ft(0, i2[r3], r3, e2) || (delete i2[r3], n2 = true);
      }
    }
    return nt.isArray(t6) ? t6.forEach(r2) : r2(t6), n2;
  }
  clear(t6) {
    const e2 = Object.keys(this);
    let i2 = e2.length, n2 = false;
    for (; i2--; ) {
      const r2 = e2[i2];
      t6 && !Ft(0, this[r2], r2, t6, true) || (delete this[r2], n2 = true);
    }
    return n2;
  }
  normalize(t6) {
    const e2 = this, i2 = {};
    return nt.forEach(this, ((n2, r2) => {
      const s2 = nt.findKey(i2, r2);
      if (s2) return e2[s2] = zt(n2), void delete e2[r2];
      const o2 = t6 ? (function(t7) {
        return t7.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, ((t8, e3, i3) => e3.toUpperCase() + i3));
      })(r2) : String(r2).trim();
      o2 !== r2 && delete e2[r2], e2[o2] = zt(n2), i2[o2] = true;
    })), this;
  }
  concat(...t6) {
    return this.constructor.concat(this, ...t6);
  }
  toJSON(t6) {
    const e2 = /* @__PURE__ */ Object.create(null);
    return nt.forEach(this, ((i2, n2) => {
      null != i2 && false !== i2 && (e2[n2] = t6 && nt.isArray(i2) ? i2.join(", ") : i2);
    })), e2;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map((([t6, e2]) => t6 + ": " + e2)).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t6) {
    return t6 instanceof this ? t6 : new this(t6);
  }
  static concat(t6, ...e2) {
    const i2 = new this(t6);
    return e2.forEach(((t7) => i2.set(t7))), i2;
  }
  static accessor(t6) {
    const e2 = (this[Dt] = this[Dt] = { accessors: {} }).accessors, i2 = this.prototype;
    function n2(t7) {
      const n3 = Ot(t7);
      e2[n3] || (!(function(t8, e3) {
        const i3 = nt.toCamelCase(" " + e3);
        ["get", "set", "has"].forEach(((n4) => {
          Object.defineProperty(t8, n4 + i3, { value: function(t9, i4, r2) {
            return this[n4].call(this, e3, t9, i4, r2);
          }, configurable: true });
        }));
      })(i2, t7), e2[n3] = true);
    }
    return nt.isArray(t6) ? t6.forEach(n2) : n2(t6), this;
  }
};
Nt.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]), nt.reduceDescriptors(Nt.prototype, (({ value: t6 }, e2) => {
  let i2 = e2[0].toUpperCase() + e2.slice(1);
  return { get: () => t6, set(t7) {
    this[i2] = t7;
  } };
})), nt.freezeMethods(Nt);
var Bt = Nt;
function kt(t6, e2) {
  const i2 = this || Lt, n2 = e2 || i2, r2 = Bt.from(n2.headers);
  let s2 = n2.data;
  return nt.forEach(t6, (function(t7) {
    s2 = t7.call(i2, s2, r2.normalize(), e2 ? e2.status : void 0);
  })), r2.normalize(), s2;
}
function Ut(t6) {
  return !(!t6 || !t6.__CANCEL__);
}
function Ht(t6, e2, i2) {
  at.call(this, null == t6 ? "canceled" : t6, at.ERR_CANCELED, e2, i2), this.name = "CanceledError";
}
nt.inherits(Ht, at, { __CANCEL__: true });
var Vt = Ht;
function jt(t6, e2, i2) {
  const n2 = i2.config.validateStatus;
  i2.status && n2 && !n2(i2.status) ? e2(new at("Request failed with status code " + i2.status, [at.ERR_BAD_REQUEST, at.ERR_BAD_RESPONSE][Math.floor(i2.status / 100) - 4], i2.config, i2.request, i2)) : t6(i2);
}
var Gt = function(t6, e2) {
  t6 = t6 || 10;
  const i2 = new Array(t6), n2 = new Array(t6);
  let r2, s2 = 0, o2 = 0;
  return e2 = void 0 !== e2 ? e2 : 1e3, function(a2) {
    const l2 = Date.now(), c2 = n2[o2];
    r2 || (r2 = l2), i2[s2] = a2, n2[s2] = l2;
    let h2 = o2, u2 = 0;
    for (; h2 !== s2; ) u2 += i2[h2++], h2 %= t6;
    if (s2 = (s2 + 1) % t6, s2 === o2 && (o2 = (o2 + 1) % t6), l2 - r2 < e2) return;
    const d2 = c2 && l2 - c2;
    return d2 ? Math.round(1e3 * u2 / d2) : void 0;
  };
};
var Wt = function(t6, e2) {
  let i2, n2, r2 = 0, s2 = 1e3 / e2;
  const o2 = (e3, s3 = Date.now()) => {
    r2 = s3, i2 = null, n2 && (clearTimeout(n2), n2 = null), t6.apply(null, e3);
  };
  return [(...t7) => {
    const e3 = Date.now(), a2 = e3 - r2;
    a2 >= s2 ? o2(t7, e3) : (i2 = t7, n2 || (n2 = setTimeout((() => {
      n2 = null, o2(i2);
    }), s2 - a2)));
  }, () => i2 && o2(i2)];
};
var qt = (t6, e2, i2 = 3) => {
  let n2 = 0;
  const r2 = Gt(50, 250);
  return Wt(((i3) => {
    const s2 = i3.loaded, o2 = i3.lengthComputable ? i3.total : void 0, a2 = s2 - n2, l2 = r2(a2);
    n2 = s2;
    t6({ loaded: s2, total: o2, progress: o2 ? s2 / o2 : void 0, bytes: a2, rate: l2 || void 0, estimated: l2 && o2 && s2 <= o2 ? (o2 - s2) / l2 : void 0, event: i3, lengthComputable: null != o2, [e2 ? "download" : "upload"]: true });
  }), i2);
};
var Xt = (t6, e2) => {
  const i2 = null != t6;
  return [(n2) => e2[0]({ lengthComputable: i2, total: t6, loaded: n2 }), e2[1]];
};
var Yt = (t6) => (...e2) => nt.asap((() => t6(...e2)));
var Zt = Ct.hasStandardBrowserEnv ? /* @__PURE__ */ ((t6, e2) => (i2) => (i2 = new URL(i2, Ct.origin), t6.protocol === i2.protocol && t6.host === i2.host && (e2 || t6.port === i2.port)))(new URL(Ct.origin), Ct.navigator && /(msie|trident)/i.test(Ct.navigator.userAgent)) : () => true;
var Jt = Ct.hasStandardBrowserEnv ? { write(t6, e2, i2, n2, r2, s2) {
  const o2 = [t6 + "=" + encodeURIComponent(e2)];
  nt.isNumber(i2) && o2.push("expires=" + new Date(i2).toGMTString()), nt.isString(n2) && o2.push("path=" + n2), nt.isString(r2) && o2.push("domain=" + r2), true === s2 && o2.push("secure"), document.cookie = o2.join("; ");
}, read(t6) {
  const e2 = document.cookie.match(new RegExp("(^|;\\s*)(" + t6 + ")=([^;]*)"));
  return e2 ? decodeURIComponent(e2[3]) : null;
}, remove(t6) {
  this.write(t6, "", Date.now() - 864e5);
} } : { write() {
}, read: () => null, remove() {
} };
function Kt(t6, e2) {
  return t6 && !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(e2) ? (function(t7, e3) {
    return e3 ? t7.replace(/\/?\/$/, "") + "/" + e3.replace(/^\/+/, "") : t7;
  })(t6, e2) : e2;
}
var $t = (t6) => t6 instanceof Bt ? { ...t6 } : t6;
function Qt(t6, e2) {
  e2 = e2 || {};
  const i2 = {};
  function n2(t7, e3, i3, n3) {
    return nt.isPlainObject(t7) && nt.isPlainObject(e3) ? nt.merge.call({ caseless: n3 }, t7, e3) : nt.isPlainObject(e3) ? nt.merge({}, e3) : nt.isArray(e3) ? e3.slice() : e3;
  }
  function r2(t7, e3, i3, r3) {
    return nt.isUndefined(e3) ? nt.isUndefined(t7) ? void 0 : n2(void 0, t7, 0, r3) : n2(t7, e3, 0, r3);
  }
  function s2(t7, e3) {
    if (!nt.isUndefined(e3)) return n2(void 0, e3);
  }
  function o2(t7, e3) {
    return nt.isUndefined(e3) ? nt.isUndefined(t7) ? void 0 : n2(void 0, t7) : n2(void 0, e3);
  }
  function a2(i3, r3, s3) {
    return s3 in e2 ? n2(i3, r3) : s3 in t6 ? n2(void 0, i3) : void 0;
  }
  const l2 = { url: s2, method: s2, data: s2, baseURL: o2, transformRequest: o2, transformResponse: o2, paramsSerializer: o2, timeout: o2, timeoutMessage: o2, withCredentials: o2, withXSRFToken: o2, adapter: o2, responseType: o2, xsrfCookieName: o2, xsrfHeaderName: o2, onUploadProgress: o2, onDownloadProgress: o2, decompress: o2, maxContentLength: o2, maxBodyLength: o2, beforeRedirect: o2, transport: o2, httpAgent: o2, httpsAgent: o2, cancelToken: o2, socketPath: o2, responseEncoding: o2, validateStatus: a2, headers: (t7, e3, i3) => r2($t(t7), $t(e3), 0, true) };
  return nt.forEach(Object.keys(Object.assign({}, t6, e2)), (function(n3) {
    const s3 = l2[n3] || r2, o3 = s3(t6[n3], e2[n3], n3);
    nt.isUndefined(o3) && s3 !== a2 || (i2[n3] = o3);
  })), i2;
}
var te = (t6) => {
  const e2 = Qt({}, t6);
  let i2, { data: n2, withXSRFToken: r2, xsrfHeaderName: s2, xsrfCookieName: o2, headers: a2, auth: l2 } = e2;
  if (e2.headers = a2 = Bt.from(a2), e2.url = xt(Kt(e2.baseURL, e2.url), t6.params, t6.paramsSerializer), l2 && a2.set("Authorization", "Basic " + btoa((l2.username || "") + ":" + (l2.password ? unescape(encodeURIComponent(l2.password)) : ""))), nt.isFormData(n2)) {
    if (Ct.hasStandardBrowserEnv || Ct.hasStandardBrowserWebWorkerEnv) a2.setContentType(void 0);
    else if (false !== (i2 = a2.getContentType())) {
      const [t7, ...e3] = i2 ? i2.split(";").map(((t8) => t8.trim())).filter(Boolean) : [];
      a2.setContentType([t7 || "multipart/form-data", ...e3].join("; "));
    }
  }
  if (Ct.hasStandardBrowserEnv && (r2 && nt.isFunction(r2) && (r2 = r2(e2)), r2 || false !== r2 && Zt(e2.url))) {
    const t7 = s2 && o2 && Jt.read(o2);
    t7 && a2.set(s2, t7);
  }
  return e2;
};
var ee = "undefined" != typeof XMLHttpRequest && function(t6) {
  return new Promise((function(e2, i2) {
    const n2 = te(t6);
    let r2 = n2.data;
    const s2 = Bt.from(n2.headers).normalize();
    let o2, a2, l2, c2, h2, { responseType: u2, onUploadProgress: d2, onDownloadProgress: p2 } = n2;
    function f2() {
      c2 && c2(), h2 && h2(), n2.cancelToken && n2.cancelToken.unsubscribe(o2), n2.signal && n2.signal.removeEventListener("abort", o2);
    }
    let m2 = new XMLHttpRequest();
    function g2() {
      if (!m2) return;
      const n3 = Bt.from("getAllResponseHeaders" in m2 && m2.getAllResponseHeaders());
      jt((function(t7) {
        e2(t7), f2();
      }), (function(t7) {
        i2(t7), f2();
      }), { data: u2 && "text" !== u2 && "json" !== u2 ? m2.response : m2.responseText, status: m2.status, statusText: m2.statusText, headers: n3, config: t6, request: m2 }), m2 = null;
    }
    m2.open(n2.method.toUpperCase(), n2.url, true), m2.timeout = n2.timeout, "onloadend" in m2 ? m2.onloadend = g2 : m2.onreadystatechange = function() {
      m2 && 4 === m2.readyState && (0 !== m2.status || m2.responseURL && 0 === m2.responseURL.indexOf("file:")) && setTimeout(g2);
    }, m2.onabort = function() {
      m2 && (i2(new at("Request aborted", at.ECONNABORTED, t6, m2)), m2 = null);
    }, m2.onerror = function() {
      i2(new at("Network Error", at.ERR_NETWORK, t6, m2)), m2 = null;
    }, m2.ontimeout = function() {
      let e3 = n2.timeout ? "timeout of " + n2.timeout + "ms exceeded" : "timeout exceeded";
      const r3 = n2.transitional || wt;
      n2.timeoutErrorMessage && (e3 = n2.timeoutErrorMessage), i2(new at(e3, r3.clarifyTimeoutError ? at.ETIMEDOUT : at.ECONNABORTED, t6, m2)), m2 = null;
    }, void 0 === r2 && s2.setContentType(null), "setRequestHeader" in m2 && nt.forEach(s2.toJSON(), (function(t7, e3) {
      m2.setRequestHeader(e3, t7);
    })), nt.isUndefined(n2.withCredentials) || (m2.withCredentials = !!n2.withCredentials), u2 && "json" !== u2 && (m2.responseType = n2.responseType), p2 && ([l2, h2] = qt(p2, true), m2.addEventListener("progress", l2)), d2 && m2.upload && ([a2, c2] = qt(d2), m2.upload.addEventListener("progress", a2), m2.upload.addEventListener("loadend", c2)), (n2.cancelToken || n2.signal) && (o2 = (e3) => {
      m2 && (i2(!e3 || e3.type ? new Vt(null, t6, m2) : e3), m2.abort(), m2 = null);
    }, n2.cancelToken && n2.cancelToken.subscribe(o2), n2.signal && (n2.signal.aborted ? o2() : n2.signal.addEventListener("abort", o2)));
    const v2 = (function(t7) {
      const e3 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t7);
      return e3 && e3[1] || "";
    })(n2.url);
    v2 && -1 === Ct.protocols.indexOf(v2) ? i2(new at("Unsupported protocol " + v2 + ":", at.ERR_BAD_REQUEST, t6)) : m2.send(r2 || null);
  }));
};
var ie = (t6, e2) => {
  const { length: i2 } = t6 = t6 ? t6.filter(Boolean) : [];
  if (e2 || i2) {
    let i3, n2 = new AbortController();
    const r2 = function(t7) {
      if (!i3) {
        i3 = true, o2();
        const e3 = t7 instanceof Error ? t7 : this.reason;
        n2.abort(e3 instanceof at ? e3 : new Vt(e3 instanceof Error ? e3.message : e3));
      }
    };
    let s2 = e2 && setTimeout((() => {
      s2 = null, r2(new at(`timeout ${e2} of ms exceeded`, at.ETIMEDOUT));
    }), e2);
    const o2 = () => {
      t6 && (s2 && clearTimeout(s2), s2 = null, t6.forEach(((t7) => {
        t7.unsubscribe ? t7.unsubscribe(r2) : t7.removeEventListener("abort", r2);
      })), t6 = null);
    };
    t6.forEach(((t7) => t7.addEventListener("abort", r2)));
    const { signal: a2 } = n2;
    return a2.unsubscribe = () => nt.asap(o2), a2;
  }
};
var ne = function* (t6, e2) {
  let i2 = t6.byteLength;
  if (!e2 || i2 < e2) return void (yield t6);
  let n2, r2 = 0;
  for (; r2 < i2; ) n2 = r2 + e2, yield t6.slice(r2, n2), r2 = n2;
};
var re = async function* (t6) {
  if (t6[Symbol.asyncIterator]) return void (yield* t6);
  const e2 = t6.getReader();
  try {
    for (; ; ) {
      const { done: t7, value: i2 } = await e2.read();
      if (t7) break;
      yield i2;
    }
  } finally {
    await e2.cancel();
  }
};
var se = (t6, e2, i2, n2) => {
  const r2 = (async function* (t7, e3) {
    for await (const i3 of re(t7)) yield* ne(i3, e3);
  })(t6, e2);
  let s2, o2 = 0, a2 = (t7) => {
    s2 || (s2 = true, n2 && n2(t7));
  };
  return new ReadableStream({ async pull(t7) {
    try {
      const { done: e3, value: n3 } = await r2.next();
      if (e3) return a2(), void t7.close();
      let s3 = n3.byteLength;
      if (i2) {
        let t8 = o2 += s3;
        i2(t8);
      }
      t7.enqueue(new Uint8Array(n3));
    } catch (t8) {
      throw a2(t8), t8;
    }
  }, cancel: (t7) => (a2(t7), r2.return()) }, { highWaterMark: 2 });
};
var oe = "function" == typeof fetch && "function" == typeof Request && "function" == typeof Response;
var ae = oe && "function" == typeof ReadableStream;
var le = oe && ("function" == typeof TextEncoder ? (ce = new TextEncoder(), (t6) => ce.encode(t6)) : async (t6) => new Uint8Array(await new Response(t6).arrayBuffer()));
var ce;
var he = (t6, ...e2) => {
  try {
    return !!t6(...e2);
  } catch (t7) {
    return false;
  }
};
var ue = ae && he((() => {
  let t6 = false;
  const e2 = new Request(Ct.origin, { body: new ReadableStream(), method: "POST", get duplex() {
    return t6 = true, "half";
  } }).headers.has("Content-Type");
  return t6 && !e2;
}));
var de = ae && he((() => nt.isReadableStream(new Response("").body)));
var pe = { stream: de && ((t6) => t6.body) };
var fe;
oe && (fe = new Response(), ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(((t6) => {
  !pe[t6] && (pe[t6] = nt.isFunction(fe[t6]) ? (e2) => e2[t6]() : (e2, i2) => {
    throw new at(`Response type '${t6}' is not supported`, at.ERR_NOT_SUPPORT, i2);
  });
})));
var me = async (t6, e2) => {
  const i2 = nt.toFiniteNumber(t6.getContentLength());
  return null == i2 ? (async (t7) => {
    if (null == t7) return 0;
    if (nt.isBlob(t7)) return t7.size;
    if (nt.isSpecCompliantForm(t7)) {
      const e3 = new Request(Ct.origin, { method: "POST", body: t7 });
      return (await e3.arrayBuffer()).byteLength;
    }
    return nt.isArrayBufferView(t7) || nt.isArrayBuffer(t7) ? t7.byteLength : (nt.isURLSearchParams(t7) && (t7 += ""), nt.isString(t7) ? (await le(t7)).byteLength : void 0);
  })(e2) : i2;
};
var ge = { http: null, xhr: ee, fetch: oe && (async (t6) => {
  let { url: e2, method: i2, data: n2, signal: r2, cancelToken: s2, timeout: o2, onDownloadProgress: a2, onUploadProgress: l2, responseType: c2, headers: h2, withCredentials: u2 = "same-origin", fetchOptions: d2 } = te(t6);
  c2 = c2 ? (c2 + "").toLowerCase() : "text";
  let p2, f2 = ie([r2, s2 && s2.toAbortSignal()], o2);
  const m2 = f2 && f2.unsubscribe && (() => {
    f2.unsubscribe();
  });
  let g2;
  try {
    if (l2 && ue && "get" !== i2 && "head" !== i2 && 0 !== (g2 = await me(h2, n2))) {
      let t7, i3 = new Request(e2, { method: "POST", body: n2, duplex: "half" });
      if (nt.isFormData(n2) && (t7 = i3.headers.get("content-type")) && h2.setContentType(t7), i3.body) {
        const [t8, e3] = Xt(g2, qt(Yt(l2)));
        n2 = se(i3.body, 65536, t8, e3);
      }
    }
    nt.isString(u2) || (u2 = u2 ? "include" : "omit");
    const r3 = "credentials" in Request.prototype;
    p2 = new Request(e2, { ...d2, signal: f2, method: i2.toUpperCase(), headers: h2.normalize().toJSON(), body: n2, duplex: "half", credentials: r3 ? u2 : void 0 });
    let s3 = await fetch(p2);
    const o3 = de && ("stream" === c2 || "response" === c2);
    if (de && (a2 || o3 && m2)) {
      const t7 = {};
      ["status", "statusText", "headers"].forEach(((e4) => {
        t7[e4] = s3[e4];
      }));
      const e3 = nt.toFiniteNumber(s3.headers.get("content-length")), [i3, n3] = a2 && Xt(e3, qt(Yt(a2), true)) || [];
      s3 = new Response(se(s3.body, 65536, i3, (() => {
        n3 && n3(), m2 && m2();
      })), t7);
    }
    c2 = c2 || "text";
    let v2 = await pe[nt.findKey(pe, c2) || "text"](s3, t6);
    return !o3 && m2 && m2(), await new Promise(((e3, i3) => {
      jt(e3, i3, { data: v2, headers: Bt.from(s3.headers), status: s3.status, statusText: s3.statusText, config: t6, request: p2 });
    }));
  } catch (e3) {
    if (m2 && m2(), e3 && "TypeError" === e3.name && /fetch/i.test(e3.message)) throw Object.assign(new at("Network Error", at.ERR_NETWORK, t6, p2), { cause: e3.cause || e3 });
    throw at.from(e3, e3 && e3.code, t6, p2);
  }
}) };
nt.forEach(ge, ((t6, e2) => {
  if (t6) {
    try {
      Object.defineProperty(t6, "name", { value: e2 });
    } catch (t7) {
    }
    Object.defineProperty(t6, "adapterName", { value: e2 });
  }
}));
var ve = (t6) => `- ${t6}`;
var ye = (t6) => nt.isFunction(t6) || null === t6 || false === t6;
var xe = (t6) => {
  t6 = nt.isArray(t6) ? t6 : [t6];
  const { length: e2 } = t6;
  let i2, n2;
  const r2 = {};
  for (let s2 = 0; s2 < e2; s2++) {
    let e3;
    if (i2 = t6[s2], n2 = i2, !ye(i2) && (n2 = ge[(e3 = String(i2)).toLowerCase()], void 0 === n2)) throw new at(`Unknown adapter '${e3}'`);
    if (n2) break;
    r2[e3 || "#" + s2] = n2;
  }
  if (!n2) {
    const t7 = Object.entries(r2).map((([t8, e3]) => `adapter ${t8} ` + (false === e3 ? "is not supported by the environment" : "is not available in the build")));
    let i3 = e2 ? t7.length > 1 ? "since :\n" + t7.map(ve).join("\n") : " " + ve(t7[0]) : "as no adapter specified";
    throw new at("There is no suitable adapter to dispatch the request " + i3, "ERR_NOT_SUPPORT");
  }
  return n2;
};
function be(t6) {
  if (t6.cancelToken && t6.cancelToken.throwIfRequested(), t6.signal && t6.signal.aborted) throw new Vt(null, t6);
}
function we(t6) {
  be(t6), t6.headers = Bt.from(t6.headers), t6.data = kt.call(t6, t6.transformRequest), -1 !== ["post", "put", "patch"].indexOf(t6.method) && t6.headers.setContentType("application/x-www-form-urlencoded", false);
  return xe(t6.adapter || Lt.adapter)(t6).then((function(e2) {
    return be(t6), e2.data = kt.call(t6, t6.transformResponse, e2), e2.headers = Bt.from(e2.headers), e2;
  }), (function(e2) {
    return Ut(e2) || (be(t6), e2 && e2.response && (e2.response.data = kt.call(t6, t6.transformResponse, e2.response), e2.response.headers = Bt.from(e2.response.headers))), Promise.reject(e2);
  }));
}
var _e = "1.7.9";
var Se = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(((t6, e2) => {
  Se[t6] = function(i2) {
    return typeof i2 === t6 || "a" + (e2 < 1 ? "n " : " ") + t6;
  };
}));
var Me = {};
Se.transitional = function(t6, e2, i2) {
  function n2(t7, e3) {
    return "[Axios v1.7.9] Transitional option '" + t7 + "'" + e3 + (i2 ? ". " + i2 : "");
  }
  return (i3, r2, s2) => {
    if (false === t6) throw new at(n2(r2, " has been removed" + (e2 ? " in " + e2 : "")), at.ERR_DEPRECATED);
    return e2 && !Me[r2] && (Me[r2] = true, console.warn(n2(r2, " has been deprecated since v" + e2 + " and will be removed in the near future"))), !t6 || t6(i3, r2, s2);
  };
}, Se.spelling = function(t6) {
  return (e2, i2) => (console.warn(`${i2} is likely a misspelling of ${t6}`), true);
};
var Te = { assertOptions: function(t6, e2, i2) {
  if ("object" != typeof t6) throw new at("options must be an object", at.ERR_BAD_OPTION_VALUE);
  const n2 = Object.keys(t6);
  let r2 = n2.length;
  for (; r2-- > 0; ) {
    const s2 = n2[r2], o2 = e2[s2];
    if (o2) {
      const e3 = t6[s2], i3 = void 0 === e3 || o2(e3, s2, t6);
      if (true !== i3) throw new at("option " + s2 + " must be " + i3, at.ERR_BAD_OPTION_VALUE);
    } else if (true !== i2) throw new at("Unknown option " + s2, at.ERR_BAD_OPTION);
  }
}, validators: Se };
var Ee = Te.validators;
var Ae = class {
  constructor(t6) {
    this.defaults = t6, this.interceptors = { request: new bt(), response: new bt() };
  }
  async request(t6, e2) {
    try {
      return await this._request(t6, e2);
    } catch (t7) {
      if (t7 instanceof Error) {
        let e3 = {};
        Error.captureStackTrace ? Error.captureStackTrace(e3) : e3 = new Error();
        const i2 = e3.stack ? e3.stack.replace(/^.+\n/, "") : "";
        try {
          t7.stack ? i2 && !String(t7.stack).endsWith(i2.replace(/^.+\n.+\n/, "")) && (t7.stack += "\n" + i2) : t7.stack = i2;
        } catch (t8) {
        }
      }
      throw t7;
    }
  }
  _request(t6, e2) {
    "string" == typeof t6 ? (e2 = e2 || {}).url = t6 : e2 = t6 || {}, e2 = Qt(this.defaults, e2);
    const { transitional: i2, paramsSerializer: n2, headers: r2 } = e2;
    void 0 !== i2 && Te.assertOptions(i2, { silentJSONParsing: Ee.transitional(Ee.boolean), forcedJSONParsing: Ee.transitional(Ee.boolean), clarifyTimeoutError: Ee.transitional(Ee.boolean) }, false), null != n2 && (nt.isFunction(n2) ? e2.paramsSerializer = { serialize: n2 } : Te.assertOptions(n2, { encode: Ee.function, serialize: Ee.function }, true)), Te.assertOptions(e2, { baseUrl: Ee.spelling("baseURL"), withXsrfToken: Ee.spelling("withXSRFToken") }, true), e2.method = (e2.method || this.defaults.method || "get").toLowerCase();
    let s2 = r2 && nt.merge(r2.common, r2[e2.method]);
    r2 && nt.forEach(["delete", "get", "head", "post", "put", "patch", "common"], ((t7) => {
      delete r2[t7];
    })), e2.headers = Bt.concat(s2, r2);
    const o2 = [];
    let a2 = true;
    this.interceptors.request.forEach((function(t7) {
      "function" == typeof t7.runWhen && false === t7.runWhen(e2) || (a2 = a2 && t7.synchronous, o2.unshift(t7.fulfilled, t7.rejected));
    }));
    const l2 = [];
    let c2;
    this.interceptors.response.forEach((function(t7) {
      l2.push(t7.fulfilled, t7.rejected);
    }));
    let h2, u2 = 0;
    if (!a2) {
      const t7 = [we.bind(this), void 0];
      for (t7.unshift.apply(t7, o2), t7.push.apply(t7, l2), h2 = t7.length, c2 = Promise.resolve(e2); u2 < h2; ) c2 = c2.then(t7[u2++], t7[u2++]);
      return c2;
    }
    h2 = o2.length;
    let d2 = e2;
    for (u2 = 0; u2 < h2; ) {
      const t7 = o2[u2++], e3 = o2[u2++];
      try {
        d2 = t7(d2);
      } catch (t8) {
        e3.call(this, t8);
        break;
      }
    }
    try {
      c2 = we.call(this, d2);
    } catch (t7) {
      return Promise.reject(t7);
    }
    for (u2 = 0, h2 = l2.length; u2 < h2; ) c2 = c2.then(l2[u2++], l2[u2++]);
    return c2;
  }
  getUri(t6) {
    return xt(Kt((t6 = Qt(this.defaults, t6)).baseURL, t6.url), t6.params, t6.paramsSerializer);
  }
};
nt.forEach(["delete", "get", "head", "options"], (function(t6) {
  Ae.prototype[t6] = function(e2, i2) {
    return this.request(Qt(i2 || {}, { method: t6, url: e2, data: (i2 || {}).data }));
  };
})), nt.forEach(["post", "put", "patch"], (function(t6) {
  function e2(e3) {
    return function(i2, n2, r2) {
      return this.request(Qt(r2 || {}, { method: t6, headers: e3 ? { "Content-Type": "multipart/form-data" } : {}, url: i2, data: n2 }));
    };
  }
  Ae.prototype[t6] = e2(), Ae.prototype[t6 + "Form"] = e2(true);
}));
var Ce = Ae;
var Re = class _Re {
  constructor(t6) {
    if ("function" != typeof t6) throw new TypeError("executor must be a function.");
    let e2;
    this.promise = new Promise((function(t7) {
      e2 = t7;
    }));
    const i2 = this;
    this.promise.then(((t7) => {
      if (!i2._listeners) return;
      let e3 = i2._listeners.length;
      for (; e3-- > 0; ) i2._listeners[e3](t7);
      i2._listeners = null;
    })), this.promise.then = (t7) => {
      let e3;
      const n2 = new Promise(((t8) => {
        i2.subscribe(t8), e3 = t8;
      })).then(t7);
      return n2.cancel = function() {
        i2.unsubscribe(e3);
      }, n2;
    }, t6((function(t7, n2, r2) {
      i2.reason || (i2.reason = new Vt(t7, n2, r2), e2(i2.reason));
    }));
  }
  throwIfRequested() {
    if (this.reason) throw this.reason;
  }
  subscribe(t6) {
    this.reason ? t6(this.reason) : this._listeners ? this._listeners.push(t6) : this._listeners = [t6];
  }
  unsubscribe(t6) {
    if (!this._listeners) return;
    const e2 = this._listeners.indexOf(t6);
    -1 !== e2 && this._listeners.splice(e2, 1);
  }
  toAbortSignal() {
    const t6 = new AbortController(), e2 = (e3) => {
      t6.abort(e3);
    };
    return this.subscribe(e2), t6.signal.unsubscribe = () => this.unsubscribe(e2), t6.signal;
  }
  static source() {
    let t6;
    const e2 = new _Re((function(e3) {
      t6 = e3;
    }));
    return { token: e2, cancel: t6 };
  }
};
var Pe = Re;
var Le = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511 };
Object.entries(Le).forEach((([t6, e2]) => {
  Le[e2] = t6;
}));
var Ie = Le;
var De = (function t3(e2) {
  const i2 = new Ce(e2), n2 = d(Ce.prototype.request, i2);
  return nt.extend(n2, Ce.prototype, i2, { allOwnKeys: true }), nt.extend(n2, i2, null, { allOwnKeys: true }), n2.create = function(i3) {
    return t3(Qt(e2, i3));
  }, n2;
})(Lt);
De.Axios = Ce, De.CanceledError = Vt, De.CancelToken = Pe, De.isCancel = Ut, De.VERSION = _e, De.toFormData = pt, De.AxiosError = at, De.Cancel = De.CanceledError, De.all = function(t6) {
  return Promise.all(t6);
}, De.spread = function(t6) {
  return function(e2) {
    return t6.apply(null, e2);
  };
}, De.isAxiosError = function(t6) {
  return nt.isObject(t6) && true === t6.isAxiosError;
}, De.mergeConfig = Qt, De.AxiosHeaders = Bt, De.formToJSON = (t6) => Rt(nt.isHTMLForm(t6) ? new FormData(t6) : t6), De.getAdapter = xe, De.HttpStatusCode = Ie, De.default = De;
var Oe = De;
function ze(t6) {
  return ze = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t7) {
    return typeof t7;
  } : function(t7) {
    return t7 && "function" == typeof Symbol && t7.constructor === Symbol && t7 !== Symbol.prototype ? "symbol" : typeof t7;
  }, ze(t6);
}
function Fe(t6, e2) {
  if (!(t6 instanceof e2)) throw new TypeError("Cannot call a class as a function");
}
function Ne(t6, e2) {
  for (var i2 = 0; i2 < e2.length; i2++) {
    var n2 = e2[i2];
    n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t6, n2.key, n2);
  }
}
function Be(t6, e2, i2) {
  return e2 && Ne(t6.prototype, e2), i2 && Ne(t6, i2), Object.defineProperty(t6, "prototype", { writable: false }), t6;
}
function ke() {
  return ke = Object.assign || function(t6) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var i2 = arguments[e2];
      for (var n2 in i2) Object.prototype.hasOwnProperty.call(i2, n2) && (t6[n2] = i2[n2]);
    }
    return t6;
  }, ke.apply(this, arguments);
}
function Ue(t6, e2) {
  if ("function" != typeof e2 && null !== e2) throw new TypeError("Super expression must either be null or a function");
  t6.prototype = Object.create(e2 && e2.prototype, { constructor: { value: t6, writable: true, configurable: true } }), Object.defineProperty(t6, "prototype", { writable: false }), e2 && Ve(t6, e2);
}
function He(t6) {
  return He = Object.setPrototypeOf ? Object.getPrototypeOf : function(t7) {
    return t7.__proto__ || Object.getPrototypeOf(t7);
  }, He(t6);
}
function Ve(t6, e2) {
  return Ve = Object.setPrototypeOf || function(t7, e3) {
    return t7.__proto__ = e3, t7;
  }, Ve(t6, e2);
}
function je(t6, e2) {
  if (e2 && ("object" == typeof e2 || "function" == typeof e2)) return e2;
  if (void 0 !== e2) throw new TypeError("Derived constructors may only return object or undefined");
  return (function(t7) {
    if (void 0 === t7) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return t7;
  })(t6);
}
function Ge(t6) {
  var e2 = (function() {
    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if ("function" == typeof Proxy) return true;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {
      }))), true;
    } catch (t7) {
      return false;
    }
  })();
  return function() {
    var i2, n2 = He(t6);
    if (e2) {
      var r2 = He(this).constructor;
      i2 = Reflect.construct(n2, arguments, r2);
    } else i2 = n2.apply(this, arguments);
    return je(this, i2);
  };
}
var We = (function() {
  function t6() {
    Fe(this, t6);
  }
  return Be(t6, [{ key: "listenForWhisper", value: function(t7, e2) {
    return this.listen(".client-" + t7, e2);
  } }, { key: "notification", value: function(t7) {
    return this.listen(".Illuminate\\Notifications\\Events\\BroadcastNotificationCreated", t7);
  } }, { key: "stopListeningForWhisper", value: function(t7, e2) {
    return this.stopListening(".client-" + t7, e2);
  } }]), t6;
})();
var qe = (function() {
  function t6(e2) {
    Fe(this, t6), this.namespace = e2;
  }
  return Be(t6, [{ key: "format", value: function(t7) {
    return "." === t7.charAt(0) || "\\" === t7.charAt(0) ? t7.substr(1) : (this.namespace && (t7 = this.namespace + "." + t7), t7.replace(/\./g, "\\"));
  } }, { key: "setNamespace", value: function(t7) {
    this.namespace = t7;
  } }]), t6;
})();
var Xe = (function() {
  Ue(e2, We);
  var t6 = Ge(e2);
  function e2(i2, n2, r2) {
    var s2;
    return Fe(this, e2), (s2 = t6.call(this)).name = n2, s2.pusher = i2, s2.options = r2, s2.eventFormatter = new qe(s2.options.namespace), s2.subscribe(), s2;
  }
  return Be(e2, [{ key: "subscribe", value: function() {
    this.subscription = this.pusher.subscribe(this.name);
  } }, { key: "unsubscribe", value: function() {
    this.pusher.unsubscribe(this.name);
  } }, { key: "listen", value: function(t7, e3) {
    return this.on(this.eventFormatter.format(t7), e3), this;
  } }, { key: "listenToAll", value: function(t7) {
    var e3 = this;
    return this.subscription.bind_global((function(i2, n2) {
      if (!i2.startsWith("pusher:")) {
        var r2 = e3.options.namespace.replace(/\./g, "\\"), s2 = i2.startsWith(r2) ? i2.substring(r2.length + 1) : "." + i2;
        t7(s2, n2);
      }
    })), this;
  } }, { key: "stopListening", value: function(t7, e3) {
    return e3 ? this.subscription.unbind(this.eventFormatter.format(t7), e3) : this.subscription.unbind(this.eventFormatter.format(t7)), this;
  } }, { key: "stopListeningToAll", value: function(t7) {
    return t7 ? this.subscription.unbind_global(t7) : this.subscription.unbind_global(), this;
  } }, { key: "subscribed", value: function(t7) {
    return this.on("pusher:subscription_succeeded", (function() {
      t7();
    })), this;
  } }, { key: "error", value: function(t7) {
    return this.on("pusher:subscription_error", (function(e3) {
      t7(e3);
    })), this;
  } }, { key: "on", value: function(t7, e3) {
    return this.subscription.bind(t7, e3), this;
  } }]), e2;
})();
var Ye = (function() {
  Ue(e2, Xe);
  var t6 = Ge(e2);
  function e2() {
    return Fe(this, e2), t6.apply(this, arguments);
  }
  return Be(e2, [{ key: "whisper", value: function(t7, e3) {
    return this.pusher.channels.channels[this.name].trigger("client-".concat(t7), e3), this;
  } }]), e2;
})();
var Ze = (function() {
  Ue(e2, Xe);
  var t6 = Ge(e2);
  function e2() {
    return Fe(this, e2), t6.apply(this, arguments);
  }
  return Be(e2, [{ key: "whisper", value: function(t7, e3) {
    return this.pusher.channels.channels[this.name].trigger("client-".concat(t7), e3), this;
  } }]), e2;
})();
var Je = (function() {
  Ue(e2, Xe);
  var t6 = Ge(e2);
  function e2() {
    return Fe(this, e2), t6.apply(this, arguments);
  }
  return Be(e2, [{ key: "here", value: function(t7) {
    return this.on("pusher:subscription_succeeded", (function(e3) {
      t7(Object.keys(e3.members).map((function(t8) {
        return e3.members[t8];
      })));
    })), this;
  } }, { key: "joining", value: function(t7) {
    return this.on("pusher:member_added", (function(e3) {
      t7(e3.info);
    })), this;
  } }, { key: "whisper", value: function(t7, e3) {
    return this.pusher.channels.channels[this.name].trigger("client-".concat(t7), e3), this;
  } }, { key: "leaving", value: function(t7) {
    return this.on("pusher:member_removed", (function(e3) {
      t7(e3.info);
    })), this;
  } }]), e2;
})();
var Ke = (function() {
  Ue(e2, We);
  var t6 = Ge(e2);
  function e2(i2, n2, r2) {
    var s2;
    return Fe(this, e2), (s2 = t6.call(this)).events = {}, s2.listeners = {}, s2.name = n2, s2.socket = i2, s2.options = r2, s2.eventFormatter = new qe(s2.options.namespace), s2.subscribe(), s2;
  }
  return Be(e2, [{ key: "subscribe", value: function() {
    this.socket.emit("subscribe", { channel: this.name, auth: this.options.auth || {} });
  } }, { key: "unsubscribe", value: function() {
    this.unbind(), this.socket.emit("unsubscribe", { channel: this.name, auth: this.options.auth || {} });
  } }, { key: "listen", value: function(t7, e3) {
    return this.on(this.eventFormatter.format(t7), e3), this;
  } }, { key: "stopListening", value: function(t7, e3) {
    return this.unbindEvent(this.eventFormatter.format(t7), e3), this;
  } }, { key: "subscribed", value: function(t7) {
    return this.on("connect", (function(e3) {
      t7(e3);
    })), this;
  } }, { key: "error", value: function(t7) {
    return this;
  } }, { key: "on", value: function(t7, e3) {
    var i2 = this;
    return this.listeners[t7] = this.listeners[t7] || [], this.events[t7] || (this.events[t7] = function(e4, n2) {
      i2.name === e4 && i2.listeners[t7] && i2.listeners[t7].forEach((function(t8) {
        return t8(n2);
      }));
    }, this.socket.on(t7, this.events[t7])), this.listeners[t7].push(e3), this;
  } }, { key: "unbind", value: function() {
    var t7 = this;
    Object.keys(this.events).forEach((function(e3) {
      t7.unbindEvent(e3);
    }));
  } }, { key: "unbindEvent", value: function(t7, e3) {
    this.listeners[t7] = this.listeners[t7] || [], e3 && (this.listeners[t7] = this.listeners[t7].filter((function(t8) {
      return t8 !== e3;
    }))), e3 && 0 !== this.listeners[t7].length || (this.events[t7] && (this.socket.removeListener(t7, this.events[t7]), delete this.events[t7]), delete this.listeners[t7]);
  } }]), e2;
})();
var $e = (function() {
  Ue(e2, Ke);
  var t6 = Ge(e2);
  function e2() {
    return Fe(this, e2), t6.apply(this, arguments);
  }
  return Be(e2, [{ key: "whisper", value: function(t7, e3) {
    return this.socket.emit("client event", { channel: this.name, event: "client-".concat(t7), data: e3 }), this;
  } }]), e2;
})();
var Qe = (function() {
  Ue(e2, $e);
  var t6 = Ge(e2);
  function e2() {
    return Fe(this, e2), t6.apply(this, arguments);
  }
  return Be(e2, [{ key: "here", value: function(t7) {
    return this.on("presence:subscribed", (function(e3) {
      t7(e3.map((function(t8) {
        return t8.user_info;
      })));
    })), this;
  } }, { key: "joining", value: function(t7) {
    return this.on("presence:joining", (function(e3) {
      return t7(e3.user_info);
    })), this;
  } }, { key: "whisper", value: function(t7, e3) {
    return this.socket.emit("client event", { channel: this.name, event: "client-".concat(t7), data: e3 }), this;
  } }, { key: "leaving", value: function(t7) {
    return this.on("presence:leaving", (function(e3) {
      return t7(e3.user_info);
    })), this;
  } }]), e2;
})();
var ti = (function() {
  Ue(e2, We);
  var t6 = Ge(e2);
  function e2() {
    return Fe(this, e2), t6.apply(this, arguments);
  }
  return Be(e2, [{ key: "subscribe", value: function() {
  } }, { key: "unsubscribe", value: function() {
  } }, { key: "listen", value: function(t7, e3) {
    return this;
  } }, { key: "listenToAll", value: function(t7) {
    return this;
  } }, { key: "stopListening", value: function(t7, e3) {
    return this;
  } }, { key: "subscribed", value: function(t7) {
    return this;
  } }, { key: "error", value: function(t7) {
    return this;
  } }, { key: "on", value: function(t7, e3) {
    return this;
  } }]), e2;
})();
var ei = (function() {
  Ue(e2, ti);
  var t6 = Ge(e2);
  function e2() {
    return Fe(this, e2), t6.apply(this, arguments);
  }
  return Be(e2, [{ key: "whisper", value: function(t7, e3) {
    return this;
  } }]), e2;
})();
var ii = (function() {
  Ue(e2, ti);
  var t6 = Ge(e2);
  function e2() {
    return Fe(this, e2), t6.apply(this, arguments);
  }
  return Be(e2, [{ key: "here", value: function(t7) {
    return this;
  } }, { key: "joining", value: function(t7) {
    return this;
  } }, { key: "whisper", value: function(t7, e3) {
    return this;
  } }, { key: "leaving", value: function(t7) {
    return this;
  } }]), e2;
})();
var ni = (function() {
  function t6(e2) {
    Fe(this, t6), this._defaultOptions = { auth: { headers: {} }, authEndpoint: "/broadcasting/auth", userAuthentication: { endpoint: "/broadcasting/user-auth", headers: {} }, broadcaster: "pusher", csrfToken: null, bearerToken: null, host: null, key: null, namespace: "App.Events" }, this.setOptions(e2), this.connect();
  }
  return Be(t6, [{ key: "setOptions", value: function(t7) {
    this.options = ke(this._defaultOptions, t7);
    var e2 = this.csrfToken();
    return e2 && (this.options.auth.headers["X-CSRF-TOKEN"] = e2, this.options.userAuthentication.headers["X-CSRF-TOKEN"] = e2), (e2 = this.options.bearerToken) && (this.options.auth.headers.Authorization = "Bearer " + e2, this.options.userAuthentication.headers.Authorization = "Bearer " + e2), t7;
  } }, { key: "csrfToken", value: function() {
    var t7;
    return "undefined" != typeof window && window.Laravel && window.Laravel.csrfToken ? window.Laravel.csrfToken : this.options.csrfToken ? this.options.csrfToken : "undefined" != typeof document && "function" == typeof document.querySelector && (t7 = document.querySelector('meta[name="csrf-token"]')) ? t7.getAttribute("content") : null;
  } }]), t6;
})();
var ri = (function() {
  Ue(e2, ni);
  var t6 = Ge(e2);
  function e2() {
    var i2;
    return Fe(this, e2), (i2 = t6.apply(this, arguments)).channels = {}, i2;
  }
  return Be(e2, [{ key: "connect", value: function() {
    void 0 !== this.options.client ? this.pusher = this.options.client : this.options.Pusher ? this.pusher = new this.options.Pusher(this.options.key, this.options) : this.pusher = new Pusher(this.options.key, this.options);
  } }, { key: "signin", value: function() {
    this.pusher.signin();
  } }, { key: "listen", value: function(t7, e3, i2) {
    return this.channel(t7).listen(e3, i2);
  } }, { key: "channel", value: function(t7) {
    return this.channels[t7] || (this.channels[t7] = new Xe(this.pusher, t7, this.options)), this.channels[t7];
  } }, { key: "privateChannel", value: function(t7) {
    return this.channels["private-" + t7] || (this.channels["private-" + t7] = new Ye(this.pusher, "private-" + t7, this.options)), this.channels["private-" + t7];
  } }, { key: "encryptedPrivateChannel", value: function(t7) {
    return this.channels["private-encrypted-" + t7] || (this.channels["private-encrypted-" + t7] = new Ze(this.pusher, "private-encrypted-" + t7, this.options)), this.channels["private-encrypted-" + t7];
  } }, { key: "presenceChannel", value: function(t7) {
    return this.channels["presence-" + t7] || (this.channels["presence-" + t7] = new Je(this.pusher, "presence-" + t7, this.options)), this.channels["presence-" + t7];
  } }, { key: "leave", value: function(t7) {
    var e3 = this;
    [t7, "private-" + t7, "private-encrypted-" + t7, "presence-" + t7].forEach((function(t8, i2) {
      e3.leaveChannel(t8);
    }));
  } }, { key: "leaveChannel", value: function(t7) {
    this.channels[t7] && (this.channels[t7].unsubscribe(), delete this.channels[t7]);
  } }, { key: "socketId", value: function() {
    return this.pusher.connection.socket_id;
  } }, { key: "disconnect", value: function() {
    this.pusher.disconnect();
  } }]), e2;
})();
var si = (function() {
  Ue(e2, ni);
  var t6 = Ge(e2);
  function e2() {
    var i2;
    return Fe(this, e2), (i2 = t6.apply(this, arguments)).channels = {}, i2;
  }
  return Be(e2, [{ key: "connect", value: function() {
    var t7 = this, e3 = this.getSocketIO();
    return this.socket = e3(this.options.host, this.options), this.socket.on("reconnect", (function() {
      Object.values(t7.channels).forEach((function(t8) {
        t8.subscribe();
      }));
    })), this.socket;
  } }, { key: "getSocketIO", value: function() {
    if (void 0 !== this.options.client) return this.options.client;
    if ("undefined" != typeof io) return io;
    throw new Error("Socket.io client not found. Should be globally available or passed via options.client");
  } }, { key: "listen", value: function(t7, e3, i2) {
    return this.channel(t7).listen(e3, i2);
  } }, { key: "channel", value: function(t7) {
    return this.channels[t7] || (this.channels[t7] = new Ke(this.socket, t7, this.options)), this.channels[t7];
  } }, { key: "privateChannel", value: function(t7) {
    return this.channels["private-" + t7] || (this.channels["private-" + t7] = new $e(this.socket, "private-" + t7, this.options)), this.channels["private-" + t7];
  } }, { key: "presenceChannel", value: function(t7) {
    return this.channels["presence-" + t7] || (this.channels["presence-" + t7] = new Qe(this.socket, "presence-" + t7, this.options)), this.channels["presence-" + t7];
  } }, { key: "leave", value: function(t7) {
    var e3 = this;
    [t7, "private-" + t7, "presence-" + t7].forEach((function(t8) {
      e3.leaveChannel(t8);
    }));
  } }, { key: "leaveChannel", value: function(t7) {
    this.channels[t7] && (this.channels[t7].unsubscribe(), delete this.channels[t7]);
  } }, { key: "socketId", value: function() {
    return this.socket.id;
  } }, { key: "disconnect", value: function() {
    this.socket.disconnect();
  } }]), e2;
})();
var oi = (function() {
  Ue(e2, ni);
  var t6 = Ge(e2);
  function e2() {
    var i2;
    return Fe(this, e2), (i2 = t6.apply(this, arguments)).channels = {}, i2;
  }
  return Be(e2, [{ key: "connect", value: function() {
  } }, { key: "listen", value: function(t7, e3, i2) {
    return new ti();
  } }, { key: "channel", value: function(t7) {
    return new ti();
  } }, { key: "privateChannel", value: function(t7) {
    return new ei();
  } }, { key: "encryptedPrivateChannel", value: function(t7) {
    return new ei();
  } }, { key: "presenceChannel", value: function(t7) {
    return new ii();
  } }, { key: "leave", value: function(t7) {
  } }, { key: "leaveChannel", value: function(t7) {
  } }, { key: "socketId", value: function() {
    return "fake-socket-id";
  } }, { key: "disconnect", value: function() {
  } }]), e2;
})();
var ai = (function() {
  function t6(e2) {
    Fe(this, t6), this.options = e2, this.connect(), this.options.withoutInterceptors || this.registerInterceptors();
  }
  return Be(t6, [{ key: "channel", value: function(t7) {
    return this.connector.channel(t7);
  } }, { key: "connect", value: function() {
    "pusher" == this.options.broadcaster ? this.connector = new ri(this.options) : "socket.io" == this.options.broadcaster ? this.connector = new si(this.options) : "null" == this.options.broadcaster ? this.connector = new oi(this.options) : "function" == typeof this.options.broadcaster && (this.connector = new this.options.broadcaster(this.options));
  } }, { key: "disconnect", value: function() {
    this.connector.disconnect();
  } }, { key: "join", value: function(t7) {
    return this.connector.presenceChannel(t7);
  } }, { key: "leave", value: function(t7) {
    this.connector.leave(t7);
  } }, { key: "leaveChannel", value: function(t7) {
    this.connector.leaveChannel(t7);
  } }, { key: "leaveAllChannels", value: function() {
    for (var t7 in this.connector.channels) this.leaveChannel(t7);
  } }, { key: "listen", value: function(t7, e2, i2) {
    return this.connector.listen(t7, e2, i2);
  } }, { key: "private", value: function(t7) {
    return this.connector.privateChannel(t7);
  } }, { key: "encryptedPrivate", value: function(t7) {
    return this.connector.encryptedPrivateChannel(t7);
  } }, { key: "socketId", value: function() {
    return this.connector.socketId();
  } }, { key: "registerInterceptors", value: function() {
    "function" == typeof Vue && Vue.http && this.registerVueRequestInterceptor(), "function" == typeof axios && this.registerAxiosRequestInterceptor(), "function" == typeof jQuery && this.registerjQueryAjaxSetup(), "object" === ("undefined" == typeof Turbo ? "undefined" : ze(Turbo)) && this.registerTurboRequestInterceptor();
  } }, { key: "registerVueRequestInterceptor", value: function() {
    var t7 = this;
    Vue.http.interceptors.push((function(e2, i2) {
      t7.socketId() && e2.headers.set("X-Socket-ID", t7.socketId()), i2();
    }));
  } }, { key: "registerAxiosRequestInterceptor", value: function() {
    var t7 = this;
    axios.interceptors.request.use((function(e2) {
      return t7.socketId() && (e2.headers["X-Socket-Id"] = t7.socketId()), e2;
    }));
  } }, { key: "registerjQueryAjaxSetup", value: function() {
    var t7 = this;
    void 0 !== jQuery.ajax && jQuery.ajaxPrefilter((function(e2, i2, n2) {
      t7.socketId() && n2.setRequestHeader("X-Socket-Id", t7.socketId());
    }));
  } }, { key: "registerTurboRequestInterceptor", value: function() {
    var t7 = this;
    document.addEventListener("turbo:before-fetch-request", (function(e2) {
      e2.detail.fetchOptions.headers["X-Socket-Id"] = t7.socketId();
    }));
  } }]), t6;
})();
var li = i(5606);
var ci = void 0 !== li ? { APP_URL: "https://dddice.com", APP_VERSION: "v0.19.34", APP_ENV: "production", CDN_URL: "https://cdn.dddice.com", PUSHER_APP_CLUSTER: "", PUSHER_APP_KEY: "DpMX1V2rIuVz9nTWIpm8YrXfVgGoFKFvhgxYTbyMgdq8wm06LIZ6taHaDIb9aaaa", WEBSOCKETS_URI: "ws.dddice.com", WEBSOCKETS_PATH: void 0, STRIPE_KEY: li.env.MIX_STRIPE_KEY, DOCS_URL: "https://docs.dddice.com" } : { APP_URL: {}.VITE_APP_URL, APP_VERSION: {}.VITE_APP_VERSION, APP_ENV: {}.VITE_APP_ENV, CDN_URL: {}.VITE_CDN_URL, PUSHER_APP_CLUSTER: {}.VITE_PUSHER_APP_CLUSTER, PUSHER_APP_KEY: {}.VITE_PUSHER_APP_KEY, WEBSOCKETS_URI: {}.VITE_WEBSOCKETS_URI, WEBSOCKETS_PATH: void 0, STRIPE_KEY: {}.VITE_STRIPE_KEY, DOCS_URL: {}.VITE_DOCS_URL, DISCORD_CLIENT_ID: {}.VITE_DISCORD_CLIENT_ID };
var hi = class _hi extends Error {
  constructor() {
    super("API not initialized"), Object.setPrototypeOf(this, _hi.prototype);
  }
};
var ui = class _ui extends Error {
  constructor() {
    super("API connection not established"), Object.setPrototypeOf(this, _ui.prototype);
  }
};
var di = class _di extends Error {
  constructor() {
    super("API not connected to a room"), Object.setPrototypeOf(this, _di.prototype);
  }
};
var pi = class _pi extends Error {
  constructor(t6) {
    super(t6), Object.setPrototypeOf(this, _pi.prototype);
  }
};
var fi = class extends Error {
  constructor(t6, e2, i2) {
    super(), this.message = t6, this.expected = e2, this.received = i2;
  }
  toString() {
    return `${this.message} [expected=${this.expected}, received=${this.received}]`;
  }
};
var mi = function(t6, e2, i2, n2) {
  return new (i2 || (i2 = Promise))((function(r2, s2) {
    function o2(t7) {
      try {
        l2(n2.next(t7));
      } catch (t8) {
        s2(t8);
      }
    }
    function a2(t7) {
      try {
        l2(n2.throw(t7));
      } catch (t8) {
        s2(t8);
      }
    }
    function l2(t7) {
      var e3;
      t7.done ? r2(t7.value) : (e3 = t7.value, e3 instanceof i2 ? e3 : new i2((function(t8) {
        t8(e3);
      }))).then(o2, a2);
    }
    l2((n2 = n2.apply(t6, e2 || [])).next());
  }));
};
var gi = "/api/1.0";
var vi;
var yi;
var xi;
var bi;
var wi;
var _i;
var Si;
var Mi;
var Ti;
var Ei;
var Ai;
!(function(t6) {
  t6.RollCreated = "RollCreateEvent", t6.RollUpdated = "RollUpdateEvent", t6.RollDeleted = "RollDeleteEvent", t6.RollStarted = "roll:started", t6.RollFinished = "roll:finished", t6.RollFadeStarted = "roll:fade:started", t6.RollFadeFinished = "roll:fade:finished", t6.RollUnhideFinished = "roll:unhide:finished";
})(vi || (vi = {})), (function(t6) {
  t6.RoomUpdated = "RoomUpdateEvent";
})(yi || (yi = {})), (function(t6) {
  t6.DiceBoxCreated = "DiceBoxCreateEvent", t6.DiceBoxDeleted = "DiceBoxDeleteEvent";
})(xi || (xi = {}));
var Ci = class {
  constructor(t6, e2) {
    this.connect = (t7, e3, i2) => (this.roomSlug = t7, this.roomPasscode = e3, this.userUuid = i2, this.connection || (this.connection = new ai({ broadcaster: "pusher", client: new (u())(ci.PUSHER_APP_KEY, { authorizer: (t8) => ({ authorize: (e4, i3) => mi(this, void 0, void 0, (function* () {
      try {
        const n2 = yield Oe.post("/broadcasting/auth", { socket_id: e4, channel_name: t8.name });
        i3(null, n2.data);
      } catch (t9) {
        i3(t9, null);
      }
    })) }), cluster: ci.PUSHER_APP_CLUSTER, disableStats: true, enabledTransports: ["ws", "wss"], disabledTransports: ["xhr_streaming"], forceTLS: "localhost" !== ci.WEBSOCKETS_URI, wsHost: ci.WEBSOCKETS_URI, wsPath: ci.WEBSOCKETS_PATH, wsPort: 6001, wssPort: 443 }), encrypted: "localhost" !== ci.WEBSOCKETS_URI, key: ci.PUSHER_APP_KEY, wsHost: ci.WEBSOCKETS_URI, wssHost: ci.WEBSOCKETS_URI, cluster: ci.PUSHER_APP_CLUSTER, wsPort: 6001, wssPort: 443, wsPath: ci.WEBSOCKETS_PATH, forceTLS: "localhost" !== ci.WEBSOCKETS_URI, enabledTransports: ["ws", "wss"], disabledTransports: ["xhr_streaming"], disableStats: true, authorizer: (t8) => ({ authorize: (e4, i3) => mi(this, void 0, void 0, (function* () {
      try {
        const n2 = yield Oe.post("/broadcasting/auth", { socket_id: e4, channel_name: t8.name });
        i3(false, n2.data);
      } catch (t9) {
        i3(true, t9);
      }
    })) }) })), this.roomConnection = this.connection.join(`room.${this.roomSlug}`), i2 && (this.privateConnection = this.connection.private(`room.${this.roomSlug}.${i2}`), this.userConnection = this.connection.private(`user.${i2}`)), this), this.disconnect = () => (this.connection && this.connection.leave(`room.${this.roomSlug}`), this.userUuid && this.connection && this.connection.leave(`room.${this.roomSlug}.${this.userUuid}`), this), this.onConnectionStateChange = (t7) => {
      if (!this.connection) throw new ui();
      return this.connection.connector.pusher.connection.bind("state_change", ((e3) => t7(e3.current))), this;
    }, this.onConnectionError = (t7) => {
      if (!this.roomConnection) throw new di();
      return this.roomConnection.error(t7), this;
    }, this.onConnect = (t7) => {
      if (!this.roomConnection) throw new di();
      return this.roomConnection.here(t7), this;
    }, this.onParticipantConnect = (t7) => {
      if (!this.roomConnection) throw new di();
      return this.roomConnection.joining(t7), this;
    }, this.onParticipantDisconnect = (t7) => {
      if (!this.roomConnection) throw new di();
      return this.roomConnection.leaving(t7), this;
    }, this.diceBox = { list: (t7) => mi(this, void 0, void 0, (function* () {
      const e3 = t7 ? `?filter=${t7}` : "", i2 = (yield Oe.get(`${gi}/dice-box${e3}`)).data;
      return this.diceBoxPagingState = i2.links, i2;
    })), next: () => mi(this, void 0, void 0, (function* () {
      if (this.diceBoxPagingState.next) {
        const t7 = (yield Oe.get(this.diceBoxPagingState.next)).data;
        return this.diceBoxPagingState = t7.links, t7;
      }
      return null;
    })) }, this.roll = { create: (t7, e3) => mi(this, void 0, void 0, (function* () {
      var i2;
      if (!this.roomSlug && !(null == e3 ? void 0 : e3.room)) throw new Error("Not connected to a room and no room id passed in");
      return (yield Oe.post(`${gi}/roll`, Object.assign({ dice: t7, room: null !== (i2 = null == e3 ? void 0 : e3.room) && void 0 !== i2 ? i2 : this.roomSlug }, e3 || {}))).data;
    })), get: (t7) => mi(this, void 0, void 0, (function* () {
      return (yield Oe.get(`${gi}/roll/${t7}`)).data;
    })), update: (t7, e3) => mi(this, void 0, void 0, (function* () {
      return (yield Oe.patch(`${gi}/roll/${t7}`, e3)).data;
    })), updateBulk: (t7) => mi(this, void 0, void 0, (function* () {
      return (yield Oe.patch(`${gi}/roll`, { rolls: t7 })).data;
    })) }, this.room = { list: () => mi(this, void 0, void 0, (function* () {
      return (yield Oe.get(`${gi}/room`)).data;
    })), create: () => mi(this, void 0, void 0, (function* () {
      return (yield Oe.post(`${gi}/room`)).data;
    })), get: (t7, e3) => mi(this, void 0, void 0, (function* () {
      var i2;
      const n2 = null !== (i2 = this.roomPasscode) && void 0 !== i2 ? i2 : e3, r2 = n2 ? `?passcode=${n2}` : "";
      return (yield Oe.get(`${gi}/room/${t7}${r2}`)).data;
    })), join: (t7, e3) => mi(this, void 0, void 0, (function* () {
      var i2;
      const n2 = null !== (i2 = this.roomPasscode) && void 0 !== i2 ? i2 : e3, r2 = n2 ? `?passcode=${n2}` : "";
      return (yield Oe.post(`${gi}/room/${t7}/participant${r2}`)).data;
    })), leave: (t7, e3) => mi(this, void 0, void 0, (function* () {
      return (yield Oe.delete(`${gi}/room/${t7}/participant/${e3}`)).data;
    })), updateParticipant: (t7, e3, i2) => mi(this, void 0, void 0, (function* () {
      return (yield Oe.patch(`${gi}/room/${t7}/participant/${e3}`, i2)).data;
    })), updateRolls: (t7, e3, i2) => mi(this, void 0, void 0, (function* () {
      return (yield Oe.patch(`${gi}/room/${t7}/roll` + (i2 ? `?participant=${i2}` : ""), { dice: e3 })).data;
    })), update: (t7, e3) => mi(this, void 0, void 0, (function* () {
      return (yield Oe.patch(`${gi}/room/${t7}`, e3)).data;
    })), deleteRolls: (t7) => mi(this, void 0, void 0, (function* () {
      return (yield Oe.delete(`${gi}/roll?room=${t7}`)).data;
    })), updateBackground: (t7, e3) => mi(this, void 0, void 0, (function* () {
      const i2 = new FormData();
      return i2.append("bg_file_path", e3), (yield Oe.post(`/api/1.0/room/${t7}`, i2)).data;
    })) }, this.theme = { get: (t7) => mi(this, void 0, void 0, (function* () {
      return (yield Oe.get(`${gi}/theme/${t7}`)).data;
    })) }, this.user = { get: () => mi(this, void 0, void 0, (function* () {
      return (yield Oe.get(`${gi}/user`)).data;
    })), guest: () => mi(this, void 0, void 0, (function* () {
      return (yield Oe.post(`${gi}/user`)).data;
    })), activate: () => mi(this, void 0, void 0, (function* () {
      const t7 = (yield Oe.post(`${gi}/activate`)).data;
      return { expiresAt: t7.data.expires_at, code: t7.data.code, apiKey: Ri(t7.data) };
    })) }, this.sendLocal = (t7, e3) => {
      var i2;
      null === (i2 = this.roomConnection) || void 0 === i2 || i2.whisper(t7, e3);
    }, this.apiKey = t6, this.appName = e2, "undefined" != typeof window ? (Oe.defaults.baseURL = ci.APP_URL || window.location.origin, "undefined" != typeof document && window.parent && window.parent.location !== window.location && (Oe.defaults.headers.common["X-Iframe-Parent"] = document.referrer)) : Oe.defaults.baseURL = ci.APP_URL, Oe.defaults.withCredentials = true, t6 && (Oe.defaults.headers.common.Authorization = `Bearer ${t6}`), e2 && (Oe.defaults.headers.common["X-Extension"] = e2);
  }
  set apiKey(t6) {
    this._apiKey = t6, Oe.defaults.headers.common.Authorization = this._apiKey ? `Bearer ${this._apiKey}` : void 0;
  }
  get apiKey() {
    return this._apiKey;
  }
  set appName(t6) {
    var e2;
    this._appName = t6, Oe.defaults.headers.common["X-Extension"] = null !== (e2 = this._appName) && void 0 !== e2 ? e2 : void 0;
  }
  listen(t6, e2) {
    var i2, n2;
    if (!this.roomConnection) throw new di();
    return this.roomConnection.listen(t6, (({ data: t7 }) => e2(t7))), null === (i2 = this.privateConnection) || void 0 === i2 || i2.listen(t6, (({ data: t7 }) => e2(t7))), null === (n2 = this.userConnection) || void 0 === n2 || n2.listen(t6, (({ data: t7 }) => e2(t7))), this;
  }
  stopListening(t6, e2) {
    var i2, n2;
    if (!this.roomConnection) throw new di();
    return this.roomConnection.stopListening(t6, (({ data: t7 }) => e2(t7))), null === (i2 = this.privateConnection) || void 0 === i2 || i2.stopListening(t6, (({ data: t7 }) => e2(t7))), null === (n2 = this.userConnection) || void 0 === n2 || n2.stopListening(t6, (({ data: t7 }) => e2(t7))), this;
  }
  listenLocal(t6, e2) {
    if (!this.roomConnection) throw new di();
    return this.roomConnection.listenForWhisper(t6, ((t7) => e2(t7))), this;
  }
};
function Ri(t6) {
  return mi(this, void 0, void 0, (function* () {
    const e2 = (/* @__PURE__ */ new Date()).getTime(), i2 = new Date(null == t6 ? void 0 : t6.expires_at).getTime();
    for (; t6 && i2 - e2 > 5e3; ) if (t6 && !t6.token && t6.code && t6.secret) {
      const e3 = (yield Oe.get(`${gi}/activate/${t6.code}`, { headers: { Authorization: `Secret ${t6.secret}` } })).data.data;
      if (e3.token) return e3.token;
      yield new Promise(((t7) => setTimeout(t7, 5e3)));
    }
  }));
}
function Pi(t6) {
  for (var e2 = 1; e2 < arguments.length; e2++) {
    var i2 = arguments[e2];
    for (var n2 in i2) t6[n2] = i2[n2];
  }
  return t6;
}
!(function(t6) {
  t6.Small = "sm", t6.Medium = "md", t6.Large = "lg";
})(bi || (bi = {})), (function(t6) {
  t6[t6.Manually = 0] = "Manually", t6[t6.BeforeNextRoll = 1] = "BeforeNextRoll";
})(wi || (wi = {})), (function(t6) {
  t6[t6.XSmall = 0.5] = "XSmall", t6[t6.Small = 1] = "Small", t6[t6.Medium = 2] = "Medium", t6[t6.Large = 3] = "Large";
})(_i || (_i = {})), (function(t6) {
  t6.Reroll = "reroll", t6.Explode = "explode", t6.Drop = "drop", t6.Nothing = "nothing";
})(Si || (Si = {})), (function(t6) {
  t6.D4 = "d4", t6.D6 = "d6", t6.D8 = "d8", t6.D10 = "d10", t6.D10X = "d10x", t6.D12 = "d12", t6.D16 = "d16", t6.D20 = "d20", t6.Modifier = "mod", t6.D2 = "d2";
})(Mi || (Mi = {})), (function(t6) {
  t6[t6.N = 0] = "N", t6[t6.NE = -45] = "NE", t6[t6.E = -90] = "E", t6[t6.SE = -135] = "SE", t6[t6.S = -180] = "S", t6[t6.SW = -225] = "SW", t6[t6.W = -270] = "W", t6[t6.NW = -315] = "NW";
})(Ti || (Ti = {})), (function(t6) {
  t6.Any = "any", t6.DieCollide = "die.collide", t6.DieValue = "die.value", t6.DieRollHigh = "die.high", t6.DieRollLow = "die.low", t6.RollLoading = "roll.loading", t6.RollLoaded = "roll.loaded", t6.Always = "always";
})(Ei || (Ei = {})), (function(t6) {
  t6.DieIdle = "die.idle", t6.Always = "always", t6.DieCollide = "die.collide", t6.DieValue = "die.value", t6.DieRollHigh = "die.high", t6.DieRollLow = "die.low", t6.RollLoading = "roll.loading", t6.RollLoaded = "roll.loaded";
})(Ai || (Ai = {}));
var Li = (function t4(e2, i2) {
  function n2(t6, n3, r2) {
    if ("undefined" != typeof document) {
      "number" == typeof (r2 = Pi({}, i2, r2)).expires && (r2.expires = new Date(Date.now() + 864e5 * r2.expires)), r2.expires && (r2.expires = r2.expires.toUTCString()), t6 = encodeURIComponent(t6).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
      var s2 = "";
      for (var o2 in r2) r2[o2] && (s2 += "; " + o2, true !== r2[o2] && (s2 += "=" + r2[o2].split(";")[0]));
      return document.cookie = t6 + "=" + e2.write(n3, t6) + s2;
    }
  }
  return Object.create({ set: n2, get: function(t6) {
    if ("undefined" != typeof document && (!arguments.length || t6)) {
      for (var i3 = document.cookie ? document.cookie.split("; ") : [], n3 = {}, r2 = 0; r2 < i3.length; r2++) {
        var s2 = i3[r2].split("="), o2 = s2.slice(1).join("=");
        try {
          var a2 = decodeURIComponent(s2[0]);
          if (n3[a2] = e2.read(o2, a2), t6 === a2) break;
        } catch (t7) {
        }
      }
      return t6 ? n3[t6] : n3;
    }
  }, remove: function(t6, e3) {
    n2(t6, "", Pi({}, e3, { expires: -1 }));
  }, withAttributes: function(e3) {
    return t4(this.converter, Pi({}, this.attributes, e3));
  }, withConverter: function(e3) {
    return t4(Pi({}, this.converter, e3), this.attributes);
  } }, { attributes: { value: Object.freeze(i2) }, converter: { value: Object.freeze(e2) } });
})({ read: function(t6) {
  return '"' === t6[0] && (t6 = t6.slice(1, -1)), t6.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
}, write: function(t6) {
  return encodeURIComponent(t6).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g, decodeURIComponent);
} }, { path: "/" });
var Ii = function(t6) {
  var e2 = typeof t6;
  return null != t6 && ("object" == e2 || "function" == e2);
};
var Di = "object" == typeof global && global && global.Object === Object && global;
var Oi = "object" == typeof self && self && self.Object === Object && self;
var zi = Di || Oi || Function("return this")();
var Fi = function() {
  return zi.Date.now();
};
var Ni = /\s/;
var Bi = function(t6) {
  for (var e2 = t6.length; e2-- && Ni.test(t6.charAt(e2)); ) ;
  return e2;
};
var ki = /^\s+/;
var Ui = function(t6) {
  return t6 ? t6.slice(0, Bi(t6) + 1).replace(ki, "") : t6;
};
var Hi = zi.Symbol;
var Vi = Object.prototype;
var ji = Vi.hasOwnProperty;
var Gi = Vi.toString;
var Wi = Hi ? Hi.toStringTag : void 0;
var qi = function(t6) {
  var e2 = ji.call(t6, Wi), i2 = t6[Wi];
  try {
    t6[Wi] = void 0;
    var n2 = true;
  } catch (t7) {
  }
  var r2 = Gi.call(t6);
  return n2 && (e2 ? t6[Wi] = i2 : delete t6[Wi]), r2;
};
var Xi = Object.prototype.toString;
var Yi = function(t6) {
  return Xi.call(t6);
};
var Zi = Hi ? Hi.toStringTag : void 0;
var Ji = function(t6) {
  return null == t6 ? void 0 === t6 ? "[object Undefined]" : "[object Null]" : Zi && Zi in Object(t6) ? qi(t6) : Yi(t6);
};
var Ki = function(t6) {
  return null != t6 && "object" == typeof t6;
};
var $i = function(t6) {
  return "symbol" == typeof t6 || Ki(t6) && "[object Symbol]" == Ji(t6);
};
var Qi = /^[-+]0x[0-9a-f]+$/i;
var tn = /^0b[01]+$/i;
var en = /^0o[0-7]+$/i;
var nn = parseInt;
var rn = function(t6) {
  if ("number" == typeof t6) return t6;
  if ($i(t6)) return NaN;
  if (Ii(t6)) {
    var e2 = "function" == typeof t6.valueOf ? t6.valueOf() : t6;
    t6 = Ii(e2) ? e2 + "" : e2;
  }
  if ("string" != typeof t6) return 0 === t6 ? t6 : +t6;
  t6 = Ui(t6);
  var i2 = tn.test(t6);
  return i2 || en.test(t6) ? nn(t6.slice(2), i2 ? 2 : 8) : Qi.test(t6) ? NaN : +t6;
};
var sn = Math.max;
var on = Math.min;
var an = function(t6, e2, i2) {
  var n2, r2, s2, o2, a2, l2, c2 = 0, h2 = false, u2 = false, d2 = true;
  if ("function" != typeof t6) throw new TypeError("Expected a function");
  function p2(e3) {
    var i3 = n2, s3 = r2;
    return n2 = r2 = void 0, c2 = e3, o2 = t6.apply(s3, i3);
  }
  function f2(t7) {
    var i3 = t7 - l2;
    return void 0 === l2 || i3 >= e2 || i3 < 0 || u2 && t7 - c2 >= s2;
  }
  function m2() {
    var t7 = Fi();
    if (f2(t7)) return g2(t7);
    a2 = setTimeout(m2, (function(t8) {
      var i3 = e2 - (t8 - l2);
      return u2 ? on(i3, s2 - (t8 - c2)) : i3;
    })(t7));
  }
  function g2(t7) {
    return a2 = void 0, d2 && n2 ? p2(t7) : (n2 = r2 = void 0, o2);
  }
  function v2() {
    var t7 = Fi(), i3 = f2(t7);
    if (n2 = arguments, r2 = this, l2 = t7, i3) {
      if (void 0 === a2) return (function(t8) {
        return c2 = t8, a2 = setTimeout(m2, e2), h2 ? p2(t8) : o2;
      })(l2);
      if (u2) return clearTimeout(a2), a2 = setTimeout(m2, e2), p2(l2);
    }
    return void 0 === a2 && (a2 = setTimeout(m2, e2)), o2;
  }
  return e2 = rn(e2) || 0, Ii(i2) && (h2 = !!i2.leading, s2 = (u2 = "maxWait" in i2) ? sn(rn(i2.maxWait) || 0, e2) : s2, d2 = "trailing" in i2 ? !!i2.trailing : d2), v2.cancel = function() {
    void 0 !== a2 && clearTimeout(a2), c2 = 0, n2 = l2 = r2 = a2 = void 0;
  }, v2.flush = function() {
    return void 0 === a2 ? o2 : g2(Fi());
  }, v2;
};
var ln = function(t6, e2, i2) {
  var n2 = true, r2 = true;
  if ("function" != typeof t6) throw new TypeError("Expected a function");
  return Ii(i2) && (n2 = "leading" in i2 ? !!i2.leading : n2, r2 = "trailing" in i2 ? !!i2.trailing : r2), an(t6, e2, { leading: n2, maxWait: e2, trailing: r2 });
};
var cn = "143";
var hn = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
var un = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
var dn = 0;
var pn = 1;
var fn = 2;
var mn = 3;
var gn = 0;
var vn = 1;
var yn = 2;
var xn = 3;
var bn = 0;
var wn = 1;
var _n = 2;
var Sn = 1;
var Mn = 2;
var Tn = 0;
var En = 1;
var An = 2;
var Cn = 3;
var Rn = 4;
var Pn = 5;
var Ln = 100;
var In = 101;
var Dn = 102;
var On = 103;
var zn = 104;
var Fn = 200;
var Nn = 201;
var Bn = 202;
var kn = 203;
var Un = 204;
var Hn = 205;
var Vn = 206;
var jn = 207;
var Gn = 208;
var Wn = 209;
var qn = 210;
var Xn = 0;
var Yn = 1;
var Zn = 2;
var Jn = 3;
var Kn = 4;
var $n = 5;
var Qn = 6;
var tr = 7;
var er = 0;
var ir = 1;
var nr = 2;
var rr = 0;
var sr = 1;
var or = 2;
var ar = 3;
var lr = 4;
var cr = 5;
var hr = 300;
var ur = 301;
var dr = 302;
var pr = 303;
var fr = 304;
var mr = 306;
var gr = 1e3;
var vr = 1001;
var yr = 1002;
var xr = 1003;
var br = 1004;
var wr = 1004;
var _r = 1005;
var Sr = 1005;
var Mr = 1006;
var Tr = 1007;
var Er = 1007;
var Ar = 1008;
var Cr = 1008;
var Rr = 1009;
var Pr = 1010;
var Lr = 1011;
var Ir = 1012;
var Dr = 1013;
var Or = 1014;
var zr = 1015;
var Fr = 1016;
var Nr = 1017;
var Br = 1018;
var kr = 1020;
var Ur = 1021;
var Hr = 1022;
var Vr = 1023;
var jr = 1024;
var Gr = 1025;
var Wr = 1026;
var qr = 1027;
var Xr = 1028;
var Yr = 1029;
var Zr = 1030;
var Jr = 1031;
var Kr = 1033;
var $r = 33776;
var Qr = 33777;
var ts = 33778;
var es = 33779;
var is = 35840;
var ns = 35841;
var rs = 35842;
var ss = 35843;
var os = 36196;
var as = 37492;
var ls = 37496;
var cs = 37808;
var hs = 37809;
var us = 37810;
var ds = 37811;
var ps = 37812;
var fs = 37813;
var ms = 37814;
var gs = 37815;
var vs = 37816;
var ys = 37817;
var xs = 37818;
var bs = 37819;
var ws = 37820;
var _s = 37821;
var Ss = 36492;
var Ms = 2200;
var Ts = 2201;
var Es = 2202;
var As = 2300;
var Cs = 2301;
var Rs = 2302;
var Ps = 2400;
var Ls = 2401;
var Is = 2402;
var Ds = 2500;
var Os = 2501;
var zs = 0;
var Fs = 1;
var Ns = 2;
var Bs = 3e3;
var ks = 3001;
var Us = 3200;
var Hs = 3201;
var Vs = 0;
var js = 1;
var Gs = "";
var Ws = "srgb";
var qs = "srgb-linear";
var Xs = 0;
var Ys = 7680;
var Zs = 7681;
var Js = 7682;
var Ks = 7683;
var $s = 34055;
var Qs = 34056;
var to = 5386;
var eo = 512;
var no = 513;
var ro = 514;
var so = 515;
var oo = 516;
var ao = 517;
var lo = 518;
var co = 519;
var ho = 35044;
var uo = 35048;
var po = 35040;
var fo = 35045;
var mo = 35049;
var go = 35041;
var vo = 35046;
var yo = 35050;
var xo = 35042;
var bo = "100";
var wo = "300 es";
var _o = 1035;
var So = class {
  addEventListener(t6, e2) {
    void 0 === this._listeners && (this._listeners = {});
    const i2 = this._listeners;
    void 0 === i2[t6] && (i2[t6] = []), -1 === i2[t6].indexOf(e2) && i2[t6].push(e2);
  }
  hasEventListener(t6, e2) {
    if (void 0 === this._listeners) return false;
    const i2 = this._listeners;
    return void 0 !== i2[t6] && -1 !== i2[t6].indexOf(e2);
  }
  removeEventListener(t6, e2) {
    if (void 0 === this._listeners) return;
    const i2 = this._listeners[t6];
    if (void 0 !== i2) {
      const t7 = i2.indexOf(e2);
      -1 !== t7 && i2.splice(t7, 1);
    }
  }
  dispatchEvent(t6) {
    if (void 0 === this._listeners) return;
    const e2 = this._listeners[t6.type];
    if (void 0 !== e2) {
      t6.target = this;
      const i2 = e2.slice(0);
      for (let e3 = 0, n2 = i2.length; e3 < n2; e3++) i2[e3].call(this, t6);
      t6.target = null;
    }
  }
};
var Mo = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
var To = 1234567;
var Eo = Math.PI / 180;
var Ao = 180 / Math.PI;
function Co() {
  const t6 = 4294967295 * Math.random() | 0, e2 = 4294967295 * Math.random() | 0, i2 = 4294967295 * Math.random() | 0, n2 = 4294967295 * Math.random() | 0;
  return (Mo[255 & t6] + Mo[t6 >> 8 & 255] + Mo[t6 >> 16 & 255] + Mo[t6 >> 24 & 255] + "-" + Mo[255 & e2] + Mo[e2 >> 8 & 255] + "-" + Mo[e2 >> 16 & 15 | 64] + Mo[e2 >> 24 & 255] + "-" + Mo[63 & i2 | 128] + Mo[i2 >> 8 & 255] + "-" + Mo[i2 >> 16 & 255] + Mo[i2 >> 24 & 255] + Mo[255 & n2] + Mo[n2 >> 8 & 255] + Mo[n2 >> 16 & 255] + Mo[n2 >> 24 & 255]).toLowerCase();
}
function Ro(t6, e2, i2) {
  return Math.max(e2, Math.min(i2, t6));
}
function Po(t6, e2) {
  return (t6 % e2 + e2) % e2;
}
function Lo(t6, e2, i2) {
  return (1 - i2) * t6 + i2 * e2;
}
function Io(t6) {
  return !(t6 & t6 - 1) && 0 !== t6;
}
function Do(t6) {
  return Math.pow(2, Math.ceil(Math.log(t6) / Math.LN2));
}
function Oo(t6) {
  return Math.pow(2, Math.floor(Math.log(t6) / Math.LN2));
}
var zo = Object.freeze({ __proto__: null, DEG2RAD: Eo, RAD2DEG: Ao, generateUUID: Co, clamp: Ro, euclideanModulo: Po, mapLinear: function(t6, e2, i2, n2, r2) {
  return n2 + (t6 - e2) * (r2 - n2) / (i2 - e2);
}, inverseLerp: function(t6, e2, i2) {
  return t6 !== e2 ? (i2 - t6) / (e2 - t6) : 0;
}, lerp: Lo, damp: function(t6, e2, i2, n2) {
  return Lo(t6, e2, 1 - Math.exp(-i2 * n2));
}, pingpong: function(t6, e2 = 1) {
  return e2 - Math.abs(Po(t6, 2 * e2) - e2);
}, smoothstep: function(t6, e2, i2) {
  return t6 <= e2 ? 0 : t6 >= i2 ? 1 : (t6 = (t6 - e2) / (i2 - e2)) * t6 * (3 - 2 * t6);
}, smootherstep: function(t6, e2, i2) {
  return t6 <= e2 ? 0 : t6 >= i2 ? 1 : (t6 = (t6 - e2) / (i2 - e2)) * t6 * t6 * (t6 * (6 * t6 - 15) + 10);
}, randInt: function(t6, e2) {
  return t6 + Math.floor(Math.random() * (e2 - t6 + 1));
}, randFloat: function(t6, e2) {
  return t6 + Math.random() * (e2 - t6);
}, randFloatSpread: function(t6) {
  return t6 * (0.5 - Math.random());
}, seededRandom: function(t6) {
  void 0 !== t6 && (To = t6);
  let e2 = To += 1831565813;
  return e2 = Math.imul(e2 ^ e2 >>> 15, 1 | e2), e2 ^= e2 + Math.imul(e2 ^ e2 >>> 7, 61 | e2), ((e2 ^ e2 >>> 14) >>> 0) / 4294967296;
}, degToRad: function(t6) {
  return t6 * Eo;
}, radToDeg: function(t6) {
  return t6 * Ao;
}, isPowerOfTwo: Io, ceilPowerOfTwo: Do, floorPowerOfTwo: Oo, setQuaternionFromProperEuler: function(t6, e2, i2, n2, r2) {
  const s2 = Math.cos, o2 = Math.sin, a2 = s2(i2 / 2), l2 = o2(i2 / 2), c2 = s2((e2 + n2) / 2), h2 = o2((e2 + n2) / 2), u2 = s2((e2 - n2) / 2), d2 = o2((e2 - n2) / 2), p2 = s2((n2 - e2) / 2), f2 = o2((n2 - e2) / 2);
  switch (r2) {
    case "XYX":
      t6.set(a2 * h2, l2 * u2, l2 * d2, a2 * c2);
      break;
    case "YZY":
      t6.set(l2 * d2, a2 * h2, l2 * u2, a2 * c2);
      break;
    case "ZXZ":
      t6.set(l2 * u2, l2 * d2, a2 * h2, a2 * c2);
      break;
    case "XZX":
      t6.set(a2 * h2, l2 * f2, l2 * p2, a2 * c2);
      break;
    case "YXY":
      t6.set(l2 * p2, a2 * h2, l2 * f2, a2 * c2);
      break;
    case "ZYZ":
      t6.set(l2 * f2, l2 * p2, a2 * h2, a2 * c2);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r2);
  }
}, normalize: function(t6, e2) {
  switch (e2.constructor) {
    case Float32Array:
      return t6;
    case Uint16Array:
      return Math.round(65535 * t6);
    case Uint8Array:
      return Math.round(255 * t6);
    case Int16Array:
      return Math.round(32767 * t6);
    case Int8Array:
      return Math.round(127 * t6);
    default:
      throw new Error("Invalid component type.");
  }
}, denormalize: function(t6, e2) {
  switch (e2.constructor) {
    case Float32Array:
      return t6;
    case Uint16Array:
      return t6 / 65535;
    case Uint8Array:
      return t6 / 255;
    case Int16Array:
      return Math.max(t6 / 32767, -1);
    case Int8Array:
      return Math.max(t6 / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
} });
var Fo = class _Fo {
  constructor(t6 = 0, e2 = 0) {
    _Fo.prototype.isVector2 = true, this.x = t6, this.y = e2;
  }
  get width() {
    return this.x;
  }
  set width(t6) {
    this.x = t6;
  }
  get height() {
    return this.y;
  }
  set height(t6) {
    this.y = t6;
  }
  set(t6, e2) {
    return this.x = t6, this.y = e2, this;
  }
  setScalar(t6) {
    return this.x = t6, this.y = t6, this;
  }
  setX(t6) {
    return this.x = t6, this;
  }
  setY(t6) {
    return this.y = t6, this;
  }
  setComponent(t6, e2) {
    switch (t6) {
      case 0:
        this.x = e2;
        break;
      case 1:
        this.y = e2;
        break;
      default:
        throw new Error("index is out of range: " + t6);
    }
    return this;
  }
  getComponent(t6) {
    switch (t6) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + t6);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(t6) {
    return this.x = t6.x, this.y = t6.y, this;
  }
  add(t6) {
    return this.x += t6.x, this.y += t6.y, this;
  }
  addScalar(t6) {
    return this.x += t6, this.y += t6, this;
  }
  addVectors(t6, e2) {
    return this.x = t6.x + e2.x, this.y = t6.y + e2.y, this;
  }
  addScaledVector(t6, e2) {
    return this.x += t6.x * e2, this.y += t6.y * e2, this;
  }
  sub(t6) {
    return this.x -= t6.x, this.y -= t6.y, this;
  }
  subScalar(t6) {
    return this.x -= t6, this.y -= t6, this;
  }
  subVectors(t6, e2) {
    return this.x = t6.x - e2.x, this.y = t6.y - e2.y, this;
  }
  multiply(t6) {
    return this.x *= t6.x, this.y *= t6.y, this;
  }
  multiplyScalar(t6) {
    return this.x *= t6, this.y *= t6, this;
  }
  divide(t6) {
    return this.x /= t6.x, this.y /= t6.y, this;
  }
  divideScalar(t6) {
    return this.multiplyScalar(1 / t6);
  }
  applyMatrix3(t6) {
    const e2 = this.x, i2 = this.y, n2 = t6.elements;
    return this.x = n2[0] * e2 + n2[3] * i2 + n2[6], this.y = n2[1] * e2 + n2[4] * i2 + n2[7], this;
  }
  min(t6) {
    return this.x = Math.min(this.x, t6.x), this.y = Math.min(this.y, t6.y), this;
  }
  max(t6) {
    return this.x = Math.max(this.x, t6.x), this.y = Math.max(this.y, t6.y), this;
  }
  clamp(t6, e2) {
    return this.x = Math.max(t6.x, Math.min(e2.x, this.x)), this.y = Math.max(t6.y, Math.min(e2.y, this.y)), this;
  }
  clampScalar(t6, e2) {
    return this.x = Math.max(t6, Math.min(e2, this.x)), this.y = Math.max(t6, Math.min(e2, this.y)), this;
  }
  clampLength(t6, e2) {
    const i2 = this.length();
    return this.divideScalar(i2 || 1).multiplyScalar(Math.max(t6, Math.min(e2, i2)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(t6) {
    return this.x * t6.x + this.y * t6.y;
  }
  cross(t6) {
    return this.x * t6.y - this.y * t6.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  distanceTo(t6) {
    return Math.sqrt(this.distanceToSquared(t6));
  }
  distanceToSquared(t6) {
    const e2 = this.x - t6.x, i2 = this.y - t6.y;
    return e2 * e2 + i2 * i2;
  }
  manhattanDistanceTo(t6) {
    return Math.abs(this.x - t6.x) + Math.abs(this.y - t6.y);
  }
  setLength(t6) {
    return this.normalize().multiplyScalar(t6);
  }
  lerp(t6, e2) {
    return this.x += (t6.x - this.x) * e2, this.y += (t6.y - this.y) * e2, this;
  }
  lerpVectors(t6, e2, i2) {
    return this.x = t6.x + (e2.x - t6.x) * i2, this.y = t6.y + (e2.y - t6.y) * i2, this;
  }
  equals(t6) {
    return t6.x === this.x && t6.y === this.y;
  }
  fromArray(t6, e2 = 0) {
    return this.x = t6[e2], this.y = t6[e2 + 1], this;
  }
  toArray(t6 = [], e2 = 0) {
    return t6[e2] = this.x, t6[e2 + 1] = this.y, t6;
  }
  fromBufferAttribute(t6, e2) {
    return this.x = t6.getX(e2), this.y = t6.getY(e2), this;
  }
  rotateAround(t6, e2) {
    const i2 = Math.cos(e2), n2 = Math.sin(e2), r2 = this.x - t6.x, s2 = this.y - t6.y;
    return this.x = r2 * i2 - s2 * n2 + t6.x, this.y = r2 * n2 + s2 * i2 + t6.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
};
var No = class _No {
  constructor() {
    _No.prototype.isMatrix3 = true, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  }
  set(t6, e2, i2, n2, r2, s2, o2, a2, l2) {
    const c2 = this.elements;
    return c2[0] = t6, c2[1] = n2, c2[2] = o2, c2[3] = e2, c2[4] = r2, c2[5] = a2, c2[6] = i2, c2[7] = s2, c2[8] = l2, this;
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(t6) {
    const e2 = this.elements, i2 = t6.elements;
    return e2[0] = i2[0], e2[1] = i2[1], e2[2] = i2[2], e2[3] = i2[3], e2[4] = i2[4], e2[5] = i2[5], e2[6] = i2[6], e2[7] = i2[7], e2[8] = i2[8], this;
  }
  extractBasis(t6, e2, i2) {
    return t6.setFromMatrix3Column(this, 0), e2.setFromMatrix3Column(this, 1), i2.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(t6) {
    const e2 = t6.elements;
    return this.set(e2[0], e2[4], e2[8], e2[1], e2[5], e2[9], e2[2], e2[6], e2[10]), this;
  }
  multiply(t6) {
    return this.multiplyMatrices(this, t6);
  }
  premultiply(t6) {
    return this.multiplyMatrices(t6, this);
  }
  multiplyMatrices(t6, e2) {
    const i2 = t6.elements, n2 = e2.elements, r2 = this.elements, s2 = i2[0], o2 = i2[3], a2 = i2[6], l2 = i2[1], c2 = i2[4], h2 = i2[7], u2 = i2[2], d2 = i2[5], p2 = i2[8], f2 = n2[0], m2 = n2[3], g2 = n2[6], v2 = n2[1], y2 = n2[4], x2 = n2[7], b2 = n2[2], w2 = n2[5], _2 = n2[8];
    return r2[0] = s2 * f2 + o2 * v2 + a2 * b2, r2[3] = s2 * m2 + o2 * y2 + a2 * w2, r2[6] = s2 * g2 + o2 * x2 + a2 * _2, r2[1] = l2 * f2 + c2 * v2 + h2 * b2, r2[4] = l2 * m2 + c2 * y2 + h2 * w2, r2[7] = l2 * g2 + c2 * x2 + h2 * _2, r2[2] = u2 * f2 + d2 * v2 + p2 * b2, r2[5] = u2 * m2 + d2 * y2 + p2 * w2, r2[8] = u2 * g2 + d2 * x2 + p2 * _2, this;
  }
  multiplyScalar(t6) {
    const e2 = this.elements;
    return e2[0] *= t6, e2[3] *= t6, e2[6] *= t6, e2[1] *= t6, e2[4] *= t6, e2[7] *= t6, e2[2] *= t6, e2[5] *= t6, e2[8] *= t6, this;
  }
  determinant() {
    const t6 = this.elements, e2 = t6[0], i2 = t6[1], n2 = t6[2], r2 = t6[3], s2 = t6[4], o2 = t6[5], a2 = t6[6], l2 = t6[7], c2 = t6[8];
    return e2 * s2 * c2 - e2 * o2 * l2 - i2 * r2 * c2 + i2 * o2 * a2 + n2 * r2 * l2 - n2 * s2 * a2;
  }
  invert() {
    const t6 = this.elements, e2 = t6[0], i2 = t6[1], n2 = t6[2], r2 = t6[3], s2 = t6[4], o2 = t6[5], a2 = t6[6], l2 = t6[7], c2 = t6[8], h2 = c2 * s2 - o2 * l2, u2 = o2 * a2 - c2 * r2, d2 = l2 * r2 - s2 * a2, p2 = e2 * h2 + i2 * u2 + n2 * d2;
    if (0 === p2) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const f2 = 1 / p2;
    return t6[0] = h2 * f2, t6[1] = (n2 * l2 - c2 * i2) * f2, t6[2] = (o2 * i2 - n2 * s2) * f2, t6[3] = u2 * f2, t6[4] = (c2 * e2 - n2 * a2) * f2, t6[5] = (n2 * r2 - o2 * e2) * f2, t6[6] = d2 * f2, t6[7] = (i2 * a2 - l2 * e2) * f2, t6[8] = (s2 * e2 - i2 * r2) * f2, this;
  }
  transpose() {
    let t6;
    const e2 = this.elements;
    return t6 = e2[1], e2[1] = e2[3], e2[3] = t6, t6 = e2[2], e2[2] = e2[6], e2[6] = t6, t6 = e2[5], e2[5] = e2[7], e2[7] = t6, this;
  }
  getNormalMatrix(t6) {
    return this.setFromMatrix4(t6).invert().transpose();
  }
  transposeIntoArray(t6) {
    const e2 = this.elements;
    return t6[0] = e2[0], t6[1] = e2[3], t6[2] = e2[6], t6[3] = e2[1], t6[4] = e2[4], t6[5] = e2[7], t6[6] = e2[2], t6[7] = e2[5], t6[8] = e2[8], this;
  }
  setUvTransform(t6, e2, i2, n2, r2, s2, o2) {
    const a2 = Math.cos(r2), l2 = Math.sin(r2);
    return this.set(i2 * a2, i2 * l2, -i2 * (a2 * s2 + l2 * o2) + s2 + t6, -n2 * l2, n2 * a2, -n2 * (-l2 * s2 + a2 * o2) + o2 + e2, 0, 0, 1), this;
  }
  scale(t6, e2) {
    const i2 = this.elements;
    return i2[0] *= t6, i2[3] *= t6, i2[6] *= t6, i2[1] *= e2, i2[4] *= e2, i2[7] *= e2, this;
  }
  rotate(t6) {
    const e2 = Math.cos(t6), i2 = Math.sin(t6), n2 = this.elements, r2 = n2[0], s2 = n2[3], o2 = n2[6], a2 = n2[1], l2 = n2[4], c2 = n2[7];
    return n2[0] = e2 * r2 + i2 * a2, n2[3] = e2 * s2 + i2 * l2, n2[6] = e2 * o2 + i2 * c2, n2[1] = -i2 * r2 + e2 * a2, n2[4] = -i2 * s2 + e2 * l2, n2[7] = -i2 * o2 + e2 * c2, this;
  }
  translate(t6, e2) {
    const i2 = this.elements;
    return i2[0] += t6 * i2[2], i2[3] += t6 * i2[5], i2[6] += t6 * i2[8], i2[1] += e2 * i2[2], i2[4] += e2 * i2[5], i2[7] += e2 * i2[8], this;
  }
  equals(t6) {
    const e2 = this.elements, i2 = t6.elements;
    for (let t7 = 0; t7 < 9; t7++) if (e2[t7] !== i2[t7]) return false;
    return true;
  }
  fromArray(t6, e2 = 0) {
    for (let i2 = 0; i2 < 9; i2++) this.elements[i2] = t6[i2 + e2];
    return this;
  }
  toArray(t6 = [], e2 = 0) {
    const i2 = this.elements;
    return t6[e2] = i2[0], t6[e2 + 1] = i2[1], t6[e2 + 2] = i2[2], t6[e2 + 3] = i2[3], t6[e2 + 4] = i2[4], t6[e2 + 5] = i2[5], t6[e2 + 6] = i2[6], t6[e2 + 7] = i2[7], t6[e2 + 8] = i2[8], t6;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
};
function Bo(t6) {
  for (let e2 = t6.length - 1; e2 >= 0; --e2) if (t6[e2] > 65535) return true;
  return false;
}
var ko = { Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array };
function Uo(t6, e2) {
  return new ko[t6](e2);
}
function Ho(t6) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", t6);
}
function Vo(t6) {
  return t6 < 0.04045 ? 0.0773993808 * t6 : Math.pow(0.9478672986 * t6 + 0.0521327014, 2.4);
}
function jo(t6) {
  return t6 < 31308e-7 ? 12.92 * t6 : 1.055 * Math.pow(t6, 0.41666) - 0.055;
}
var Go = { [Ws]: { [qs]: Vo }, [qs]: { [Ws]: jo } };
var Wo = { legacyMode: true, get workingColorSpace() {
  return qs;
}, set workingColorSpace(t6) {
  console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
}, convert: function(t6, e2, i2) {
  if (this.legacyMode || e2 === i2 || !e2 || !i2) return t6;
  if (Go[e2] && void 0 !== Go[e2][i2]) {
    const n2 = Go[e2][i2];
    return t6.r = n2(t6.r), t6.g = n2(t6.g), t6.b = n2(t6.b), t6;
  }
  throw new Error("Unsupported color space conversion.");
}, fromWorkingColorSpace: function(t6, e2) {
  return this.convert(t6, this.workingColorSpace, e2);
}, toWorkingColorSpace: function(t6, e2) {
  return this.convert(t6, e2, this.workingColorSpace);
} };
var qo = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 };
var Xo = { r: 0, g: 0, b: 0 };
var Yo = { h: 0, s: 0, l: 0 };
var Zo = { h: 0, s: 0, l: 0 };
function Jo(t6, e2, i2) {
  return i2 < 0 && (i2 += 1), i2 > 1 && (i2 -= 1), i2 < 1 / 6 ? t6 + 6 * (e2 - t6) * i2 : i2 < 0.5 ? e2 : i2 < 2 / 3 ? t6 + 6 * (e2 - t6) * (2 / 3 - i2) : t6;
}
function Ko(t6, e2) {
  return e2.r = t6.r, e2.g = t6.g, e2.b = t6.b, e2;
}
var $o = class {
  constructor(t6, e2, i2) {
    return this.isColor = true, this.r = 1, this.g = 1, this.b = 1, void 0 === e2 && void 0 === i2 ? this.set(t6) : this.setRGB(t6, e2, i2);
  }
  set(t6) {
    return t6 && t6.isColor ? this.copy(t6) : "number" == typeof t6 ? this.setHex(t6) : "string" == typeof t6 && this.setStyle(t6), this;
  }
  setScalar(t6) {
    return this.r = t6, this.g = t6, this.b = t6, this;
  }
  setHex(t6, e2 = Ws) {
    return t6 = Math.floor(t6), this.r = (t6 >> 16 & 255) / 255, this.g = (t6 >> 8 & 255) / 255, this.b = (255 & t6) / 255, Wo.toWorkingColorSpace(this, e2), this;
  }
  setRGB(t6, e2, i2, n2 = qs) {
    return this.r = t6, this.g = e2, this.b = i2, Wo.toWorkingColorSpace(this, n2), this;
  }
  setHSL(t6, e2, i2, n2 = qs) {
    if (t6 = Po(t6, 1), e2 = Ro(e2, 0, 1), i2 = Ro(i2, 0, 1), 0 === e2) this.r = this.g = this.b = i2;
    else {
      const n3 = i2 <= 0.5 ? i2 * (1 + e2) : i2 + e2 - i2 * e2, r2 = 2 * i2 - n3;
      this.r = Jo(r2, n3, t6 + 1 / 3), this.g = Jo(r2, n3, t6), this.b = Jo(r2, n3, t6 - 1 / 3);
    }
    return Wo.toWorkingColorSpace(this, n2), this;
  }
  setStyle(t6, e2 = Ws) {
    function i2(e3) {
      void 0 !== e3 && parseFloat(e3) < 1 && console.warn("THREE.Color: Alpha component of " + t6 + " will be ignored.");
    }
    let n2;
    if (n2 = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t6)) {
      let t7;
      const r2 = n2[1], s2 = n2[2];
      switch (r2) {
        case "rgb":
        case "rgba":
          if (t7 = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s2)) return this.r = Math.min(255, parseInt(t7[1], 10)) / 255, this.g = Math.min(255, parseInt(t7[2], 10)) / 255, this.b = Math.min(255, parseInt(t7[3], 10)) / 255, Wo.toWorkingColorSpace(this, e2), i2(t7[4]), this;
          if (t7 = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s2)) return this.r = Math.min(100, parseInt(t7[1], 10)) / 100, this.g = Math.min(100, parseInt(t7[2], 10)) / 100, this.b = Math.min(100, parseInt(t7[3], 10)) / 100, Wo.toWorkingColorSpace(this, e2), i2(t7[4]), this;
          break;
        case "hsl":
        case "hsla":
          if (t7 = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s2)) {
            const n3 = parseFloat(t7[1]) / 360, r3 = parseInt(t7[2], 10) / 100, s3 = parseInt(t7[3], 10) / 100;
            return i2(t7[4]), this.setHSL(n3, r3, s3, e2);
          }
      }
    } else if (n2 = /^\#([A-Fa-f\d]+)$/.exec(t6)) {
      const t7 = n2[1], i3 = t7.length;
      if (3 === i3) return this.r = parseInt(t7.charAt(0) + t7.charAt(0), 16) / 255, this.g = parseInt(t7.charAt(1) + t7.charAt(1), 16) / 255, this.b = parseInt(t7.charAt(2) + t7.charAt(2), 16) / 255, Wo.toWorkingColorSpace(this, e2), this;
      if (6 === i3) return this.r = parseInt(t7.charAt(0) + t7.charAt(1), 16) / 255, this.g = parseInt(t7.charAt(2) + t7.charAt(3), 16) / 255, this.b = parseInt(t7.charAt(4) + t7.charAt(5), 16) / 255, Wo.toWorkingColorSpace(this, e2), this;
    }
    return t6 && t6.length > 0 ? this.setColorName(t6, e2) : this;
  }
  setColorName(t6, e2 = Ws) {
    const i2 = qo[t6.toLowerCase()];
    return void 0 !== i2 ? this.setHex(i2, e2) : console.warn("THREE.Color: Unknown color " + t6), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(t6) {
    return this.r = t6.r, this.g = t6.g, this.b = t6.b, this;
  }
  copySRGBToLinear(t6) {
    return this.r = Vo(t6.r), this.g = Vo(t6.g), this.b = Vo(t6.b), this;
  }
  copyLinearToSRGB(t6) {
    return this.r = jo(t6.r), this.g = jo(t6.g), this.b = jo(t6.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(t6 = Ws) {
    return Wo.fromWorkingColorSpace(Ko(this, Xo), t6), Ro(255 * Xo.r, 0, 255) << 16 ^ Ro(255 * Xo.g, 0, 255) << 8 ^ Ro(255 * Xo.b, 0, 255);
  }
  getHexString(t6 = Ws) {
    return ("000000" + this.getHex(t6).toString(16)).slice(-6);
  }
  getHSL(t6, e2 = qs) {
    Wo.fromWorkingColorSpace(Ko(this, Xo), e2);
    const i2 = Xo.r, n2 = Xo.g, r2 = Xo.b, s2 = Math.max(i2, n2, r2), o2 = Math.min(i2, n2, r2);
    let a2, l2;
    const c2 = (o2 + s2) / 2;
    if (o2 === s2) a2 = 0, l2 = 0;
    else {
      const t7 = s2 - o2;
      switch (l2 = c2 <= 0.5 ? t7 / (s2 + o2) : t7 / (2 - s2 - o2), s2) {
        case i2:
          a2 = (n2 - r2) / t7 + (n2 < r2 ? 6 : 0);
          break;
        case n2:
          a2 = (r2 - i2) / t7 + 2;
          break;
        case r2:
          a2 = (i2 - n2) / t7 + 4;
      }
      a2 /= 6;
    }
    return t6.h = a2, t6.s = l2, t6.l = c2, t6;
  }
  getRGB(t6, e2 = qs) {
    return Wo.fromWorkingColorSpace(Ko(this, Xo), e2), t6.r = Xo.r, t6.g = Xo.g, t6.b = Xo.b, t6;
  }
  getStyle(t6 = Ws) {
    return Wo.fromWorkingColorSpace(Ko(this, Xo), t6), t6 !== Ws ? `color(${t6} ${Xo.r} ${Xo.g} ${Xo.b})` : `rgb(${255 * Xo.r | 0},${255 * Xo.g | 0},${255 * Xo.b | 0})`;
  }
  offsetHSL(t6, e2, i2) {
    return this.getHSL(Yo), Yo.h += t6, Yo.s += e2, Yo.l += i2, this.setHSL(Yo.h, Yo.s, Yo.l), this;
  }
  add(t6) {
    return this.r += t6.r, this.g += t6.g, this.b += t6.b, this;
  }
  addColors(t6, e2) {
    return this.r = t6.r + e2.r, this.g = t6.g + e2.g, this.b = t6.b + e2.b, this;
  }
  addScalar(t6) {
    return this.r += t6, this.g += t6, this.b += t6, this;
  }
  sub(t6) {
    return this.r = Math.max(0, this.r - t6.r), this.g = Math.max(0, this.g - t6.g), this.b = Math.max(0, this.b - t6.b), this;
  }
  multiply(t6) {
    return this.r *= t6.r, this.g *= t6.g, this.b *= t6.b, this;
  }
  multiplyScalar(t6) {
    return this.r *= t6, this.g *= t6, this.b *= t6, this;
  }
  lerp(t6, e2) {
    return this.r += (t6.r - this.r) * e2, this.g += (t6.g - this.g) * e2, this.b += (t6.b - this.b) * e2, this;
  }
  lerpColors(t6, e2, i2) {
    return this.r = t6.r + (e2.r - t6.r) * i2, this.g = t6.g + (e2.g - t6.g) * i2, this.b = t6.b + (e2.b - t6.b) * i2, this;
  }
  lerpHSL(t6, e2) {
    this.getHSL(Yo), t6.getHSL(Zo);
    const i2 = Lo(Yo.h, Zo.h, e2), n2 = Lo(Yo.s, Zo.s, e2), r2 = Lo(Yo.l, Zo.l, e2);
    return this.setHSL(i2, n2, r2), this;
  }
  equals(t6) {
    return t6.r === this.r && t6.g === this.g && t6.b === this.b;
  }
  fromArray(t6, e2 = 0) {
    return this.r = t6[e2], this.g = t6[e2 + 1], this.b = t6[e2 + 2], this;
  }
  toArray(t6 = [], e2 = 0) {
    return t6[e2] = this.r, t6[e2 + 1] = this.g, t6[e2 + 2] = this.b, t6;
  }
  fromBufferAttribute(t6, e2) {
    return this.r = t6.getX(e2), this.g = t6.getY(e2), this.b = t6.getZ(e2), true === t6.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
};
var Qo;
$o.NAMES = qo;
var ta = class {
  static getDataURL(t6) {
    if (/^data:/i.test(t6.src)) return t6.src;
    if ("undefined" == typeof HTMLCanvasElement) return t6.src;
    let e2;
    if (t6 instanceof HTMLCanvasElement) e2 = t6;
    else {
      void 0 === Qo && (Qo = Ho("canvas")), Qo.width = t6.width, Qo.height = t6.height;
      const i2 = Qo.getContext("2d");
      t6 instanceof ImageData ? i2.putImageData(t6, 0, 0) : i2.drawImage(t6, 0, 0, t6.width, t6.height), e2 = Qo;
    }
    return e2.width > 2048 || e2.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t6), e2.toDataURL("image/jpeg", 0.6)) : e2.toDataURL("image/png");
  }
  static sRGBToLinear(t6) {
    if ("undefined" != typeof HTMLImageElement && t6 instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t6 instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t6 instanceof ImageBitmap) {
      const e2 = Ho("canvas");
      e2.width = t6.width, e2.height = t6.height;
      const i2 = e2.getContext("2d");
      i2.drawImage(t6, 0, 0, t6.width, t6.height);
      const n2 = i2.getImageData(0, 0, t6.width, t6.height), r2 = n2.data;
      for (let t7 = 0; t7 < r2.length; t7++) r2[t7] = 255 * Vo(r2[t7] / 255);
      return i2.putImageData(n2, 0, 0), e2;
    }
    if (t6.data) {
      const e2 = t6.data.slice(0);
      for (let t7 = 0; t7 < e2.length; t7++) e2 instanceof Uint8Array || e2 instanceof Uint8ClampedArray ? e2[t7] = Math.floor(255 * Vo(e2[t7] / 255)) : e2[t7] = Vo(e2[t7]);
      return { data: e2, width: t6.width, height: t6.height };
    }
    return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t6;
  }
};
var ea = class {
  constructor(t6 = null) {
    this.isSource = true, this.uuid = Co(), this.data = t6, this.version = 0;
  }
  set needsUpdate(t6) {
    true === t6 && this.version++;
  }
  toJSON(t6) {
    const e2 = void 0 === t6 || "string" == typeof t6;
    if (!e2 && void 0 !== t6.images[this.uuid]) return t6.images[this.uuid];
    const i2 = { uuid: this.uuid, url: "" }, n2 = this.data;
    if (null !== n2) {
      let t7;
      if (Array.isArray(n2)) {
        t7 = [];
        for (let e3 = 0, i3 = n2.length; e3 < i3; e3++) n2[e3].isDataTexture ? t7.push(ia(n2[e3].image)) : t7.push(ia(n2[e3]));
      } else t7 = ia(n2);
      i2.url = t7;
    }
    return e2 || (t6.images[this.uuid] = i2), i2;
  }
};
function ia(t6) {
  return "undefined" != typeof HTMLImageElement && t6 instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t6 instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t6 instanceof ImageBitmap ? ta.getDataURL(t6) : t6.data ? { data: Array.from(t6.data), width: t6.width, height: t6.height, type: t6.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
var na = 0;
var ra = class _ra extends So {
  constructor(t6 = _ra.DEFAULT_IMAGE, e2 = _ra.DEFAULT_MAPPING, i2 = vr, n2 = vr, r2 = Mr, s2 = Ar, o2 = Vr, a2 = Rr, l2 = 1, c2 = Bs) {
    super(), this.isTexture = true, Object.defineProperty(this, "id", { value: na++ }), this.uuid = Co(), this.name = "", this.source = new ea(t6), this.mipmaps = [], this.mapping = e2, this.wrapS = i2, this.wrapT = n2, this.magFilter = r2, this.minFilter = s2, this.anisotropy = l2, this.format = o2, this.internalFormat = null, this.type = a2, this.offset = new Fo(0, 0), this.repeat = new Fo(1, 1), this.center = new Fo(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new No(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.encoding = c2, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = false, this.needsPMREMUpdate = false;
  }
  get image() {
    return this.source.data;
  }
  set image(t6) {
    this.source.data = t6;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t6) {
    return this.name = t6.name, this.source = t6.source, this.mipmaps = t6.mipmaps.slice(0), this.mapping = t6.mapping, this.wrapS = t6.wrapS, this.wrapT = t6.wrapT, this.magFilter = t6.magFilter, this.minFilter = t6.minFilter, this.anisotropy = t6.anisotropy, this.format = t6.format, this.internalFormat = t6.internalFormat, this.type = t6.type, this.offset.copy(t6.offset), this.repeat.copy(t6.repeat), this.center.copy(t6.center), this.rotation = t6.rotation, this.matrixAutoUpdate = t6.matrixAutoUpdate, this.matrix.copy(t6.matrix), this.generateMipmaps = t6.generateMipmaps, this.premultiplyAlpha = t6.premultiplyAlpha, this.flipY = t6.flipY, this.unpackAlignment = t6.unpackAlignment, this.encoding = t6.encoding, this.userData = JSON.parse(JSON.stringify(t6.userData)), this.needsUpdate = true, this;
  }
  toJSON(t6) {
    const e2 = void 0 === t6 || "string" == typeof t6;
    if (!e2 && void 0 !== t6.textures[this.uuid]) return t6.textures[this.uuid];
    const i2 = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(t6).uuid, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
    return "{}" !== JSON.stringify(this.userData) && (i2.userData = this.userData), e2 || (t6.textures[this.uuid] = i2), i2;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(t6) {
    if (this.mapping !== hr) return t6;
    if (t6.applyMatrix3(this.matrix), t6.x < 0 || t6.x > 1) switch (this.wrapS) {
      case gr:
        t6.x = t6.x - Math.floor(t6.x);
        break;
      case vr:
        t6.x = t6.x < 0 ? 0 : 1;
        break;
      case yr:
        1 === Math.abs(Math.floor(t6.x) % 2) ? t6.x = Math.ceil(t6.x) - t6.x : t6.x = t6.x - Math.floor(t6.x);
    }
    if (t6.y < 0 || t6.y > 1) switch (this.wrapT) {
      case gr:
        t6.y = t6.y - Math.floor(t6.y);
        break;
      case vr:
        t6.y = t6.y < 0 ? 0 : 1;
        break;
      case yr:
        1 === Math.abs(Math.floor(t6.y) % 2) ? t6.y = Math.ceil(t6.y) - t6.y : t6.y = t6.y - Math.floor(t6.y);
    }
    return this.flipY && (t6.y = 1 - t6.y), t6;
  }
  set needsUpdate(t6) {
    true === t6 && (this.version++, this.source.needsUpdate = true);
  }
};
ra.DEFAULT_IMAGE = null, ra.DEFAULT_MAPPING = hr;
var sa = class _sa {
  constructor(t6 = 0, e2 = 0, i2 = 0, n2 = 1) {
    _sa.prototype.isVector4 = true, this.x = t6, this.y = e2, this.z = i2, this.w = n2;
  }
  get width() {
    return this.z;
  }
  set width(t6) {
    this.z = t6;
  }
  get height() {
    return this.w;
  }
  set height(t6) {
    this.w = t6;
  }
  set(t6, e2, i2, n2) {
    return this.x = t6, this.y = e2, this.z = i2, this.w = n2, this;
  }
  setScalar(t6) {
    return this.x = t6, this.y = t6, this.z = t6, this.w = t6, this;
  }
  setX(t6) {
    return this.x = t6, this;
  }
  setY(t6) {
    return this.y = t6, this;
  }
  setZ(t6) {
    return this.z = t6, this;
  }
  setW(t6) {
    return this.w = t6, this;
  }
  setComponent(t6, e2) {
    switch (t6) {
      case 0:
        this.x = e2;
        break;
      case 1:
        this.y = e2;
        break;
      case 2:
        this.z = e2;
        break;
      case 3:
        this.w = e2;
        break;
      default:
        throw new Error("index is out of range: " + t6);
    }
    return this;
  }
  getComponent(t6) {
    switch (t6) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + t6);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(t6) {
    return this.x = t6.x, this.y = t6.y, this.z = t6.z, this.w = void 0 !== t6.w ? t6.w : 1, this;
  }
  add(t6) {
    return this.x += t6.x, this.y += t6.y, this.z += t6.z, this.w += t6.w, this;
  }
  addScalar(t6) {
    return this.x += t6, this.y += t6, this.z += t6, this.w += t6, this;
  }
  addVectors(t6, e2) {
    return this.x = t6.x + e2.x, this.y = t6.y + e2.y, this.z = t6.z + e2.z, this.w = t6.w + e2.w, this;
  }
  addScaledVector(t6, e2) {
    return this.x += t6.x * e2, this.y += t6.y * e2, this.z += t6.z * e2, this.w += t6.w * e2, this;
  }
  sub(t6) {
    return this.x -= t6.x, this.y -= t6.y, this.z -= t6.z, this.w -= t6.w, this;
  }
  subScalar(t6) {
    return this.x -= t6, this.y -= t6, this.z -= t6, this.w -= t6, this;
  }
  subVectors(t6, e2) {
    return this.x = t6.x - e2.x, this.y = t6.y - e2.y, this.z = t6.z - e2.z, this.w = t6.w - e2.w, this;
  }
  multiply(t6) {
    return this.x *= t6.x, this.y *= t6.y, this.z *= t6.z, this.w *= t6.w, this;
  }
  multiplyScalar(t6) {
    return this.x *= t6, this.y *= t6, this.z *= t6, this.w *= t6, this;
  }
  applyMatrix4(t6) {
    const e2 = this.x, i2 = this.y, n2 = this.z, r2 = this.w, s2 = t6.elements;
    return this.x = s2[0] * e2 + s2[4] * i2 + s2[8] * n2 + s2[12] * r2, this.y = s2[1] * e2 + s2[5] * i2 + s2[9] * n2 + s2[13] * r2, this.z = s2[2] * e2 + s2[6] * i2 + s2[10] * n2 + s2[14] * r2, this.w = s2[3] * e2 + s2[7] * i2 + s2[11] * n2 + s2[15] * r2, this;
  }
  divideScalar(t6) {
    return this.multiplyScalar(1 / t6);
  }
  setAxisAngleFromQuaternion(t6) {
    this.w = 2 * Math.acos(t6.w);
    const e2 = Math.sqrt(1 - t6.w * t6.w);
    return e2 < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t6.x / e2, this.y = t6.y / e2, this.z = t6.z / e2), this;
  }
  setAxisAngleFromRotationMatrix(t6) {
    let e2, i2, n2, r2;
    const s2 = 0.01, o2 = 0.1, a2 = t6.elements, l2 = a2[0], c2 = a2[4], h2 = a2[8], u2 = a2[1], d2 = a2[5], p2 = a2[9], f2 = a2[2], m2 = a2[6], g2 = a2[10];
    if (Math.abs(c2 - u2) < s2 && Math.abs(h2 - f2) < s2 && Math.abs(p2 - m2) < s2) {
      if (Math.abs(c2 + u2) < o2 && Math.abs(h2 + f2) < o2 && Math.abs(p2 + m2) < o2 && Math.abs(l2 + d2 + g2 - 3) < o2) return this.set(1, 0, 0, 0), this;
      e2 = Math.PI;
      const t7 = (l2 + 1) / 2, a3 = (d2 + 1) / 2, v3 = (g2 + 1) / 2, y2 = (c2 + u2) / 4, x2 = (h2 + f2) / 4, b2 = (p2 + m2) / 4;
      return t7 > a3 && t7 > v3 ? t7 < s2 ? (i2 = 0, n2 = 0.707106781, r2 = 0.707106781) : (i2 = Math.sqrt(t7), n2 = y2 / i2, r2 = x2 / i2) : a3 > v3 ? a3 < s2 ? (i2 = 0.707106781, n2 = 0, r2 = 0.707106781) : (n2 = Math.sqrt(a3), i2 = y2 / n2, r2 = b2 / n2) : v3 < s2 ? (i2 = 0.707106781, n2 = 0.707106781, r2 = 0) : (r2 = Math.sqrt(v3), i2 = x2 / r2, n2 = b2 / r2), this.set(i2, n2, r2, e2), this;
    }
    let v2 = Math.sqrt((m2 - p2) * (m2 - p2) + (h2 - f2) * (h2 - f2) + (u2 - c2) * (u2 - c2));
    return Math.abs(v2) < 1e-3 && (v2 = 1), this.x = (m2 - p2) / v2, this.y = (h2 - f2) / v2, this.z = (u2 - c2) / v2, this.w = Math.acos((l2 + d2 + g2 - 1) / 2), this;
  }
  min(t6) {
    return this.x = Math.min(this.x, t6.x), this.y = Math.min(this.y, t6.y), this.z = Math.min(this.z, t6.z), this.w = Math.min(this.w, t6.w), this;
  }
  max(t6) {
    return this.x = Math.max(this.x, t6.x), this.y = Math.max(this.y, t6.y), this.z = Math.max(this.z, t6.z), this.w = Math.max(this.w, t6.w), this;
  }
  clamp(t6, e2) {
    return this.x = Math.max(t6.x, Math.min(e2.x, this.x)), this.y = Math.max(t6.y, Math.min(e2.y, this.y)), this.z = Math.max(t6.z, Math.min(e2.z, this.z)), this.w = Math.max(t6.w, Math.min(e2.w, this.w)), this;
  }
  clampScalar(t6, e2) {
    return this.x = Math.max(t6, Math.min(e2, this.x)), this.y = Math.max(t6, Math.min(e2, this.y)), this.z = Math.max(t6, Math.min(e2, this.z)), this.w = Math.max(t6, Math.min(e2, this.w)), this;
  }
  clampLength(t6, e2) {
    const i2 = this.length();
    return this.divideScalar(i2 || 1).multiplyScalar(Math.max(t6, Math.min(e2, i2)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(t6) {
    return this.x * t6.x + this.y * t6.y + this.z * t6.z + this.w * t6.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t6) {
    return this.normalize().multiplyScalar(t6);
  }
  lerp(t6, e2) {
    return this.x += (t6.x - this.x) * e2, this.y += (t6.y - this.y) * e2, this.z += (t6.z - this.z) * e2, this.w += (t6.w - this.w) * e2, this;
  }
  lerpVectors(t6, e2, i2) {
    return this.x = t6.x + (e2.x - t6.x) * i2, this.y = t6.y + (e2.y - t6.y) * i2, this.z = t6.z + (e2.z - t6.z) * i2, this.w = t6.w + (e2.w - t6.w) * i2, this;
  }
  equals(t6) {
    return t6.x === this.x && t6.y === this.y && t6.z === this.z && t6.w === this.w;
  }
  fromArray(t6, e2 = 0) {
    return this.x = t6[e2], this.y = t6[e2 + 1], this.z = t6[e2 + 2], this.w = t6[e2 + 3], this;
  }
  toArray(t6 = [], e2 = 0) {
    return t6[e2] = this.x, t6[e2 + 1] = this.y, t6[e2 + 2] = this.z, t6[e2 + 3] = this.w, t6;
  }
  fromBufferAttribute(t6, e2) {
    return this.x = t6.getX(e2), this.y = t6.getY(e2), this.z = t6.getZ(e2), this.w = t6.getW(e2), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
};
var oa = class extends So {
  constructor(t6, e2, i2 = {}) {
    super(), this.isWebGLRenderTarget = true, this.width = t6, this.height = e2, this.depth = 1, this.scissor = new sa(0, 0, t6, e2), this.scissorTest = false, this.viewport = new sa(0, 0, t6, e2);
    const n2 = { width: t6, height: e2, depth: 1 };
    this.texture = new ra(n2, i2.mapping, i2.wrapS, i2.wrapT, i2.magFilter, i2.minFilter, i2.format, i2.type, i2.anisotropy, i2.encoding), this.texture.isRenderTargetTexture = true, this.texture.flipY = false, this.texture.generateMipmaps = void 0 !== i2.generateMipmaps && i2.generateMipmaps, this.texture.internalFormat = void 0 !== i2.internalFormat ? i2.internalFormat : null, this.texture.minFilter = void 0 !== i2.minFilter ? i2.minFilter : Mr, this.depthBuffer = void 0 === i2.depthBuffer || i2.depthBuffer, this.stencilBuffer = void 0 !== i2.stencilBuffer && i2.stencilBuffer, this.depthTexture = void 0 !== i2.depthTexture ? i2.depthTexture : null, this.samples = void 0 !== i2.samples ? i2.samples : 0;
  }
  setSize(t6, e2, i2 = 1) {
    this.width === t6 && this.height === e2 && this.depth === i2 || (this.width = t6, this.height = e2, this.depth = i2, this.texture.image.width = t6, this.texture.image.height = e2, this.texture.image.depth = i2, this.dispose()), this.viewport.set(0, 0, t6, e2), this.scissor.set(0, 0, t6, e2);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t6) {
    this.width = t6.width, this.height = t6.height, this.depth = t6.depth, this.viewport.copy(t6.viewport), this.texture = t6.texture.clone(), this.texture.isRenderTargetTexture = true;
    const e2 = Object.assign({}, t6.texture.image);
    return this.texture.source = new ea(e2), this.depthBuffer = t6.depthBuffer, this.stencilBuffer = t6.stencilBuffer, null !== t6.depthTexture && (this.depthTexture = t6.depthTexture.clone()), this.samples = t6.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
var aa = class extends ra {
  constructor(t6 = null, e2 = 1, i2 = 1, n2 = 1) {
    super(null), this.isDataArrayTexture = true, this.image = { data: t6, width: e2, height: i2, depth: n2 }, this.magFilter = xr, this.minFilter = xr, this.wrapR = vr, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
  }
};
var la = class extends oa {
  constructor(t6, e2, i2) {
    super(t6, e2), this.isWebGLArrayRenderTarget = true, this.depth = i2, this.texture = new aa(null, t6, e2, i2), this.texture.isRenderTargetTexture = true;
  }
};
var ca = class extends ra {
  constructor(t6 = null, e2 = 1, i2 = 1, n2 = 1) {
    super(null), this.isData3DTexture = true, this.image = { data: t6, width: e2, height: i2, depth: n2 }, this.magFilter = xr, this.minFilter = xr, this.wrapR = vr, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
  }
};
var ha = class extends oa {
  constructor(t6, e2, i2) {
    super(t6, e2), this.isWebGL3DRenderTarget = true, this.depth = i2, this.texture = new ca(null, t6, e2, i2), this.texture.isRenderTargetTexture = true;
  }
};
var ua = class extends oa {
  constructor(t6, e2, i2, n2 = {}) {
    super(t6, e2, n2), this.isWebGLMultipleRenderTargets = true;
    const r2 = this.texture;
    this.texture = [];
    for (let t7 = 0; t7 < i2; t7++) this.texture[t7] = r2.clone(), this.texture[t7].isRenderTargetTexture = true;
  }
  setSize(t6, e2, i2 = 1) {
    if (this.width !== t6 || this.height !== e2 || this.depth !== i2) {
      this.width = t6, this.height = e2, this.depth = i2;
      for (let n2 = 0, r2 = this.texture.length; n2 < r2; n2++) this.texture[n2].image.width = t6, this.texture[n2].image.height = e2, this.texture[n2].image.depth = i2;
      this.dispose();
    }
    return this.viewport.set(0, 0, t6, e2), this.scissor.set(0, 0, t6, e2), this;
  }
  copy(t6) {
    this.dispose(), this.width = t6.width, this.height = t6.height, this.depth = t6.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = t6.depthBuffer, this.stencilBuffer = t6.stencilBuffer, null !== t6.depthTexture && (this.depthTexture = t6.depthTexture.clone()), this.texture.length = 0;
    for (let e2 = 0, i2 = t6.texture.length; e2 < i2; e2++) this.texture[e2] = t6.texture[e2].clone(), this.texture[e2].isRenderTargetTexture = true;
    return this;
  }
};
var da = class {
  constructor(t6 = 0, e2 = 0, i2 = 0, n2 = 1) {
    this.isQuaternion = true, this._x = t6, this._y = e2, this._z = i2, this._w = n2;
  }
  static slerpFlat(t6, e2, i2, n2, r2, s2, o2) {
    let a2 = i2[n2 + 0], l2 = i2[n2 + 1], c2 = i2[n2 + 2], h2 = i2[n2 + 3];
    const u2 = r2[s2 + 0], d2 = r2[s2 + 1], p2 = r2[s2 + 2], f2 = r2[s2 + 3];
    if (0 === o2) return t6[e2 + 0] = a2, t6[e2 + 1] = l2, t6[e2 + 2] = c2, void (t6[e2 + 3] = h2);
    if (1 === o2) return t6[e2 + 0] = u2, t6[e2 + 1] = d2, t6[e2 + 2] = p2, void (t6[e2 + 3] = f2);
    if (h2 !== f2 || a2 !== u2 || l2 !== d2 || c2 !== p2) {
      let t7 = 1 - o2;
      const e3 = a2 * u2 + l2 * d2 + c2 * p2 + h2 * f2, i3 = e3 >= 0 ? 1 : -1, n3 = 1 - e3 * e3;
      if (n3 > Number.EPSILON) {
        const r4 = Math.sqrt(n3), s3 = Math.atan2(r4, e3 * i3);
        t7 = Math.sin(t7 * s3) / r4, o2 = Math.sin(o2 * s3) / r4;
      }
      const r3 = o2 * i3;
      if (a2 = a2 * t7 + u2 * r3, l2 = l2 * t7 + d2 * r3, c2 = c2 * t7 + p2 * r3, h2 = h2 * t7 + f2 * r3, t7 === 1 - o2) {
        const t8 = 1 / Math.sqrt(a2 * a2 + l2 * l2 + c2 * c2 + h2 * h2);
        a2 *= t8, l2 *= t8, c2 *= t8, h2 *= t8;
      }
    }
    t6[e2] = a2, t6[e2 + 1] = l2, t6[e2 + 2] = c2, t6[e2 + 3] = h2;
  }
  static multiplyQuaternionsFlat(t6, e2, i2, n2, r2, s2) {
    const o2 = i2[n2], a2 = i2[n2 + 1], l2 = i2[n2 + 2], c2 = i2[n2 + 3], h2 = r2[s2], u2 = r2[s2 + 1], d2 = r2[s2 + 2], p2 = r2[s2 + 3];
    return t6[e2] = o2 * p2 + c2 * h2 + a2 * d2 - l2 * u2, t6[e2 + 1] = a2 * p2 + c2 * u2 + l2 * h2 - o2 * d2, t6[e2 + 2] = l2 * p2 + c2 * d2 + o2 * u2 - a2 * h2, t6[e2 + 3] = c2 * p2 - o2 * h2 - a2 * u2 - l2 * d2, t6;
  }
  get x() {
    return this._x;
  }
  set x(t6) {
    this._x = t6, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t6) {
    this._y = t6, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t6) {
    this._z = t6, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(t6) {
    this._w = t6, this._onChangeCallback();
  }
  set(t6, e2, i2, n2) {
    return this._x = t6, this._y = e2, this._z = i2, this._w = n2, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(t6) {
    return this._x = t6.x, this._y = t6.y, this._z = t6.z, this._w = t6.w, this._onChangeCallback(), this;
  }
  setFromEuler(t6, e2) {
    if (!t6 || !t6.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    const i2 = t6._x, n2 = t6._y, r2 = t6._z, s2 = t6._order, o2 = Math.cos, a2 = Math.sin, l2 = o2(i2 / 2), c2 = o2(n2 / 2), h2 = o2(r2 / 2), u2 = a2(i2 / 2), d2 = a2(n2 / 2), p2 = a2(r2 / 2);
    switch (s2) {
      case "XYZ":
        this._x = u2 * c2 * h2 + l2 * d2 * p2, this._y = l2 * d2 * h2 - u2 * c2 * p2, this._z = l2 * c2 * p2 + u2 * d2 * h2, this._w = l2 * c2 * h2 - u2 * d2 * p2;
        break;
      case "YXZ":
        this._x = u2 * c2 * h2 + l2 * d2 * p2, this._y = l2 * d2 * h2 - u2 * c2 * p2, this._z = l2 * c2 * p2 - u2 * d2 * h2, this._w = l2 * c2 * h2 + u2 * d2 * p2;
        break;
      case "ZXY":
        this._x = u2 * c2 * h2 - l2 * d2 * p2, this._y = l2 * d2 * h2 + u2 * c2 * p2, this._z = l2 * c2 * p2 + u2 * d2 * h2, this._w = l2 * c2 * h2 - u2 * d2 * p2;
        break;
      case "ZYX":
        this._x = u2 * c2 * h2 - l2 * d2 * p2, this._y = l2 * d2 * h2 + u2 * c2 * p2, this._z = l2 * c2 * p2 - u2 * d2 * h2, this._w = l2 * c2 * h2 + u2 * d2 * p2;
        break;
      case "YZX":
        this._x = u2 * c2 * h2 + l2 * d2 * p2, this._y = l2 * d2 * h2 + u2 * c2 * p2, this._z = l2 * c2 * p2 - u2 * d2 * h2, this._w = l2 * c2 * h2 - u2 * d2 * p2;
        break;
      case "XZY":
        this._x = u2 * c2 * h2 - l2 * d2 * p2, this._y = l2 * d2 * h2 - u2 * c2 * p2, this._z = l2 * c2 * p2 + u2 * d2 * h2, this._w = l2 * c2 * h2 + u2 * d2 * p2;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s2);
    }
    return false !== e2 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(t6, e2) {
    const i2 = e2 / 2, n2 = Math.sin(i2);
    return this._x = t6.x * n2, this._y = t6.y * n2, this._z = t6.z * n2, this._w = Math.cos(i2), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(t6) {
    const e2 = t6.elements, i2 = e2[0], n2 = e2[4], r2 = e2[8], s2 = e2[1], o2 = e2[5], a2 = e2[9], l2 = e2[2], c2 = e2[6], h2 = e2[10], u2 = i2 + o2 + h2;
    if (u2 > 0) {
      const t7 = 0.5 / Math.sqrt(u2 + 1);
      this._w = 0.25 / t7, this._x = (c2 - a2) * t7, this._y = (r2 - l2) * t7, this._z = (s2 - n2) * t7;
    } else if (i2 > o2 && i2 > h2) {
      const t7 = 2 * Math.sqrt(1 + i2 - o2 - h2);
      this._w = (c2 - a2) / t7, this._x = 0.25 * t7, this._y = (n2 + s2) / t7, this._z = (r2 + l2) / t7;
    } else if (o2 > h2) {
      const t7 = 2 * Math.sqrt(1 + o2 - i2 - h2);
      this._w = (r2 - l2) / t7, this._x = (n2 + s2) / t7, this._y = 0.25 * t7, this._z = (a2 + c2) / t7;
    } else {
      const t7 = 2 * Math.sqrt(1 + h2 - i2 - o2);
      this._w = (s2 - n2) / t7, this._x = (r2 + l2) / t7, this._y = (a2 + c2) / t7, this._z = 0.25 * t7;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(t6, e2) {
    let i2 = t6.dot(e2) + 1;
    return i2 < Number.EPSILON ? (i2 = 0, Math.abs(t6.x) > Math.abs(t6.z) ? (this._x = -t6.y, this._y = t6.x, this._z = 0, this._w = i2) : (this._x = 0, this._y = -t6.z, this._z = t6.y, this._w = i2)) : (this._x = t6.y * e2.z - t6.z * e2.y, this._y = t6.z * e2.x - t6.x * e2.z, this._z = t6.x * e2.y - t6.y * e2.x, this._w = i2), this.normalize();
  }
  angleTo(t6) {
    return 2 * Math.acos(Math.abs(Ro(this.dot(t6), -1, 1)));
  }
  rotateTowards(t6, e2) {
    const i2 = this.angleTo(t6);
    if (0 === i2) return this;
    const n2 = Math.min(1, e2 / i2);
    return this.slerp(t6, n2), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(t6) {
    return this._x * t6._x + this._y * t6._y + this._z * t6._z + this._w * t6._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let t6 = this.length();
    return 0 === t6 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t6 = 1 / t6, this._x = this._x * t6, this._y = this._y * t6, this._z = this._z * t6, this._w = this._w * t6), this._onChangeCallback(), this;
  }
  multiply(t6) {
    return this.multiplyQuaternions(this, t6);
  }
  premultiply(t6) {
    return this.multiplyQuaternions(t6, this);
  }
  multiplyQuaternions(t6, e2) {
    const i2 = t6._x, n2 = t6._y, r2 = t6._z, s2 = t6._w, o2 = e2._x, a2 = e2._y, l2 = e2._z, c2 = e2._w;
    return this._x = i2 * c2 + s2 * o2 + n2 * l2 - r2 * a2, this._y = n2 * c2 + s2 * a2 + r2 * o2 - i2 * l2, this._z = r2 * c2 + s2 * l2 + i2 * a2 - n2 * o2, this._w = s2 * c2 - i2 * o2 - n2 * a2 - r2 * l2, this._onChangeCallback(), this;
  }
  slerp(t6, e2) {
    if (0 === e2) return this;
    if (1 === e2) return this.copy(t6);
    const i2 = this._x, n2 = this._y, r2 = this._z, s2 = this._w;
    let o2 = s2 * t6._w + i2 * t6._x + n2 * t6._y + r2 * t6._z;
    if (o2 < 0 ? (this._w = -t6._w, this._x = -t6._x, this._y = -t6._y, this._z = -t6._z, o2 = -o2) : this.copy(t6), o2 >= 1) return this._w = s2, this._x = i2, this._y = n2, this._z = r2, this;
    const a2 = 1 - o2 * o2;
    if (a2 <= Number.EPSILON) {
      const t7 = 1 - e2;
      return this._w = t7 * s2 + e2 * this._w, this._x = t7 * i2 + e2 * this._x, this._y = t7 * n2 + e2 * this._y, this._z = t7 * r2 + e2 * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    const l2 = Math.sqrt(a2), c2 = Math.atan2(l2, o2), h2 = Math.sin((1 - e2) * c2) / l2, u2 = Math.sin(e2 * c2) / l2;
    return this._w = s2 * h2 + this._w * u2, this._x = i2 * h2 + this._x * u2, this._y = n2 * h2 + this._y * u2, this._z = r2 * h2 + this._z * u2, this._onChangeCallback(), this;
  }
  slerpQuaternions(t6, e2, i2) {
    return this.copy(t6).slerp(e2, i2);
  }
  random() {
    const t6 = Math.random(), e2 = Math.sqrt(1 - t6), i2 = Math.sqrt(t6), n2 = 2 * Math.PI * Math.random(), r2 = 2 * Math.PI * Math.random();
    return this.set(e2 * Math.cos(n2), i2 * Math.sin(r2), i2 * Math.cos(r2), e2 * Math.sin(n2));
  }
  equals(t6) {
    return t6._x === this._x && t6._y === this._y && t6._z === this._z && t6._w === this._w;
  }
  fromArray(t6, e2 = 0) {
    return this._x = t6[e2], this._y = t6[e2 + 1], this._z = t6[e2 + 2], this._w = t6[e2 + 3], this._onChangeCallback(), this;
  }
  toArray(t6 = [], e2 = 0) {
    return t6[e2] = this._x, t6[e2 + 1] = this._y, t6[e2 + 2] = this._z, t6[e2 + 3] = this._w, t6;
  }
  fromBufferAttribute(t6, e2) {
    return this._x = t6.getX(e2), this._y = t6.getY(e2), this._z = t6.getZ(e2), this._w = t6.getW(e2), this;
  }
  _onChange(t6) {
    return this._onChangeCallback = t6, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
};
var pa = class _pa {
  constructor(t6 = 0, e2 = 0, i2 = 0) {
    _pa.prototype.isVector3 = true, this.x = t6, this.y = e2, this.z = i2;
  }
  set(t6, e2, i2) {
    return void 0 === i2 && (i2 = this.z), this.x = t6, this.y = e2, this.z = i2, this;
  }
  setScalar(t6) {
    return this.x = t6, this.y = t6, this.z = t6, this;
  }
  setX(t6) {
    return this.x = t6, this;
  }
  setY(t6) {
    return this.y = t6, this;
  }
  setZ(t6) {
    return this.z = t6, this;
  }
  setComponent(t6, e2) {
    switch (t6) {
      case 0:
        this.x = e2;
        break;
      case 1:
        this.y = e2;
        break;
      case 2:
        this.z = e2;
        break;
      default:
        throw new Error("index is out of range: " + t6);
    }
    return this;
  }
  getComponent(t6) {
    switch (t6) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + t6);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(t6) {
    return this.x = t6.x, this.y = t6.y, this.z = t6.z, this;
  }
  add(t6) {
    return this.x += t6.x, this.y += t6.y, this.z += t6.z, this;
  }
  addScalar(t6) {
    return this.x += t6, this.y += t6, this.z += t6, this;
  }
  addVectors(t6, e2) {
    return this.x = t6.x + e2.x, this.y = t6.y + e2.y, this.z = t6.z + e2.z, this;
  }
  addScaledVector(t6, e2) {
    return this.x += t6.x * e2, this.y += t6.y * e2, this.z += t6.z * e2, this;
  }
  sub(t6) {
    return this.x -= t6.x, this.y -= t6.y, this.z -= t6.z, this;
  }
  subScalar(t6) {
    return this.x -= t6, this.y -= t6, this.z -= t6, this;
  }
  subVectors(t6, e2) {
    return this.x = t6.x - e2.x, this.y = t6.y - e2.y, this.z = t6.z - e2.z, this;
  }
  multiply(t6) {
    return this.x *= t6.x, this.y *= t6.y, this.z *= t6.z, this;
  }
  multiplyScalar(t6) {
    return this.x *= t6, this.y *= t6, this.z *= t6, this;
  }
  multiplyVectors(t6, e2) {
    return this.x = t6.x * e2.x, this.y = t6.y * e2.y, this.z = t6.z * e2.z, this;
  }
  applyEuler(t6) {
    return this.applyQuaternion(ma.setFromEuler(t6));
  }
  applyAxisAngle(t6, e2) {
    return this.applyQuaternion(ma.setFromAxisAngle(t6, e2));
  }
  applyMatrix3(t6) {
    const e2 = this.x, i2 = this.y, n2 = this.z, r2 = t6.elements;
    return this.x = r2[0] * e2 + r2[3] * i2 + r2[6] * n2, this.y = r2[1] * e2 + r2[4] * i2 + r2[7] * n2, this.z = r2[2] * e2 + r2[5] * i2 + r2[8] * n2, this;
  }
  applyNormalMatrix(t6) {
    return this.applyMatrix3(t6).normalize();
  }
  applyMatrix4(t6) {
    const e2 = this.x, i2 = this.y, n2 = this.z, r2 = t6.elements, s2 = 1 / (r2[3] * e2 + r2[7] * i2 + r2[11] * n2 + r2[15]);
    return this.x = (r2[0] * e2 + r2[4] * i2 + r2[8] * n2 + r2[12]) * s2, this.y = (r2[1] * e2 + r2[5] * i2 + r2[9] * n2 + r2[13]) * s2, this.z = (r2[2] * e2 + r2[6] * i2 + r2[10] * n2 + r2[14]) * s2, this;
  }
  applyQuaternion(t6) {
    const e2 = this.x, i2 = this.y, n2 = this.z, r2 = t6.x, s2 = t6.y, o2 = t6.z, a2 = t6.w, l2 = a2 * e2 + s2 * n2 - o2 * i2, c2 = a2 * i2 + o2 * e2 - r2 * n2, h2 = a2 * n2 + r2 * i2 - s2 * e2, u2 = -r2 * e2 - s2 * i2 - o2 * n2;
    return this.x = l2 * a2 + u2 * -r2 + c2 * -o2 - h2 * -s2, this.y = c2 * a2 + u2 * -s2 + h2 * -r2 - l2 * -o2, this.z = h2 * a2 + u2 * -o2 + l2 * -s2 - c2 * -r2, this;
  }
  project(t6) {
    return this.applyMatrix4(t6.matrixWorldInverse).applyMatrix4(t6.projectionMatrix);
  }
  unproject(t6) {
    return this.applyMatrix4(t6.projectionMatrixInverse).applyMatrix4(t6.matrixWorld);
  }
  transformDirection(t6) {
    const e2 = this.x, i2 = this.y, n2 = this.z, r2 = t6.elements;
    return this.x = r2[0] * e2 + r2[4] * i2 + r2[8] * n2, this.y = r2[1] * e2 + r2[5] * i2 + r2[9] * n2, this.z = r2[2] * e2 + r2[6] * i2 + r2[10] * n2, this.normalize();
  }
  divide(t6) {
    return this.x /= t6.x, this.y /= t6.y, this.z /= t6.z, this;
  }
  divideScalar(t6) {
    return this.multiplyScalar(1 / t6);
  }
  min(t6) {
    return this.x = Math.min(this.x, t6.x), this.y = Math.min(this.y, t6.y), this.z = Math.min(this.z, t6.z), this;
  }
  max(t6) {
    return this.x = Math.max(this.x, t6.x), this.y = Math.max(this.y, t6.y), this.z = Math.max(this.z, t6.z), this;
  }
  clamp(t6, e2) {
    return this.x = Math.max(t6.x, Math.min(e2.x, this.x)), this.y = Math.max(t6.y, Math.min(e2.y, this.y)), this.z = Math.max(t6.z, Math.min(e2.z, this.z)), this;
  }
  clampScalar(t6, e2) {
    return this.x = Math.max(t6, Math.min(e2, this.x)), this.y = Math.max(t6, Math.min(e2, this.y)), this.z = Math.max(t6, Math.min(e2, this.z)), this;
  }
  clampLength(t6, e2) {
    const i2 = this.length();
    return this.divideScalar(i2 || 1).multiplyScalar(Math.max(t6, Math.min(e2, i2)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(t6) {
    return this.x * t6.x + this.y * t6.y + this.z * t6.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t6) {
    return this.normalize().multiplyScalar(t6);
  }
  lerp(t6, e2) {
    return this.x += (t6.x - this.x) * e2, this.y += (t6.y - this.y) * e2, this.z += (t6.z - this.z) * e2, this;
  }
  lerpVectors(t6, e2, i2) {
    return this.x = t6.x + (e2.x - t6.x) * i2, this.y = t6.y + (e2.y - t6.y) * i2, this.z = t6.z + (e2.z - t6.z) * i2, this;
  }
  cross(t6) {
    return this.crossVectors(this, t6);
  }
  crossVectors(t6, e2) {
    const i2 = t6.x, n2 = t6.y, r2 = t6.z, s2 = e2.x, o2 = e2.y, a2 = e2.z;
    return this.x = n2 * a2 - r2 * o2, this.y = r2 * s2 - i2 * a2, this.z = i2 * o2 - n2 * s2, this;
  }
  projectOnVector(t6) {
    const e2 = t6.lengthSq();
    if (0 === e2) return this.set(0, 0, 0);
    const i2 = t6.dot(this) / e2;
    return this.copy(t6).multiplyScalar(i2);
  }
  projectOnPlane(t6) {
    return fa.copy(this).projectOnVector(t6), this.sub(fa);
  }
  reflect(t6) {
    return this.sub(fa.copy(t6).multiplyScalar(2 * this.dot(t6)));
  }
  angleTo(t6) {
    const e2 = Math.sqrt(this.lengthSq() * t6.lengthSq());
    if (0 === e2) return Math.PI / 2;
    const i2 = this.dot(t6) / e2;
    return Math.acos(Ro(i2, -1, 1));
  }
  distanceTo(t6) {
    return Math.sqrt(this.distanceToSquared(t6));
  }
  distanceToSquared(t6) {
    const e2 = this.x - t6.x, i2 = this.y - t6.y, n2 = this.z - t6.z;
    return e2 * e2 + i2 * i2 + n2 * n2;
  }
  manhattanDistanceTo(t6) {
    return Math.abs(this.x - t6.x) + Math.abs(this.y - t6.y) + Math.abs(this.z - t6.z);
  }
  setFromSpherical(t6) {
    return this.setFromSphericalCoords(t6.radius, t6.phi, t6.theta);
  }
  setFromSphericalCoords(t6, e2, i2) {
    const n2 = Math.sin(e2) * t6;
    return this.x = n2 * Math.sin(i2), this.y = Math.cos(e2) * t6, this.z = n2 * Math.cos(i2), this;
  }
  setFromCylindrical(t6) {
    return this.setFromCylindricalCoords(t6.radius, t6.theta, t6.y);
  }
  setFromCylindricalCoords(t6, e2, i2) {
    return this.x = t6 * Math.sin(e2), this.y = i2, this.z = t6 * Math.cos(e2), this;
  }
  setFromMatrixPosition(t6) {
    const e2 = t6.elements;
    return this.x = e2[12], this.y = e2[13], this.z = e2[14], this;
  }
  setFromMatrixScale(t6) {
    const e2 = this.setFromMatrixColumn(t6, 0).length(), i2 = this.setFromMatrixColumn(t6, 1).length(), n2 = this.setFromMatrixColumn(t6, 2).length();
    return this.x = e2, this.y = i2, this.z = n2, this;
  }
  setFromMatrixColumn(t6, e2) {
    return this.fromArray(t6.elements, 4 * e2);
  }
  setFromMatrix3Column(t6, e2) {
    return this.fromArray(t6.elements, 3 * e2);
  }
  setFromEuler(t6) {
    return this.x = t6._x, this.y = t6._y, this.z = t6._z, this;
  }
  equals(t6) {
    return t6.x === this.x && t6.y === this.y && t6.z === this.z;
  }
  fromArray(t6, e2 = 0) {
    return this.x = t6[e2], this.y = t6[e2 + 1], this.z = t6[e2 + 2], this;
  }
  toArray(t6 = [], e2 = 0) {
    return t6[e2] = this.x, t6[e2 + 1] = this.y, t6[e2 + 2] = this.z, t6;
  }
  fromBufferAttribute(t6, e2) {
    return this.x = t6.getX(e2), this.y = t6.getY(e2), this.z = t6.getZ(e2), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const t6 = 2 * (Math.random() - 0.5), e2 = Math.random() * Math.PI * 2, i2 = Math.sqrt(1 - t6 ** 2);
    return this.x = i2 * Math.cos(e2), this.y = i2 * Math.sin(e2), this.z = t6, this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
};
var fa = new pa();
var ma = new da();
var ga = class {
  constructor(t6 = new pa(1 / 0, 1 / 0, 1 / 0), e2 = new pa(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = true, this.min = t6, this.max = e2;
  }
  set(t6, e2) {
    return this.min.copy(t6), this.max.copy(e2), this;
  }
  setFromArray(t6) {
    let e2 = 1 / 0, i2 = 1 / 0, n2 = 1 / 0, r2 = -1 / 0, s2 = -1 / 0, o2 = -1 / 0;
    for (let a2 = 0, l2 = t6.length; a2 < l2; a2 += 3) {
      const l3 = t6[a2], c2 = t6[a2 + 1], h2 = t6[a2 + 2];
      l3 < e2 && (e2 = l3), c2 < i2 && (i2 = c2), h2 < n2 && (n2 = h2), l3 > r2 && (r2 = l3), c2 > s2 && (s2 = c2), h2 > o2 && (o2 = h2);
    }
    return this.min.set(e2, i2, n2), this.max.set(r2, s2, o2), this;
  }
  setFromBufferAttribute(t6) {
    let e2 = 1 / 0, i2 = 1 / 0, n2 = 1 / 0, r2 = -1 / 0, s2 = -1 / 0, o2 = -1 / 0;
    for (let a2 = 0, l2 = t6.count; a2 < l2; a2++) {
      const l3 = t6.getX(a2), c2 = t6.getY(a2), h2 = t6.getZ(a2);
      l3 < e2 && (e2 = l3), c2 < i2 && (i2 = c2), h2 < n2 && (n2 = h2), l3 > r2 && (r2 = l3), c2 > s2 && (s2 = c2), h2 > o2 && (o2 = h2);
    }
    return this.min.set(e2, i2, n2), this.max.set(r2, s2, o2), this;
  }
  setFromPoints(t6) {
    this.makeEmpty();
    for (let e2 = 0, i2 = t6.length; e2 < i2; e2++) this.expandByPoint(t6[e2]);
    return this;
  }
  setFromCenterAndSize(t6, e2) {
    const i2 = ya.copy(e2).multiplyScalar(0.5);
    return this.min.copy(t6).sub(i2), this.max.copy(t6).add(i2), this;
  }
  setFromObject(t6, e2 = false) {
    return this.makeEmpty(), this.expandByObject(t6, e2);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t6) {
    return this.min.copy(t6.min), this.max.copy(t6.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(t6) {
    return this.isEmpty() ? t6.set(0, 0, 0) : t6.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(t6) {
    return this.isEmpty() ? t6.set(0, 0, 0) : t6.subVectors(this.max, this.min);
  }
  expandByPoint(t6) {
    return this.min.min(t6), this.max.max(t6), this;
  }
  expandByVector(t6) {
    return this.min.sub(t6), this.max.add(t6), this;
  }
  expandByScalar(t6) {
    return this.min.addScalar(-t6), this.max.addScalar(t6), this;
  }
  expandByObject(t6, e2 = false) {
    t6.updateWorldMatrix(false, false);
    const i2 = t6.geometry;
    if (void 0 !== i2) if (e2 && null != i2.attributes && void 0 !== i2.attributes.position) {
      const e3 = i2.attributes.position;
      for (let i3 = 0, n3 = e3.count; i3 < n3; i3++) ya.fromBufferAttribute(e3, i3).applyMatrix4(t6.matrixWorld), this.expandByPoint(ya);
    } else null === i2.boundingBox && i2.computeBoundingBox(), xa.copy(i2.boundingBox), xa.applyMatrix4(t6.matrixWorld), this.union(xa);
    const n2 = t6.children;
    for (let t7 = 0, i3 = n2.length; t7 < i3; t7++) this.expandByObject(n2[t7], e2);
    return this;
  }
  containsPoint(t6) {
    return !(t6.x < this.min.x || t6.x > this.max.x || t6.y < this.min.y || t6.y > this.max.y || t6.z < this.min.z || t6.z > this.max.z);
  }
  containsBox(t6) {
    return this.min.x <= t6.min.x && t6.max.x <= this.max.x && this.min.y <= t6.min.y && t6.max.y <= this.max.y && this.min.z <= t6.min.z && t6.max.z <= this.max.z;
  }
  getParameter(t6, e2) {
    return e2.set((t6.x - this.min.x) / (this.max.x - this.min.x), (t6.y - this.min.y) / (this.max.y - this.min.y), (t6.z - this.min.z) / (this.max.z - this.min.z));
  }
  intersectsBox(t6) {
    return !(t6.max.x < this.min.x || t6.min.x > this.max.x || t6.max.y < this.min.y || t6.min.y > this.max.y || t6.max.z < this.min.z || t6.min.z > this.max.z);
  }
  intersectsSphere(t6) {
    return this.clampPoint(t6.center, ya), ya.distanceToSquared(t6.center) <= t6.radius * t6.radius;
  }
  intersectsPlane(t6) {
    let e2, i2;
    return t6.normal.x > 0 ? (e2 = t6.normal.x * this.min.x, i2 = t6.normal.x * this.max.x) : (e2 = t6.normal.x * this.max.x, i2 = t6.normal.x * this.min.x), t6.normal.y > 0 ? (e2 += t6.normal.y * this.min.y, i2 += t6.normal.y * this.max.y) : (e2 += t6.normal.y * this.max.y, i2 += t6.normal.y * this.min.y), t6.normal.z > 0 ? (e2 += t6.normal.z * this.min.z, i2 += t6.normal.z * this.max.z) : (e2 += t6.normal.z * this.max.z, i2 += t6.normal.z * this.min.z), e2 <= -t6.constant && i2 >= -t6.constant;
  }
  intersectsTriangle(t6) {
    if (this.isEmpty()) return false;
    this.getCenter(Ea), Aa.subVectors(this.max, Ea), ba.subVectors(t6.a, Ea), wa.subVectors(t6.b, Ea), _a.subVectors(t6.c, Ea), Sa.subVectors(wa, ba), Ma.subVectors(_a, wa), Ta.subVectors(ba, _a);
    let e2 = [0, -Sa.z, Sa.y, 0, -Ma.z, Ma.y, 0, -Ta.z, Ta.y, Sa.z, 0, -Sa.x, Ma.z, 0, -Ma.x, Ta.z, 0, -Ta.x, -Sa.y, Sa.x, 0, -Ma.y, Ma.x, 0, -Ta.y, Ta.x, 0];
    return !!Pa(e2, ba, wa, _a, Aa) && (e2 = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!Pa(e2, ba, wa, _a, Aa) && (Ca.crossVectors(Sa, Ma), e2 = [Ca.x, Ca.y, Ca.z], Pa(e2, ba, wa, _a, Aa)));
  }
  clampPoint(t6, e2) {
    return e2.copy(t6).clamp(this.min, this.max);
  }
  distanceToPoint(t6) {
    return ya.copy(t6).clamp(this.min, this.max).sub(t6).length();
  }
  getBoundingSphere(t6) {
    return this.getCenter(t6.center), t6.radius = 0.5 * this.getSize(ya).length(), t6;
  }
  intersect(t6) {
    return this.min.max(t6.min), this.max.min(t6.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(t6) {
    return this.min.min(t6.min), this.max.max(t6.max), this;
  }
  applyMatrix4(t6) {
    return this.isEmpty() || (va[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t6), va[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t6), va[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t6), va[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t6), va[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t6), va[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t6), va[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t6), va[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t6), this.setFromPoints(va)), this;
  }
  translate(t6) {
    return this.min.add(t6), this.max.add(t6), this;
  }
  equals(t6) {
    return t6.min.equals(this.min) && t6.max.equals(this.max);
  }
};
var va = [new pa(), new pa(), new pa(), new pa(), new pa(), new pa(), new pa(), new pa()];
var ya = new pa();
var xa = new ga();
var ba = new pa();
var wa = new pa();
var _a = new pa();
var Sa = new pa();
var Ma = new pa();
var Ta = new pa();
var Ea = new pa();
var Aa = new pa();
var Ca = new pa();
var Ra = new pa();
function Pa(t6, e2, i2, n2, r2) {
  for (let s2 = 0, o2 = t6.length - 3; s2 <= o2; s2 += 3) {
    Ra.fromArray(t6, s2);
    const o3 = r2.x * Math.abs(Ra.x) + r2.y * Math.abs(Ra.y) + r2.z * Math.abs(Ra.z), a2 = e2.dot(Ra), l2 = i2.dot(Ra), c2 = n2.dot(Ra);
    if (Math.max(-Math.max(a2, l2, c2), Math.min(a2, l2, c2)) > o3) return false;
  }
  return true;
}
var La = new ga();
var Ia = new pa();
var Da = new pa();
var Oa = new pa();
var za = class {
  constructor(t6 = new pa(), e2 = -1) {
    this.center = t6, this.radius = e2;
  }
  set(t6, e2) {
    return this.center.copy(t6), this.radius = e2, this;
  }
  setFromPoints(t6, e2) {
    const i2 = this.center;
    void 0 !== e2 ? i2.copy(e2) : La.setFromPoints(t6).getCenter(i2);
    let n2 = 0;
    for (let e3 = 0, r2 = t6.length; e3 < r2; e3++) n2 = Math.max(n2, i2.distanceToSquared(t6[e3]));
    return this.radius = Math.sqrt(n2), this;
  }
  copy(t6) {
    return this.center.copy(t6.center), this.radius = t6.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(t6) {
    return t6.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(t6) {
    return t6.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(t6) {
    const e2 = this.radius + t6.radius;
    return t6.center.distanceToSquared(this.center) <= e2 * e2;
  }
  intersectsBox(t6) {
    return t6.intersectsSphere(this);
  }
  intersectsPlane(t6) {
    return Math.abs(t6.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(t6, e2) {
    const i2 = this.center.distanceToSquared(t6);
    return e2.copy(t6), i2 > this.radius * this.radius && (e2.sub(this.center).normalize(), e2.multiplyScalar(this.radius).add(this.center)), e2;
  }
  getBoundingBox(t6) {
    return this.isEmpty() ? (t6.makeEmpty(), t6) : (t6.set(this.center, this.center), t6.expandByScalar(this.radius), t6);
  }
  applyMatrix4(t6) {
    return this.center.applyMatrix4(t6), this.radius = this.radius * t6.getMaxScaleOnAxis(), this;
  }
  translate(t6) {
    return this.center.add(t6), this;
  }
  expandByPoint(t6) {
    Oa.subVectors(t6, this.center);
    const e2 = Oa.lengthSq();
    if (e2 > this.radius * this.radius) {
      const t7 = Math.sqrt(e2), i2 = 0.5 * (t7 - this.radius);
      this.center.add(Oa.multiplyScalar(i2 / t7)), this.radius += i2;
    }
    return this;
  }
  union(t6) {
    return true === this.center.equals(t6.center) ? Da.set(0, 0, 1).multiplyScalar(t6.radius) : Da.subVectors(t6.center, this.center).normalize().multiplyScalar(t6.radius), this.expandByPoint(Ia.copy(t6.center).add(Da)), this.expandByPoint(Ia.copy(t6.center).sub(Da)), this;
  }
  equals(t6) {
    return t6.center.equals(this.center) && t6.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var Fa = new pa();
var Na = new pa();
var Ba = new pa();
var ka = new pa();
var Ua = new pa();
var Ha = new pa();
var Va = new pa();
var ja = class {
  constructor(t6 = new pa(), e2 = new pa(0, 0, -1)) {
    this.origin = t6, this.direction = e2;
  }
  set(t6, e2) {
    return this.origin.copy(t6), this.direction.copy(e2), this;
  }
  copy(t6) {
    return this.origin.copy(t6.origin), this.direction.copy(t6.direction), this;
  }
  at(t6, e2) {
    return e2.copy(this.direction).multiplyScalar(t6).add(this.origin);
  }
  lookAt(t6) {
    return this.direction.copy(t6).sub(this.origin).normalize(), this;
  }
  recast(t6) {
    return this.origin.copy(this.at(t6, Fa)), this;
  }
  closestPointToPoint(t6, e2) {
    e2.subVectors(t6, this.origin);
    const i2 = e2.dot(this.direction);
    return i2 < 0 ? e2.copy(this.origin) : e2.copy(this.direction).multiplyScalar(i2).add(this.origin);
  }
  distanceToPoint(t6) {
    return Math.sqrt(this.distanceSqToPoint(t6));
  }
  distanceSqToPoint(t6) {
    const e2 = Fa.subVectors(t6, this.origin).dot(this.direction);
    return e2 < 0 ? this.origin.distanceToSquared(t6) : (Fa.copy(this.direction).multiplyScalar(e2).add(this.origin), Fa.distanceToSquared(t6));
  }
  distanceSqToSegment(t6, e2, i2, n2) {
    Na.copy(t6).add(e2).multiplyScalar(0.5), Ba.copy(e2).sub(t6).normalize(), ka.copy(this.origin).sub(Na);
    const r2 = 0.5 * t6.distanceTo(e2), s2 = -this.direction.dot(Ba), o2 = ka.dot(this.direction), a2 = -ka.dot(Ba), l2 = ka.lengthSq(), c2 = Math.abs(1 - s2 * s2);
    let h2, u2, d2, p2;
    if (c2 > 0) if (h2 = s2 * a2 - o2, u2 = s2 * o2 - a2, p2 = r2 * c2, h2 >= 0) if (u2 >= -p2) if (u2 <= p2) {
      const t7 = 1 / c2;
      h2 *= t7, u2 *= t7, d2 = h2 * (h2 + s2 * u2 + 2 * o2) + u2 * (s2 * h2 + u2 + 2 * a2) + l2;
    } else u2 = r2, h2 = Math.max(0, -(s2 * u2 + o2)), d2 = -h2 * h2 + u2 * (u2 + 2 * a2) + l2;
    else u2 = -r2, h2 = Math.max(0, -(s2 * u2 + o2)), d2 = -h2 * h2 + u2 * (u2 + 2 * a2) + l2;
    else u2 <= -p2 ? (h2 = Math.max(0, -(-s2 * r2 + o2)), u2 = h2 > 0 ? -r2 : Math.min(Math.max(-r2, -a2), r2), d2 = -h2 * h2 + u2 * (u2 + 2 * a2) + l2) : u2 <= p2 ? (h2 = 0, u2 = Math.min(Math.max(-r2, -a2), r2), d2 = u2 * (u2 + 2 * a2) + l2) : (h2 = Math.max(0, -(s2 * r2 + o2)), u2 = h2 > 0 ? r2 : Math.min(Math.max(-r2, -a2), r2), d2 = -h2 * h2 + u2 * (u2 + 2 * a2) + l2);
    else u2 = s2 > 0 ? -r2 : r2, h2 = Math.max(0, -(s2 * u2 + o2)), d2 = -h2 * h2 + u2 * (u2 + 2 * a2) + l2;
    return i2 && i2.copy(this.direction).multiplyScalar(h2).add(this.origin), n2 && n2.copy(Ba).multiplyScalar(u2).add(Na), d2;
  }
  intersectSphere(t6, e2) {
    Fa.subVectors(t6.center, this.origin);
    const i2 = Fa.dot(this.direction), n2 = Fa.dot(Fa) - i2 * i2, r2 = t6.radius * t6.radius;
    if (n2 > r2) return null;
    const s2 = Math.sqrt(r2 - n2), o2 = i2 - s2, a2 = i2 + s2;
    return o2 < 0 && a2 < 0 ? null : o2 < 0 ? this.at(a2, e2) : this.at(o2, e2);
  }
  intersectsSphere(t6) {
    return this.distanceSqToPoint(t6.center) <= t6.radius * t6.radius;
  }
  distanceToPlane(t6) {
    const e2 = t6.normal.dot(this.direction);
    if (0 === e2) return 0 === t6.distanceToPoint(this.origin) ? 0 : null;
    const i2 = -(this.origin.dot(t6.normal) + t6.constant) / e2;
    return i2 >= 0 ? i2 : null;
  }
  intersectPlane(t6, e2) {
    const i2 = this.distanceToPlane(t6);
    return null === i2 ? null : this.at(i2, e2);
  }
  intersectsPlane(t6) {
    const e2 = t6.distanceToPoint(this.origin);
    if (0 === e2) return true;
    return t6.normal.dot(this.direction) * e2 < 0;
  }
  intersectBox(t6, e2) {
    let i2, n2, r2, s2, o2, a2;
    const l2 = 1 / this.direction.x, c2 = 1 / this.direction.y, h2 = 1 / this.direction.z, u2 = this.origin;
    return l2 >= 0 ? (i2 = (t6.min.x - u2.x) * l2, n2 = (t6.max.x - u2.x) * l2) : (i2 = (t6.max.x - u2.x) * l2, n2 = (t6.min.x - u2.x) * l2), c2 >= 0 ? (r2 = (t6.min.y - u2.y) * c2, s2 = (t6.max.y - u2.y) * c2) : (r2 = (t6.max.y - u2.y) * c2, s2 = (t6.min.y - u2.y) * c2), i2 > s2 || r2 > n2 ? null : ((r2 > i2 || i2 != i2) && (i2 = r2), (s2 < n2 || n2 != n2) && (n2 = s2), h2 >= 0 ? (o2 = (t6.min.z - u2.z) * h2, a2 = (t6.max.z - u2.z) * h2) : (o2 = (t6.max.z - u2.z) * h2, a2 = (t6.min.z - u2.z) * h2), i2 > a2 || o2 > n2 ? null : ((o2 > i2 || i2 != i2) && (i2 = o2), (a2 < n2 || n2 != n2) && (n2 = a2), n2 < 0 ? null : this.at(i2 >= 0 ? i2 : n2, e2)));
  }
  intersectsBox(t6) {
    return null !== this.intersectBox(t6, Fa);
  }
  intersectTriangle(t6, e2, i2, n2, r2) {
    Ua.subVectors(e2, t6), Ha.subVectors(i2, t6), Va.crossVectors(Ua, Ha);
    let s2, o2 = this.direction.dot(Va);
    if (o2 > 0) {
      if (n2) return null;
      s2 = 1;
    } else {
      if (!(o2 < 0)) return null;
      s2 = -1, o2 = -o2;
    }
    ka.subVectors(this.origin, t6);
    const a2 = s2 * this.direction.dot(Ha.crossVectors(ka, Ha));
    if (a2 < 0) return null;
    const l2 = s2 * this.direction.dot(Ua.cross(ka));
    if (l2 < 0) return null;
    if (a2 + l2 > o2) return null;
    const c2 = -s2 * ka.dot(Va);
    return c2 < 0 ? null : this.at(c2 / o2, r2);
  }
  applyMatrix4(t6) {
    return this.origin.applyMatrix4(t6), this.direction.transformDirection(t6), this;
  }
  equals(t6) {
    return t6.origin.equals(this.origin) && t6.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var Ga = class _Ga {
  constructor() {
    _Ga.prototype.isMatrix4 = true, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  set(t6, e2, i2, n2, r2, s2, o2, a2, l2, c2, h2, u2, d2, p2, f2, m2) {
    const g2 = this.elements;
    return g2[0] = t6, g2[4] = e2, g2[8] = i2, g2[12] = n2, g2[1] = r2, g2[5] = s2, g2[9] = o2, g2[13] = a2, g2[2] = l2, g2[6] = c2, g2[10] = h2, g2[14] = u2, g2[3] = d2, g2[7] = p2, g2[11] = f2, g2[15] = m2, this;
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new _Ga().fromArray(this.elements);
  }
  copy(t6) {
    const e2 = this.elements, i2 = t6.elements;
    return e2[0] = i2[0], e2[1] = i2[1], e2[2] = i2[2], e2[3] = i2[3], e2[4] = i2[4], e2[5] = i2[5], e2[6] = i2[6], e2[7] = i2[7], e2[8] = i2[8], e2[9] = i2[9], e2[10] = i2[10], e2[11] = i2[11], e2[12] = i2[12], e2[13] = i2[13], e2[14] = i2[14], e2[15] = i2[15], this;
  }
  copyPosition(t6) {
    const e2 = this.elements, i2 = t6.elements;
    return e2[12] = i2[12], e2[13] = i2[13], e2[14] = i2[14], this;
  }
  setFromMatrix3(t6) {
    const e2 = t6.elements;
    return this.set(e2[0], e2[3], e2[6], 0, e2[1], e2[4], e2[7], 0, e2[2], e2[5], e2[8], 0, 0, 0, 0, 1), this;
  }
  extractBasis(t6, e2, i2) {
    return t6.setFromMatrixColumn(this, 0), e2.setFromMatrixColumn(this, 1), i2.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(t6, e2, i2) {
    return this.set(t6.x, e2.x, i2.x, 0, t6.y, e2.y, i2.y, 0, t6.z, e2.z, i2.z, 0, 0, 0, 0, 1), this;
  }
  extractRotation(t6) {
    const e2 = this.elements, i2 = t6.elements, n2 = 1 / Wa.setFromMatrixColumn(t6, 0).length(), r2 = 1 / Wa.setFromMatrixColumn(t6, 1).length(), s2 = 1 / Wa.setFromMatrixColumn(t6, 2).length();
    return e2[0] = i2[0] * n2, e2[1] = i2[1] * n2, e2[2] = i2[2] * n2, e2[3] = 0, e2[4] = i2[4] * r2, e2[5] = i2[5] * r2, e2[6] = i2[6] * r2, e2[7] = 0, e2[8] = i2[8] * s2, e2[9] = i2[9] * s2, e2[10] = i2[10] * s2, e2[11] = 0, e2[12] = 0, e2[13] = 0, e2[14] = 0, e2[15] = 1, this;
  }
  makeRotationFromEuler(t6) {
    const e2 = this.elements, i2 = t6.x, n2 = t6.y, r2 = t6.z, s2 = Math.cos(i2), o2 = Math.sin(i2), a2 = Math.cos(n2), l2 = Math.sin(n2), c2 = Math.cos(r2), h2 = Math.sin(r2);
    if ("XYZ" === t6.order) {
      const t7 = s2 * c2, i3 = s2 * h2, n3 = o2 * c2, r3 = o2 * h2;
      e2[0] = a2 * c2, e2[4] = -a2 * h2, e2[8] = l2, e2[1] = i3 + n3 * l2, e2[5] = t7 - r3 * l2, e2[9] = -o2 * a2, e2[2] = r3 - t7 * l2, e2[6] = n3 + i3 * l2, e2[10] = s2 * a2;
    } else if ("YXZ" === t6.order) {
      const t7 = a2 * c2, i3 = a2 * h2, n3 = l2 * c2, r3 = l2 * h2;
      e2[0] = t7 + r3 * o2, e2[4] = n3 * o2 - i3, e2[8] = s2 * l2, e2[1] = s2 * h2, e2[5] = s2 * c2, e2[9] = -o2, e2[2] = i3 * o2 - n3, e2[6] = r3 + t7 * o2, e2[10] = s2 * a2;
    } else if ("ZXY" === t6.order) {
      const t7 = a2 * c2, i3 = a2 * h2, n3 = l2 * c2, r3 = l2 * h2;
      e2[0] = t7 - r3 * o2, e2[4] = -s2 * h2, e2[8] = n3 + i3 * o2, e2[1] = i3 + n3 * o2, e2[5] = s2 * c2, e2[9] = r3 - t7 * o2, e2[2] = -s2 * l2, e2[6] = o2, e2[10] = s2 * a2;
    } else if ("ZYX" === t6.order) {
      const t7 = s2 * c2, i3 = s2 * h2, n3 = o2 * c2, r3 = o2 * h2;
      e2[0] = a2 * c2, e2[4] = n3 * l2 - i3, e2[8] = t7 * l2 + r3, e2[1] = a2 * h2, e2[5] = r3 * l2 + t7, e2[9] = i3 * l2 - n3, e2[2] = -l2, e2[6] = o2 * a2, e2[10] = s2 * a2;
    } else if ("YZX" === t6.order) {
      const t7 = s2 * a2, i3 = s2 * l2, n3 = o2 * a2, r3 = o2 * l2;
      e2[0] = a2 * c2, e2[4] = r3 - t7 * h2, e2[8] = n3 * h2 + i3, e2[1] = h2, e2[5] = s2 * c2, e2[9] = -o2 * c2, e2[2] = -l2 * c2, e2[6] = i3 * h2 + n3, e2[10] = t7 - r3 * h2;
    } else if ("XZY" === t6.order) {
      const t7 = s2 * a2, i3 = s2 * l2, n3 = o2 * a2, r3 = o2 * l2;
      e2[0] = a2 * c2, e2[4] = -h2, e2[8] = l2 * c2, e2[1] = t7 * h2 + r3, e2[5] = s2 * c2, e2[9] = i3 * h2 - n3, e2[2] = n3 * h2 - i3, e2[6] = o2 * c2, e2[10] = r3 * h2 + t7;
    }
    return e2[3] = 0, e2[7] = 0, e2[11] = 0, e2[12] = 0, e2[13] = 0, e2[14] = 0, e2[15] = 1, this;
  }
  makeRotationFromQuaternion(t6) {
    return this.compose(Xa, t6, Ya);
  }
  lookAt(t6, e2, i2) {
    const n2 = this.elements;
    return Ka.subVectors(t6, e2), 0 === Ka.lengthSq() && (Ka.z = 1), Ka.normalize(), Za.crossVectors(i2, Ka), 0 === Za.lengthSq() && (1 === Math.abs(i2.z) ? Ka.x += 1e-4 : Ka.z += 1e-4, Ka.normalize(), Za.crossVectors(i2, Ka)), Za.normalize(), Ja.crossVectors(Ka, Za), n2[0] = Za.x, n2[4] = Ja.x, n2[8] = Ka.x, n2[1] = Za.y, n2[5] = Ja.y, n2[9] = Ka.y, n2[2] = Za.z, n2[6] = Ja.z, n2[10] = Ka.z, this;
  }
  multiply(t6) {
    return this.multiplyMatrices(this, t6);
  }
  premultiply(t6) {
    return this.multiplyMatrices(t6, this);
  }
  multiplyMatrices(t6, e2) {
    const i2 = t6.elements, n2 = e2.elements, r2 = this.elements, s2 = i2[0], o2 = i2[4], a2 = i2[8], l2 = i2[12], c2 = i2[1], h2 = i2[5], u2 = i2[9], d2 = i2[13], p2 = i2[2], f2 = i2[6], m2 = i2[10], g2 = i2[14], v2 = i2[3], y2 = i2[7], x2 = i2[11], b2 = i2[15], w2 = n2[0], _2 = n2[4], S2 = n2[8], M2 = n2[12], T2 = n2[1], E2 = n2[5], A2 = n2[9], C2 = n2[13], R2 = n2[2], P2 = n2[6], L2 = n2[10], I2 = n2[14], D2 = n2[3], O2 = n2[7], z2 = n2[11], F2 = n2[15];
    return r2[0] = s2 * w2 + o2 * T2 + a2 * R2 + l2 * D2, r2[4] = s2 * _2 + o2 * E2 + a2 * P2 + l2 * O2, r2[8] = s2 * S2 + o2 * A2 + a2 * L2 + l2 * z2, r2[12] = s2 * M2 + o2 * C2 + a2 * I2 + l2 * F2, r2[1] = c2 * w2 + h2 * T2 + u2 * R2 + d2 * D2, r2[5] = c2 * _2 + h2 * E2 + u2 * P2 + d2 * O2, r2[9] = c2 * S2 + h2 * A2 + u2 * L2 + d2 * z2, r2[13] = c2 * M2 + h2 * C2 + u2 * I2 + d2 * F2, r2[2] = p2 * w2 + f2 * T2 + m2 * R2 + g2 * D2, r2[6] = p2 * _2 + f2 * E2 + m2 * P2 + g2 * O2, r2[10] = p2 * S2 + f2 * A2 + m2 * L2 + g2 * z2, r2[14] = p2 * M2 + f2 * C2 + m2 * I2 + g2 * F2, r2[3] = v2 * w2 + y2 * T2 + x2 * R2 + b2 * D2, r2[7] = v2 * _2 + y2 * E2 + x2 * P2 + b2 * O2, r2[11] = v2 * S2 + y2 * A2 + x2 * L2 + b2 * z2, r2[15] = v2 * M2 + y2 * C2 + x2 * I2 + b2 * F2, this;
  }
  multiplyScalar(t6) {
    const e2 = this.elements;
    return e2[0] *= t6, e2[4] *= t6, e2[8] *= t6, e2[12] *= t6, e2[1] *= t6, e2[5] *= t6, e2[9] *= t6, e2[13] *= t6, e2[2] *= t6, e2[6] *= t6, e2[10] *= t6, e2[14] *= t6, e2[3] *= t6, e2[7] *= t6, e2[11] *= t6, e2[15] *= t6, this;
  }
  determinant() {
    const t6 = this.elements, e2 = t6[0], i2 = t6[4], n2 = t6[8], r2 = t6[12], s2 = t6[1], o2 = t6[5], a2 = t6[9], l2 = t6[13], c2 = t6[2], h2 = t6[6], u2 = t6[10], d2 = t6[14];
    return t6[3] * (+r2 * a2 * h2 - n2 * l2 * h2 - r2 * o2 * u2 + i2 * l2 * u2 + n2 * o2 * d2 - i2 * a2 * d2) + t6[7] * (+e2 * a2 * d2 - e2 * l2 * u2 + r2 * s2 * u2 - n2 * s2 * d2 + n2 * l2 * c2 - r2 * a2 * c2) + t6[11] * (+e2 * l2 * h2 - e2 * o2 * d2 - r2 * s2 * h2 + i2 * s2 * d2 + r2 * o2 * c2 - i2 * l2 * c2) + t6[15] * (-n2 * o2 * c2 - e2 * a2 * h2 + e2 * o2 * u2 + n2 * s2 * h2 - i2 * s2 * u2 + i2 * a2 * c2);
  }
  transpose() {
    const t6 = this.elements;
    let e2;
    return e2 = t6[1], t6[1] = t6[4], t6[4] = e2, e2 = t6[2], t6[2] = t6[8], t6[8] = e2, e2 = t6[6], t6[6] = t6[9], t6[9] = e2, e2 = t6[3], t6[3] = t6[12], t6[12] = e2, e2 = t6[7], t6[7] = t6[13], t6[13] = e2, e2 = t6[11], t6[11] = t6[14], t6[14] = e2, this;
  }
  setPosition(t6, e2, i2) {
    const n2 = this.elements;
    return t6.isVector3 ? (n2[12] = t6.x, n2[13] = t6.y, n2[14] = t6.z) : (n2[12] = t6, n2[13] = e2, n2[14] = i2), this;
  }
  invert() {
    const t6 = this.elements, e2 = t6[0], i2 = t6[1], n2 = t6[2], r2 = t6[3], s2 = t6[4], o2 = t6[5], a2 = t6[6], l2 = t6[7], c2 = t6[8], h2 = t6[9], u2 = t6[10], d2 = t6[11], p2 = t6[12], f2 = t6[13], m2 = t6[14], g2 = t6[15], v2 = h2 * m2 * l2 - f2 * u2 * l2 + f2 * a2 * d2 - o2 * m2 * d2 - h2 * a2 * g2 + o2 * u2 * g2, y2 = p2 * u2 * l2 - c2 * m2 * l2 - p2 * a2 * d2 + s2 * m2 * d2 + c2 * a2 * g2 - s2 * u2 * g2, x2 = c2 * f2 * l2 - p2 * h2 * l2 + p2 * o2 * d2 - s2 * f2 * d2 - c2 * o2 * g2 + s2 * h2 * g2, b2 = p2 * h2 * a2 - c2 * f2 * a2 - p2 * o2 * u2 + s2 * f2 * u2 + c2 * o2 * m2 - s2 * h2 * m2, w2 = e2 * v2 + i2 * y2 + n2 * x2 + r2 * b2;
    if (0 === w2) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const _2 = 1 / w2;
    return t6[0] = v2 * _2, t6[1] = (f2 * u2 * r2 - h2 * m2 * r2 - f2 * n2 * d2 + i2 * m2 * d2 + h2 * n2 * g2 - i2 * u2 * g2) * _2, t6[2] = (o2 * m2 * r2 - f2 * a2 * r2 + f2 * n2 * l2 - i2 * m2 * l2 - o2 * n2 * g2 + i2 * a2 * g2) * _2, t6[3] = (h2 * a2 * r2 - o2 * u2 * r2 - h2 * n2 * l2 + i2 * u2 * l2 + o2 * n2 * d2 - i2 * a2 * d2) * _2, t6[4] = y2 * _2, t6[5] = (c2 * m2 * r2 - p2 * u2 * r2 + p2 * n2 * d2 - e2 * m2 * d2 - c2 * n2 * g2 + e2 * u2 * g2) * _2, t6[6] = (p2 * a2 * r2 - s2 * m2 * r2 - p2 * n2 * l2 + e2 * m2 * l2 + s2 * n2 * g2 - e2 * a2 * g2) * _2, t6[7] = (s2 * u2 * r2 - c2 * a2 * r2 + c2 * n2 * l2 - e2 * u2 * l2 - s2 * n2 * d2 + e2 * a2 * d2) * _2, t6[8] = x2 * _2, t6[9] = (p2 * h2 * r2 - c2 * f2 * r2 - p2 * i2 * d2 + e2 * f2 * d2 + c2 * i2 * g2 - e2 * h2 * g2) * _2, t6[10] = (s2 * f2 * r2 - p2 * o2 * r2 + p2 * i2 * l2 - e2 * f2 * l2 - s2 * i2 * g2 + e2 * o2 * g2) * _2, t6[11] = (c2 * o2 * r2 - s2 * h2 * r2 - c2 * i2 * l2 + e2 * h2 * l2 + s2 * i2 * d2 - e2 * o2 * d2) * _2, t6[12] = b2 * _2, t6[13] = (c2 * f2 * n2 - p2 * h2 * n2 + p2 * i2 * u2 - e2 * f2 * u2 - c2 * i2 * m2 + e2 * h2 * m2) * _2, t6[14] = (p2 * o2 * n2 - s2 * f2 * n2 - p2 * i2 * a2 + e2 * f2 * a2 + s2 * i2 * m2 - e2 * o2 * m2) * _2, t6[15] = (s2 * h2 * n2 - c2 * o2 * n2 + c2 * i2 * a2 - e2 * h2 * a2 - s2 * i2 * u2 + e2 * o2 * u2) * _2, this;
  }
  scale(t6) {
    const e2 = this.elements, i2 = t6.x, n2 = t6.y, r2 = t6.z;
    return e2[0] *= i2, e2[4] *= n2, e2[8] *= r2, e2[1] *= i2, e2[5] *= n2, e2[9] *= r2, e2[2] *= i2, e2[6] *= n2, e2[10] *= r2, e2[3] *= i2, e2[7] *= n2, e2[11] *= r2, this;
  }
  getMaxScaleOnAxis() {
    const t6 = this.elements, e2 = t6[0] * t6[0] + t6[1] * t6[1] + t6[2] * t6[2], i2 = t6[4] * t6[4] + t6[5] * t6[5] + t6[6] * t6[6], n2 = t6[8] * t6[8] + t6[9] * t6[9] + t6[10] * t6[10];
    return Math.sqrt(Math.max(e2, i2, n2));
  }
  makeTranslation(t6, e2, i2) {
    return this.set(1, 0, 0, t6, 0, 1, 0, e2, 0, 0, 1, i2, 0, 0, 0, 1), this;
  }
  makeRotationX(t6) {
    const e2 = Math.cos(t6), i2 = Math.sin(t6);
    return this.set(1, 0, 0, 0, 0, e2, -i2, 0, 0, i2, e2, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(t6) {
    const e2 = Math.cos(t6), i2 = Math.sin(t6);
    return this.set(e2, 0, i2, 0, 0, 1, 0, 0, -i2, 0, e2, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(t6) {
    const e2 = Math.cos(t6), i2 = Math.sin(t6);
    return this.set(e2, -i2, 0, 0, i2, e2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(t6, e2) {
    const i2 = Math.cos(e2), n2 = Math.sin(e2), r2 = 1 - i2, s2 = t6.x, o2 = t6.y, a2 = t6.z, l2 = r2 * s2, c2 = r2 * o2;
    return this.set(l2 * s2 + i2, l2 * o2 - n2 * a2, l2 * a2 + n2 * o2, 0, l2 * o2 + n2 * a2, c2 * o2 + i2, c2 * a2 - n2 * s2, 0, l2 * a2 - n2 * o2, c2 * a2 + n2 * s2, r2 * a2 * a2 + i2, 0, 0, 0, 0, 1), this;
  }
  makeScale(t6, e2, i2) {
    return this.set(t6, 0, 0, 0, 0, e2, 0, 0, 0, 0, i2, 0, 0, 0, 0, 1), this;
  }
  makeShear(t6, e2, i2, n2, r2, s2) {
    return this.set(1, i2, r2, 0, t6, 1, s2, 0, e2, n2, 1, 0, 0, 0, 0, 1), this;
  }
  compose(t6, e2, i2) {
    const n2 = this.elements, r2 = e2._x, s2 = e2._y, o2 = e2._z, a2 = e2._w, l2 = r2 + r2, c2 = s2 + s2, h2 = o2 + o2, u2 = r2 * l2, d2 = r2 * c2, p2 = r2 * h2, f2 = s2 * c2, m2 = s2 * h2, g2 = o2 * h2, v2 = a2 * l2, y2 = a2 * c2, x2 = a2 * h2, b2 = i2.x, w2 = i2.y, _2 = i2.z;
    return n2[0] = (1 - (f2 + g2)) * b2, n2[1] = (d2 + x2) * b2, n2[2] = (p2 - y2) * b2, n2[3] = 0, n2[4] = (d2 - x2) * w2, n2[5] = (1 - (u2 + g2)) * w2, n2[6] = (m2 + v2) * w2, n2[7] = 0, n2[8] = (p2 + y2) * _2, n2[9] = (m2 - v2) * _2, n2[10] = (1 - (u2 + f2)) * _2, n2[11] = 0, n2[12] = t6.x, n2[13] = t6.y, n2[14] = t6.z, n2[15] = 1, this;
  }
  decompose(t6, e2, i2) {
    const n2 = this.elements;
    let r2 = Wa.set(n2[0], n2[1], n2[2]).length();
    const s2 = Wa.set(n2[4], n2[5], n2[6]).length(), o2 = Wa.set(n2[8], n2[9], n2[10]).length();
    this.determinant() < 0 && (r2 = -r2), t6.x = n2[12], t6.y = n2[13], t6.z = n2[14], qa.copy(this);
    const a2 = 1 / r2, l2 = 1 / s2, c2 = 1 / o2;
    return qa.elements[0] *= a2, qa.elements[1] *= a2, qa.elements[2] *= a2, qa.elements[4] *= l2, qa.elements[5] *= l2, qa.elements[6] *= l2, qa.elements[8] *= c2, qa.elements[9] *= c2, qa.elements[10] *= c2, e2.setFromRotationMatrix(qa), i2.x = r2, i2.y = s2, i2.z = o2, this;
  }
  makePerspective(t6, e2, i2, n2, r2, s2) {
    const o2 = this.elements, a2 = 2 * r2 / (e2 - t6), l2 = 2 * r2 / (i2 - n2), c2 = (e2 + t6) / (e2 - t6), h2 = (i2 + n2) / (i2 - n2), u2 = -(s2 + r2) / (s2 - r2), d2 = -2 * s2 * r2 / (s2 - r2);
    return o2[0] = a2, o2[4] = 0, o2[8] = c2, o2[12] = 0, o2[1] = 0, o2[5] = l2, o2[9] = h2, o2[13] = 0, o2[2] = 0, o2[6] = 0, o2[10] = u2, o2[14] = d2, o2[3] = 0, o2[7] = 0, o2[11] = -1, o2[15] = 0, this;
  }
  makeOrthographic(t6, e2, i2, n2, r2, s2) {
    const o2 = this.elements, a2 = 1 / (e2 - t6), l2 = 1 / (i2 - n2), c2 = 1 / (s2 - r2), h2 = (e2 + t6) * a2, u2 = (i2 + n2) * l2, d2 = (s2 + r2) * c2;
    return o2[0] = 2 * a2, o2[4] = 0, o2[8] = 0, o2[12] = -h2, o2[1] = 0, o2[5] = 2 * l2, o2[9] = 0, o2[13] = -u2, o2[2] = 0, o2[6] = 0, o2[10] = -2 * c2, o2[14] = -d2, o2[3] = 0, o2[7] = 0, o2[11] = 0, o2[15] = 1, this;
  }
  equals(t6) {
    const e2 = this.elements, i2 = t6.elements;
    for (let t7 = 0; t7 < 16; t7++) if (e2[t7] !== i2[t7]) return false;
    return true;
  }
  fromArray(t6, e2 = 0) {
    for (let i2 = 0; i2 < 16; i2++) this.elements[i2] = t6[i2 + e2];
    return this;
  }
  toArray(t6 = [], e2 = 0) {
    const i2 = this.elements;
    return t6[e2] = i2[0], t6[e2 + 1] = i2[1], t6[e2 + 2] = i2[2], t6[e2 + 3] = i2[3], t6[e2 + 4] = i2[4], t6[e2 + 5] = i2[5], t6[e2 + 6] = i2[6], t6[e2 + 7] = i2[7], t6[e2 + 8] = i2[8], t6[e2 + 9] = i2[9], t6[e2 + 10] = i2[10], t6[e2 + 11] = i2[11], t6[e2 + 12] = i2[12], t6[e2 + 13] = i2[13], t6[e2 + 14] = i2[14], t6[e2 + 15] = i2[15], t6;
  }
};
var Wa = new pa();
var qa = new Ga();
var Xa = new pa(0, 0, 0);
var Ya = new pa(1, 1, 1);
var Za = new pa();
var Ja = new pa();
var Ka = new pa();
var $a = new Ga();
var Qa = new da();
var tl = class _tl {
  constructor(t6 = 0, e2 = 0, i2 = 0, n2 = _tl.DefaultOrder) {
    this.isEuler = true, this._x = t6, this._y = e2, this._z = i2, this._order = n2;
  }
  get x() {
    return this._x;
  }
  set x(t6) {
    this._x = t6, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t6) {
    this._y = t6, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t6) {
    this._z = t6, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(t6) {
    this._order = t6, this._onChangeCallback();
  }
  set(t6, e2, i2, n2 = this._order) {
    return this._x = t6, this._y = e2, this._z = i2, this._order = n2, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(t6) {
    return this._x = t6._x, this._y = t6._y, this._z = t6._z, this._order = t6._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(t6, e2 = this._order, i2 = true) {
    const n2 = t6.elements, r2 = n2[0], s2 = n2[4], o2 = n2[8], a2 = n2[1], l2 = n2[5], c2 = n2[9], h2 = n2[2], u2 = n2[6], d2 = n2[10];
    switch (e2) {
      case "XYZ":
        this._y = Math.asin(Ro(o2, -1, 1)), Math.abs(o2) < 0.9999999 ? (this._x = Math.atan2(-c2, d2), this._z = Math.atan2(-s2, r2)) : (this._x = Math.atan2(u2, l2), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-Ro(c2, -1, 1)), Math.abs(c2) < 0.9999999 ? (this._y = Math.atan2(o2, d2), this._z = Math.atan2(a2, l2)) : (this._y = Math.atan2(-h2, r2), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(Ro(u2, -1, 1)), Math.abs(u2) < 0.9999999 ? (this._y = Math.atan2(-h2, d2), this._z = Math.atan2(-s2, l2)) : (this._y = 0, this._z = Math.atan2(a2, r2));
        break;
      case "ZYX":
        this._y = Math.asin(-Ro(h2, -1, 1)), Math.abs(h2) < 0.9999999 ? (this._x = Math.atan2(u2, d2), this._z = Math.atan2(a2, r2)) : (this._x = 0, this._z = Math.atan2(-s2, l2));
        break;
      case "YZX":
        this._z = Math.asin(Ro(a2, -1, 1)), Math.abs(a2) < 0.9999999 ? (this._x = Math.atan2(-c2, l2), this._y = Math.atan2(-h2, r2)) : (this._x = 0, this._y = Math.atan2(o2, d2));
        break;
      case "XZY":
        this._z = Math.asin(-Ro(s2, -1, 1)), Math.abs(s2) < 0.9999999 ? (this._x = Math.atan2(u2, l2), this._y = Math.atan2(o2, r2)) : (this._x = Math.atan2(-c2, d2), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e2);
    }
    return this._order = e2, true === i2 && this._onChangeCallback(), this;
  }
  setFromQuaternion(t6, e2, i2) {
    return $a.makeRotationFromQuaternion(t6), this.setFromRotationMatrix($a, e2, i2);
  }
  setFromVector3(t6, e2 = this._order) {
    return this.set(t6.x, t6.y, t6.z, e2);
  }
  reorder(t6) {
    return Qa.setFromEuler(this), this.setFromQuaternion(Qa, t6);
  }
  equals(t6) {
    return t6._x === this._x && t6._y === this._y && t6._z === this._z && t6._order === this._order;
  }
  fromArray(t6) {
    return this._x = t6[0], this._y = t6[1], this._z = t6[2], void 0 !== t6[3] && (this._order = t6[3]), this._onChangeCallback(), this;
  }
  toArray(t6 = [], e2 = 0) {
    return t6[e2] = this._x, t6[e2 + 1] = this._y, t6[e2 + 2] = this._z, t6[e2 + 3] = this._order, t6;
  }
  _onChange(t6) {
    return this._onChangeCallback = t6, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
  toVector3() {
    console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead");
  }
};
tl.DefaultOrder = "XYZ", tl.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
var el = class {
  constructor() {
    this.mask = 1;
  }
  set(t6) {
    this.mask = 1 << t6 >>> 0;
  }
  enable(t6) {
    this.mask |= 1 << t6;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(t6) {
    this.mask ^= 1 << t6;
  }
  disable(t6) {
    this.mask &= ~(1 << t6);
  }
  disableAll() {
    this.mask = 0;
  }
  test(t6) {
    return !!(this.mask & t6.mask);
  }
  isEnabled(t6) {
    return !!(this.mask & 1 << t6);
  }
};
var il = 0;
var nl = new pa();
var rl = new da();
var sl = new Ga();
var ol = new pa();
var al = new pa();
var ll = new pa();
var cl = new da();
var hl = new pa(1, 0, 0);
var ul = new pa(0, 1, 0);
var dl = new pa(0, 0, 1);
var pl = { type: "added" };
var fl = { type: "removed" };
var ml = class _ml extends So {
  constructor() {
    super(), this.isObject3D = true, Object.defineProperty(this, "id", { value: il++ }), this.uuid = Co(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = _ml.DefaultUp.clone();
    const t6 = new pa(), e2 = new tl(), i2 = new da(), n2 = new pa(1, 1, 1);
    e2._onChange((function() {
      i2.setFromEuler(e2, false);
    })), i2._onChange((function() {
      e2.setFromQuaternion(i2, void 0, false);
    })), Object.defineProperties(this, { position: { configurable: true, enumerable: true, value: t6 }, rotation: { configurable: true, enumerable: true, value: e2 }, quaternion: { configurable: true, enumerable: true, value: i2 }, scale: { configurable: true, enumerable: true, value: n2 }, modelViewMatrix: { value: new Ga() }, normalMatrix: { value: new No() } }), this.matrix = new Ga(), this.matrixWorld = new Ga(), this.matrixAutoUpdate = _ml.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = false, this.layers = new el(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(t6) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t6), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(t6) {
    return this.quaternion.premultiply(t6), this;
  }
  setRotationFromAxisAngle(t6, e2) {
    this.quaternion.setFromAxisAngle(t6, e2);
  }
  setRotationFromEuler(t6) {
    this.quaternion.setFromEuler(t6, true);
  }
  setRotationFromMatrix(t6) {
    this.quaternion.setFromRotationMatrix(t6);
  }
  setRotationFromQuaternion(t6) {
    this.quaternion.copy(t6);
  }
  rotateOnAxis(t6, e2) {
    return rl.setFromAxisAngle(t6, e2), this.quaternion.multiply(rl), this;
  }
  rotateOnWorldAxis(t6, e2) {
    return rl.setFromAxisAngle(t6, e2), this.quaternion.premultiply(rl), this;
  }
  rotateX(t6) {
    return this.rotateOnAxis(hl, t6);
  }
  rotateY(t6) {
    return this.rotateOnAxis(ul, t6);
  }
  rotateZ(t6) {
    return this.rotateOnAxis(dl, t6);
  }
  translateOnAxis(t6, e2) {
    return nl.copy(t6).applyQuaternion(this.quaternion), this.position.add(nl.multiplyScalar(e2)), this;
  }
  translateX(t6) {
    return this.translateOnAxis(hl, t6);
  }
  translateY(t6) {
    return this.translateOnAxis(ul, t6);
  }
  translateZ(t6) {
    return this.translateOnAxis(dl, t6);
  }
  localToWorld(t6) {
    return t6.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(t6) {
    return t6.applyMatrix4(sl.copy(this.matrixWorld).invert());
  }
  lookAt(t6, e2, i2) {
    t6.isVector3 ? ol.copy(t6) : ol.set(t6, e2, i2);
    const n2 = this.parent;
    this.updateWorldMatrix(true, false), al.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? sl.lookAt(al, ol, this.up) : sl.lookAt(ol, al, this.up), this.quaternion.setFromRotationMatrix(sl), n2 && (sl.extractRotation(n2.matrixWorld), rl.setFromRotationMatrix(sl), this.quaternion.premultiply(rl.invert()));
  }
  add(t6) {
    if (arguments.length > 1) {
      for (let t7 = 0; t7 < arguments.length; t7++) this.add(arguments[t7]);
      return this;
    }
    return t6 === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t6), this) : (t6 && t6.isObject3D ? (null !== t6.parent && t6.parent.remove(t6), t6.parent = this, this.children.push(t6), t6.dispatchEvent(pl)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t6), this);
  }
  remove(t6) {
    if (arguments.length > 1) {
      for (let t7 = 0; t7 < arguments.length; t7++) this.remove(arguments[t7]);
      return this;
    }
    const e2 = this.children.indexOf(t6);
    return -1 !== e2 && (t6.parent = null, this.children.splice(e2, 1), t6.dispatchEvent(fl)), this;
  }
  removeFromParent() {
    const t6 = this.parent;
    return null !== t6 && t6.remove(this), this;
  }
  clear() {
    for (let t6 = 0; t6 < this.children.length; t6++) {
      const e2 = this.children[t6];
      e2.parent = null, e2.dispatchEvent(fl);
    }
    return this.children.length = 0, this;
  }
  attach(t6) {
    return this.updateWorldMatrix(true, false), sl.copy(this.matrixWorld).invert(), null !== t6.parent && (t6.parent.updateWorldMatrix(true, false), sl.multiply(t6.parent.matrixWorld)), t6.applyMatrix4(sl), this.add(t6), t6.updateWorldMatrix(false, true), this;
  }
  getObjectById(t6) {
    return this.getObjectByProperty("id", t6);
  }
  getObjectByName(t6) {
    return this.getObjectByProperty("name", t6);
  }
  getObjectByProperty(t6, e2) {
    if (this[t6] === e2) return this;
    for (let i2 = 0, n2 = this.children.length; i2 < n2; i2++) {
      const n3 = this.children[i2].getObjectByProperty(t6, e2);
      if (void 0 !== n3) return n3;
    }
  }
  getWorldPosition(t6) {
    return this.updateWorldMatrix(true, false), t6.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(t6) {
    return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(al, t6, ll), t6;
  }
  getWorldScale(t6) {
    return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(al, cl, t6), t6;
  }
  getWorldDirection(t6) {
    this.updateWorldMatrix(true, false);
    const e2 = this.matrixWorld.elements;
    return t6.set(e2[8], e2[9], e2[10]).normalize();
  }
  raycast() {
  }
  traverse(t6) {
    t6(this);
    const e2 = this.children;
    for (let i2 = 0, n2 = e2.length; i2 < n2; i2++) e2[i2].traverse(t6);
  }
  traverseVisible(t6) {
    if (false === this.visible) return;
    t6(this);
    const e2 = this.children;
    for (let i2 = 0, n2 = e2.length; i2 < n2; i2++) e2[i2].traverseVisible(t6);
  }
  traverseAncestors(t6) {
    const e2 = this.parent;
    null !== e2 && (t6(e2), e2.traverseAncestors(t6));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
  }
  updateMatrixWorld(t6) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t6) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = false, t6 = true);
    const e2 = this.children;
    for (let i2 = 0, n2 = e2.length; i2 < n2; i2++) e2[i2].updateMatrixWorld(t6);
  }
  updateWorldMatrix(t6, e2) {
    const i2 = this.parent;
    if (true === t6 && null !== i2 && i2.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), true === e2) {
      const t7 = this.children;
      for (let e3 = 0, i3 = t7.length; e3 < i3; e3++) t7[e3].updateWorldMatrix(false, true);
    }
  }
  toJSON(t6) {
    const e2 = void 0 === t6 || "string" == typeof t6, i2 = {};
    e2 && (t6 = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, i2.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" });
    const n2 = {};
    function r2(e3, i3) {
      return void 0 === e3[i3.uuid] && (e3[i3.uuid] = i3.toJSON(t6)), i3.uuid;
    }
    if (n2.uuid = this.uuid, n2.type = this.type, "" !== this.name && (n2.name = this.name), true === this.castShadow && (n2.castShadow = true), true === this.receiveShadow && (n2.receiveShadow = true), false === this.visible && (n2.visible = false), false === this.frustumCulled && (n2.frustumCulled = false), 0 !== this.renderOrder && (n2.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (n2.userData = this.userData), n2.layers = this.layers.mask, n2.matrix = this.matrix.toArray(), false === this.matrixAutoUpdate && (n2.matrixAutoUpdate = false), this.isInstancedMesh && (n2.type = "InstancedMesh", n2.count = this.count, n2.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (n2.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? n2.background = this.background.toJSON() : this.background.isTexture && (n2.background = this.background.toJSON(t6).uuid)), this.environment && this.environment.isTexture && true !== this.environment.isRenderTargetTexture && (n2.environment = this.environment.toJSON(t6).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      n2.geometry = r2(t6.geometries, this.geometry);
      const e3 = this.geometry.parameters;
      if (void 0 !== e3 && void 0 !== e3.shapes) {
        const i3 = e3.shapes;
        if (Array.isArray(i3)) for (let e4 = 0, n3 = i3.length; e4 < n3; e4++) {
          const n4 = i3[e4];
          r2(t6.shapes, n4);
        }
        else r2(t6.shapes, i3);
      }
    }
    if (this.isSkinnedMesh && (n2.bindMode = this.bindMode, n2.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r2(t6.skeletons, this.skeleton), n2.skeleton = this.skeleton.uuid)), void 0 !== this.material) if (Array.isArray(this.material)) {
      const e3 = [];
      for (let i3 = 0, n3 = this.material.length; i3 < n3; i3++) e3.push(r2(t6.materials, this.material[i3]));
      n2.material = e3;
    } else n2.material = r2(t6.materials, this.material);
    if (this.children.length > 0) {
      n2.children = [];
      for (let e3 = 0; e3 < this.children.length; e3++) n2.children.push(this.children[e3].toJSON(t6).object);
    }
    if (this.animations.length > 0) {
      n2.animations = [];
      for (let e3 = 0; e3 < this.animations.length; e3++) {
        const i3 = this.animations[e3];
        n2.animations.push(r2(t6.animations, i3));
      }
    }
    if (e2) {
      const e3 = s2(t6.geometries), n3 = s2(t6.materials), r3 = s2(t6.textures), o2 = s2(t6.images), a2 = s2(t6.shapes), l2 = s2(t6.skeletons), c2 = s2(t6.animations), h2 = s2(t6.nodes);
      e3.length > 0 && (i2.geometries = e3), n3.length > 0 && (i2.materials = n3), r3.length > 0 && (i2.textures = r3), o2.length > 0 && (i2.images = o2), a2.length > 0 && (i2.shapes = a2), l2.length > 0 && (i2.skeletons = l2), c2.length > 0 && (i2.animations = c2), h2.length > 0 && (i2.nodes = h2);
    }
    return i2.object = n2, i2;
    function s2(t7) {
      const e3 = [];
      for (const i3 in t7) {
        const n3 = t7[i3];
        delete n3.metadata, e3.push(n3);
      }
      return e3;
    }
  }
  clone(t6) {
    return new this.constructor().copy(this, t6);
  }
  copy(t6, e2 = true) {
    if (this.name = t6.name, this.up.copy(t6.up), this.position.copy(t6.position), this.rotation.order = t6.rotation.order, this.quaternion.copy(t6.quaternion), this.scale.copy(t6.scale), this.matrix.copy(t6.matrix), this.matrixWorld.copy(t6.matrixWorld), this.matrixAutoUpdate = t6.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t6.matrixWorldNeedsUpdate, this.layers.mask = t6.layers.mask, this.visible = t6.visible, this.castShadow = t6.castShadow, this.receiveShadow = t6.receiveShadow, this.frustumCulled = t6.frustumCulled, this.renderOrder = t6.renderOrder, this.userData = JSON.parse(JSON.stringify(t6.userData)), true === e2) for (let e3 = 0; e3 < t6.children.length; e3++) {
      const i2 = t6.children[e3];
      this.add(i2.clone());
    }
    return this;
  }
};
ml.DefaultUp = new pa(0, 1, 0), ml.DefaultMatrixAutoUpdate = true;
var gl = new pa();
var vl = new pa();
var yl = new pa();
var xl = new pa();
var bl = new pa();
var wl = new pa();
var _l = new pa();
var Sl = new pa();
var Ml = new pa();
var Tl = new pa();
var El = class _El {
  constructor(t6 = new pa(), e2 = new pa(), i2 = new pa()) {
    this.a = t6, this.b = e2, this.c = i2;
  }
  static getNormal(t6, e2, i2, n2) {
    n2.subVectors(i2, e2), gl.subVectors(t6, e2), n2.cross(gl);
    const r2 = n2.lengthSq();
    return r2 > 0 ? n2.multiplyScalar(1 / Math.sqrt(r2)) : n2.set(0, 0, 0);
  }
  static getBarycoord(t6, e2, i2, n2, r2) {
    gl.subVectors(n2, e2), vl.subVectors(i2, e2), yl.subVectors(t6, e2);
    const s2 = gl.dot(gl), o2 = gl.dot(vl), a2 = gl.dot(yl), l2 = vl.dot(vl), c2 = vl.dot(yl), h2 = s2 * l2 - o2 * o2;
    if (0 === h2) return r2.set(-2, -1, -1);
    const u2 = 1 / h2, d2 = (l2 * a2 - o2 * c2) * u2, p2 = (s2 * c2 - o2 * a2) * u2;
    return r2.set(1 - d2 - p2, p2, d2);
  }
  static containsPoint(t6, e2, i2, n2) {
    return this.getBarycoord(t6, e2, i2, n2, xl), xl.x >= 0 && xl.y >= 0 && xl.x + xl.y <= 1;
  }
  static getUV(t6, e2, i2, n2, r2, s2, o2, a2) {
    return this.getBarycoord(t6, e2, i2, n2, xl), a2.set(0, 0), a2.addScaledVector(r2, xl.x), a2.addScaledVector(s2, xl.y), a2.addScaledVector(o2, xl.z), a2;
  }
  static isFrontFacing(t6, e2, i2, n2) {
    return gl.subVectors(i2, e2), vl.subVectors(t6, e2), gl.cross(vl).dot(n2) < 0;
  }
  set(t6, e2, i2) {
    return this.a.copy(t6), this.b.copy(e2), this.c.copy(i2), this;
  }
  setFromPointsAndIndices(t6, e2, i2, n2) {
    return this.a.copy(t6[e2]), this.b.copy(t6[i2]), this.c.copy(t6[n2]), this;
  }
  setFromAttributeAndIndices(t6, e2, i2, n2) {
    return this.a.fromBufferAttribute(t6, e2), this.b.fromBufferAttribute(t6, i2), this.c.fromBufferAttribute(t6, n2), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t6) {
    return this.a.copy(t6.a), this.b.copy(t6.b), this.c.copy(t6.c), this;
  }
  getArea() {
    return gl.subVectors(this.c, this.b), vl.subVectors(this.a, this.b), 0.5 * gl.cross(vl).length();
  }
  getMidpoint(t6) {
    return t6.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(t6) {
    return _El.getNormal(this.a, this.b, this.c, t6);
  }
  getPlane(t6) {
    return t6.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(t6, e2) {
    return _El.getBarycoord(t6, this.a, this.b, this.c, e2);
  }
  getUV(t6, e2, i2, n2, r2) {
    return _El.getUV(t6, this.a, this.b, this.c, e2, i2, n2, r2);
  }
  containsPoint(t6) {
    return _El.containsPoint(t6, this.a, this.b, this.c);
  }
  isFrontFacing(t6) {
    return _El.isFrontFacing(this.a, this.b, this.c, t6);
  }
  intersectsBox(t6) {
    return t6.intersectsTriangle(this);
  }
  closestPointToPoint(t6, e2) {
    const i2 = this.a, n2 = this.b, r2 = this.c;
    let s2, o2;
    bl.subVectors(n2, i2), wl.subVectors(r2, i2), Sl.subVectors(t6, i2);
    const a2 = bl.dot(Sl), l2 = wl.dot(Sl);
    if (a2 <= 0 && l2 <= 0) return e2.copy(i2);
    Ml.subVectors(t6, n2);
    const c2 = bl.dot(Ml), h2 = wl.dot(Ml);
    if (c2 >= 0 && h2 <= c2) return e2.copy(n2);
    const u2 = a2 * h2 - c2 * l2;
    if (u2 <= 0 && a2 >= 0 && c2 <= 0) return s2 = a2 / (a2 - c2), e2.copy(i2).addScaledVector(bl, s2);
    Tl.subVectors(t6, r2);
    const d2 = bl.dot(Tl), p2 = wl.dot(Tl);
    if (p2 >= 0 && d2 <= p2) return e2.copy(r2);
    const f2 = d2 * l2 - a2 * p2;
    if (f2 <= 0 && l2 >= 0 && p2 <= 0) return o2 = l2 / (l2 - p2), e2.copy(i2).addScaledVector(wl, o2);
    const m2 = c2 * p2 - d2 * h2;
    if (m2 <= 0 && h2 - c2 >= 0 && d2 - p2 >= 0) return _l.subVectors(r2, n2), o2 = (h2 - c2) / (h2 - c2 + (d2 - p2)), e2.copy(n2).addScaledVector(_l, o2);
    const g2 = 1 / (m2 + f2 + u2);
    return s2 = f2 * g2, o2 = u2 * g2, e2.copy(i2).addScaledVector(bl, s2).addScaledVector(wl, o2);
  }
  equals(t6) {
    return t6.a.equals(this.a) && t6.b.equals(this.b) && t6.c.equals(this.c);
  }
};
var Al = 0;
var Cl = class extends So {
  constructor() {
    super(), this.isMaterial = true, Object.defineProperty(this, "id", { value: Al++ }), this.uuid = Co(), this.name = "", this.type = "Material", this.blending = En, this.side = bn, this.vertexColors = false, this.opacity = 1, this.transparent = false, this.blendSrc = Un, this.blendDst = Hn, this.blendEquation = Ln, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = Jn, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = co, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Ys, this.stencilZFail = Ys, this.stencilZPass = Ys, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(t6) {
    this._alphaTest > 0 != t6 > 0 && this.version++, this._alphaTest = t6;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(t6) {
    if (void 0 !== t6) for (const e2 in t6) {
      const i2 = t6[e2];
      if (void 0 === i2) {
        console.warn("THREE.Material: '" + e2 + "' parameter is undefined.");
        continue;
      }
      if ("shading" === e2) {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = i2 === Sn;
        continue;
      }
      const n2 = this[e2];
      void 0 !== n2 ? n2 && n2.isColor ? n2.set(i2) : n2 && n2.isVector3 && i2 && i2.isVector3 ? n2.copy(i2) : this[e2] = i2 : console.warn("THREE." + this.type + ": '" + e2 + "' is not a property of this material.");
    }
  }
  toJSON(t6) {
    const e2 = void 0 === t6 || "string" == typeof t6;
    e2 && (t6 = { textures: {}, images: {} });
    const i2 = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } };
    function n2(t7) {
      const e3 = [];
      for (const i3 in t7) {
        const n3 = t7[i3];
        delete n3.metadata, e3.push(n3);
      }
      return e3;
    }
    if (i2.uuid = this.uuid, i2.type = this.type, "" !== this.name && (i2.name = this.name), this.color && this.color.isColor && (i2.color = this.color.getHex()), void 0 !== this.roughness && (i2.roughness = this.roughness), void 0 !== this.metalness && (i2.metalness = this.metalness), void 0 !== this.sheen && (i2.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i2.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (i2.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i2.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (i2.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i2.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (i2.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i2.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (i2.shininess = this.shininess), void 0 !== this.clearcoat && (i2.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (i2.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i2.clearcoatMap = this.clearcoatMap.toJSON(t6).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i2.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t6).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i2.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t6).uuid, i2.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.iridescence && (i2.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (i2.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (i2.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i2.iridescenceMap = this.iridescenceMap.toJSON(t6).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i2.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t6).uuid), this.map && this.map.isTexture && (i2.map = this.map.toJSON(t6).uuid), this.matcap && this.matcap.isTexture && (i2.matcap = this.matcap.toJSON(t6).uuid), this.alphaMap && this.alphaMap.isTexture && (i2.alphaMap = this.alphaMap.toJSON(t6).uuid), this.lightMap && this.lightMap.isTexture && (i2.lightMap = this.lightMap.toJSON(t6).uuid, i2.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i2.aoMap = this.aoMap.toJSON(t6).uuid, i2.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i2.bumpMap = this.bumpMap.toJSON(t6).uuid, i2.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i2.normalMap = this.normalMap.toJSON(t6).uuid, i2.normalMapType = this.normalMapType, i2.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i2.displacementMap = this.displacementMap.toJSON(t6).uuid, i2.displacementScale = this.displacementScale, i2.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i2.roughnessMap = this.roughnessMap.toJSON(t6).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i2.metalnessMap = this.metalnessMap.toJSON(t6).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i2.emissiveMap = this.emissiveMap.toJSON(t6).uuid), this.specularMap && this.specularMap.isTexture && (i2.specularMap = this.specularMap.toJSON(t6).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i2.specularIntensityMap = this.specularIntensityMap.toJSON(t6).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i2.specularColorMap = this.specularColorMap.toJSON(t6).uuid), this.envMap && this.envMap.isTexture && (i2.envMap = this.envMap.toJSON(t6).uuid, void 0 !== this.combine && (i2.combine = this.combine)), void 0 !== this.envMapIntensity && (i2.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (i2.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (i2.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i2.gradientMap = this.gradientMap.toJSON(t6).uuid), void 0 !== this.transmission && (i2.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i2.transmissionMap = this.transmissionMap.toJSON(t6).uuid), void 0 !== this.thickness && (i2.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i2.thicknessMap = this.thicknessMap.toJSON(t6).uuid), void 0 !== this.attenuationDistance && (i2.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (i2.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (i2.size = this.size), null !== this.shadowSide && (i2.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (i2.sizeAttenuation = this.sizeAttenuation), this.blending !== En && (i2.blending = this.blending), this.side !== bn && (i2.side = this.side), this.vertexColors && (i2.vertexColors = true), this.opacity < 1 && (i2.opacity = this.opacity), true === this.transparent && (i2.transparent = this.transparent), i2.depthFunc = this.depthFunc, i2.depthTest = this.depthTest, i2.depthWrite = this.depthWrite, i2.colorWrite = this.colorWrite, i2.stencilWrite = this.stencilWrite, i2.stencilWriteMask = this.stencilWriteMask, i2.stencilFunc = this.stencilFunc, i2.stencilRef = this.stencilRef, i2.stencilFuncMask = this.stencilFuncMask, i2.stencilFail = this.stencilFail, i2.stencilZFail = this.stencilZFail, i2.stencilZPass = this.stencilZPass, void 0 !== this.rotation && 0 !== this.rotation && (i2.rotation = this.rotation), true === this.polygonOffset && (i2.polygonOffset = true), 0 !== this.polygonOffsetFactor && (i2.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (i2.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (i2.linewidth = this.linewidth), void 0 !== this.dashSize && (i2.dashSize = this.dashSize), void 0 !== this.gapSize && (i2.gapSize = this.gapSize), void 0 !== this.scale && (i2.scale = this.scale), true === this.dithering && (i2.dithering = true), this.alphaTest > 0 && (i2.alphaTest = this.alphaTest), true === this.alphaToCoverage && (i2.alphaToCoverage = this.alphaToCoverage), true === this.premultipliedAlpha && (i2.premultipliedAlpha = this.premultipliedAlpha), true === this.wireframe && (i2.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i2.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i2.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i2.wireframeLinejoin = this.wireframeLinejoin), true === this.flatShading && (i2.flatShading = this.flatShading), false === this.visible && (i2.visible = false), false === this.toneMapped && (i2.toneMapped = false), false === this.fog && (i2.fog = false), "{}" !== JSON.stringify(this.userData) && (i2.userData = this.userData), e2) {
      const e3 = n2(t6.textures), r2 = n2(t6.images);
      e3.length > 0 && (i2.textures = e3), r2.length > 0 && (i2.images = r2);
    }
    return i2;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t6) {
    this.name = t6.name, this.blending = t6.blending, this.side = t6.side, this.vertexColors = t6.vertexColors, this.opacity = t6.opacity, this.transparent = t6.transparent, this.blendSrc = t6.blendSrc, this.blendDst = t6.blendDst, this.blendEquation = t6.blendEquation, this.blendSrcAlpha = t6.blendSrcAlpha, this.blendDstAlpha = t6.blendDstAlpha, this.blendEquationAlpha = t6.blendEquationAlpha, this.depthFunc = t6.depthFunc, this.depthTest = t6.depthTest, this.depthWrite = t6.depthWrite, this.stencilWriteMask = t6.stencilWriteMask, this.stencilFunc = t6.stencilFunc, this.stencilRef = t6.stencilRef, this.stencilFuncMask = t6.stencilFuncMask, this.stencilFail = t6.stencilFail, this.stencilZFail = t6.stencilZFail, this.stencilZPass = t6.stencilZPass, this.stencilWrite = t6.stencilWrite;
    const e2 = t6.clippingPlanes;
    let i2 = null;
    if (null !== e2) {
      const t7 = e2.length;
      i2 = new Array(t7);
      for (let n2 = 0; n2 !== t7; ++n2) i2[n2] = e2[n2].clone();
    }
    return this.clippingPlanes = i2, this.clipIntersection = t6.clipIntersection, this.clipShadows = t6.clipShadows, this.shadowSide = t6.shadowSide, this.colorWrite = t6.colorWrite, this.precision = t6.precision, this.polygonOffset = t6.polygonOffset, this.polygonOffsetFactor = t6.polygonOffsetFactor, this.polygonOffsetUnits = t6.polygonOffsetUnits, this.dithering = t6.dithering, this.alphaTest = t6.alphaTest, this.alphaToCoverage = t6.alphaToCoverage, this.premultipliedAlpha = t6.premultipliedAlpha, this.visible = t6.visible, this.toneMapped = t6.toneMapped, this.userData = JSON.parse(JSON.stringify(t6.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(t6) {
    true === t6 && this.version++;
  }
};
var Rl = class extends Cl {
  constructor(t6) {
    super(), this.isMeshBasicMaterial = true, this.type = "MeshBasicMaterial", this.color = new $o(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = er, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(t6);
  }
  copy(t6) {
    return super.copy(t6), this.color.copy(t6.color), this.map = t6.map, this.lightMap = t6.lightMap, this.lightMapIntensity = t6.lightMapIntensity, this.aoMap = t6.aoMap, this.aoMapIntensity = t6.aoMapIntensity, this.specularMap = t6.specularMap, this.alphaMap = t6.alphaMap, this.envMap = t6.envMap, this.combine = t6.combine, this.reflectivity = t6.reflectivity, this.refractionRatio = t6.refractionRatio, this.wireframe = t6.wireframe, this.wireframeLinewidth = t6.wireframeLinewidth, this.wireframeLinecap = t6.wireframeLinecap, this.wireframeLinejoin = t6.wireframeLinejoin, this.fog = t6.fog, this;
  }
};
var Pl = new pa();
var Ll = new Fo();
var Il = class {
  constructor(t6, e2, i2) {
    if (Array.isArray(t6)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = true, this.name = "", this.array = t6, this.itemSize = e2, this.count = void 0 !== t6 ? t6.length / e2 : 0, this.normalized = true === i2, this.usage = ho, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(t6) {
    true === t6 && this.version++;
  }
  setUsage(t6) {
    return this.usage = t6, this;
  }
  copy(t6) {
    return this.name = t6.name, this.array = new t6.array.constructor(t6.array), this.itemSize = t6.itemSize, this.count = t6.count, this.normalized = t6.normalized, this.usage = t6.usage, this;
  }
  copyAt(t6, e2, i2) {
    t6 *= this.itemSize, i2 *= e2.itemSize;
    for (let n2 = 0, r2 = this.itemSize; n2 < r2; n2++) this.array[t6 + n2] = e2.array[i2 + n2];
    return this;
  }
  copyArray(t6) {
    return this.array.set(t6), this;
  }
  copyColorsArray(t6) {
    const e2 = this.array;
    let i2 = 0;
    for (let n2 = 0, r2 = t6.length; n2 < r2; n2++) {
      let r3 = t6[n2];
      void 0 === r3 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n2), r3 = new $o()), e2[i2++] = r3.r, e2[i2++] = r3.g, e2[i2++] = r3.b;
    }
    return this;
  }
  copyVector2sArray(t6) {
    const e2 = this.array;
    let i2 = 0;
    for (let n2 = 0, r2 = t6.length; n2 < r2; n2++) {
      let r3 = t6[n2];
      void 0 === r3 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n2), r3 = new Fo()), e2[i2++] = r3.x, e2[i2++] = r3.y;
    }
    return this;
  }
  copyVector3sArray(t6) {
    const e2 = this.array;
    let i2 = 0;
    for (let n2 = 0, r2 = t6.length; n2 < r2; n2++) {
      let r3 = t6[n2];
      void 0 === r3 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n2), r3 = new pa()), e2[i2++] = r3.x, e2[i2++] = r3.y, e2[i2++] = r3.z;
    }
    return this;
  }
  copyVector4sArray(t6) {
    const e2 = this.array;
    let i2 = 0;
    for (let n2 = 0, r2 = t6.length; n2 < r2; n2++) {
      let r3 = t6[n2];
      void 0 === r3 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n2), r3 = new sa()), e2[i2++] = r3.x, e2[i2++] = r3.y, e2[i2++] = r3.z, e2[i2++] = r3.w;
    }
    return this;
  }
  applyMatrix3(t6) {
    if (2 === this.itemSize) for (let e2 = 0, i2 = this.count; e2 < i2; e2++) Ll.fromBufferAttribute(this, e2), Ll.applyMatrix3(t6), this.setXY(e2, Ll.x, Ll.y);
    else if (3 === this.itemSize) for (let e2 = 0, i2 = this.count; e2 < i2; e2++) Pl.fromBufferAttribute(this, e2), Pl.applyMatrix3(t6), this.setXYZ(e2, Pl.x, Pl.y, Pl.z);
    return this;
  }
  applyMatrix4(t6) {
    for (let e2 = 0, i2 = this.count; e2 < i2; e2++) Pl.fromBufferAttribute(this, e2), Pl.applyMatrix4(t6), this.setXYZ(e2, Pl.x, Pl.y, Pl.z);
    return this;
  }
  applyNormalMatrix(t6) {
    for (let e2 = 0, i2 = this.count; e2 < i2; e2++) Pl.fromBufferAttribute(this, e2), Pl.applyNormalMatrix(t6), this.setXYZ(e2, Pl.x, Pl.y, Pl.z);
    return this;
  }
  transformDirection(t6) {
    for (let e2 = 0, i2 = this.count; e2 < i2; e2++) Pl.fromBufferAttribute(this, e2), Pl.transformDirection(t6), this.setXYZ(e2, Pl.x, Pl.y, Pl.z);
    return this;
  }
  set(t6, e2 = 0) {
    return this.array.set(t6, e2), this;
  }
  getX(t6) {
    return this.array[t6 * this.itemSize];
  }
  setX(t6, e2) {
    return this.array[t6 * this.itemSize] = e2, this;
  }
  getY(t6) {
    return this.array[t6 * this.itemSize + 1];
  }
  setY(t6, e2) {
    return this.array[t6 * this.itemSize + 1] = e2, this;
  }
  getZ(t6) {
    return this.array[t6 * this.itemSize + 2];
  }
  setZ(t6, e2) {
    return this.array[t6 * this.itemSize + 2] = e2, this;
  }
  getW(t6) {
    return this.array[t6 * this.itemSize + 3];
  }
  setW(t6, e2) {
    return this.array[t6 * this.itemSize + 3] = e2, this;
  }
  setXY(t6, e2, i2) {
    return t6 *= this.itemSize, this.array[t6 + 0] = e2, this.array[t6 + 1] = i2, this;
  }
  setXYZ(t6, e2, i2, n2) {
    return t6 *= this.itemSize, this.array[t6 + 0] = e2, this.array[t6 + 1] = i2, this.array[t6 + 2] = n2, this;
  }
  setXYZW(t6, e2, i2, n2, r2) {
    return t6 *= this.itemSize, this.array[t6 + 0] = e2, this.array[t6 + 1] = i2, this.array[t6 + 2] = n2, this.array[t6 + 3] = r2, this;
  }
  onUpload(t6) {
    return this.onUploadCallback = t6, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const t6 = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized };
    return "" !== this.name && (t6.name = this.name), this.usage !== ho && (t6.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t6.updateRange = this.updateRange), t6;
  }
};
var Dl = class extends Il {
  constructor(t6, e2, i2) {
    super(new Int8Array(t6), e2, i2);
  }
};
var Ol = class extends Il {
  constructor(t6, e2, i2) {
    super(new Uint8Array(t6), e2, i2);
  }
};
var zl = class extends Il {
  constructor(t6, e2, i2) {
    super(new Uint8ClampedArray(t6), e2, i2);
  }
};
var Fl = class extends Il {
  constructor(t6, e2, i2) {
    super(new Int16Array(t6), e2, i2);
  }
};
var Nl = class extends Il {
  constructor(t6, e2, i2) {
    super(new Uint16Array(t6), e2, i2);
  }
};
var Bl = class extends Il {
  constructor(t6, e2, i2) {
    super(new Int32Array(t6), e2, i2);
  }
};
var kl = class extends Il {
  constructor(t6, e2, i2) {
    super(new Uint32Array(t6), e2, i2);
  }
};
var Ul = class extends Il {
  constructor(t6, e2, i2) {
    super(new Uint16Array(t6), e2, i2), this.isFloat16BufferAttribute = true;
  }
};
var Hl = class extends Il {
  constructor(t6, e2, i2) {
    super(new Float32Array(t6), e2, i2);
  }
};
var Vl = class extends Il {
  constructor(t6, e2, i2) {
    super(new Float64Array(t6), e2, i2);
  }
};
var jl = 0;
var Gl = new Ga();
var Wl = new ml();
var ql = new pa();
var Xl = new ga();
var Yl = new ga();
var Zl = new pa();
var Jl = class _Jl extends So {
  constructor() {
    super(), this.isBufferGeometry = true, Object.defineProperty(this, "id", { value: jl++ }), this.uuid = Co(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(t6) {
    return Array.isArray(t6) ? this.index = new (Bo(t6) ? kl : Nl)(t6, 1) : this.index = t6, this;
  }
  getAttribute(t6) {
    return this.attributes[t6];
  }
  setAttribute(t6, e2) {
    return this.attributes[t6] = e2, this;
  }
  deleteAttribute(t6) {
    return delete this.attributes[t6], this;
  }
  hasAttribute(t6) {
    return void 0 !== this.attributes[t6];
  }
  addGroup(t6, e2, i2 = 0) {
    this.groups.push({ start: t6, count: e2, materialIndex: i2 });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(t6, e2) {
    this.drawRange.start = t6, this.drawRange.count = e2;
  }
  applyMatrix4(t6) {
    const e2 = this.attributes.position;
    void 0 !== e2 && (e2.applyMatrix4(t6), e2.needsUpdate = true);
    const i2 = this.attributes.normal;
    if (void 0 !== i2) {
      const e3 = new No().getNormalMatrix(t6);
      i2.applyNormalMatrix(e3), i2.needsUpdate = true;
    }
    const n2 = this.attributes.tangent;
    return void 0 !== n2 && (n2.transformDirection(t6), n2.needsUpdate = true), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this;
  }
  applyQuaternion(t6) {
    return Gl.makeRotationFromQuaternion(t6), this.applyMatrix4(Gl), this;
  }
  rotateX(t6) {
    return Gl.makeRotationX(t6), this.applyMatrix4(Gl), this;
  }
  rotateY(t6) {
    return Gl.makeRotationY(t6), this.applyMatrix4(Gl), this;
  }
  rotateZ(t6) {
    return Gl.makeRotationZ(t6), this.applyMatrix4(Gl), this;
  }
  translate(t6, e2, i2) {
    return Gl.makeTranslation(t6, e2, i2), this.applyMatrix4(Gl), this;
  }
  scale(t6, e2, i2) {
    return Gl.makeScale(t6, e2, i2), this.applyMatrix4(Gl), this;
  }
  lookAt(t6) {
    return Wl.lookAt(t6), Wl.updateMatrix(), this.applyMatrix4(Wl.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(ql).negate(), this.translate(ql.x, ql.y, ql.z), this;
  }
  setFromPoints(t6) {
    const e2 = [];
    for (let i2 = 0, n2 = t6.length; i2 < n2; i2++) {
      const n3 = t6[i2];
      e2.push(n3.x, n3.y, n3.z || 0);
    }
    return this.setAttribute("position", new Hl(e2, 3)), this;
  }
  computeBoundingBox() {
    null === this.boundingBox && (this.boundingBox = new ga());
    const t6 = this.attributes.position, e2 = this.morphAttributes.position;
    if (t6 && t6.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new pa(-1 / 0, -1 / 0, -1 / 0), new pa(1 / 0, 1 / 0, 1 / 0));
    if (void 0 !== t6) {
      if (this.boundingBox.setFromBufferAttribute(t6), e2) for (let t7 = 0, i2 = e2.length; t7 < i2; t7++) {
        const i3 = e2[t7];
        Xl.setFromBufferAttribute(i3), this.morphTargetsRelative ? (Zl.addVectors(this.boundingBox.min, Xl.min), this.boundingBox.expandByPoint(Zl), Zl.addVectors(this.boundingBox.max, Xl.max), this.boundingBox.expandByPoint(Zl)) : (this.boundingBox.expandByPoint(Xl.min), this.boundingBox.expandByPoint(Xl.max));
      }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    null === this.boundingSphere && (this.boundingSphere = new za());
    const t6 = this.attributes.position, e2 = this.morphAttributes.position;
    if (t6 && t6.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new pa(), 1 / 0);
    if (t6) {
      const i2 = this.boundingSphere.center;
      if (Xl.setFromBufferAttribute(t6), e2) for (let t7 = 0, i3 = e2.length; t7 < i3; t7++) {
        const i4 = e2[t7];
        Yl.setFromBufferAttribute(i4), this.morphTargetsRelative ? (Zl.addVectors(Xl.min, Yl.min), Xl.expandByPoint(Zl), Zl.addVectors(Xl.max, Yl.max), Xl.expandByPoint(Zl)) : (Xl.expandByPoint(Yl.min), Xl.expandByPoint(Yl.max));
      }
      Xl.getCenter(i2);
      let n2 = 0;
      for (let e3 = 0, r2 = t6.count; e3 < r2; e3++) Zl.fromBufferAttribute(t6, e3), n2 = Math.max(n2, i2.distanceToSquared(Zl));
      if (e2) for (let r2 = 0, s2 = e2.length; r2 < s2; r2++) {
        const s3 = e2[r2], o2 = this.morphTargetsRelative;
        for (let e3 = 0, r3 = s3.count; e3 < r3; e3++) Zl.fromBufferAttribute(s3, e3), o2 && (ql.fromBufferAttribute(t6, e3), Zl.add(ql)), n2 = Math.max(n2, i2.distanceToSquared(Zl));
      }
      this.boundingSphere.radius = Math.sqrt(n2), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const t6 = this.index, e2 = this.attributes;
    if (null === t6 || void 0 === e2.position || void 0 === e2.normal || void 0 === e2.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
    const i2 = t6.array, n2 = e2.position.array, r2 = e2.normal.array, s2 = e2.uv.array, o2 = n2.length / 3;
    false === this.hasAttribute("tangent") && this.setAttribute("tangent", new Il(new Float32Array(4 * o2), 4));
    const a2 = this.getAttribute("tangent").array, l2 = [], c2 = [];
    for (let t7 = 0; t7 < o2; t7++) l2[t7] = new pa(), c2[t7] = new pa();
    const h2 = new pa(), u2 = new pa(), d2 = new pa(), p2 = new Fo(), f2 = new Fo(), m2 = new Fo(), g2 = new pa(), v2 = new pa();
    function y2(t7, e3, i3) {
      h2.fromArray(n2, 3 * t7), u2.fromArray(n2, 3 * e3), d2.fromArray(n2, 3 * i3), p2.fromArray(s2, 2 * t7), f2.fromArray(s2, 2 * e3), m2.fromArray(s2, 2 * i3), u2.sub(h2), d2.sub(h2), f2.sub(p2), m2.sub(p2);
      const r3 = 1 / (f2.x * m2.y - m2.x * f2.y);
      isFinite(r3) && (g2.copy(u2).multiplyScalar(m2.y).addScaledVector(d2, -f2.y).multiplyScalar(r3), v2.copy(d2).multiplyScalar(f2.x).addScaledVector(u2, -m2.x).multiplyScalar(r3), l2[t7].add(g2), l2[e3].add(g2), l2[i3].add(g2), c2[t7].add(v2), c2[e3].add(v2), c2[i3].add(v2));
    }
    let x2 = this.groups;
    0 === x2.length && (x2 = [{ start: 0, count: i2.length }]);
    for (let t7 = 0, e3 = x2.length; t7 < e3; ++t7) {
      const e4 = x2[t7], n3 = e4.start;
      for (let t8 = n3, r3 = n3 + e4.count; t8 < r3; t8 += 3) y2(i2[t8 + 0], i2[t8 + 1], i2[t8 + 2]);
    }
    const b2 = new pa(), w2 = new pa(), _2 = new pa(), S2 = new pa();
    function M2(t7) {
      _2.fromArray(r2, 3 * t7), S2.copy(_2);
      const e3 = l2[t7];
      b2.copy(e3), b2.sub(_2.multiplyScalar(_2.dot(e3))).normalize(), w2.crossVectors(S2, e3);
      const i3 = w2.dot(c2[t7]) < 0 ? -1 : 1;
      a2[4 * t7] = b2.x, a2[4 * t7 + 1] = b2.y, a2[4 * t7 + 2] = b2.z, a2[4 * t7 + 3] = i3;
    }
    for (let t7 = 0, e3 = x2.length; t7 < e3; ++t7) {
      const e4 = x2[t7], n3 = e4.start;
      for (let t8 = n3, r3 = n3 + e4.count; t8 < r3; t8 += 3) M2(i2[t8 + 0]), M2(i2[t8 + 1]), M2(i2[t8 + 2]);
    }
  }
  computeVertexNormals() {
    const t6 = this.index, e2 = this.getAttribute("position");
    if (void 0 !== e2) {
      let i2 = this.getAttribute("normal");
      if (void 0 === i2) i2 = new Il(new Float32Array(3 * e2.count), 3), this.setAttribute("normal", i2);
      else for (let t7 = 0, e3 = i2.count; t7 < e3; t7++) i2.setXYZ(t7, 0, 0, 0);
      const n2 = new pa(), r2 = new pa(), s2 = new pa(), o2 = new pa(), a2 = new pa(), l2 = new pa(), c2 = new pa(), h2 = new pa();
      if (t6) for (let u2 = 0, d2 = t6.count; u2 < d2; u2 += 3) {
        const d3 = t6.getX(u2 + 0), p2 = t6.getX(u2 + 1), f2 = t6.getX(u2 + 2);
        n2.fromBufferAttribute(e2, d3), r2.fromBufferAttribute(e2, p2), s2.fromBufferAttribute(e2, f2), c2.subVectors(s2, r2), h2.subVectors(n2, r2), c2.cross(h2), o2.fromBufferAttribute(i2, d3), a2.fromBufferAttribute(i2, p2), l2.fromBufferAttribute(i2, f2), o2.add(c2), a2.add(c2), l2.add(c2), i2.setXYZ(d3, o2.x, o2.y, o2.z), i2.setXYZ(p2, a2.x, a2.y, a2.z), i2.setXYZ(f2, l2.x, l2.y, l2.z);
      }
      else for (let t7 = 0, o3 = e2.count; t7 < o3; t7 += 3) n2.fromBufferAttribute(e2, t7 + 0), r2.fromBufferAttribute(e2, t7 + 1), s2.fromBufferAttribute(e2, t7 + 2), c2.subVectors(s2, r2), h2.subVectors(n2, r2), c2.cross(h2), i2.setXYZ(t7 + 0, c2.x, c2.y, c2.z), i2.setXYZ(t7 + 1, c2.x, c2.y, c2.z), i2.setXYZ(t7 + 2, c2.x, c2.y, c2.z);
      this.normalizeNormals(), i2.needsUpdate = true;
    }
  }
  merge(t6, e2) {
    if (!t6 || !t6.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t6);
    void 0 === e2 && (e2 = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
    const i2 = this.attributes;
    for (const n2 in i2) {
      if (void 0 === t6.attributes[n2]) continue;
      const r2 = i2[n2].array, s2 = t6.attributes[n2], o2 = s2.array, a2 = s2.itemSize * e2, l2 = Math.min(o2.length, r2.length - a2);
      for (let t7 = 0, e3 = a2; t7 < l2; t7++, e3++) r2[e3] = o2[t7];
    }
    return this;
  }
  normalizeNormals() {
    const t6 = this.attributes.normal;
    for (let e2 = 0, i2 = t6.count; e2 < i2; e2++) Zl.fromBufferAttribute(t6, e2), Zl.normalize(), t6.setXYZ(e2, Zl.x, Zl.y, Zl.z);
  }
  toNonIndexed() {
    function t6(t7, e3) {
      const i3 = t7.array, n3 = t7.itemSize, r3 = t7.normalized, s3 = new i3.constructor(e3.length * n3);
      let o2 = 0, a2 = 0;
      for (let r4 = 0, l2 = e3.length; r4 < l2; r4++) {
        o2 = t7.isInterleavedBufferAttribute ? e3[r4] * t7.data.stride + t7.offset : e3[r4] * n3;
        for (let t8 = 0; t8 < n3; t8++) s3[a2++] = i3[o2++];
      }
      return new Il(s3, n3, r3);
    }
    if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const e2 = new _Jl(), i2 = this.index.array, n2 = this.attributes;
    for (const r3 in n2) {
      const s3 = t6(n2[r3], i2);
      e2.setAttribute(r3, s3);
    }
    const r2 = this.morphAttributes;
    for (const n3 in r2) {
      const s3 = [], o2 = r2[n3];
      for (let e3 = 0, n4 = o2.length; e3 < n4; e3++) {
        const n5 = t6(o2[e3], i2);
        s3.push(n5);
      }
      e2.morphAttributes[n3] = s3;
    }
    e2.morphTargetsRelative = this.morphTargetsRelative;
    const s2 = this.groups;
    for (let t7 = 0, i3 = s2.length; t7 < i3; t7++) {
      const i4 = s2[t7];
      e2.addGroup(i4.start, i4.count, i4.materialIndex);
    }
    return e2;
  }
  toJSON() {
    const t6 = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
    if (t6.uuid = this.uuid, t6.type = this.type, "" !== this.name && (t6.name = this.name), Object.keys(this.userData).length > 0 && (t6.userData = this.userData), void 0 !== this.parameters) {
      const e3 = this.parameters;
      for (const i3 in e3) void 0 !== e3[i3] && (t6[i3] = e3[i3]);
      return t6;
    }
    t6.data = { attributes: {} };
    const e2 = this.index;
    null !== e2 && (t6.data.index = { type: e2.array.constructor.name, array: Array.prototype.slice.call(e2.array) });
    const i2 = this.attributes;
    for (const e3 in i2) {
      const n3 = i2[e3];
      t6.data.attributes[e3] = n3.toJSON(t6.data);
    }
    const n2 = {};
    let r2 = false;
    for (const e3 in this.morphAttributes) {
      const i3 = this.morphAttributes[e3], s3 = [];
      for (let e4 = 0, n3 = i3.length; e4 < n3; e4++) {
        const n4 = i3[e4];
        s3.push(n4.toJSON(t6.data));
      }
      s3.length > 0 && (n2[e3] = s3, r2 = true);
    }
    r2 && (t6.data.morphAttributes = n2, t6.data.morphTargetsRelative = this.morphTargetsRelative);
    const s2 = this.groups;
    s2.length > 0 && (t6.data.groups = JSON.parse(JSON.stringify(s2)));
    const o2 = this.boundingSphere;
    return null !== o2 && (t6.data.boundingSphere = { center: o2.center.toArray(), radius: o2.radius }), t6;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t6) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const e2 = {};
    this.name = t6.name;
    const i2 = t6.index;
    null !== i2 && this.setIndex(i2.clone(e2));
    const n2 = t6.attributes;
    for (const t7 in n2) {
      const i3 = n2[t7];
      this.setAttribute(t7, i3.clone(e2));
    }
    const r2 = t6.morphAttributes;
    for (const t7 in r2) {
      const i3 = [], n3 = r2[t7];
      for (let t8 = 0, r3 = n3.length; t8 < r3; t8++) i3.push(n3[t8].clone(e2));
      this.morphAttributes[t7] = i3;
    }
    this.morphTargetsRelative = t6.morphTargetsRelative;
    const s2 = t6.groups;
    for (let t7 = 0, e3 = s2.length; t7 < e3; t7++) {
      const e4 = s2[t7];
      this.addGroup(e4.start, e4.count, e4.materialIndex);
    }
    const o2 = t6.boundingBox;
    null !== o2 && (this.boundingBox = o2.clone());
    const a2 = t6.boundingSphere;
    return null !== a2 && (this.boundingSphere = a2.clone()), this.drawRange.start = t6.drawRange.start, this.drawRange.count = t6.drawRange.count, this.userData = t6.userData, void 0 !== t6.parameters && (this.parameters = Object.assign({}, t6.parameters)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
var Kl = new Ga();
var $l = new ja();
var Ql = new za();
var tc = new pa();
var ec = new pa();
var ic = new pa();
var nc = new pa();
var rc = new pa();
var sc = new pa();
var oc = new pa();
var ac = new pa();
var lc = new pa();
var cc = new Fo();
var hc = new Fo();
var uc = new Fo();
var dc = new pa();
var pc = new pa();
var fc = class extends ml {
  constructor(t6 = new Jl(), e2 = new Rl()) {
    super(), this.isMesh = true, this.type = "Mesh", this.geometry = t6, this.material = e2, this.updateMorphTargets();
  }
  copy(t6, e2) {
    return super.copy(t6, e2), void 0 !== t6.morphTargetInfluences && (this.morphTargetInfluences = t6.morphTargetInfluences.slice()), void 0 !== t6.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t6.morphTargetDictionary)), this.material = t6.material, this.geometry = t6.geometry, this;
  }
  updateMorphTargets() {
    const t6 = this.geometry.morphAttributes, e2 = Object.keys(t6);
    if (e2.length > 0) {
      const i2 = t6[e2[0]];
      if (void 0 !== i2) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let t7 = 0, e3 = i2.length; t7 < e3; t7++) {
          const e4 = i2[t7].name || String(t7);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[e4] = t7;
        }
      }
    }
  }
  raycast(t6, e2) {
    const i2 = this.geometry, n2 = this.material, r2 = this.matrixWorld;
    if (void 0 === n2) return;
    if (null === i2.boundingSphere && i2.computeBoundingSphere(), Ql.copy(i2.boundingSphere), Ql.applyMatrix4(r2), false === t6.ray.intersectsSphere(Ql)) return;
    if (Kl.copy(r2).invert(), $l.copy(t6.ray).applyMatrix4(Kl), null !== i2.boundingBox && false === $l.intersectsBox(i2.boundingBox)) return;
    let s2;
    const o2 = i2.index, a2 = i2.attributes.position, l2 = i2.morphAttributes.position, c2 = i2.morphTargetsRelative, h2 = i2.attributes.uv, u2 = i2.attributes.uv2, d2 = i2.groups, p2 = i2.drawRange;
    if (null !== o2) if (Array.isArray(n2)) for (let i3 = 0, r3 = d2.length; i3 < r3; i3++) {
      const r4 = d2[i3], f2 = n2[r4.materialIndex];
      for (let i4 = Math.max(r4.start, p2.start), n3 = Math.min(o2.count, Math.min(r4.start + r4.count, p2.start + p2.count)); i4 < n3; i4 += 3) {
        const n4 = o2.getX(i4), d3 = o2.getX(i4 + 1), p3 = o2.getX(i4 + 2);
        s2 = mc(this, f2, t6, $l, a2, l2, c2, h2, u2, n4, d3, p3), s2 && (s2.faceIndex = Math.floor(i4 / 3), s2.face.materialIndex = r4.materialIndex, e2.push(s2));
      }
    }
    else {
      for (let i3 = Math.max(0, p2.start), r3 = Math.min(o2.count, p2.start + p2.count); i3 < r3; i3 += 3) {
        const r4 = o2.getX(i3), d3 = o2.getX(i3 + 1), p3 = o2.getX(i3 + 2);
        s2 = mc(this, n2, t6, $l, a2, l2, c2, h2, u2, r4, d3, p3), s2 && (s2.faceIndex = Math.floor(i3 / 3), e2.push(s2));
      }
    }
    else if (void 0 !== a2) if (Array.isArray(n2)) for (let i3 = 0, r3 = d2.length; i3 < r3; i3++) {
      const r4 = d2[i3], o3 = n2[r4.materialIndex];
      for (let i4 = Math.max(r4.start, p2.start), n3 = Math.min(a2.count, Math.min(r4.start + r4.count, p2.start + p2.count)); i4 < n3; i4 += 3) {
        s2 = mc(this, o3, t6, $l, a2, l2, c2, h2, u2, i4, i4 + 1, i4 + 2), s2 && (s2.faceIndex = Math.floor(i4 / 3), s2.face.materialIndex = r4.materialIndex, e2.push(s2));
      }
    }
    else {
      for (let i3 = Math.max(0, p2.start), r3 = Math.min(a2.count, p2.start + p2.count); i3 < r3; i3 += 3) {
        s2 = mc(this, n2, t6, $l, a2, l2, c2, h2, u2, i3, i3 + 1, i3 + 2), s2 && (s2.faceIndex = Math.floor(i3 / 3), e2.push(s2));
      }
    }
  }
};
function mc(t6, e2, i2, n2, r2, s2, o2, a2, l2, c2, h2, u2) {
  tc.fromBufferAttribute(r2, c2), ec.fromBufferAttribute(r2, h2), ic.fromBufferAttribute(r2, u2);
  const d2 = t6.morphTargetInfluences;
  if (s2 && d2) {
    oc.set(0, 0, 0), ac.set(0, 0, 0), lc.set(0, 0, 0);
    for (let t7 = 0, e3 = s2.length; t7 < e3; t7++) {
      const e4 = d2[t7], i3 = s2[t7];
      0 !== e4 && (nc.fromBufferAttribute(i3, c2), rc.fromBufferAttribute(i3, h2), sc.fromBufferAttribute(i3, u2), o2 ? (oc.addScaledVector(nc, e4), ac.addScaledVector(rc, e4), lc.addScaledVector(sc, e4)) : (oc.addScaledVector(nc.sub(tc), e4), ac.addScaledVector(rc.sub(ec), e4), lc.addScaledVector(sc.sub(ic), e4)));
    }
    tc.add(oc), ec.add(ac), ic.add(lc);
  }
  t6.isSkinnedMesh && (t6.boneTransform(c2, tc), t6.boneTransform(h2, ec), t6.boneTransform(u2, ic));
  const p2 = (function(t7, e3, i3, n3, r3, s3, o3, a3) {
    let l3;
    if (l3 = e3.side === wn ? n3.intersectTriangle(o3, s3, r3, true, a3) : n3.intersectTriangle(r3, s3, o3, e3.side !== _n, a3), null === l3) return null;
    pc.copy(a3), pc.applyMatrix4(t7.matrixWorld);
    const c3 = i3.ray.origin.distanceTo(pc);
    return c3 < i3.near || c3 > i3.far ? null : { distance: c3, point: pc.clone(), object: t7 };
  })(t6, e2, i2, n2, tc, ec, ic, dc);
  if (p2) {
    a2 && (cc.fromBufferAttribute(a2, c2), hc.fromBufferAttribute(a2, h2), uc.fromBufferAttribute(a2, u2), p2.uv = El.getUV(dc, tc, ec, ic, cc, hc, uc, new Fo())), l2 && (cc.fromBufferAttribute(l2, c2), hc.fromBufferAttribute(l2, h2), uc.fromBufferAttribute(l2, u2), p2.uv2 = El.getUV(dc, tc, ec, ic, cc, hc, uc, new Fo()));
    const t7 = { a: c2, b: h2, c: u2, normal: new pa(), materialIndex: 0 };
    El.getNormal(tc, ec, ic, t7.normal), p2.face = t7;
  }
  return p2;
}
var gc = class _gc extends Jl {
  constructor(t6 = 1, e2 = 1, i2 = 1, n2 = 1, r2 = 1, s2 = 1) {
    super(), this.type = "BoxGeometry", this.parameters = { width: t6, height: e2, depth: i2, widthSegments: n2, heightSegments: r2, depthSegments: s2 };
    const o2 = this;
    n2 = Math.floor(n2), r2 = Math.floor(r2), s2 = Math.floor(s2);
    const a2 = [], l2 = [], c2 = [], h2 = [];
    let u2 = 0, d2 = 0;
    function p2(t7, e3, i3, n3, r3, s3, p3, f2, m2, g2, v2) {
      const y2 = s3 / m2, x2 = p3 / g2, b2 = s3 / 2, w2 = p3 / 2, _2 = f2 / 2, S2 = m2 + 1, M2 = g2 + 1;
      let T2 = 0, E2 = 0;
      const A2 = new pa();
      for (let s4 = 0; s4 < M2; s4++) {
        const o3 = s4 * x2 - w2;
        for (let a3 = 0; a3 < S2; a3++) {
          const u3 = a3 * y2 - b2;
          A2[t7] = u3 * n3, A2[e3] = o3 * r3, A2[i3] = _2, l2.push(A2.x, A2.y, A2.z), A2[t7] = 0, A2[e3] = 0, A2[i3] = f2 > 0 ? 1 : -1, c2.push(A2.x, A2.y, A2.z), h2.push(a3 / m2), h2.push(1 - s4 / g2), T2 += 1;
        }
      }
      for (let t8 = 0; t8 < g2; t8++) for (let e4 = 0; e4 < m2; e4++) {
        const i4 = u2 + e4 + S2 * t8, n4 = u2 + e4 + S2 * (t8 + 1), r4 = u2 + (e4 + 1) + S2 * (t8 + 1), s4 = u2 + (e4 + 1) + S2 * t8;
        a2.push(i4, n4, s4), a2.push(n4, r4, s4), E2 += 6;
      }
      o2.addGroup(d2, E2, v2), d2 += E2, u2 += T2;
    }
    p2("z", "y", "x", -1, -1, i2, e2, t6, s2, r2, 0), p2("z", "y", "x", 1, -1, i2, e2, -t6, s2, r2, 1), p2("x", "z", "y", 1, 1, t6, i2, e2, n2, s2, 2), p2("x", "z", "y", 1, -1, t6, i2, -e2, n2, s2, 3), p2("x", "y", "z", 1, -1, t6, e2, i2, n2, r2, 4), p2("x", "y", "z", -1, -1, t6, e2, -i2, n2, r2, 5), this.setIndex(a2), this.setAttribute("position", new Hl(l2, 3)), this.setAttribute("normal", new Hl(c2, 3)), this.setAttribute("uv", new Hl(h2, 2));
  }
  static fromJSON(t6) {
    return new _gc(t6.width, t6.height, t6.depth, t6.widthSegments, t6.heightSegments, t6.depthSegments);
  }
};
function vc(t6) {
  const e2 = {};
  for (const i2 in t6) {
    e2[i2] = {};
    for (const n2 in t6[i2]) {
      const r2 = t6[i2][n2];
      r2 && (r2.isColor || r2.isMatrix3 || r2.isMatrix4 || r2.isVector2 || r2.isVector3 || r2.isVector4 || r2.isTexture || r2.isQuaternion) ? e2[i2][n2] = r2.clone() : Array.isArray(r2) ? e2[i2][n2] = r2.slice() : e2[i2][n2] = r2;
    }
  }
  return e2;
}
function yc(t6) {
  const e2 = {};
  for (let i2 = 0; i2 < t6.length; i2++) {
    const n2 = vc(t6[i2]);
    for (const t7 in n2) e2[t7] = n2[t7];
  }
  return e2;
}
var xc = { clone: vc, merge: yc };
var bc = class extends Cl {
  constructor(t6) {
    super(), this.isShaderMaterial = true, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.extensions = { derivatives: false, fragDepth: false, drawBuffers: false, shaderTextureLOD: false }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, void 0 !== t6 && (void 0 !== t6.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t6));
  }
  copy(t6) {
    return super.copy(t6), this.fragmentShader = t6.fragmentShader, this.vertexShader = t6.vertexShader, this.uniforms = vc(t6.uniforms), this.uniformsGroups = (function(t7) {
      const e2 = [];
      for (let i2 = 0; i2 < t7.length; i2++) e2.push(t7[i2].clone());
      return e2;
    })(t6.uniformsGroups), this.defines = Object.assign({}, t6.defines), this.wireframe = t6.wireframe, this.wireframeLinewidth = t6.wireframeLinewidth, this.fog = t6.fog, this.lights = t6.lights, this.clipping = t6.clipping, this.extensions = Object.assign({}, t6.extensions), this.glslVersion = t6.glslVersion, this;
  }
  toJSON(t6) {
    const e2 = super.toJSON(t6);
    e2.glslVersion = this.glslVersion, e2.uniforms = {};
    for (const i3 in this.uniforms) {
      const n2 = this.uniforms[i3].value;
      n2 && n2.isTexture ? e2.uniforms[i3] = { type: "t", value: n2.toJSON(t6).uuid } : n2 && n2.isColor ? e2.uniforms[i3] = { type: "c", value: n2.getHex() } : n2 && n2.isVector2 ? e2.uniforms[i3] = { type: "v2", value: n2.toArray() } : n2 && n2.isVector3 ? e2.uniforms[i3] = { type: "v3", value: n2.toArray() } : n2 && n2.isVector4 ? e2.uniforms[i3] = { type: "v4", value: n2.toArray() } : n2 && n2.isMatrix3 ? e2.uniforms[i3] = { type: "m3", value: n2.toArray() } : n2 && n2.isMatrix4 ? e2.uniforms[i3] = { type: "m4", value: n2.toArray() } : e2.uniforms[i3] = { value: n2 };
    }
    Object.keys(this.defines).length > 0 && (e2.defines = this.defines), e2.vertexShader = this.vertexShader, e2.fragmentShader = this.fragmentShader;
    const i2 = {};
    for (const t7 in this.extensions) true === this.extensions[t7] && (i2[t7] = true);
    return Object.keys(i2).length > 0 && (e2.extensions = i2), e2;
  }
};
var wc = class extends ml {
  constructor() {
    super(), this.isCamera = true, this.type = "Camera", this.matrixWorldInverse = new Ga(), this.projectionMatrix = new Ga(), this.projectionMatrixInverse = new Ga();
  }
  copy(t6, e2) {
    return super.copy(t6, e2), this.matrixWorldInverse.copy(t6.matrixWorldInverse), this.projectionMatrix.copy(t6.projectionMatrix), this.projectionMatrixInverse.copy(t6.projectionMatrixInverse), this;
  }
  getWorldDirection(t6) {
    this.updateWorldMatrix(true, false);
    const e2 = this.matrixWorld.elements;
    return t6.set(-e2[8], -e2[9], -e2[10]).normalize();
  }
  updateMatrixWorld(t6) {
    super.updateMatrixWorld(t6), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(t6, e2) {
    super.updateWorldMatrix(t6, e2), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var _c = class extends wc {
  constructor(t6 = 50, e2 = 1, i2 = 0.1, n2 = 2e3) {
    super(), this.isPerspectiveCamera = true, this.type = "PerspectiveCamera", this.fov = t6, this.zoom = 1, this.near = i2, this.far = n2, this.focus = 10, this.aspect = e2, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(t6, e2) {
    return super.copy(t6, e2), this.fov = t6.fov, this.zoom = t6.zoom, this.near = t6.near, this.far = t6.far, this.focus = t6.focus, this.aspect = t6.aspect, this.view = null === t6.view ? null : Object.assign({}, t6.view), this.filmGauge = t6.filmGauge, this.filmOffset = t6.filmOffset, this;
  }
  setFocalLength(t6) {
    const e2 = 0.5 * this.getFilmHeight() / t6;
    this.fov = 2 * Ao * Math.atan(e2), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const t6 = Math.tan(0.5 * Eo * this.fov);
    return 0.5 * this.getFilmHeight() / t6;
  }
  getEffectiveFOV() {
    return 2 * Ao * Math.atan(Math.tan(0.5 * Eo * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(t6, e2, i2, n2, r2, s2) {
    this.aspect = t6 / e2, null === this.view && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = t6, this.view.fullHeight = e2, this.view.offsetX = i2, this.view.offsetY = n2, this.view.width = r2, this.view.height = s2, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    null !== this.view && (this.view.enabled = false), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const t6 = this.near;
    let e2 = t6 * Math.tan(0.5 * Eo * this.fov) / this.zoom, i2 = 2 * e2, n2 = this.aspect * i2, r2 = -0.5 * n2;
    const s2 = this.view;
    if (null !== this.view && this.view.enabled) {
      const t7 = s2.fullWidth, o3 = s2.fullHeight;
      r2 += s2.offsetX * n2 / t7, e2 -= s2.offsetY * i2 / o3, n2 *= s2.width / t7, i2 *= s2.height / o3;
    }
    const o2 = this.filmOffset;
    0 !== o2 && (r2 += t6 * o2 / this.getFilmWidth()), this.projectionMatrix.makePerspective(r2, r2 + n2, e2, e2 - i2, t6, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(t6) {
    const e2 = super.toJSON(t6);
    return e2.object.fov = this.fov, e2.object.zoom = this.zoom, e2.object.near = this.near, e2.object.far = this.far, e2.object.focus = this.focus, e2.object.aspect = this.aspect, null !== this.view && (e2.object.view = Object.assign({}, this.view)), e2.object.filmGauge = this.filmGauge, e2.object.filmOffset = this.filmOffset, e2;
  }
};
var Sc = 90;
var Mc = class extends ml {
  constructor(t6, e2, i2) {
    if (super(), this.type = "CubeCamera", true !== i2.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
    this.renderTarget = i2;
    const n2 = new _c(Sc, 1, t6, e2);
    n2.layers = this.layers, n2.up.set(0, -1, 0), n2.lookAt(new pa(1, 0, 0)), this.add(n2);
    const r2 = new _c(Sc, 1, t6, e2);
    r2.layers = this.layers, r2.up.set(0, -1, 0), r2.lookAt(new pa(-1, 0, 0)), this.add(r2);
    const s2 = new _c(Sc, 1, t6, e2);
    s2.layers = this.layers, s2.up.set(0, 0, 1), s2.lookAt(new pa(0, 1, 0)), this.add(s2);
    const o2 = new _c(Sc, 1, t6, e2);
    o2.layers = this.layers, o2.up.set(0, 0, -1), o2.lookAt(new pa(0, -1, 0)), this.add(o2);
    const a2 = new _c(Sc, 1, t6, e2);
    a2.layers = this.layers, a2.up.set(0, -1, 0), a2.lookAt(new pa(0, 0, 1)), this.add(a2);
    const l2 = new _c(Sc, 1, t6, e2);
    l2.layers = this.layers, l2.up.set(0, -1, 0), l2.lookAt(new pa(0, 0, -1)), this.add(l2);
  }
  update(t6, e2) {
    null === this.parent && this.updateMatrixWorld();
    const i2 = this.renderTarget, [n2, r2, s2, o2, a2, l2] = this.children, c2 = t6.getRenderTarget(), h2 = t6.toneMapping, u2 = t6.xr.enabled;
    t6.toneMapping = rr, t6.xr.enabled = false;
    const d2 = i2.texture.generateMipmaps;
    i2.texture.generateMipmaps = false, t6.setRenderTarget(i2, 0), t6.render(e2, n2), t6.setRenderTarget(i2, 1), t6.render(e2, r2), t6.setRenderTarget(i2, 2), t6.render(e2, s2), t6.setRenderTarget(i2, 3), t6.render(e2, o2), t6.setRenderTarget(i2, 4), t6.render(e2, a2), i2.texture.generateMipmaps = d2, t6.setRenderTarget(i2, 5), t6.render(e2, l2), t6.setRenderTarget(c2), t6.toneMapping = h2, t6.xr.enabled = u2, i2.texture.needsPMREMUpdate = true;
  }
};
var Tc = class extends ra {
  constructor(t6, e2, i2, n2, r2, s2, o2, a2, l2, c2) {
    super(t6 = void 0 !== t6 ? t6 : [], e2 = void 0 !== e2 ? e2 : ur, i2, n2, r2, s2, o2, a2, l2, c2), this.isCubeTexture = true, this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(t6) {
    this.image = t6;
  }
};
var Ec = class extends oa {
  constructor(t6, e2 = {}) {
    super(t6, t6, e2), this.isWebGLCubeRenderTarget = true;
    const i2 = { width: t6, height: t6, depth: 1 }, n2 = [i2, i2, i2, i2, i2, i2];
    this.texture = new Tc(n2, e2.mapping, e2.wrapS, e2.wrapT, e2.magFilter, e2.minFilter, e2.format, e2.type, e2.anisotropy, e2.encoding), this.texture.isRenderTargetTexture = true, this.texture.generateMipmaps = void 0 !== e2.generateMipmaps && e2.generateMipmaps, this.texture.minFilter = void 0 !== e2.minFilter ? e2.minFilter : Mr;
  }
  fromEquirectangularTexture(t6, e2) {
    this.texture.type = e2.type, this.texture.encoding = e2.encoding, this.texture.generateMipmaps = e2.generateMipmaps, this.texture.minFilter = e2.minFilter, this.texture.magFilter = e2.magFilter;
    const i2 = { uniforms: { tEquirect: { value: null } }, vertexShader: "\n\n				varying vec3 vWorldDirection;\n\n				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n				}\n\n				void main() {\n\n					vWorldDirection = transformDirection( position, modelMatrix );\n\n					#include <begin_vertex>\n					#include <project_vertex>\n\n				}\n			", fragmentShader: "\n\n				uniform sampler2D tEquirect;\n\n				varying vec3 vWorldDirection;\n\n				#include <common>\n\n				void main() {\n\n					vec3 direction = normalize( vWorldDirection );\n\n					vec2 sampleUV = equirectUv( direction );\n\n					gl_FragColor = texture2D( tEquirect, sampleUV );\n\n				}\n			" }, n2 = new gc(5, 5, 5), r2 = new bc({ name: "CubemapFromEquirect", uniforms: vc(i2.uniforms), vertexShader: i2.vertexShader, fragmentShader: i2.fragmentShader, side: wn, blending: Tn });
    r2.uniforms.tEquirect.value = e2;
    const s2 = new fc(n2, r2), o2 = e2.minFilter;
    e2.minFilter === Ar && (e2.minFilter = Mr);
    return new Mc(1, 10, this).update(t6, s2), e2.minFilter = o2, s2.geometry.dispose(), s2.material.dispose(), this;
  }
  clear(t6, e2, i2, n2) {
    const r2 = t6.getRenderTarget();
    for (let r3 = 0; r3 < 6; r3++) t6.setRenderTarget(this, r3), t6.clear(e2, i2, n2);
    t6.setRenderTarget(r2);
  }
};
var Ac = new pa();
var Cc = new pa();
var Rc = new No();
var Pc = class {
  constructor(t6 = new pa(1, 0, 0), e2 = 0) {
    this.isPlane = true, this.normal = t6, this.constant = e2;
  }
  set(t6, e2) {
    return this.normal.copy(t6), this.constant = e2, this;
  }
  setComponents(t6, e2, i2, n2) {
    return this.normal.set(t6, e2, i2), this.constant = n2, this;
  }
  setFromNormalAndCoplanarPoint(t6, e2) {
    return this.normal.copy(t6), this.constant = -e2.dot(this.normal), this;
  }
  setFromCoplanarPoints(t6, e2, i2) {
    const n2 = Ac.subVectors(i2, e2).cross(Cc.subVectors(t6, e2)).normalize();
    return this.setFromNormalAndCoplanarPoint(n2, t6), this;
  }
  copy(t6) {
    return this.normal.copy(t6.normal), this.constant = t6.constant, this;
  }
  normalize() {
    const t6 = 1 / this.normal.length();
    return this.normal.multiplyScalar(t6), this.constant *= t6, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(t6) {
    return this.normal.dot(t6) + this.constant;
  }
  distanceToSphere(t6) {
    return this.distanceToPoint(t6.center) - t6.radius;
  }
  projectPoint(t6, e2) {
    return e2.copy(this.normal).multiplyScalar(-this.distanceToPoint(t6)).add(t6);
  }
  intersectLine(t6, e2) {
    const i2 = t6.delta(Ac), n2 = this.normal.dot(i2);
    if (0 === n2) return 0 === this.distanceToPoint(t6.start) ? e2.copy(t6.start) : null;
    const r2 = -(t6.start.dot(this.normal) + this.constant) / n2;
    return r2 < 0 || r2 > 1 ? null : e2.copy(i2).multiplyScalar(r2).add(t6.start);
  }
  intersectsLine(t6) {
    const e2 = this.distanceToPoint(t6.start), i2 = this.distanceToPoint(t6.end);
    return e2 < 0 && i2 > 0 || i2 < 0 && e2 > 0;
  }
  intersectsBox(t6) {
    return t6.intersectsPlane(this);
  }
  intersectsSphere(t6) {
    return t6.intersectsPlane(this);
  }
  coplanarPoint(t6) {
    return t6.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(t6, e2) {
    const i2 = e2 || Rc.getNormalMatrix(t6), n2 = this.coplanarPoint(Ac).applyMatrix4(t6), r2 = this.normal.applyMatrix3(i2).normalize();
    return this.constant = -n2.dot(r2), this;
  }
  translate(t6) {
    return this.constant -= t6.dot(this.normal), this;
  }
  equals(t6) {
    return t6.normal.equals(this.normal) && t6.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var Lc = new za();
var Ic = new pa();
var Dc = class {
  constructor(t6 = new Pc(), e2 = new Pc(), i2 = new Pc(), n2 = new Pc(), r2 = new Pc(), s2 = new Pc()) {
    this.planes = [t6, e2, i2, n2, r2, s2];
  }
  set(t6, e2, i2, n2, r2, s2) {
    const o2 = this.planes;
    return o2[0].copy(t6), o2[1].copy(e2), o2[2].copy(i2), o2[3].copy(n2), o2[4].copy(r2), o2[5].copy(s2), this;
  }
  copy(t6) {
    const e2 = this.planes;
    for (let i2 = 0; i2 < 6; i2++) e2[i2].copy(t6.planes[i2]);
    return this;
  }
  setFromProjectionMatrix(t6) {
    const e2 = this.planes, i2 = t6.elements, n2 = i2[0], r2 = i2[1], s2 = i2[2], o2 = i2[3], a2 = i2[4], l2 = i2[5], c2 = i2[6], h2 = i2[7], u2 = i2[8], d2 = i2[9], p2 = i2[10], f2 = i2[11], m2 = i2[12], g2 = i2[13], v2 = i2[14], y2 = i2[15];
    return e2[0].setComponents(o2 - n2, h2 - a2, f2 - u2, y2 - m2).normalize(), e2[1].setComponents(o2 + n2, h2 + a2, f2 + u2, y2 + m2).normalize(), e2[2].setComponents(o2 + r2, h2 + l2, f2 + d2, y2 + g2).normalize(), e2[3].setComponents(o2 - r2, h2 - l2, f2 - d2, y2 - g2).normalize(), e2[4].setComponents(o2 - s2, h2 - c2, f2 - p2, y2 - v2).normalize(), e2[5].setComponents(o2 + s2, h2 + c2, f2 + p2, y2 + v2).normalize(), this;
  }
  intersectsObject(t6) {
    const e2 = t6.geometry;
    return null === e2.boundingSphere && e2.computeBoundingSphere(), Lc.copy(e2.boundingSphere).applyMatrix4(t6.matrixWorld), this.intersectsSphere(Lc);
  }
  intersectsSprite(t6) {
    return Lc.center.set(0, 0, 0), Lc.radius = 0.7071067811865476, Lc.applyMatrix4(t6.matrixWorld), this.intersectsSphere(Lc);
  }
  intersectsSphere(t6) {
    const e2 = this.planes, i2 = t6.center, n2 = -t6.radius;
    for (let t7 = 0; t7 < 6; t7++) {
      if (e2[t7].distanceToPoint(i2) < n2) return false;
    }
    return true;
  }
  intersectsBox(t6) {
    const e2 = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      const n2 = e2[i2];
      if (Ic.x = n2.normal.x > 0 ? t6.max.x : t6.min.x, Ic.y = n2.normal.y > 0 ? t6.max.y : t6.min.y, Ic.z = n2.normal.z > 0 ? t6.max.z : t6.min.z, n2.distanceToPoint(Ic) < 0) return false;
    }
    return true;
  }
  containsPoint(t6) {
    const e2 = this.planes;
    for (let i2 = 0; i2 < 6; i2++) if (e2[i2].distanceToPoint(t6) < 0) return false;
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
function Oc() {
  let t6 = null, e2 = false, i2 = null, n2 = null;
  function r2(e3, s2) {
    i2(e3, s2), n2 = t6.requestAnimationFrame(r2);
  }
  return { start: function() {
    true !== e2 && null !== i2 && (n2 = t6.requestAnimationFrame(r2), e2 = true);
  }, stop: function() {
    t6.cancelAnimationFrame(n2), e2 = false;
  }, setAnimationLoop: function(t7) {
    i2 = t7;
  }, setContext: function(e3) {
    t6 = e3;
  } };
}
function zc(t6, e2) {
  const i2 = e2.isWebGL2, n2 = /* @__PURE__ */ new WeakMap();
  return { get: function(t7) {
    return t7.isInterleavedBufferAttribute && (t7 = t7.data), n2.get(t7);
  }, remove: function(e3) {
    e3.isInterleavedBufferAttribute && (e3 = e3.data);
    const i3 = n2.get(e3);
    i3 && (t6.deleteBuffer(i3.buffer), n2.delete(e3));
  }, update: function(e3, r2) {
    if (e3.isGLBufferAttribute) {
      const t7 = n2.get(e3);
      return void ((!t7 || t7.version < e3.version) && n2.set(e3, { buffer: e3.buffer, type: e3.type, bytesPerElement: e3.elementSize, version: e3.version }));
    }
    e3.isInterleavedBufferAttribute && (e3 = e3.data);
    const s2 = n2.get(e3);
    void 0 === s2 ? n2.set(e3, (function(e4, n3) {
      const r3 = e4.array, s3 = e4.usage, o2 = t6.createBuffer();
      let a2;
      if (t6.bindBuffer(n3, o2), t6.bufferData(n3, r3, s3), e4.onUploadCallback(), r3 instanceof Float32Array) a2 = 5126;
      else if (r3 instanceof Uint16Array) if (e4.isFloat16BufferAttribute) {
        if (!i2) throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
        a2 = 5131;
      } else a2 = 5123;
      else if (r3 instanceof Int16Array) a2 = 5122;
      else if (r3 instanceof Uint32Array) a2 = 5125;
      else if (r3 instanceof Int32Array) a2 = 5124;
      else if (r3 instanceof Int8Array) a2 = 5120;
      else if (r3 instanceof Uint8Array) a2 = 5121;
      else {
        if (!(r3 instanceof Uint8ClampedArray)) throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + r3);
        a2 = 5121;
      }
      return { buffer: o2, type: a2, bytesPerElement: r3.BYTES_PER_ELEMENT, version: e4.version };
    })(e3, r2)) : s2.version < e3.version && (!(function(e4, n3, r3) {
      const s3 = n3.array, o2 = n3.updateRange;
      t6.bindBuffer(r3, e4), -1 === o2.count ? t6.bufferSubData(r3, 0, s3) : (i2 ? t6.bufferSubData(r3, o2.offset * s3.BYTES_PER_ELEMENT, s3, o2.offset, o2.count) : t6.bufferSubData(r3, o2.offset * s3.BYTES_PER_ELEMENT, s3.subarray(o2.offset, o2.offset + o2.count)), o2.count = -1);
    })(s2.buffer, e3, r2), s2.version = e3.version);
  } };
}
var Fc = class _Fc extends Jl {
  constructor(t6 = 1, e2 = 1, i2 = 1, n2 = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = { width: t6, height: e2, widthSegments: i2, heightSegments: n2 };
    const r2 = t6 / 2, s2 = e2 / 2, o2 = Math.floor(i2), a2 = Math.floor(n2), l2 = o2 + 1, c2 = a2 + 1, h2 = t6 / o2, u2 = e2 / a2, d2 = [], p2 = [], f2 = [], m2 = [];
    for (let t7 = 0; t7 < c2; t7++) {
      const e3 = t7 * u2 - s2;
      for (let i3 = 0; i3 < l2; i3++) {
        const n3 = i3 * h2 - r2;
        p2.push(n3, -e3, 0), f2.push(0, 0, 1), m2.push(i3 / o2), m2.push(1 - t7 / a2);
      }
    }
    for (let t7 = 0; t7 < a2; t7++) for (let e3 = 0; e3 < o2; e3++) {
      const i3 = e3 + l2 * t7, n3 = e3 + l2 * (t7 + 1), r3 = e3 + 1 + l2 * (t7 + 1), s3 = e3 + 1 + l2 * t7;
      d2.push(i3, n3, s3), d2.push(n3, r3, s3);
    }
    this.setIndex(d2), this.setAttribute("position", new Hl(p2, 3)), this.setAttribute("normal", new Hl(f2, 3)), this.setAttribute("uv", new Hl(m2, 2));
  }
  static fromJSON(t6) {
    return new _Fc(t6.width, t6.height, t6.widthSegments, t6.heightSegments);
  }
};
var Nc = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif", alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif", iridescence_fragment: "#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			 return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float R21 = R12;\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = dFdx( surf_pos.xyz );\n		vec3 vSigmaY = dFdy( surf_pos.xyz );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n	return dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointLightInfo( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotLightInfo( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARCOLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEENCOLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEENROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n	#endif\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	#ifdef USE_IRIDESCENCE\n		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n	#else\n		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometry.viewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif", map_fragment: "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif", morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform ivec2 morphTargetsTextureSize;\n		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n			int y = texelIndex / morphTargetsTextureSize.x;\n			int x = texelIndex - y * morphTargetsTextureSize.x;\n			ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n			return texelFetch( morphTargetsTexture, morphUV, 0 );\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif", normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", normal_pars_fragment: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif", normal_pars_vertex: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif", normal_vertex: "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif", clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif", iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif", output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	uniform int boneTextureSize;\n	mat4 getBoneMatrix( const in float i ) {\n		float j = i * 4.0;\n		float x = mod( j, float( boneTextureSize ) );\n		float y = floor( j / float( boneTextureSize ) );\n		float dx = 1.0 / float( boneTextureSize );\n		float dy = 1.0 / float( boneTextureSize );\n		y = dy * ( y + 0.5 );\n		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n		mat4 bone = mat4( v1, v2, v3, v4 );\n		return bone;\n	}\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmission_fragment: "#ifdef USE_TRANSMISSION\n	float transmissionAlpha = 1.0;\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationColor, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif", transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef texture2DLodEXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( attenuationDistance == 0.0 ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif", uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	gl_FragColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n	#endif\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}", cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}", meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARCOLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEENCOLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEENROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}" };
var Bc = { common: { diffuse: { value: new $o(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new No() }, uv2Transform: { value: new No() }, alphaMap: { value: null }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: 0.98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new Fo(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new $o(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new $o(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new No() } }, sprite: { diffuse: { value: new $o(16777215) }, opacity: { value: 1 }, center: { value: new Fo(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new No() } } };
var kc = { basic: { uniforms: yc([Bc.common, Bc.specularmap, Bc.envmap, Bc.aomap, Bc.lightmap, Bc.fog]), vertexShader: Nc.meshbasic_vert, fragmentShader: Nc.meshbasic_frag }, lambert: { uniforms: yc([Bc.common, Bc.specularmap, Bc.envmap, Bc.aomap, Bc.lightmap, Bc.emissivemap, Bc.fog, Bc.lights, { emissive: { value: new $o(0) } }]), vertexShader: Nc.meshlambert_vert, fragmentShader: Nc.meshlambert_frag }, phong: { uniforms: yc([Bc.common, Bc.specularmap, Bc.envmap, Bc.aomap, Bc.lightmap, Bc.emissivemap, Bc.bumpmap, Bc.normalmap, Bc.displacementmap, Bc.fog, Bc.lights, { emissive: { value: new $o(0) }, specular: { value: new $o(1118481) }, shininess: { value: 30 } }]), vertexShader: Nc.meshphong_vert, fragmentShader: Nc.meshphong_frag }, standard: { uniforms: yc([Bc.common, Bc.envmap, Bc.aomap, Bc.lightmap, Bc.emissivemap, Bc.bumpmap, Bc.normalmap, Bc.displacementmap, Bc.roughnessmap, Bc.metalnessmap, Bc.fog, Bc.lights, { emissive: { value: new $o(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: Nc.meshphysical_vert, fragmentShader: Nc.meshphysical_frag }, toon: { uniforms: yc([Bc.common, Bc.aomap, Bc.lightmap, Bc.emissivemap, Bc.bumpmap, Bc.normalmap, Bc.displacementmap, Bc.gradientmap, Bc.fog, Bc.lights, { emissive: { value: new $o(0) } }]), vertexShader: Nc.meshtoon_vert, fragmentShader: Nc.meshtoon_frag }, matcap: { uniforms: yc([Bc.common, Bc.bumpmap, Bc.normalmap, Bc.displacementmap, Bc.fog, { matcap: { value: null } }]), vertexShader: Nc.meshmatcap_vert, fragmentShader: Nc.meshmatcap_frag }, points: { uniforms: yc([Bc.points, Bc.fog]), vertexShader: Nc.points_vert, fragmentShader: Nc.points_frag }, dashed: { uniforms: yc([Bc.common, Bc.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: Nc.linedashed_vert, fragmentShader: Nc.linedashed_frag }, depth: { uniforms: yc([Bc.common, Bc.displacementmap]), vertexShader: Nc.depth_vert, fragmentShader: Nc.depth_frag }, normal: { uniforms: yc([Bc.common, Bc.bumpmap, Bc.normalmap, Bc.displacementmap, { opacity: { value: 1 } }]), vertexShader: Nc.meshnormal_vert, fragmentShader: Nc.meshnormal_frag }, sprite: { uniforms: yc([Bc.sprite, Bc.fog]), vertexShader: Nc.sprite_vert, fragmentShader: Nc.sprite_frag }, background: { uniforms: { uvTransform: { value: new No() }, t2D: { value: null } }, vertexShader: Nc.background_vert, fragmentShader: Nc.background_frag }, cube: { uniforms: yc([Bc.envmap, { opacity: { value: 1 } }]), vertexShader: Nc.cube_vert, fragmentShader: Nc.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: Nc.equirect_vert, fragmentShader: Nc.equirect_frag }, distanceRGBA: { uniforms: yc([Bc.common, Bc.displacementmap, { referencePosition: { value: new pa() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: Nc.distanceRGBA_vert, fragmentShader: Nc.distanceRGBA_frag }, shadow: { uniforms: yc([Bc.lights, Bc.fog, { color: { value: new $o(0) }, opacity: { value: 1 } }]), vertexShader: Nc.shadow_vert, fragmentShader: Nc.shadow_frag } };
function Uc(t6, e2, i2, n2, r2, s2) {
  const o2 = new $o(0);
  let a2, l2, c2 = true === r2 ? 0 : 1, h2 = null, u2 = 0, d2 = null;
  function p2(t7, e3) {
    i2.buffers.color.setClear(t7.r, t7.g, t7.b, e3, s2);
  }
  return { getClearColor: function() {
    return o2;
  }, setClearColor: function(t7, e3 = 1) {
    o2.set(t7), c2 = e3, p2(o2, c2);
  }, getClearAlpha: function() {
    return c2;
  }, setClearAlpha: function(t7) {
    c2 = t7, p2(o2, c2);
  }, render: function(i3, r3) {
    let s3 = false, f2 = true === r3.isScene ? r3.background : null;
    f2 && f2.isTexture && (f2 = e2.get(f2));
    const m2 = t6.xr, g2 = m2.getSession && m2.getSession();
    g2 && "additive" === g2.environmentBlendMode && (f2 = null), null === f2 ? p2(o2, c2) : f2 && f2.isColor && (p2(f2, 1), s3 = true), (t6.autoClear || s3) && t6.clear(t6.autoClearColor, t6.autoClearDepth, t6.autoClearStencil), f2 && (f2.isCubeTexture || f2.mapping === mr) ? (void 0 === l2 && (l2 = new fc(new gc(1, 1, 1), new bc({ name: "BackgroundCubeMaterial", uniforms: vc(kc.cube.uniforms), vertexShader: kc.cube.vertexShader, fragmentShader: kc.cube.fragmentShader, side: wn, depthTest: false, depthWrite: false, fog: false })), l2.geometry.deleteAttribute("normal"), l2.geometry.deleteAttribute("uv"), l2.onBeforeRender = function(t7, e3, i4) {
      this.matrixWorld.copyPosition(i4.matrixWorld);
    }, Object.defineProperty(l2.material, "envMap", { get: function() {
      return this.uniforms.envMap.value;
    } }), n2.update(l2)), l2.material.uniforms.envMap.value = f2, l2.material.uniforms.flipEnvMap.value = f2.isCubeTexture && false === f2.isRenderTargetTexture ? -1 : 1, h2 === f2 && u2 === f2.version && d2 === t6.toneMapping || (l2.material.needsUpdate = true, h2 = f2, u2 = f2.version, d2 = t6.toneMapping), l2.layers.enableAll(), i3.unshift(l2, l2.geometry, l2.material, 0, 0, null)) : f2 && f2.isTexture && (void 0 === a2 && (a2 = new fc(new Fc(2, 2), new bc({ name: "BackgroundMaterial", uniforms: vc(kc.background.uniforms), vertexShader: kc.background.vertexShader, fragmentShader: kc.background.fragmentShader, side: bn, depthTest: false, depthWrite: false, fog: false })), a2.geometry.deleteAttribute("normal"), Object.defineProperty(a2.material, "map", { get: function() {
      return this.uniforms.t2D.value;
    } }), n2.update(a2)), a2.material.uniforms.t2D.value = f2, true === f2.matrixAutoUpdate && f2.updateMatrix(), a2.material.uniforms.uvTransform.value.copy(f2.matrix), h2 === f2 && u2 === f2.version && d2 === t6.toneMapping || (a2.material.needsUpdate = true, h2 = f2, u2 = f2.version, d2 = t6.toneMapping), a2.layers.enableAll(), i3.unshift(a2, a2.geometry, a2.material, 0, 0, null));
  } };
}
function Hc(t6, e2, i2, n2) {
  const r2 = t6.getParameter(34921), s2 = n2.isWebGL2 ? null : e2.get("OES_vertex_array_object"), o2 = n2.isWebGL2 || null !== s2, a2 = {}, l2 = p2(null);
  let c2 = l2, h2 = false;
  function u2(e3) {
    return n2.isWebGL2 ? t6.bindVertexArray(e3) : s2.bindVertexArrayOES(e3);
  }
  function d2(e3) {
    return n2.isWebGL2 ? t6.deleteVertexArray(e3) : s2.deleteVertexArrayOES(e3);
  }
  function p2(t7) {
    const e3 = [], i3 = [], n3 = [];
    for (let t8 = 0; t8 < r2; t8++) e3[t8] = 0, i3[t8] = 0, n3[t8] = 0;
    return { geometry: null, program: null, wireframe: false, newAttributes: e3, enabledAttributes: i3, attributeDivisors: n3, object: t7, attributes: {}, index: null };
  }
  function f2() {
    const t7 = c2.newAttributes;
    for (let e3 = 0, i3 = t7.length; e3 < i3; e3++) t7[e3] = 0;
  }
  function m2(t7) {
    g2(t7, 0);
  }
  function g2(i3, r3) {
    const s3 = c2.newAttributes, o3 = c2.enabledAttributes, a3 = c2.attributeDivisors;
    if (s3[i3] = 1, 0 === o3[i3] && (t6.enableVertexAttribArray(i3), o3[i3] = 1), a3[i3] !== r3) {
      (n2.isWebGL2 ? t6 : e2.get("ANGLE_instanced_arrays"))[n2.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i3, r3), a3[i3] = r3;
    }
  }
  function v2() {
    const e3 = c2.newAttributes, i3 = c2.enabledAttributes;
    for (let n3 = 0, r3 = i3.length; n3 < r3; n3++) i3[n3] !== e3[n3] && (t6.disableVertexAttribArray(n3), i3[n3] = 0);
  }
  function y2(e3, i3, r3, s3, o3, a3) {
    true !== n2.isWebGL2 || 5124 !== r3 && 5125 !== r3 ? t6.vertexAttribPointer(e3, i3, r3, s3, o3, a3) : t6.vertexAttribIPointer(e3, i3, r3, o3, a3);
  }
  function x2() {
    b2(), h2 = true, c2 !== l2 && (c2 = l2, u2(c2.object));
  }
  function b2() {
    l2.geometry = null, l2.program = null, l2.wireframe = false;
  }
  return { setup: function(r3, l3, d3, x3, b3) {
    let w2 = false;
    if (o2) {
      const e3 = (function(e4, i3, r4) {
        const o3 = true === r4.wireframe;
        let l4 = a2[e4.id];
        void 0 === l4 && (l4 = {}, a2[e4.id] = l4);
        let c3 = l4[i3.id];
        void 0 === c3 && (c3 = {}, l4[i3.id] = c3);
        let h3 = c3[o3];
        void 0 === h3 && (h3 = p2(n2.isWebGL2 ? t6.createVertexArray() : s2.createVertexArrayOES()), c3[o3] = h3);
        return h3;
      })(x3, d3, l3);
      c2 !== e3 && (c2 = e3, u2(c2.object)), w2 = (function(t7, e4, i3, n3) {
        const r4 = c2.attributes, s3 = e4.attributes;
        let o3 = 0;
        const a3 = i3.getAttributes();
        for (const e5 in a3) {
          if (a3[e5].location >= 0) {
            const i4 = r4[e5];
            let n4 = s3[e5];
            if (void 0 === n4 && ("instanceMatrix" === e5 && t7.instanceMatrix && (n4 = t7.instanceMatrix), "instanceColor" === e5 && t7.instanceColor && (n4 = t7.instanceColor)), void 0 === i4) return true;
            if (i4.attribute !== n4) return true;
            if (n4 && i4.data !== n4.data) return true;
            o3++;
          }
        }
        return c2.attributesNum !== o3 || c2.index !== n3;
      })(r3, x3, d3, b3), w2 && (function(t7, e4, i3, n3) {
        const r4 = {}, s3 = e4.attributes;
        let o3 = 0;
        const a3 = i3.getAttributes();
        for (const e5 in a3) {
          if (a3[e5].location >= 0) {
            let i4 = s3[e5];
            void 0 === i4 && ("instanceMatrix" === e5 && t7.instanceMatrix && (i4 = t7.instanceMatrix), "instanceColor" === e5 && t7.instanceColor && (i4 = t7.instanceColor));
            const n4 = {};
            n4.attribute = i4, i4 && i4.data && (n4.data = i4.data), r4[e5] = n4, o3++;
          }
        }
        c2.attributes = r4, c2.attributesNum = o3, c2.index = n3;
      })(r3, x3, d3, b3);
    } else {
      const t7 = true === l3.wireframe;
      c2.geometry === x3.id && c2.program === d3.id && c2.wireframe === t7 || (c2.geometry = x3.id, c2.program = d3.id, c2.wireframe = t7, w2 = true);
    }
    null !== b3 && i2.update(b3, 34963), (w2 || h2) && (h2 = false, (function(r4, s3, o3, a3) {
      if (false === n2.isWebGL2 && (r4.isInstancedMesh || a3.isInstancedBufferGeometry) && null === e2.get("ANGLE_instanced_arrays")) return;
      f2();
      const l4 = a3.attributes, c3 = o3.getAttributes(), h3 = s3.defaultAttributeValues;
      for (const e3 in c3) {
        const n3 = c3[e3];
        if (n3.location >= 0) {
          let s4 = l4[e3];
          if (void 0 === s4 && ("instanceMatrix" === e3 && r4.instanceMatrix && (s4 = r4.instanceMatrix), "instanceColor" === e3 && r4.instanceColor && (s4 = r4.instanceColor)), void 0 !== s4) {
            const e4 = s4.normalized, o4 = s4.itemSize, l5 = i2.get(s4);
            if (void 0 === l5) continue;
            const c4 = l5.buffer, h4 = l5.type, u3 = l5.bytesPerElement;
            if (s4.isInterleavedBufferAttribute) {
              const i3 = s4.data, l6 = i3.stride, d4 = s4.offset;
              if (i3.isInstancedInterleavedBuffer) {
                for (let t7 = 0; t7 < n3.locationSize; t7++) g2(n3.location + t7, i3.meshPerAttribute);
                true !== r4.isInstancedMesh && void 0 === a3._maxInstanceCount && (a3._maxInstanceCount = i3.meshPerAttribute * i3.count);
              } else for (let t7 = 0; t7 < n3.locationSize; t7++) m2(n3.location + t7);
              t6.bindBuffer(34962, c4);
              for (let t7 = 0; t7 < n3.locationSize; t7++) y2(n3.location + t7, o4 / n3.locationSize, h4, e4, l6 * u3, (d4 + o4 / n3.locationSize * t7) * u3);
            } else {
              if (s4.isInstancedBufferAttribute) {
                for (let t7 = 0; t7 < n3.locationSize; t7++) g2(n3.location + t7, s4.meshPerAttribute);
                true !== r4.isInstancedMesh && void 0 === a3._maxInstanceCount && (a3._maxInstanceCount = s4.meshPerAttribute * s4.count);
              } else for (let t7 = 0; t7 < n3.locationSize; t7++) m2(n3.location + t7);
              t6.bindBuffer(34962, c4);
              for (let t7 = 0; t7 < n3.locationSize; t7++) y2(n3.location + t7, o4 / n3.locationSize, h4, e4, o4 * u3, o4 / n3.locationSize * t7 * u3);
            }
          } else if (void 0 !== h3) {
            const i3 = h3[e3];
            if (void 0 !== i3) switch (i3.length) {
              case 2:
                t6.vertexAttrib2fv(n3.location, i3);
                break;
              case 3:
                t6.vertexAttrib3fv(n3.location, i3);
                break;
              case 4:
                t6.vertexAttrib4fv(n3.location, i3);
                break;
              default:
                t6.vertexAttrib1fv(n3.location, i3);
            }
          }
        }
      }
      v2();
    })(r3, l3, d3, x3), null !== b3 && t6.bindBuffer(34963, i2.get(b3).buffer));
  }, reset: x2, resetDefaultState: b2, dispose: function() {
    x2();
    for (const t7 in a2) {
      const e3 = a2[t7];
      for (const t8 in e3) {
        const i3 = e3[t8];
        for (const t9 in i3) d2(i3[t9].object), delete i3[t9];
        delete e3[t8];
      }
      delete a2[t7];
    }
  }, releaseStatesOfGeometry: function(t7) {
    if (void 0 === a2[t7.id]) return;
    const e3 = a2[t7.id];
    for (const t8 in e3) {
      const i3 = e3[t8];
      for (const t9 in i3) d2(i3[t9].object), delete i3[t9];
      delete e3[t8];
    }
    delete a2[t7.id];
  }, releaseStatesOfProgram: function(t7) {
    for (const e3 in a2) {
      const i3 = a2[e3];
      if (void 0 === i3[t7.id]) continue;
      const n3 = i3[t7.id];
      for (const t8 in n3) d2(n3[t8].object), delete n3[t8];
      delete i3[t7.id];
    }
  }, initAttributes: f2, enableAttribute: m2, disableUnusedAttributes: v2 };
}
function Vc(t6, e2, i2, n2) {
  const r2 = n2.isWebGL2;
  let s2;
  this.setMode = function(t7) {
    s2 = t7;
  }, this.render = function(e3, n3) {
    t6.drawArrays(s2, e3, n3), i2.update(n3, s2, 1);
  }, this.renderInstances = function(n3, o2, a2) {
    if (0 === a2) return;
    let l2, c2;
    if (r2) l2 = t6, c2 = "drawArraysInstanced";
    else if (l2 = e2.get("ANGLE_instanced_arrays"), c2 = "drawArraysInstancedANGLE", null === l2) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
    l2[c2](s2, n3, o2, a2), i2.update(o2, s2, a2);
  };
}
function jc(t6, e2, i2) {
  let n2;
  function r2(e3) {
    if ("highp" === e3) {
      if (t6.getShaderPrecisionFormat(35633, 36338).precision > 0 && t6.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
      e3 = "mediump";
    }
    return "mediump" === e3 && t6.getShaderPrecisionFormat(35633, 36337).precision > 0 && t6.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
  }
  const s2 = "undefined" != typeof WebGL2RenderingContext && t6 instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t6 instanceof WebGL2ComputeRenderingContext;
  let o2 = void 0 !== i2.precision ? i2.precision : "highp";
  const a2 = r2(o2);
  a2 !== o2 && (console.warn("THREE.WebGLRenderer:", o2, "not supported, using", a2, "instead."), o2 = a2);
  const l2 = s2 || e2.has("WEBGL_draw_buffers"), c2 = true === i2.logarithmicDepthBuffer, h2 = t6.getParameter(34930), u2 = t6.getParameter(35660), d2 = t6.getParameter(3379), p2 = t6.getParameter(34076), f2 = t6.getParameter(34921), m2 = t6.getParameter(36347), g2 = t6.getParameter(36348), v2 = t6.getParameter(36349), y2 = u2 > 0, x2 = s2 || e2.has("OES_texture_float");
  return { isWebGL2: s2, drawBuffers: l2, getMaxAnisotropy: function() {
    if (void 0 !== n2) return n2;
    if (true === e2.has("EXT_texture_filter_anisotropic")) {
      const i3 = e2.get("EXT_texture_filter_anisotropic");
      n2 = t6.getParameter(i3.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else n2 = 0;
    return n2;
  }, getMaxPrecision: r2, precision: o2, logarithmicDepthBuffer: c2, maxTextures: h2, maxVertexTextures: u2, maxTextureSize: d2, maxCubemapSize: p2, maxAttributes: f2, maxVertexUniforms: m2, maxVaryings: g2, maxFragmentUniforms: v2, vertexTextures: y2, floatFragmentTextures: x2, floatVertexTextures: y2 && x2, maxSamples: s2 ? t6.getParameter(36183) : 0 };
}
function Gc(t6) {
  const e2 = this;
  let i2 = null, n2 = 0, r2 = false, s2 = false;
  const o2 = new Pc(), a2 = new No(), l2 = { value: null, needsUpdate: false };
  function c2() {
    l2.value !== i2 && (l2.value = i2, l2.needsUpdate = n2 > 0), e2.numPlanes = n2, e2.numIntersection = 0;
  }
  function h2(t7, i3, n3, r3) {
    const s3 = null !== t7 ? t7.length : 0;
    let c3 = null;
    if (0 !== s3) {
      if (c3 = l2.value, true !== r3 || null === c3) {
        const e3 = n3 + 4 * s3, r4 = i3.matrixWorldInverse;
        a2.getNormalMatrix(r4), (null === c3 || c3.length < e3) && (c3 = new Float32Array(e3));
        for (let e4 = 0, i4 = n3; e4 !== s3; ++e4, i4 += 4) o2.copy(t7[e4]).applyMatrix4(r4, a2), o2.normal.toArray(c3, i4), c3[i4 + 3] = o2.constant;
      }
      l2.value = c3, l2.needsUpdate = true;
    }
    return e2.numPlanes = s3, e2.numIntersection = 0, c3;
  }
  this.uniform = l2, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t7, e3, s3) {
    const o3 = 0 !== t7.length || e3 || 0 !== n2 || r2;
    return r2 = e3, i2 = h2(t7, s3, 0), n2 = t7.length, o3;
  }, this.beginShadows = function() {
    s2 = true, h2(null);
  }, this.endShadows = function() {
    s2 = false, c2();
  }, this.setState = function(e3, o3, a3) {
    const u2 = e3.clippingPlanes, d2 = e3.clipIntersection, p2 = e3.clipShadows, f2 = t6.get(e3);
    if (!r2 || null === u2 || 0 === u2.length || s2 && !p2) s2 ? h2(null) : c2();
    else {
      const t7 = s2 ? 0 : n2, e4 = 4 * t7;
      let r3 = f2.clippingState || null;
      l2.value = r3, r3 = h2(u2, o3, e4, a3);
      for (let t8 = 0; t8 !== e4; ++t8) r3[t8] = i2[t8];
      f2.clippingState = r3, this.numIntersection = d2 ? this.numPlanes : 0, this.numPlanes += t7;
    }
  };
}
function Wc(t6) {
  let e2 = /* @__PURE__ */ new WeakMap();
  function i2(t7, e3) {
    return e3 === pr ? t7.mapping = ur : e3 === fr && (t7.mapping = dr), t7;
  }
  function n2(t7) {
    const i3 = t7.target;
    i3.removeEventListener("dispose", n2);
    const r2 = e2.get(i3);
    void 0 !== r2 && (e2.delete(i3), r2.dispose());
  }
  return { get: function(r2) {
    if (r2 && r2.isTexture && false === r2.isRenderTargetTexture) {
      const s2 = r2.mapping;
      if (s2 === pr || s2 === fr) {
        if (e2.has(r2)) {
          return i2(e2.get(r2).texture, r2.mapping);
        }
        {
          const s3 = r2.image;
          if (s3 && s3.height > 0) {
            const o2 = new Ec(s3.height / 2);
            return o2.fromEquirectangularTexture(t6, r2), e2.set(r2, o2), r2.addEventListener("dispose", n2), i2(o2.texture, r2.mapping);
          }
          return null;
        }
      }
    }
    return r2;
  }, dispose: function() {
    e2 = /* @__PURE__ */ new WeakMap();
  } };
}
kc.physical = { uniforms: yc([kc.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new Fo(1, 1) }, clearcoatNormalMap: { value: null }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, sheen: { value: 0 }, sheenColor: { value: new $o(0) }, sheenColorMap: { value: null }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionSamplerSize: { value: new Fo() }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, attenuationDistance: { value: 0 }, attenuationColor: { value: new $o(0) }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularColor: { value: new $o(1, 1, 1) }, specularColorMap: { value: null } }]), vertexShader: Nc.meshphysical_vert, fragmentShader: Nc.meshphysical_frag };
var qc = class extends wc {
  constructor(t6 = -1, e2 = 1, i2 = 1, n2 = -1, r2 = 0.1, s2 = 2e3) {
    super(), this.isOrthographicCamera = true, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t6, this.right = e2, this.top = i2, this.bottom = n2, this.near = r2, this.far = s2, this.updateProjectionMatrix();
  }
  copy(t6, e2) {
    return super.copy(t6, e2), this.left = t6.left, this.right = t6.right, this.top = t6.top, this.bottom = t6.bottom, this.near = t6.near, this.far = t6.far, this.zoom = t6.zoom, this.view = null === t6.view ? null : Object.assign({}, t6.view), this;
  }
  setViewOffset(t6, e2, i2, n2, r2, s2) {
    null === this.view && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = t6, this.view.fullHeight = e2, this.view.offsetX = i2, this.view.offsetY = n2, this.view.width = r2, this.view.height = s2, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    null !== this.view && (this.view.enabled = false), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const t6 = (this.right - this.left) / (2 * this.zoom), e2 = (this.top - this.bottom) / (2 * this.zoom), i2 = (this.right + this.left) / 2, n2 = (this.top + this.bottom) / 2;
    let r2 = i2 - t6, s2 = i2 + t6, o2 = n2 + e2, a2 = n2 - e2;
    if (null !== this.view && this.view.enabled) {
      const t7 = (this.right - this.left) / this.view.fullWidth / this.zoom, e3 = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      r2 += t7 * this.view.offsetX, s2 = r2 + t7 * this.view.width, o2 -= e3 * this.view.offsetY, a2 = o2 - e3 * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(r2, s2, o2, a2, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(t6) {
    const e2 = super.toJSON(t6);
    return e2.object.zoom = this.zoom, e2.object.left = this.left, e2.object.right = this.right, e2.object.top = this.top, e2.object.bottom = this.bottom, e2.object.near = this.near, e2.object.far = this.far, null !== this.view && (e2.object.view = Object.assign({}, this.view)), e2;
  }
};
var Xc = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
var Yc = 20;
var Zc = new qc();
var Jc = new $o();
var Kc = null;
var $c = (1 + Math.sqrt(5)) / 2;
var Qc = 1 / $c;
var th = [new pa(1, 1, 1), new pa(-1, 1, 1), new pa(1, 1, -1), new pa(-1, 1, -1), new pa(0, $c, Qc), new pa(0, $c, -Qc), new pa(Qc, 0, $c), new pa(-Qc, 0, $c), new pa($c, Qc, 0), new pa(-$c, Qc, 0)];
var eh = class {
  constructor(t6) {
    this._renderer = t6, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  fromScene(t6, e2 = 0, i2 = 0.1, n2 = 100) {
    Kc = this._renderer.getRenderTarget(), this._setSize(256);
    const r2 = this._allocateTargets();
    return r2.depthBuffer = true, this._sceneToCubeUV(t6, i2, n2, r2), e2 > 0 && this._blur(r2, 0, 0, e2), this._applyPMREM(r2), this._cleanup(r2), r2;
  }
  fromEquirectangular(t6, e2 = null) {
    return this._fromTexture(t6, e2);
  }
  fromCubemap(t6, e2 = null) {
    return this._fromTexture(t6, e2);
  }
  compileCubemapShader() {
    null === this._cubemapMaterial && (this._cubemapMaterial = sh(), this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    null === this._equirectMaterial && (this._equirectMaterial = rh(), this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose();
  }
  _setSize(t6) {
    this._lodMax = Math.floor(Math.log2(t6)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
    for (let t6 = 0; t6 < this._lodPlanes.length; t6++) this._lodPlanes[t6].dispose();
  }
  _cleanup(t6) {
    this._renderer.setRenderTarget(Kc), t6.scissorTest = false, nh(t6, 0, 0, t6.width, t6.height);
  }
  _fromTexture(t6, e2) {
    t6.mapping === ur || t6.mapping === dr ? this._setSize(0 === t6.image.length ? 16 : t6.image[0].width || t6.image[0].image.width) : this._setSize(t6.image.width / 4), Kc = this._renderer.getRenderTarget();
    const i2 = e2 || this._allocateTargets();
    return this._textureToCubeUV(t6, i2), this._applyPMREM(i2), this._cleanup(i2), i2;
  }
  _allocateTargets() {
    const t6 = 3 * Math.max(this._cubeSize, 112), e2 = 4 * this._cubeSize, i2 = { magFilter: Mr, minFilter: Mr, generateMipmaps: false, type: Fr, format: Vr, encoding: Bs, depthBuffer: false }, n2 = ih(t6, e2, i2);
    if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== t6) {
      null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = ih(t6, e2, i2);
      const { _lodMax: n3 } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = (function(t7) {
        const e3 = [], i3 = [], n4 = [];
        let r2 = t7;
        const s2 = t7 - 4 + 1 + Xc.length;
        for (let o2 = 0; o2 < s2; o2++) {
          const s3 = Math.pow(2, r2);
          i3.push(s3);
          let a2 = 1 / s3;
          o2 > t7 - 4 ? a2 = Xc[o2 - t7 + 4 - 1] : 0 === o2 && (a2 = 0), n4.push(a2);
          const l2 = 1 / (s3 - 2), c2 = -l2, h2 = 1 + l2, u2 = [c2, c2, h2, c2, h2, h2, c2, c2, h2, h2, c2, h2], d2 = 6, p2 = 6, f2 = 3, m2 = 2, g2 = 1, v2 = new Float32Array(f2 * p2 * d2), y2 = new Float32Array(m2 * p2 * d2), x2 = new Float32Array(g2 * p2 * d2);
          for (let t8 = 0; t8 < d2; t8++) {
            const e4 = t8 % 3 * 2 / 3 - 1, i4 = t8 > 2 ? 0 : -1, n5 = [e4, i4, 0, e4 + 2 / 3, i4, 0, e4 + 2 / 3, i4 + 1, 0, e4, i4, 0, e4 + 2 / 3, i4 + 1, 0, e4, i4 + 1, 0];
            v2.set(n5, f2 * p2 * t8), y2.set(u2, m2 * p2 * t8);
            const r3 = [t8, t8, t8, t8, t8, t8];
            x2.set(r3, g2 * p2 * t8);
          }
          const b2 = new Jl();
          b2.setAttribute("position", new Il(v2, f2)), b2.setAttribute("uv", new Il(y2, m2)), b2.setAttribute("faceIndex", new Il(x2, g2)), e3.push(b2), r2 > 4 && r2--;
        }
        return { lodPlanes: e3, sizeLods: i3, sigmas: n4 };
      })(n3)), this._blurMaterial = (function(t7, e3, i3) {
        const n4 = new Float32Array(Yc), r2 = new pa(0, 1, 0), s2 = new bc({ name: "SphericalGaussianBlur", defines: { n: Yc, CUBEUV_TEXEL_WIDTH: 1 / e3, CUBEUV_TEXEL_HEIGHT: 1 / i3, CUBEUV_MAX_MIP: `${t7}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: n4 }, latitudinal: { value: false }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: r2 } }, vertexShader: oh(), fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n			uniform int samples;\n			uniform float weights[ n ];\n			uniform bool latitudinal;\n			uniform float dTheta;\n			uniform float mipInt;\n			uniform vec3 poleAxis;\n\n			#define ENVMAP_TYPE_CUBE_UV\n			#include <cube_uv_reflection_fragment>\n\n			vec3 getSample( float theta, vec3 axis ) {\n\n				float cosTheta = cos( theta );\n				// Rodrigues' axis-angle rotation\n				vec3 sampleDirection = vOutputDirection * cosTheta\n					+ cross( axis, vOutputDirection ) * sin( theta )\n					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n				return bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n			}\n\n			void main() {\n\n				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n				}\n\n				axis = normalize( axis );\n\n				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n				for ( int i = 1; i < n; i++ ) {\n\n					if ( i >= samples ) {\n\n						break;\n\n					}\n\n					float theta = dTheta * float( i );\n					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n				}\n\n			}\n		", blending: Tn, depthTest: false, depthWrite: false });
        return s2;
      })(n3, t6, e2);
    }
    return n2;
  }
  _compileMaterial(t6) {
    const e2 = new fc(this._lodPlanes[0], t6);
    this._renderer.compile(e2, Zc);
  }
  _sceneToCubeUV(t6, e2, i2, n2) {
    const r2 = new _c(90, 1, e2, i2), s2 = [1, -1, 1, 1, 1, 1], o2 = [1, 1, 1, -1, -1, -1], a2 = this._renderer, l2 = a2.autoClear, c2 = a2.toneMapping;
    a2.getClearColor(Jc), a2.toneMapping = rr, a2.autoClear = false;
    const h2 = new Rl({ name: "PMREM.Background", side: wn, depthWrite: false, depthTest: false }), u2 = new fc(new gc(), h2);
    let d2 = false;
    const p2 = t6.background;
    p2 ? p2.isColor && (h2.color.copy(p2), t6.background = null, d2 = true) : (h2.color.copy(Jc), d2 = true);
    for (let e3 = 0; e3 < 6; e3++) {
      const i3 = e3 % 3;
      0 === i3 ? (r2.up.set(0, s2[e3], 0), r2.lookAt(o2[e3], 0, 0)) : 1 === i3 ? (r2.up.set(0, 0, s2[e3]), r2.lookAt(0, o2[e3], 0)) : (r2.up.set(0, s2[e3], 0), r2.lookAt(0, 0, o2[e3]));
      const l3 = this._cubeSize;
      nh(n2, i3 * l3, e3 > 2 ? l3 : 0, l3, l3), a2.setRenderTarget(n2), d2 && a2.render(u2, r2), a2.render(t6, r2);
    }
    u2.geometry.dispose(), u2.material.dispose(), a2.toneMapping = c2, a2.autoClear = l2, t6.background = p2;
  }
  _textureToCubeUV(t6, e2) {
    const i2 = this._renderer, n2 = t6.mapping === ur || t6.mapping === dr;
    n2 ? (null === this._cubemapMaterial && (this._cubemapMaterial = sh()), this._cubemapMaterial.uniforms.flipEnvMap.value = false === t6.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = rh());
    const r2 = n2 ? this._cubemapMaterial : this._equirectMaterial, s2 = new fc(this._lodPlanes[0], r2);
    r2.uniforms.envMap.value = t6;
    const o2 = this._cubeSize;
    nh(e2, 0, 0, 3 * o2, 2 * o2), i2.setRenderTarget(e2), i2.render(s2, Zc);
  }
  _applyPMREM(t6) {
    const e2 = this._renderer, i2 = e2.autoClear;
    e2.autoClear = false;
    for (let e3 = 1; e3 < this._lodPlanes.length; e3++) {
      const i3 = Math.sqrt(this._sigmas[e3] * this._sigmas[e3] - this._sigmas[e3 - 1] * this._sigmas[e3 - 1]), n2 = th[(e3 - 1) % th.length];
      this._blur(t6, e3 - 1, e3, i3, n2);
    }
    e2.autoClear = i2;
  }
  _blur(t6, e2, i2, n2, r2) {
    const s2 = this._pingPongRenderTarget;
    this._halfBlur(t6, s2, e2, i2, n2, "latitudinal", r2), this._halfBlur(s2, t6, i2, i2, n2, "longitudinal", r2);
  }
  _halfBlur(t6, e2, i2, n2, r2, s2, o2) {
    const a2 = this._renderer, l2 = this._blurMaterial;
    "latitudinal" !== s2 && "longitudinal" !== s2 && console.error("blur direction must be either latitudinal or longitudinal!");
    const c2 = new fc(this._lodPlanes[n2], l2), h2 = l2.uniforms, u2 = this._sizeLods[i2] - 1, d2 = isFinite(r2) ? Math.PI / (2 * u2) : 2 * Math.PI / 39, p2 = r2 / d2, f2 = isFinite(r2) ? 1 + Math.floor(3 * p2) : Yc;
    f2 > Yc && console.warn(`sigmaRadians, ${r2}, is too large and will clip, as it requested ${f2} samples when the maximum is set to 20`);
    const m2 = [];
    let g2 = 0;
    for (let t7 = 0; t7 < Yc; ++t7) {
      const e3 = t7 / p2, i3 = Math.exp(-e3 * e3 / 2);
      m2.push(i3), 0 === t7 ? g2 += i3 : t7 < f2 && (g2 += 2 * i3);
    }
    for (let t7 = 0; t7 < m2.length; t7++) m2[t7] = m2[t7] / g2;
    h2.envMap.value = t6.texture, h2.samples.value = f2, h2.weights.value = m2, h2.latitudinal.value = "latitudinal" === s2, o2 && (h2.poleAxis.value = o2);
    const { _lodMax: v2 } = this;
    h2.dTheta.value = d2, h2.mipInt.value = v2 - i2;
    const y2 = this._sizeLods[n2];
    nh(e2, 3 * y2 * (n2 > v2 - 4 ? n2 - v2 + 4 : 0), 4 * (this._cubeSize - y2), 3 * y2, 2 * y2), a2.setRenderTarget(e2), a2.render(c2, Zc);
  }
};
function ih(t6, e2, i2) {
  const n2 = new oa(t6, e2, i2);
  return n2.texture.mapping = mr, n2.texture.name = "PMREM.cubeUv", n2.scissorTest = true, n2;
}
function nh(t6, e2, i2, n2, r2) {
  t6.viewport.set(e2, i2, n2, r2), t6.scissor.set(e2, i2, n2, r2);
}
function rh() {
  return new bc({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: oh(), fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n\n			#include <common>\n\n			void main() {\n\n				vec3 outputDirection = normalize( vOutputDirection );\n				vec2 uv = equirectUv( outputDirection );\n\n				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n			}\n		", blending: Tn, depthTest: false, depthWrite: false });
}
function sh() {
  return new bc({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: oh(), fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			uniform float flipEnvMap;\n\n			varying vec3 vOutputDirection;\n\n			uniform samplerCube envMap;\n\n			void main() {\n\n				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n			}\n		", blending: Tn, depthTest: false, depthWrite: false });
}
function oh() {
  return "\n\n		precision mediump float;\n		precision mediump int;\n\n		attribute float faceIndex;\n\n		varying vec3 vOutputDirection;\n\n		// RH coordinate system; PMREM face-indexing convention\n		vec3 getDirection( vec2 uv, float face ) {\n\n			uv = 2.0 * uv - 1.0;\n\n			vec3 direction = vec3( uv, 1.0 );\n\n			if ( face == 0.0 ) {\n\n				direction = direction.zyx; // ( 1, v, u ) pos x\n\n			} else if ( face == 1.0 ) {\n\n				direction = direction.xzy;\n				direction.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n			} else if ( face == 2.0 ) {\n\n				direction.x *= -1.0; // ( -u, v, 1 ) pos z\n\n			} else if ( face == 3.0 ) {\n\n				direction = direction.zyx;\n				direction.xz *= -1.0; // ( -1, v, -u ) neg x\n\n			} else if ( face == 4.0 ) {\n\n				direction = direction.xzy;\n				direction.xy *= -1.0; // ( -u, -1, v ) neg y\n\n			} else if ( face == 5.0 ) {\n\n				direction.z *= -1.0; // ( u, v, -1 ) neg z\n\n			}\n\n			return direction;\n\n		}\n\n		void main() {\n\n			vOutputDirection = getDirection( uv, faceIndex );\n			gl_Position = vec4( position, 1.0 );\n\n		}\n	";
}
function ah(t6) {
  let e2 = /* @__PURE__ */ new WeakMap(), i2 = null;
  function n2(t7) {
    const i3 = t7.target;
    i3.removeEventListener("dispose", n2);
    const r2 = e2.get(i3);
    void 0 !== r2 && (e2.delete(i3), r2.dispose());
  }
  return { get: function(r2) {
    if (r2 && r2.isTexture) {
      const s2 = r2.mapping, o2 = s2 === pr || s2 === fr, a2 = s2 === ur || s2 === dr;
      if (o2 || a2) {
        if (r2.isRenderTargetTexture && true === r2.needsPMREMUpdate) {
          r2.needsPMREMUpdate = false;
          let n3 = e2.get(r2);
          return null === i2 && (i2 = new eh(t6)), n3 = o2 ? i2.fromEquirectangular(r2, n3) : i2.fromCubemap(r2, n3), e2.set(r2, n3), n3.texture;
        }
        if (e2.has(r2)) return e2.get(r2).texture;
        {
          const s3 = r2.image;
          if (o2 && s3 && s3.height > 0 || a2 && s3 && (function(t7) {
            let e3 = 0;
            const i3 = 6;
            for (let n3 = 0; n3 < i3; n3++) void 0 !== t7[n3] && e3++;
            return e3 === i3;
          })(s3)) {
            null === i2 && (i2 = new eh(t6));
            const s4 = o2 ? i2.fromEquirectangular(r2) : i2.fromCubemap(r2);
            return e2.set(r2, s4), r2.addEventListener("dispose", n2), s4.texture;
          }
          return null;
        }
      }
    }
    return r2;
  }, dispose: function() {
    e2 = /* @__PURE__ */ new WeakMap(), null !== i2 && (i2.dispose(), i2 = null);
  } };
}
function lh(t6) {
  const e2 = {};
  function i2(i3) {
    if (void 0 !== e2[i3]) return e2[i3];
    let n2;
    switch (i3) {
      case "WEBGL_depth_texture":
        n2 = t6.getExtension("WEBGL_depth_texture") || t6.getExtension("MOZ_WEBGL_depth_texture") || t6.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        n2 = t6.getExtension("EXT_texture_filter_anisotropic") || t6.getExtension("MOZ_EXT_texture_filter_anisotropic") || t6.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        n2 = t6.getExtension("WEBGL_compressed_texture_s3tc") || t6.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t6.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        n2 = t6.getExtension("WEBGL_compressed_texture_pvrtc") || t6.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        n2 = t6.getExtension(i3);
    }
    return e2[i3] = n2, n2;
  }
  return { has: function(t7) {
    return null !== i2(t7);
  }, init: function(t7) {
    t7.isWebGL2 ? i2("EXT_color_buffer_float") : (i2("WEBGL_depth_texture"), i2("OES_texture_float"), i2("OES_texture_half_float"), i2("OES_texture_half_float_linear"), i2("OES_standard_derivatives"), i2("OES_element_index_uint"), i2("OES_vertex_array_object"), i2("ANGLE_instanced_arrays")), i2("OES_texture_float_linear"), i2("EXT_color_buffer_half_float"), i2("WEBGL_multisampled_render_to_texture");
  }, get: function(t7) {
    const e3 = i2(t7);
    return null === e3 && console.warn("THREE.WebGLRenderer: " + t7 + " extension not supported."), e3;
  } };
}
function ch(t6, e2, i2, n2) {
  const r2 = {}, s2 = /* @__PURE__ */ new WeakMap();
  function o2(t7) {
    const a3 = t7.target;
    null !== a3.index && e2.remove(a3.index);
    for (const t8 in a3.attributes) e2.remove(a3.attributes[t8]);
    a3.removeEventListener("dispose", o2), delete r2[a3.id];
    const l2 = s2.get(a3);
    l2 && (e2.remove(l2), s2.delete(a3)), n2.releaseStatesOfGeometry(a3), true === a3.isInstancedBufferGeometry && delete a3._maxInstanceCount, i2.memory.geometries--;
  }
  function a2(t7) {
    const i3 = [], n3 = t7.index, r3 = t7.attributes.position;
    let o3 = 0;
    if (null !== n3) {
      const t8 = n3.array;
      o3 = n3.version;
      for (let e3 = 0, n4 = t8.length; e3 < n4; e3 += 3) {
        const n5 = t8[e3 + 0], r4 = t8[e3 + 1], s3 = t8[e3 + 2];
        i3.push(n5, r4, r4, s3, s3, n5);
      }
    } else {
      const t8 = r3.array;
      o3 = r3.version;
      for (let e3 = 0, n4 = t8.length / 3 - 1; e3 < n4; e3 += 3) {
        const t9 = e3 + 0, n5 = e3 + 1, r4 = e3 + 2;
        i3.push(t9, n5, n5, r4, r4, t9);
      }
    }
    const a3 = new (Bo(i3) ? kl : Nl)(i3, 1);
    a3.version = o3;
    const l2 = s2.get(t7);
    l2 && e2.remove(l2), s2.set(t7, a3);
  }
  return { get: function(t7, e3) {
    return true === r2[e3.id] || (e3.addEventListener("dispose", o2), r2[e3.id] = true, i2.memory.geometries++), e3;
  }, update: function(t7) {
    const i3 = t7.attributes;
    for (const t8 in i3) e2.update(i3[t8], 34962);
    const n3 = t7.morphAttributes;
    for (const t8 in n3) {
      const i4 = n3[t8];
      for (let t9 = 0, n4 = i4.length; t9 < n4; t9++) e2.update(i4[t9], 34962);
    }
  }, getWireframeAttribute: function(t7) {
    const e3 = s2.get(t7);
    if (e3) {
      const i3 = t7.index;
      null !== i3 && e3.version < i3.version && a2(t7);
    } else a2(t7);
    return s2.get(t7);
  } };
}
function hh(t6, e2, i2, n2) {
  const r2 = n2.isWebGL2;
  let s2, o2, a2;
  this.setMode = function(t7) {
    s2 = t7;
  }, this.setIndex = function(t7) {
    o2 = t7.type, a2 = t7.bytesPerElement;
  }, this.render = function(e3, n3) {
    t6.drawElements(s2, n3, o2, e3 * a2), i2.update(n3, s2, 1);
  }, this.renderInstances = function(n3, l2, c2) {
    if (0 === c2) return;
    let h2, u2;
    if (r2) h2 = t6, u2 = "drawElementsInstanced";
    else if (h2 = e2.get("ANGLE_instanced_arrays"), u2 = "drawElementsInstancedANGLE", null === h2) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
    h2[u2](s2, l2, o2, n3 * a2, c2), i2.update(l2, s2, c2);
  };
}
function uh(t6) {
  const e2 = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  return { memory: { geometries: 0, textures: 0 }, render: e2, programs: null, autoReset: true, reset: function() {
    e2.frame++, e2.calls = 0, e2.triangles = 0, e2.points = 0, e2.lines = 0;
  }, update: function(t7, i2, n2) {
    switch (e2.calls++, i2) {
      case 4:
        e2.triangles += n2 * (t7 / 3);
        break;
      case 1:
        e2.lines += n2 * (t7 / 2);
        break;
      case 3:
        e2.lines += n2 * (t7 - 1);
        break;
      case 2:
        e2.lines += n2 * t7;
        break;
      case 0:
        e2.points += n2 * t7;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", i2);
    }
  } };
}
function dh(t6, e2) {
  return t6[0] - e2[0];
}
function ph(t6, e2) {
  return Math.abs(e2[1]) - Math.abs(t6[1]);
}
function fh(t6, e2) {
  let i2 = 1;
  const n2 = e2.isInterleavedBufferAttribute ? e2.data.array : e2.array;
  n2 instanceof Int8Array ? i2 = 127 : n2 instanceof Uint8Array ? i2 = 255 : n2 instanceof Uint16Array ? i2 = 65535 : n2 instanceof Int16Array ? i2 = 32767 : n2 instanceof Int32Array ? i2 = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", n2), t6.divideScalar(i2);
}
function mh(t6, e2, i2) {
  const n2 = {}, r2 = new Float32Array(8), s2 = /* @__PURE__ */ new WeakMap(), o2 = new sa(), a2 = [];
  for (let t7 = 0; t7 < 8; t7++) a2[t7] = [t7, 0];
  return { update: function(l2, c2, h2, u2) {
    const d2 = l2.morphTargetInfluences;
    if (true === e2.isWebGL2) {
      const p2 = c2.morphAttributes.position || c2.morphAttributes.normal || c2.morphAttributes.color, f2 = void 0 !== p2 ? p2.length : 0;
      let m2 = s2.get(c2);
      if (void 0 === m2 || m2.count !== f2) {
        let P2 = function() {
          C2.dispose(), s2.delete(c2), c2.removeEventListener("dispose", P2);
        };
        void 0 !== m2 && m2.texture.dispose();
        const y2 = void 0 !== c2.morphAttributes.position, x2 = void 0 !== c2.morphAttributes.normal, b2 = void 0 !== c2.morphAttributes.color, w2 = c2.morphAttributes.position || [], _2 = c2.morphAttributes.normal || [], S2 = c2.morphAttributes.color || [];
        let M2 = 0;
        true === y2 && (M2 = 1), true === x2 && (M2 = 2), true === b2 && (M2 = 3);
        let T2 = c2.attributes.position.count * M2, E2 = 1;
        T2 > e2.maxTextureSize && (E2 = Math.ceil(T2 / e2.maxTextureSize), T2 = e2.maxTextureSize);
        const A2 = new Float32Array(T2 * E2 * 4 * f2), C2 = new aa(A2, T2, E2, f2);
        C2.type = zr, C2.needsUpdate = true;
        const R2 = 4 * M2;
        for (let L2 = 0; L2 < f2; L2++) {
          const I2 = w2[L2], D2 = _2[L2], O2 = S2[L2], z2 = T2 * E2 * 4 * L2;
          for (let F2 = 0; F2 < I2.count; F2++) {
            const N2 = F2 * R2;
            true === y2 && (o2.fromBufferAttribute(I2, F2), true === I2.normalized && fh(o2, I2), A2[z2 + N2 + 0] = o2.x, A2[z2 + N2 + 1] = o2.y, A2[z2 + N2 + 2] = o2.z, A2[z2 + N2 + 3] = 0), true === x2 && (o2.fromBufferAttribute(D2, F2), true === D2.normalized && fh(o2, D2), A2[z2 + N2 + 4] = o2.x, A2[z2 + N2 + 5] = o2.y, A2[z2 + N2 + 6] = o2.z, A2[z2 + N2 + 7] = 0), true === b2 && (o2.fromBufferAttribute(O2, F2), true === O2.normalized && fh(o2, O2), A2[z2 + N2 + 8] = o2.x, A2[z2 + N2 + 9] = o2.y, A2[z2 + N2 + 10] = o2.z, A2[z2 + N2 + 11] = 4 === O2.itemSize ? o2.w : 1);
          }
        }
        m2 = { count: f2, texture: C2, size: new Fo(T2, E2) }, s2.set(c2, m2), c2.addEventListener("dispose", P2);
      }
      let g2 = 0;
      for (let B2 = 0; B2 < d2.length; B2++) g2 += d2[B2];
      const v2 = c2.morphTargetsRelative ? 1 : 1 - g2;
      u2.getUniforms().setValue(t6, "morphTargetBaseInfluence", v2), u2.getUniforms().setValue(t6, "morphTargetInfluences", d2), u2.getUniforms().setValue(t6, "morphTargetsTexture", m2.texture, i2), u2.getUniforms().setValue(t6, "morphTargetsTextureSize", m2.size);
    } else {
      const k2 = void 0 === d2 ? 0 : d2.length;
      let U2 = n2[c2.id];
      if (void 0 === U2 || U2.length !== k2) {
        U2 = [];
        for (let W2 = 0; W2 < k2; W2++) U2[W2] = [W2, 0];
        n2[c2.id] = U2;
      }
      for (let q2 = 0; q2 < k2; q2++) {
        const X2 = U2[q2];
        X2[0] = q2, X2[1] = d2[q2];
      }
      U2.sort(ph);
      for (let Y2 = 0; Y2 < 8; Y2++) Y2 < k2 && U2[Y2][1] ? (a2[Y2][0] = U2[Y2][0], a2[Y2][1] = U2[Y2][1]) : (a2[Y2][0] = Number.MAX_SAFE_INTEGER, a2[Y2][1] = 0);
      a2.sort(dh);
      const H2 = c2.morphAttributes.position, V2 = c2.morphAttributes.normal;
      let j2 = 0;
      for (let Z2 = 0; Z2 < 8; Z2++) {
        const J2 = a2[Z2], K2 = J2[0], $2 = J2[1];
        K2 !== Number.MAX_SAFE_INTEGER && $2 ? (H2 && c2.getAttribute("morphTarget" + Z2) !== H2[K2] && c2.setAttribute("morphTarget" + Z2, H2[K2]), V2 && c2.getAttribute("morphNormal" + Z2) !== V2[K2] && c2.setAttribute("morphNormal" + Z2, V2[K2]), r2[Z2] = $2, j2 += $2) : (H2 && true === c2.hasAttribute("morphTarget" + Z2) && c2.deleteAttribute("morphTarget" + Z2), V2 && true === c2.hasAttribute("morphNormal" + Z2) && c2.deleteAttribute("morphNormal" + Z2), r2[Z2] = 0);
      }
      const G2 = c2.morphTargetsRelative ? 1 : 1 - j2;
      u2.getUniforms().setValue(t6, "morphTargetBaseInfluence", G2), u2.getUniforms().setValue(t6, "morphTargetInfluences", r2);
    }
  } };
}
function gh(t6, e2, i2, n2) {
  let r2 = /* @__PURE__ */ new WeakMap();
  function s2(t7) {
    const e3 = t7.target;
    e3.removeEventListener("dispose", s2), i2.remove(e3.instanceMatrix), null !== e3.instanceColor && i2.remove(e3.instanceColor);
  }
  return { update: function(t7) {
    const o2 = n2.render.frame, a2 = t7.geometry, l2 = e2.get(t7, a2);
    return r2.get(l2) !== o2 && (e2.update(l2), r2.set(l2, o2)), t7.isInstancedMesh && (false === t7.hasEventListener("dispose", s2) && t7.addEventListener("dispose", s2), i2.update(t7.instanceMatrix, 34962), null !== t7.instanceColor && i2.update(t7.instanceColor, 34962)), l2;
  }, dispose: function() {
    r2 = /* @__PURE__ */ new WeakMap();
  } };
}
var vh = new ra();
var yh = new aa();
var xh = new ca();
var bh = new Tc();
var wh = [];
var _h = [];
var Sh = new Float32Array(16);
var Mh = new Float32Array(9);
var Th = new Float32Array(4);
function Eh(t6, e2, i2) {
  const n2 = t6[0];
  if (n2 <= 0 || n2 > 0) return t6;
  const r2 = e2 * i2;
  let s2 = wh[r2];
  if (void 0 === s2 && (s2 = new Float32Array(r2), wh[r2] = s2), 0 !== e2) {
    n2.toArray(s2, 0);
    for (let n3 = 1, r3 = 0; n3 !== e2; ++n3) r3 += i2, t6[n3].toArray(s2, r3);
  }
  return s2;
}
function Ah(t6, e2) {
  if (t6.length !== e2.length) return false;
  for (let i2 = 0, n2 = t6.length; i2 < n2; i2++) if (t6[i2] !== e2[i2]) return false;
  return true;
}
function Ch(t6, e2) {
  for (let i2 = 0, n2 = e2.length; i2 < n2; i2++) t6[i2] = e2[i2];
}
function Rh(t6, e2) {
  let i2 = _h[e2];
  void 0 === i2 && (i2 = new Int32Array(e2), _h[e2] = i2);
  for (let n2 = 0; n2 !== e2; ++n2) i2[n2] = t6.allocateTextureUnit();
  return i2;
}
function Ph(t6, e2) {
  const i2 = this.cache;
  i2[0] !== e2 && (t6.uniform1f(this.addr, e2), i2[0] = e2);
}
function Lh(t6, e2) {
  const i2 = this.cache;
  if (void 0 !== e2.x) i2[0] === e2.x && i2[1] === e2.y || (t6.uniform2f(this.addr, e2.x, e2.y), i2[0] = e2.x, i2[1] = e2.y);
  else {
    if (Ah(i2, e2)) return;
    t6.uniform2fv(this.addr, e2), Ch(i2, e2);
  }
}
function Ih(t6, e2) {
  const i2 = this.cache;
  if (void 0 !== e2.x) i2[0] === e2.x && i2[1] === e2.y && i2[2] === e2.z || (t6.uniform3f(this.addr, e2.x, e2.y, e2.z), i2[0] = e2.x, i2[1] = e2.y, i2[2] = e2.z);
  else if (void 0 !== e2.r) i2[0] === e2.r && i2[1] === e2.g && i2[2] === e2.b || (t6.uniform3f(this.addr, e2.r, e2.g, e2.b), i2[0] = e2.r, i2[1] = e2.g, i2[2] = e2.b);
  else {
    if (Ah(i2, e2)) return;
    t6.uniform3fv(this.addr, e2), Ch(i2, e2);
  }
}
function Dh(t6, e2) {
  const i2 = this.cache;
  if (void 0 !== e2.x) i2[0] === e2.x && i2[1] === e2.y && i2[2] === e2.z && i2[3] === e2.w || (t6.uniform4f(this.addr, e2.x, e2.y, e2.z, e2.w), i2[0] = e2.x, i2[1] = e2.y, i2[2] = e2.z, i2[3] = e2.w);
  else {
    if (Ah(i2, e2)) return;
    t6.uniform4fv(this.addr, e2), Ch(i2, e2);
  }
}
function Oh(t6, e2) {
  const i2 = this.cache, n2 = e2.elements;
  if (void 0 === n2) {
    if (Ah(i2, e2)) return;
    t6.uniformMatrix2fv(this.addr, false, e2), Ch(i2, e2);
  } else {
    if (Ah(i2, n2)) return;
    Th.set(n2), t6.uniformMatrix2fv(this.addr, false, Th), Ch(i2, n2);
  }
}
function zh(t6, e2) {
  const i2 = this.cache, n2 = e2.elements;
  if (void 0 === n2) {
    if (Ah(i2, e2)) return;
    t6.uniformMatrix3fv(this.addr, false, e2), Ch(i2, e2);
  } else {
    if (Ah(i2, n2)) return;
    Mh.set(n2), t6.uniformMatrix3fv(this.addr, false, Mh), Ch(i2, n2);
  }
}
function Fh(t6, e2) {
  const i2 = this.cache, n2 = e2.elements;
  if (void 0 === n2) {
    if (Ah(i2, e2)) return;
    t6.uniformMatrix4fv(this.addr, false, e2), Ch(i2, e2);
  } else {
    if (Ah(i2, n2)) return;
    Sh.set(n2), t6.uniformMatrix4fv(this.addr, false, Sh), Ch(i2, n2);
  }
}
function Nh(t6, e2) {
  const i2 = this.cache;
  i2[0] !== e2 && (t6.uniform1i(this.addr, e2), i2[0] = e2);
}
function Bh(t6, e2) {
  const i2 = this.cache;
  Ah(i2, e2) || (t6.uniform2iv(this.addr, e2), Ch(i2, e2));
}
function kh(t6, e2) {
  const i2 = this.cache;
  Ah(i2, e2) || (t6.uniform3iv(this.addr, e2), Ch(i2, e2));
}
function Uh(t6, e2) {
  const i2 = this.cache;
  Ah(i2, e2) || (t6.uniform4iv(this.addr, e2), Ch(i2, e2));
}
function Hh(t6, e2) {
  const i2 = this.cache;
  i2[0] !== e2 && (t6.uniform1ui(this.addr, e2), i2[0] = e2);
}
function Vh(t6, e2) {
  const i2 = this.cache;
  Ah(i2, e2) || (t6.uniform2uiv(this.addr, e2), Ch(i2, e2));
}
function jh(t6, e2) {
  const i2 = this.cache;
  Ah(i2, e2) || (t6.uniform3uiv(this.addr, e2), Ch(i2, e2));
}
function Gh(t6, e2) {
  const i2 = this.cache;
  Ah(i2, e2) || (t6.uniform4uiv(this.addr, e2), Ch(i2, e2));
}
function Wh(t6, e2, i2) {
  const n2 = this.cache, r2 = i2.allocateTextureUnit();
  n2[0] !== r2 && (t6.uniform1i(this.addr, r2), n2[0] = r2), i2.setTexture2D(e2 || vh, r2);
}
function qh(t6, e2, i2) {
  const n2 = this.cache, r2 = i2.allocateTextureUnit();
  n2[0] !== r2 && (t6.uniform1i(this.addr, r2), n2[0] = r2), i2.setTexture3D(e2 || xh, r2);
}
function Xh(t6, e2, i2) {
  const n2 = this.cache, r2 = i2.allocateTextureUnit();
  n2[0] !== r2 && (t6.uniform1i(this.addr, r2), n2[0] = r2), i2.setTextureCube(e2 || bh, r2);
}
function Yh(t6, e2, i2) {
  const n2 = this.cache, r2 = i2.allocateTextureUnit();
  n2[0] !== r2 && (t6.uniform1i(this.addr, r2), n2[0] = r2), i2.setTexture2DArray(e2 || yh, r2);
}
function Zh(t6, e2) {
  t6.uniform1fv(this.addr, e2);
}
function Jh(t6, e2) {
  const i2 = Eh(e2, this.size, 2);
  t6.uniform2fv(this.addr, i2);
}
function Kh(t6, e2) {
  const i2 = Eh(e2, this.size, 3);
  t6.uniform3fv(this.addr, i2);
}
function $h(t6, e2) {
  const i2 = Eh(e2, this.size, 4);
  t6.uniform4fv(this.addr, i2);
}
function Qh(t6, e2) {
  const i2 = Eh(e2, this.size, 4);
  t6.uniformMatrix2fv(this.addr, false, i2);
}
function tu(t6, e2) {
  const i2 = Eh(e2, this.size, 9);
  t6.uniformMatrix3fv(this.addr, false, i2);
}
function eu(t6, e2) {
  const i2 = Eh(e2, this.size, 16);
  t6.uniformMatrix4fv(this.addr, false, i2);
}
function iu(t6, e2) {
  t6.uniform1iv(this.addr, e2);
}
function nu(t6, e2) {
  t6.uniform2iv(this.addr, e2);
}
function ru(t6, e2) {
  t6.uniform3iv(this.addr, e2);
}
function su(t6, e2) {
  t6.uniform4iv(this.addr, e2);
}
function ou(t6, e2) {
  t6.uniform1uiv(this.addr, e2);
}
function au(t6, e2) {
  t6.uniform2uiv(this.addr, e2);
}
function lu(t6, e2) {
  t6.uniform3uiv(this.addr, e2);
}
function cu(t6, e2) {
  t6.uniform4uiv(this.addr, e2);
}
function hu(t6, e2, i2) {
  const n2 = e2.length, r2 = Rh(i2, n2);
  t6.uniform1iv(this.addr, r2);
  for (let t7 = 0; t7 !== n2; ++t7) i2.setTexture2D(e2[t7] || vh, r2[t7]);
}
function uu(t6, e2, i2) {
  const n2 = e2.length, r2 = Rh(i2, n2);
  t6.uniform1iv(this.addr, r2);
  for (let t7 = 0; t7 !== n2; ++t7) i2.setTexture3D(e2[t7] || xh, r2[t7]);
}
function du(t6, e2, i2) {
  const n2 = e2.length, r2 = Rh(i2, n2);
  t6.uniform1iv(this.addr, r2);
  for (let t7 = 0; t7 !== n2; ++t7) i2.setTextureCube(e2[t7] || bh, r2[t7]);
}
function pu(t6, e2, i2) {
  const n2 = e2.length, r2 = Rh(i2, n2);
  t6.uniform1iv(this.addr, r2);
  for (let t7 = 0; t7 !== n2; ++t7) i2.setTexture2DArray(e2[t7] || yh, r2[t7]);
}
var fu = class {
  constructor(t6, e2, i2) {
    this.id = t6, this.addr = i2, this.cache = [], this.setValue = (function(t7) {
      switch (t7) {
        case 5126:
          return Ph;
        case 35664:
          return Lh;
        case 35665:
          return Ih;
        case 35666:
          return Dh;
        case 35674:
          return Oh;
        case 35675:
          return zh;
        case 35676:
          return Fh;
        case 5124:
        case 35670:
          return Nh;
        case 35667:
        case 35671:
          return Bh;
        case 35668:
        case 35672:
          return kh;
        case 35669:
        case 35673:
          return Uh;
        case 5125:
          return Hh;
        case 36294:
          return Vh;
        case 36295:
          return jh;
        case 36296:
          return Gh;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return Wh;
        case 35679:
        case 36299:
        case 36307:
          return qh;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return Xh;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
          return Yh;
      }
    })(e2.type);
  }
};
var mu = class {
  constructor(t6, e2, i2) {
    this.id = t6, this.addr = i2, this.cache = [], this.size = e2.size, this.setValue = (function(t7) {
      switch (t7) {
        case 5126:
          return Zh;
        case 35664:
          return Jh;
        case 35665:
          return Kh;
        case 35666:
          return $h;
        case 35674:
          return Qh;
        case 35675:
          return tu;
        case 35676:
          return eu;
        case 5124:
        case 35670:
          return iu;
        case 35667:
        case 35671:
          return nu;
        case 35668:
        case 35672:
          return ru;
        case 35669:
        case 35673:
          return su;
        case 5125:
          return ou;
        case 36294:
          return au;
        case 36295:
          return lu;
        case 36296:
          return cu;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return hu;
        case 35679:
        case 36299:
        case 36307:
          return uu;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return du;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
          return pu;
      }
    })(e2.type);
  }
};
var gu = class {
  constructor(t6) {
    this.id = t6, this.seq = [], this.map = {};
  }
  setValue(t6, e2, i2) {
    const n2 = this.seq;
    for (let r2 = 0, s2 = n2.length; r2 !== s2; ++r2) {
      const s3 = n2[r2];
      s3.setValue(t6, e2[s3.id], i2);
    }
  }
};
var vu = /(\w+)(\])?(\[|\.)?/g;
function yu(t6, e2) {
  t6.seq.push(e2), t6.map[e2.id] = e2;
}
function xu(t6, e2, i2) {
  const n2 = t6.name, r2 = n2.length;
  for (vu.lastIndex = 0; ; ) {
    const s2 = vu.exec(n2), o2 = vu.lastIndex;
    let a2 = s2[1];
    const l2 = "]" === s2[2], c2 = s2[3];
    if (l2 && (a2 |= 0), void 0 === c2 || "[" === c2 && o2 + 2 === r2) {
      yu(i2, void 0 === c2 ? new fu(a2, t6, e2) : new mu(a2, t6, e2));
      break;
    }
    {
      let t7 = i2.map[a2];
      void 0 === t7 && (t7 = new gu(a2), yu(i2, t7)), i2 = t7;
    }
  }
}
var bu = class {
  constructor(t6, e2) {
    this.seq = [], this.map = {};
    const i2 = t6.getProgramParameter(e2, 35718);
    for (let n2 = 0; n2 < i2; ++n2) {
      const i3 = t6.getActiveUniform(e2, n2);
      xu(i3, t6.getUniformLocation(e2, i3.name), this);
    }
  }
  setValue(t6, e2, i2, n2) {
    const r2 = this.map[e2];
    void 0 !== r2 && r2.setValue(t6, i2, n2);
  }
  setOptional(t6, e2, i2) {
    const n2 = e2[i2];
    void 0 !== n2 && this.setValue(t6, i2, n2);
  }
  static upload(t6, e2, i2, n2) {
    for (let r2 = 0, s2 = e2.length; r2 !== s2; ++r2) {
      const s3 = e2[r2], o2 = i2[s3.id];
      false !== o2.needsUpdate && s3.setValue(t6, o2.value, n2);
    }
  }
  static seqWithValue(t6, e2) {
    const i2 = [];
    for (let n2 = 0, r2 = t6.length; n2 !== r2; ++n2) {
      const r3 = t6[n2];
      r3.id in e2 && i2.push(r3);
    }
    return i2;
  }
};
function wu(t6, e2, i2) {
  const n2 = t6.createShader(e2);
  return t6.shaderSource(n2, i2), t6.compileShader(n2), n2;
}
var _u = 0;
function Su(t6, e2, i2) {
  const n2 = t6.getShaderParameter(e2, 35713), r2 = t6.getShaderInfoLog(e2).trim();
  if (n2 && "" === r2) return "";
  const s2 = /ERROR: 0:(\d+)/.exec(r2);
  if (s2) {
    const n3 = parseInt(s2[1]);
    return i2.toUpperCase() + "\n\n" + r2 + "\n\n" + (function(t7, e3) {
      const i3 = t7.split("\n"), n4 = [], r3 = Math.max(e3 - 6, 0), s3 = Math.min(e3 + 6, i3.length);
      for (let t8 = r3; t8 < s3; t8++) {
        const r4 = t8 + 1;
        n4.push(`${r4 === e3 ? ">" : " "} ${r4}: ${i3[t8]}`);
      }
      return n4.join("\n");
    })(t6.getShaderSource(e2), n3);
  }
  return r2;
}
function Mu(t6, e2) {
  const i2 = (function(t7) {
    switch (t7) {
      case Bs:
        return ["Linear", "( value )"];
      case ks:
        return ["sRGB", "( value )"];
      default:
        return console.warn("THREE.WebGLProgram: Unsupported encoding:", t7), ["Linear", "( value )"];
    }
  })(e2);
  return "vec4 " + t6 + "( vec4 value ) { return LinearTo" + i2[0] + i2[1] + "; }";
}
function Tu(t6, e2) {
  let i2;
  switch (e2) {
    case sr:
      i2 = "Linear";
      break;
    case or:
      i2 = "Reinhard";
      break;
    case ar:
      i2 = "OptimizedCineon";
      break;
    case lr:
      i2 = "ACESFilmic";
      break;
    case cr:
      i2 = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e2), i2 = "Linear";
  }
  return "vec3 " + t6 + "( vec3 color ) { return " + i2 + "ToneMapping( color ); }";
}
function Eu(t6) {
  return "" !== t6;
}
function Au(t6, e2) {
  return t6.replace(/NUM_DIR_LIGHTS/g, e2.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e2.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e2.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e2.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e2.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e2.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e2.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e2.numPointLightShadows);
}
function Cu(t6, e2) {
  return t6.replace(/NUM_CLIPPING_PLANES/g, e2.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e2.numClippingPlanes - e2.numClipIntersection);
}
var Ru = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Pu(t6) {
  return t6.replace(Ru, Lu);
}
function Lu(t6, e2) {
  const i2 = Nc[e2];
  if (void 0 === i2) throw new Error("Can not resolve #include <" + e2 + ">");
  return Pu(i2);
}
var Iu = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
var Du = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Ou(t6) {
  return t6.replace(Du, Fu).replace(Iu, zu);
}
function zu(t6, e2, i2, n2) {
  return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Fu(t6, e2, i2, n2);
}
function Fu(t6, e2, i2, n2) {
  let r2 = "";
  for (let t7 = parseInt(e2); t7 < parseInt(i2); t7++) r2 += n2.replace(/\[\s*i\s*\]/g, "[ " + t7 + " ]").replace(/UNROLLED_LOOP_INDEX/g, t7);
  return r2;
}
function Nu(t6) {
  let e2 = "precision " + t6.precision + " float;\nprecision " + t6.precision + " int;";
  return "highp" === t6.precision ? e2 += "\n#define HIGH_PRECISION" : "mediump" === t6.precision ? e2 += "\n#define MEDIUM_PRECISION" : "lowp" === t6.precision && (e2 += "\n#define LOW_PRECISION"), e2;
}
function Bu(t6, e2, i2, n2) {
  const r2 = t6.getContext(), s2 = i2.defines;
  let o2 = i2.vertexShader, a2 = i2.fragmentShader;
  const l2 = (function(t7) {
    let e3 = "SHADOWMAP_TYPE_BASIC";
    return t7.shadowMapType === vn ? e3 = "SHADOWMAP_TYPE_PCF" : t7.shadowMapType === yn ? e3 = "SHADOWMAP_TYPE_PCF_SOFT" : t7.shadowMapType === xn && (e3 = "SHADOWMAP_TYPE_VSM"), e3;
  })(i2), c2 = (function(t7) {
    let e3 = "ENVMAP_TYPE_CUBE";
    if (t7.envMap) switch (t7.envMapMode) {
      case ur:
      case dr:
        e3 = "ENVMAP_TYPE_CUBE";
        break;
      case mr:
        e3 = "ENVMAP_TYPE_CUBE_UV";
    }
    return e3;
  })(i2), h2 = (function(t7) {
    let e3 = "ENVMAP_MODE_REFLECTION";
    t7.envMap && t7.envMapMode === dr && (e3 = "ENVMAP_MODE_REFRACTION");
    return e3;
  })(i2), u2 = (function(t7) {
    let e3 = "ENVMAP_BLENDING_NONE";
    if (t7.envMap) switch (t7.combine) {
      case er:
        e3 = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case ir:
        e3 = "ENVMAP_BLENDING_MIX";
        break;
      case nr:
        e3 = "ENVMAP_BLENDING_ADD";
    }
    return e3;
  })(i2), d2 = (function(t7) {
    const e3 = t7.envMapCubeUVHeight;
    if (null === e3) return null;
    const i3 = Math.log2(e3) - 2, n3 = 1 / e3;
    return { texelWidth: 1 / (3 * Math.max(Math.pow(2, i3), 112)), texelHeight: n3, maxMip: i3 };
  })(i2), p2 = i2.isWebGL2 ? "" : (function(t7) {
    return [t7.extensionDerivatives || t7.envMapCubeUVHeight || t7.bumpMap || t7.tangentSpaceNormalMap || t7.clearcoatNormalMap || t7.flatShading || "physical" === t7.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t7.extensionFragDepth || t7.logarithmicDepthBuffer) && t7.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t7.extensionDrawBuffers && t7.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t7.extensionShaderTextureLOD || t7.envMap || t7.transmission) && t7.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Eu).join("\n");
  })(i2), f2 = (function(t7) {
    const e3 = [];
    for (const i3 in t7) {
      const n3 = t7[i3];
      false !== n3 && e3.push("#define " + i3 + " " + n3);
    }
    return e3.join("\n");
  })(s2), m2 = r2.createProgram();
  let g2, v2, y2 = i2.glslVersion ? "#version " + i2.glslVersion + "\n" : "";
  i2.isRawShaderMaterial ? (g2 = [f2].filter(Eu).join("\n"), g2.length > 0 && (g2 += "\n"), v2 = [p2, f2].filter(Eu).join("\n"), v2.length > 0 && (v2 += "\n")) : (g2 = [Nu(i2), "#define SHADER_NAME " + i2.shaderName, f2, i2.instancing ? "#define USE_INSTANCING" : "", i2.instancingColor ? "#define USE_INSTANCING_COLOR" : "", i2.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", i2.useFog && i2.fog ? "#define USE_FOG" : "", i2.useFog && i2.fogExp2 ? "#define FOG_EXP2" : "", i2.map ? "#define USE_MAP" : "", i2.envMap ? "#define USE_ENVMAP" : "", i2.envMap ? "#define " + h2 : "", i2.lightMap ? "#define USE_LIGHTMAP" : "", i2.aoMap ? "#define USE_AOMAP" : "", i2.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i2.bumpMap ? "#define USE_BUMPMAP" : "", i2.normalMap ? "#define USE_NORMALMAP" : "", i2.normalMap && i2.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i2.normalMap && i2.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i2.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i2.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i2.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i2.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", i2.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", i2.displacementMap && i2.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", i2.specularMap ? "#define USE_SPECULARMAP" : "", i2.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", i2.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", i2.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i2.metalnessMap ? "#define USE_METALNESSMAP" : "", i2.alphaMap ? "#define USE_ALPHAMAP" : "", i2.transmission ? "#define USE_TRANSMISSION" : "", i2.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i2.thicknessMap ? "#define USE_THICKNESSMAP" : "", i2.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", i2.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", i2.vertexTangents ? "#define USE_TANGENT" : "", i2.vertexColors ? "#define USE_COLOR" : "", i2.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i2.vertexUvs ? "#define USE_UV" : "", i2.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i2.flatShading ? "#define FLAT_SHADED" : "", i2.skinning ? "#define USE_SKINNING" : "", i2.morphTargets ? "#define USE_MORPHTARGETS" : "", i2.morphNormals && false === i2.flatShading ? "#define USE_MORPHNORMALS" : "", i2.morphColors && i2.isWebGL2 ? "#define USE_MORPHCOLORS" : "", i2.morphTargetsCount > 0 && i2.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", i2.morphTargetsCount > 0 && i2.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + i2.morphTextureStride : "", i2.morphTargetsCount > 0 && i2.isWebGL2 ? "#define MORPHTARGETS_COUNT " + i2.morphTargetsCount : "", i2.doubleSided ? "#define DOUBLE_SIDED" : "", i2.flipSided ? "#define FLIP_SIDED" : "", i2.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i2.shadowMapEnabled ? "#define " + l2 : "", i2.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", i2.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i2.logarithmicDepthBuffer && i2.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(Eu).join("\n"), v2 = [p2, Nu(i2), "#define SHADER_NAME " + i2.shaderName, f2, i2.useFog && i2.fog ? "#define USE_FOG" : "", i2.useFog && i2.fogExp2 ? "#define FOG_EXP2" : "", i2.map ? "#define USE_MAP" : "", i2.matcap ? "#define USE_MATCAP" : "", i2.envMap ? "#define USE_ENVMAP" : "", i2.envMap ? "#define " + c2 : "", i2.envMap ? "#define " + h2 : "", i2.envMap ? "#define " + u2 : "", d2 ? "#define CUBEUV_TEXEL_WIDTH " + d2.texelWidth : "", d2 ? "#define CUBEUV_TEXEL_HEIGHT " + d2.texelHeight : "", d2 ? "#define CUBEUV_MAX_MIP " + d2.maxMip + ".0" : "", i2.lightMap ? "#define USE_LIGHTMAP" : "", i2.aoMap ? "#define USE_AOMAP" : "", i2.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i2.bumpMap ? "#define USE_BUMPMAP" : "", i2.normalMap ? "#define USE_NORMALMAP" : "", i2.normalMap && i2.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i2.normalMap && i2.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i2.clearcoat ? "#define USE_CLEARCOAT" : "", i2.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i2.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i2.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i2.iridescence ? "#define USE_IRIDESCENCE" : "", i2.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", i2.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", i2.specularMap ? "#define USE_SPECULARMAP" : "", i2.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", i2.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", i2.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i2.metalnessMap ? "#define USE_METALNESSMAP" : "", i2.alphaMap ? "#define USE_ALPHAMAP" : "", i2.alphaTest ? "#define USE_ALPHATEST" : "", i2.sheen ? "#define USE_SHEEN" : "", i2.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", i2.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", i2.transmission ? "#define USE_TRANSMISSION" : "", i2.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i2.thicknessMap ? "#define USE_THICKNESSMAP" : "", i2.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", i2.vertexTangents ? "#define USE_TANGENT" : "", i2.vertexColors || i2.instancingColor ? "#define USE_COLOR" : "", i2.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i2.vertexUvs ? "#define USE_UV" : "", i2.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i2.gradientMap ? "#define USE_GRADIENTMAP" : "", i2.flatShading ? "#define FLAT_SHADED" : "", i2.doubleSided ? "#define DOUBLE_SIDED" : "", i2.flipSided ? "#define FLIP_SIDED" : "", i2.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i2.shadowMapEnabled ? "#define " + l2 : "", i2.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", i2.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", i2.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i2.logarithmicDepthBuffer && i2.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", i2.toneMapping !== rr ? "#define TONE_MAPPING" : "", i2.toneMapping !== rr ? Nc.tonemapping_pars_fragment : "", i2.toneMapping !== rr ? Tu("toneMapping", i2.toneMapping) : "", i2.dithering ? "#define DITHERING" : "", i2.opaque ? "#define OPAQUE" : "", Nc.encodings_pars_fragment, Mu("linearToOutputTexel", i2.outputEncoding), i2.useDepthPacking ? "#define DEPTH_PACKING " + i2.depthPacking : "", "\n"].filter(Eu).join("\n")), o2 = Pu(o2), o2 = Au(o2, i2), o2 = Cu(o2, i2), a2 = Pu(a2), a2 = Au(a2, i2), a2 = Cu(a2, i2), o2 = Ou(o2), a2 = Ou(a2), i2.isWebGL2 && true !== i2.isRawShaderMaterial && (y2 = "#version 300 es\n", g2 = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g2, v2 = ["#define varying in", i2.glslVersion === wo ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", i2.glslVersion === wo ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v2);
  const x2 = y2 + v2 + a2, b2 = wu(r2, 35633, y2 + g2 + o2), w2 = wu(r2, 35632, x2);
  if (r2.attachShader(m2, b2), r2.attachShader(m2, w2), void 0 !== i2.index0AttributeName ? r2.bindAttribLocation(m2, 0, i2.index0AttributeName) : true === i2.morphTargets && r2.bindAttribLocation(m2, 0, "position"), r2.linkProgram(m2), t6.debug.checkShaderErrors) {
    const t7 = r2.getProgramInfoLog(m2).trim(), e3 = r2.getShaderInfoLog(b2).trim(), i3 = r2.getShaderInfoLog(w2).trim();
    let n3 = true, s3 = true;
    if (false === r2.getProgramParameter(m2, 35714)) {
      n3 = false;
      const e4 = Su(r2, b2, "vertex"), i4 = Su(r2, w2, "fragment");
      console.error("THREE.WebGLProgram: Shader Error " + r2.getError() + " - VALIDATE_STATUS " + r2.getProgramParameter(m2, 35715) + "\n\nProgram Info Log: " + t7 + "\n" + e4 + "\n" + i4);
    } else "" !== t7 ? console.warn("THREE.WebGLProgram: Program Info Log:", t7) : "" !== e3 && "" !== i3 || (s3 = false);
    s3 && (this.diagnostics = { runnable: n3, programLog: t7, vertexShader: { log: e3, prefix: g2 }, fragmentShader: { log: i3, prefix: v2 } });
  }
  let _2, S2;
  return r2.deleteShader(b2), r2.deleteShader(w2), this.getUniforms = function() {
    return void 0 === _2 && (_2 = new bu(r2, m2)), _2;
  }, this.getAttributes = function() {
    return void 0 === S2 && (S2 = (function(t7, e3) {
      const i3 = {}, n3 = t7.getProgramParameter(e3, 35721);
      for (let r3 = 0; r3 < n3; r3++) {
        const n4 = t7.getActiveAttrib(e3, r3), s3 = n4.name;
        let o3 = 1;
        35674 === n4.type && (o3 = 2), 35675 === n4.type && (o3 = 3), 35676 === n4.type && (o3 = 4), i3[s3] = { type: n4.type, location: t7.getAttribLocation(e3, s3), locationSize: o3 };
      }
      return i3;
    })(r2, m2)), S2;
  }, this.destroy = function() {
    n2.releaseStatesOfProgram(this), r2.deleteProgram(m2), this.program = void 0;
  }, this.name = i2.shaderName, this.id = _u++, this.cacheKey = e2, this.usedTimes = 1, this.program = m2, this.vertexShader = b2, this.fragmentShader = w2, this;
}
var ku = 0;
var Uu = class {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(t6) {
    const e2 = t6.vertexShader, i2 = t6.fragmentShader, n2 = this._getShaderStage(e2), r2 = this._getShaderStage(i2), s2 = this._getShaderCacheForMaterial(t6);
    return false === s2.has(n2) && (s2.add(n2), n2.usedTimes++), false === s2.has(r2) && (s2.add(r2), r2.usedTimes++), this;
  }
  remove(t6) {
    const e2 = this.materialCache.get(t6);
    for (const t7 of e2) t7.usedTimes--, 0 === t7.usedTimes && this.shaderCache.delete(t7.code);
    return this.materialCache.delete(t6), this;
  }
  getVertexShaderID(t6) {
    return this._getShaderStage(t6.vertexShader).id;
  }
  getFragmentShaderID(t6) {
    return this._getShaderStage(t6.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(t6) {
    const e2 = this.materialCache;
    return false === e2.has(t6) && e2.set(t6, /* @__PURE__ */ new Set()), e2.get(t6);
  }
  _getShaderStage(t6) {
    const e2 = this.shaderCache;
    if (false === e2.has(t6)) {
      const i2 = new Hu(t6);
      e2.set(t6, i2);
    }
    return e2.get(t6);
  }
};
var Hu = class {
  constructor(t6) {
    this.id = ku++, this.code = t6, this.usedTimes = 0;
  }
};
function Vu(t6, e2, i2, n2, r2, s2, o2) {
  const a2 = new el(), l2 = new Uu(), c2 = [], h2 = r2.isWebGL2, u2 = r2.logarithmicDepthBuffer, d2 = r2.vertexTextures;
  let p2 = r2.precision;
  const f2 = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" };
  return { getParameters: function(s3, a3, c3, m2, g2) {
    const v2 = m2.fog, y2 = g2.geometry, x2 = s3.isMeshStandardMaterial ? m2.environment : null, b2 = (s3.isMeshStandardMaterial ? i2 : e2).get(s3.envMap || x2), w2 = b2 && b2.mapping === mr ? b2.image.height : null, _2 = f2[s3.type];
    null !== s3.precision && (p2 = r2.getMaxPrecision(s3.precision), p2 !== s3.precision && console.warn("THREE.WebGLProgram.getParameters:", s3.precision, "not supported, using", p2, "instead."));
    const S2 = y2.morphAttributes.position || y2.morphAttributes.normal || y2.morphAttributes.color, M2 = void 0 !== S2 ? S2.length : 0;
    let T2, E2, A2, C2, R2 = 0;
    if (void 0 !== y2.morphAttributes.position && (R2 = 1), void 0 !== y2.morphAttributes.normal && (R2 = 2), void 0 !== y2.morphAttributes.color && (R2 = 3), _2) {
      const t7 = kc[_2];
      T2 = t7.vertexShader, E2 = t7.fragmentShader;
    } else T2 = s3.vertexShader, E2 = s3.fragmentShader, l2.update(s3), A2 = l2.getVertexShaderID(s3), C2 = l2.getFragmentShaderID(s3);
    const P2 = t6.getRenderTarget(), L2 = s3.alphaTest > 0, I2 = s3.clearcoat > 0, D2 = s3.iridescence > 0;
    return { isWebGL2: h2, shaderID: _2, shaderName: s3.type, vertexShader: T2, fragmentShader: E2, defines: s3.defines, customVertexShaderID: A2, customFragmentShaderID: C2, isRawShaderMaterial: true === s3.isRawShaderMaterial, glslVersion: s3.glslVersion, precision: p2, instancing: true === g2.isInstancedMesh, instancingColor: true === g2.isInstancedMesh && null !== g2.instanceColor, supportsVertexTextures: d2, outputEncoding: null === P2 ? t6.outputEncoding : true === P2.isXRRenderTarget ? P2.texture.encoding : Bs, map: !!s3.map, matcap: !!s3.matcap, envMap: !!b2, envMapMode: b2 && b2.mapping, envMapCubeUVHeight: w2, lightMap: !!s3.lightMap, aoMap: !!s3.aoMap, emissiveMap: !!s3.emissiveMap, bumpMap: !!s3.bumpMap, normalMap: !!s3.normalMap, objectSpaceNormalMap: s3.normalMapType === js, tangentSpaceNormalMap: s3.normalMapType === Vs, decodeVideoTexture: !!s3.map && true === s3.map.isVideoTexture && s3.map.encoding === ks, clearcoat: I2, clearcoatMap: I2 && !!s3.clearcoatMap, clearcoatRoughnessMap: I2 && !!s3.clearcoatRoughnessMap, clearcoatNormalMap: I2 && !!s3.clearcoatNormalMap, iridescence: D2, iridescenceMap: D2 && !!s3.iridescenceMap, iridescenceThicknessMap: D2 && !!s3.iridescenceThicknessMap, displacementMap: !!s3.displacementMap, roughnessMap: !!s3.roughnessMap, metalnessMap: !!s3.metalnessMap, specularMap: !!s3.specularMap, specularIntensityMap: !!s3.specularIntensityMap, specularColorMap: !!s3.specularColorMap, opaque: false === s3.transparent && s3.blending === En, alphaMap: !!s3.alphaMap, alphaTest: L2, gradientMap: !!s3.gradientMap, sheen: s3.sheen > 0, sheenColorMap: !!s3.sheenColorMap, sheenRoughnessMap: !!s3.sheenRoughnessMap, transmission: s3.transmission > 0, transmissionMap: !!s3.transmissionMap, thicknessMap: !!s3.thicknessMap, combine: s3.combine, vertexTangents: !!s3.normalMap && !!y2.attributes.tangent, vertexColors: s3.vertexColors, vertexAlphas: true === s3.vertexColors && !!y2.attributes.color && 4 === y2.attributes.color.itemSize, vertexUvs: !!(s3.map || s3.bumpMap || s3.normalMap || s3.specularMap || s3.alphaMap || s3.emissiveMap || s3.roughnessMap || s3.metalnessMap || s3.clearcoatMap || s3.clearcoatRoughnessMap || s3.clearcoatNormalMap || s3.iridescenceMap || s3.iridescenceThicknessMap || s3.displacementMap || s3.transmissionMap || s3.thicknessMap || s3.specularIntensityMap || s3.specularColorMap || s3.sheenColorMap || s3.sheenRoughnessMap), uvsVertexOnly: !(s3.map || s3.bumpMap || s3.normalMap || s3.specularMap || s3.alphaMap || s3.emissiveMap || s3.roughnessMap || s3.metalnessMap || s3.clearcoatNormalMap || s3.iridescenceMap || s3.iridescenceThicknessMap || s3.transmission > 0 || s3.transmissionMap || s3.thicknessMap || s3.specularIntensityMap || s3.specularColorMap || s3.sheen > 0 || s3.sheenColorMap || s3.sheenRoughnessMap || !s3.displacementMap), fog: !!v2, useFog: true === s3.fog, fogExp2: v2 && v2.isFogExp2, flatShading: !!s3.flatShading, sizeAttenuation: s3.sizeAttenuation, logarithmicDepthBuffer: u2, skinning: true === g2.isSkinnedMesh, morphTargets: void 0 !== y2.morphAttributes.position, morphNormals: void 0 !== y2.morphAttributes.normal, morphColors: void 0 !== y2.morphAttributes.color, morphTargetsCount: M2, morphTextureStride: R2, numDirLights: a3.directional.length, numPointLights: a3.point.length, numSpotLights: a3.spot.length, numRectAreaLights: a3.rectArea.length, numHemiLights: a3.hemi.length, numDirLightShadows: a3.directionalShadowMap.length, numPointLightShadows: a3.pointShadowMap.length, numSpotLightShadows: a3.spotShadowMap.length, numClippingPlanes: o2.numPlanes, numClipIntersection: o2.numIntersection, dithering: s3.dithering, shadowMapEnabled: t6.shadowMap.enabled && c3.length > 0, shadowMapType: t6.shadowMap.type, toneMapping: s3.toneMapped ? t6.toneMapping : rr, physicallyCorrectLights: t6.physicallyCorrectLights, premultipliedAlpha: s3.premultipliedAlpha, doubleSided: s3.side === _n, flipSided: s3.side === wn, useDepthPacking: !!s3.depthPacking, depthPacking: s3.depthPacking || 0, index0AttributeName: s3.index0AttributeName, extensionDerivatives: s3.extensions && s3.extensions.derivatives, extensionFragDepth: s3.extensions && s3.extensions.fragDepth, extensionDrawBuffers: s3.extensions && s3.extensions.drawBuffers, extensionShaderTextureLOD: s3.extensions && s3.extensions.shaderTextureLOD, rendererExtensionFragDepth: h2 || n2.has("EXT_frag_depth"), rendererExtensionDrawBuffers: h2 || n2.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: h2 || n2.has("EXT_shader_texture_lod"), customProgramCacheKey: s3.customProgramCacheKey() };
  }, getProgramCacheKey: function(e3) {
    const i3 = [];
    if (e3.shaderID ? i3.push(e3.shaderID) : (i3.push(e3.customVertexShaderID), i3.push(e3.customFragmentShaderID)), void 0 !== e3.defines) for (const t7 in e3.defines) i3.push(t7), i3.push(e3.defines[t7]);
    return false === e3.isRawShaderMaterial && (!(function(t7, e4) {
      t7.push(e4.precision), t7.push(e4.outputEncoding), t7.push(e4.envMapMode), t7.push(e4.envMapCubeUVHeight), t7.push(e4.combine), t7.push(e4.vertexUvs), t7.push(e4.fogExp2), t7.push(e4.sizeAttenuation), t7.push(e4.morphTargetsCount), t7.push(e4.morphAttributeCount), t7.push(e4.numDirLights), t7.push(e4.numPointLights), t7.push(e4.numSpotLights), t7.push(e4.numHemiLights), t7.push(e4.numRectAreaLights), t7.push(e4.numDirLightShadows), t7.push(e4.numPointLightShadows), t7.push(e4.numSpotLightShadows), t7.push(e4.shadowMapType), t7.push(e4.toneMapping), t7.push(e4.numClippingPlanes), t7.push(e4.numClipIntersection), t7.push(e4.depthPacking);
    })(i3, e3), (function(t7, e4) {
      a2.disableAll(), e4.isWebGL2 && a2.enable(0);
      e4.supportsVertexTextures && a2.enable(1);
      e4.instancing && a2.enable(2);
      e4.instancingColor && a2.enable(3);
      e4.map && a2.enable(4);
      e4.matcap && a2.enable(5);
      e4.envMap && a2.enable(6);
      e4.lightMap && a2.enable(7);
      e4.aoMap && a2.enable(8);
      e4.emissiveMap && a2.enable(9);
      e4.bumpMap && a2.enable(10);
      e4.normalMap && a2.enable(11);
      e4.objectSpaceNormalMap && a2.enable(12);
      e4.tangentSpaceNormalMap && a2.enable(13);
      e4.clearcoat && a2.enable(14);
      e4.clearcoatMap && a2.enable(15);
      e4.clearcoatRoughnessMap && a2.enable(16);
      e4.clearcoatNormalMap && a2.enable(17);
      e4.iridescence && a2.enable(18);
      e4.iridescenceMap && a2.enable(19);
      e4.iridescenceThicknessMap && a2.enable(20);
      e4.displacementMap && a2.enable(21);
      e4.specularMap && a2.enable(22);
      e4.roughnessMap && a2.enable(23);
      e4.metalnessMap && a2.enable(24);
      e4.gradientMap && a2.enable(25);
      e4.alphaMap && a2.enable(26);
      e4.alphaTest && a2.enable(27);
      e4.vertexColors && a2.enable(28);
      e4.vertexAlphas && a2.enable(29);
      e4.vertexUvs && a2.enable(30);
      e4.vertexTangents && a2.enable(31);
      e4.uvsVertexOnly && a2.enable(32);
      e4.fog && a2.enable(33);
      t7.push(a2.mask), a2.disableAll(), e4.useFog && a2.enable(0);
      e4.flatShading && a2.enable(1);
      e4.logarithmicDepthBuffer && a2.enable(2);
      e4.skinning && a2.enable(3);
      e4.morphTargets && a2.enable(4);
      e4.morphNormals && a2.enable(5);
      e4.morphColors && a2.enable(6);
      e4.premultipliedAlpha && a2.enable(7);
      e4.shadowMapEnabled && a2.enable(8);
      e4.physicallyCorrectLights && a2.enable(9);
      e4.doubleSided && a2.enable(10);
      e4.flipSided && a2.enable(11);
      e4.useDepthPacking && a2.enable(12);
      e4.dithering && a2.enable(13);
      e4.specularIntensityMap && a2.enable(14);
      e4.specularColorMap && a2.enable(15);
      e4.transmission && a2.enable(16);
      e4.transmissionMap && a2.enable(17);
      e4.thicknessMap && a2.enable(18);
      e4.sheen && a2.enable(19);
      e4.sheenColorMap && a2.enable(20);
      e4.sheenRoughnessMap && a2.enable(21);
      e4.decodeVideoTexture && a2.enable(22);
      e4.opaque && a2.enable(23);
      t7.push(a2.mask);
    })(i3, e3), i3.push(t6.outputEncoding)), i3.push(e3.customProgramCacheKey), i3.join();
  }, getUniforms: function(t7) {
    const e3 = f2[t7.type];
    let i3;
    if (e3) {
      const t8 = kc[e3];
      i3 = xc.clone(t8.uniforms);
    } else i3 = t7.uniforms;
    return i3;
  }, acquireProgram: function(e3, i3) {
    let n3;
    for (let t7 = 0, e4 = c2.length; t7 < e4; t7++) {
      const e5 = c2[t7];
      if (e5.cacheKey === i3) {
        n3 = e5, ++n3.usedTimes;
        break;
      }
    }
    return void 0 === n3 && (n3 = new Bu(t6, i3, e3, s2), c2.push(n3)), n3;
  }, releaseProgram: function(t7) {
    if (0 == --t7.usedTimes) {
      const e3 = c2.indexOf(t7);
      c2[e3] = c2[c2.length - 1], c2.pop(), t7.destroy();
    }
  }, releaseShaderCache: function(t7) {
    l2.remove(t7);
  }, programs: c2, dispose: function() {
    l2.dispose();
  } };
}
function ju() {
  let t6 = /* @__PURE__ */ new WeakMap();
  return { get: function(e2) {
    let i2 = t6.get(e2);
    return void 0 === i2 && (i2 = {}, t6.set(e2, i2)), i2;
  }, remove: function(e2) {
    t6.delete(e2);
  }, update: function(e2, i2, n2) {
    t6.get(e2)[i2] = n2;
  }, dispose: function() {
    t6 = /* @__PURE__ */ new WeakMap();
  } };
}
function Gu(t6, e2) {
  return t6.groupOrder !== e2.groupOrder ? t6.groupOrder - e2.groupOrder : t6.renderOrder !== e2.renderOrder ? t6.renderOrder - e2.renderOrder : t6.material.id !== e2.material.id ? t6.material.id - e2.material.id : t6.z !== e2.z ? t6.z - e2.z : t6.id - e2.id;
}
function Wu(t6, e2) {
  return t6.groupOrder !== e2.groupOrder ? t6.groupOrder - e2.groupOrder : t6.renderOrder !== e2.renderOrder ? t6.renderOrder - e2.renderOrder : t6.z !== e2.z ? e2.z - t6.z : t6.id - e2.id;
}
function qu() {
  const t6 = [];
  let e2 = 0;
  const i2 = [], n2 = [], r2 = [];
  function s2(i3, n3, r3, s3, o2, a2) {
    let l2 = t6[e2];
    return void 0 === l2 ? (l2 = { id: i3.id, object: i3, geometry: n3, material: r3, groupOrder: s3, renderOrder: i3.renderOrder, z: o2, group: a2 }, t6[e2] = l2) : (l2.id = i3.id, l2.object = i3, l2.geometry = n3, l2.material = r3, l2.groupOrder = s3, l2.renderOrder = i3.renderOrder, l2.z = o2, l2.group = a2), e2++, l2;
  }
  return { opaque: i2, transmissive: n2, transparent: r2, init: function() {
    e2 = 0, i2.length = 0, n2.length = 0, r2.length = 0;
  }, push: function(t7, e3, o2, a2, l2, c2) {
    const h2 = s2(t7, e3, o2, a2, l2, c2);
    o2.transmission > 0 ? n2.push(h2) : true === o2.transparent ? r2.push(h2) : i2.push(h2);
  }, unshift: function(t7, e3, o2, a2, l2, c2) {
    const h2 = s2(t7, e3, o2, a2, l2, c2);
    o2.transmission > 0 ? n2.unshift(h2) : true === o2.transparent ? r2.unshift(h2) : i2.unshift(h2);
  }, finish: function() {
    for (let i3 = e2, n3 = t6.length; i3 < n3; i3++) {
      const e3 = t6[i3];
      if (null === e3.id) break;
      e3.id = null, e3.object = null, e3.geometry = null, e3.material = null, e3.group = null;
    }
  }, sort: function(t7, e3) {
    i2.length > 1 && i2.sort(t7 || Gu), n2.length > 1 && n2.sort(e3 || Wu), r2.length > 1 && r2.sort(e3 || Wu);
  } };
}
function Xu() {
  let t6 = /* @__PURE__ */ new WeakMap();
  return { get: function(e2, i2) {
    let n2;
    return false === t6.has(e2) ? (n2 = new qu(), t6.set(e2, [n2])) : i2 >= t6.get(e2).length ? (n2 = new qu(), t6.get(e2).push(n2)) : n2 = t6.get(e2)[i2], n2;
  }, dispose: function() {
    t6 = /* @__PURE__ */ new WeakMap();
  } };
}
function Yu() {
  const t6 = {};
  return { get: function(e2) {
    if (void 0 !== t6[e2.id]) return t6[e2.id];
    let i2;
    switch (e2.type) {
      case "DirectionalLight":
        i2 = { direction: new pa(), color: new $o() };
        break;
      case "SpotLight":
        i2 = { position: new pa(), direction: new pa(), color: new $o(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
        break;
      case "PointLight":
        i2 = { position: new pa(), color: new $o(), distance: 0, decay: 0 };
        break;
      case "HemisphereLight":
        i2 = { direction: new pa(), skyColor: new $o(), groundColor: new $o() };
        break;
      case "RectAreaLight":
        i2 = { color: new $o(), position: new pa(), halfWidth: new pa(), halfHeight: new pa() };
    }
    return t6[e2.id] = i2, i2;
  } };
}
var Zu = 0;
function Ju(t6, e2) {
  return (e2.castShadow ? 1 : 0) - (t6.castShadow ? 1 : 0);
}
function Ku(t6, e2) {
  const i2 = new Yu(), n2 = /* @__PURE__ */ (function() {
    const t7 = {};
    return { get: function(e3) {
      if (void 0 !== t7[e3.id]) return t7[e3.id];
      let i3;
      switch (e3.type) {
        case "DirectionalLight":
        case "SpotLight":
          i3 = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Fo() };
          break;
        case "PointLight":
          i3 = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Fo(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
      }
      return t7[e3.id] = i3, i3;
    } };
  })(), r2 = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] };
  for (let t7 = 0; t7 < 9; t7++) r2.probe.push(new pa());
  const s2 = new pa(), o2 = new Ga(), a2 = new Ga();
  return { setup: function(s3, o3) {
    let a3 = 0, l2 = 0, c2 = 0;
    for (let t7 = 0; t7 < 9; t7++) r2.probe[t7].set(0, 0, 0);
    let h2 = 0, u2 = 0, d2 = 0, p2 = 0, f2 = 0, m2 = 0, g2 = 0, v2 = 0;
    s3.sort(Ju);
    const y2 = true !== o3 ? Math.PI : 1;
    for (let t7 = 0, e3 = s3.length; t7 < e3; t7++) {
      const e4 = s3[t7], o4 = e4.color, x3 = e4.intensity, b2 = e4.distance, w2 = e4.shadow && e4.shadow.map ? e4.shadow.map.texture : null;
      if (e4.isAmbientLight) a3 += o4.r * x3 * y2, l2 += o4.g * x3 * y2, c2 += o4.b * x3 * y2;
      else if (e4.isLightProbe) for (let t8 = 0; t8 < 9; t8++) r2.probe[t8].addScaledVector(e4.sh.coefficients[t8], x3);
      else if (e4.isDirectionalLight) {
        const t8 = i2.get(e4);
        if (t8.color.copy(e4.color).multiplyScalar(e4.intensity * y2), e4.castShadow) {
          const t9 = e4.shadow, i3 = n2.get(e4);
          i3.shadowBias = t9.bias, i3.shadowNormalBias = t9.normalBias, i3.shadowRadius = t9.radius, i3.shadowMapSize = t9.mapSize, r2.directionalShadow[h2] = i3, r2.directionalShadowMap[h2] = w2, r2.directionalShadowMatrix[h2] = e4.shadow.matrix, m2++;
        }
        r2.directional[h2] = t8, h2++;
      } else if (e4.isSpotLight) {
        const t8 = i2.get(e4);
        if (t8.position.setFromMatrixPosition(e4.matrixWorld), t8.color.copy(o4).multiplyScalar(x3 * y2), t8.distance = b2, t8.coneCos = Math.cos(e4.angle), t8.penumbraCos = Math.cos(e4.angle * (1 - e4.penumbra)), t8.decay = e4.decay, e4.castShadow) {
          const t9 = e4.shadow, i3 = n2.get(e4);
          i3.shadowBias = t9.bias, i3.shadowNormalBias = t9.normalBias, i3.shadowRadius = t9.radius, i3.shadowMapSize = t9.mapSize, r2.spotShadow[d2] = i3, r2.spotShadowMap[d2] = w2, r2.spotShadowMatrix[d2] = e4.shadow.matrix, v2++;
        }
        r2.spot[d2] = t8, d2++;
      } else if (e4.isRectAreaLight) {
        const t8 = i2.get(e4);
        t8.color.copy(o4).multiplyScalar(x3), t8.halfWidth.set(0.5 * e4.width, 0, 0), t8.halfHeight.set(0, 0.5 * e4.height, 0), r2.rectArea[p2] = t8, p2++;
      } else if (e4.isPointLight) {
        const t8 = i2.get(e4);
        if (t8.color.copy(e4.color).multiplyScalar(e4.intensity * y2), t8.distance = e4.distance, t8.decay = e4.decay, e4.castShadow) {
          const t9 = e4.shadow, i3 = n2.get(e4);
          i3.shadowBias = t9.bias, i3.shadowNormalBias = t9.normalBias, i3.shadowRadius = t9.radius, i3.shadowMapSize = t9.mapSize, i3.shadowCameraNear = t9.camera.near, i3.shadowCameraFar = t9.camera.far, r2.pointShadow[u2] = i3, r2.pointShadowMap[u2] = w2, r2.pointShadowMatrix[u2] = e4.shadow.matrix, g2++;
        }
        r2.point[u2] = t8, u2++;
      } else if (e4.isHemisphereLight) {
        const t8 = i2.get(e4);
        t8.skyColor.copy(e4.color).multiplyScalar(x3 * y2), t8.groundColor.copy(e4.groundColor).multiplyScalar(x3 * y2), r2.hemi[f2] = t8, f2++;
      }
    }
    p2 > 0 && (e2.isWebGL2 || true === t6.has("OES_texture_float_linear") ? (r2.rectAreaLTC1 = Bc.LTC_FLOAT_1, r2.rectAreaLTC2 = Bc.LTC_FLOAT_2) : true === t6.has("OES_texture_half_float_linear") ? (r2.rectAreaLTC1 = Bc.LTC_HALF_1, r2.rectAreaLTC2 = Bc.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r2.ambient[0] = a3, r2.ambient[1] = l2, r2.ambient[2] = c2;
    const x2 = r2.hash;
    x2.directionalLength === h2 && x2.pointLength === u2 && x2.spotLength === d2 && x2.rectAreaLength === p2 && x2.hemiLength === f2 && x2.numDirectionalShadows === m2 && x2.numPointShadows === g2 && x2.numSpotShadows === v2 || (r2.directional.length = h2, r2.spot.length = d2, r2.rectArea.length = p2, r2.point.length = u2, r2.hemi.length = f2, r2.directionalShadow.length = m2, r2.directionalShadowMap.length = m2, r2.pointShadow.length = g2, r2.pointShadowMap.length = g2, r2.spotShadow.length = v2, r2.spotShadowMap.length = v2, r2.directionalShadowMatrix.length = m2, r2.pointShadowMatrix.length = g2, r2.spotShadowMatrix.length = v2, x2.directionalLength = h2, x2.pointLength = u2, x2.spotLength = d2, x2.rectAreaLength = p2, x2.hemiLength = f2, x2.numDirectionalShadows = m2, x2.numPointShadows = g2, x2.numSpotShadows = v2, r2.version = Zu++);
  }, setupView: function(t7, e3) {
    let i3 = 0, n3 = 0, l2 = 0, c2 = 0, h2 = 0;
    const u2 = e3.matrixWorldInverse;
    for (let e4 = 0, d2 = t7.length; e4 < d2; e4++) {
      const d3 = t7[e4];
      if (d3.isDirectionalLight) {
        const t8 = r2.directional[i3];
        t8.direction.setFromMatrixPosition(d3.matrixWorld), s2.setFromMatrixPosition(d3.target.matrixWorld), t8.direction.sub(s2), t8.direction.transformDirection(u2), i3++;
      } else if (d3.isSpotLight) {
        const t8 = r2.spot[l2];
        t8.position.setFromMatrixPosition(d3.matrixWorld), t8.position.applyMatrix4(u2), t8.direction.setFromMatrixPosition(d3.matrixWorld), s2.setFromMatrixPosition(d3.target.matrixWorld), t8.direction.sub(s2), t8.direction.transformDirection(u2), l2++;
      } else if (d3.isRectAreaLight) {
        const t8 = r2.rectArea[c2];
        t8.position.setFromMatrixPosition(d3.matrixWorld), t8.position.applyMatrix4(u2), a2.identity(), o2.copy(d3.matrixWorld), o2.premultiply(u2), a2.extractRotation(o2), t8.halfWidth.set(0.5 * d3.width, 0, 0), t8.halfHeight.set(0, 0.5 * d3.height, 0), t8.halfWidth.applyMatrix4(a2), t8.halfHeight.applyMatrix4(a2), c2++;
      } else if (d3.isPointLight) {
        const t8 = r2.point[n3];
        t8.position.setFromMatrixPosition(d3.matrixWorld), t8.position.applyMatrix4(u2), n3++;
      } else if (d3.isHemisphereLight) {
        const t8 = r2.hemi[h2];
        t8.direction.setFromMatrixPosition(d3.matrixWorld), t8.direction.transformDirection(u2), h2++;
      }
    }
  }, state: r2 };
}
function $u(t6, e2) {
  const i2 = new Ku(t6, e2), n2 = [], r2 = [];
  return { init: function() {
    n2.length = 0, r2.length = 0;
  }, state: { lightsArray: n2, shadowsArray: r2, lights: i2 }, setupLights: function(t7) {
    i2.setup(n2, t7);
  }, setupLightsView: function(t7) {
    i2.setupView(n2, t7);
  }, pushLight: function(t7) {
    n2.push(t7);
  }, pushShadow: function(t7) {
    r2.push(t7);
  } };
}
function Qu(t6, e2) {
  let i2 = /* @__PURE__ */ new WeakMap();
  return { get: function(n2, r2 = 0) {
    let s2;
    return false === i2.has(n2) ? (s2 = new $u(t6, e2), i2.set(n2, [s2])) : r2 >= i2.get(n2).length ? (s2 = new $u(t6, e2), i2.get(n2).push(s2)) : s2 = i2.get(n2)[r2], s2;
  }, dispose: function() {
    i2 = /* @__PURE__ */ new WeakMap();
  } };
}
var td = class extends Cl {
  constructor(t6) {
    super(), this.isMeshDepthMaterial = true, this.type = "MeshDepthMaterial", this.depthPacking = Us, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.setValues(t6);
  }
  copy(t6) {
    return super.copy(t6), this.depthPacking = t6.depthPacking, this.map = t6.map, this.alphaMap = t6.alphaMap, this.displacementMap = t6.displacementMap, this.displacementScale = t6.displacementScale, this.displacementBias = t6.displacementBias, this.wireframe = t6.wireframe, this.wireframeLinewidth = t6.wireframeLinewidth, this;
  }
};
var ed = class extends Cl {
  constructor(t6) {
    super(), this.isMeshDistanceMaterial = true, this.type = "MeshDistanceMaterial", this.referencePosition = new pa(), this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(t6);
  }
  copy(t6) {
    return super.copy(t6), this.referencePosition.copy(t6.referencePosition), this.nearDistance = t6.nearDistance, this.farDistance = t6.farDistance, this.map = t6.map, this.alphaMap = t6.alphaMap, this.displacementMap = t6.displacementMap, this.displacementScale = t6.displacementScale, this.displacementBias = t6.displacementBias, this;
  }
};
var id = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
var nd = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
function rd(t6, e2, i2) {
  let n2 = new Dc();
  const r2 = new Fo(), s2 = new Fo(), o2 = new sa(), a2 = new td({ depthPacking: Hs }), l2 = new ed(), c2 = {}, h2 = i2.maxTextureSize, u2 = { 0: wn, 1: bn, 2: _n }, d2 = new bc({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new Fo() }, radius: { value: 4 } }, vertexShader: id, fragmentShader: nd }), p2 = d2.clone();
  p2.defines.HORIZONTAL_PASS = 1;
  const f2 = new Jl();
  f2.setAttribute("position", new Il(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const m2 = new fc(f2, d2), g2 = this;
  function v2(i3, n3) {
    const s3 = e2.update(m2);
    d2.defines.VSM_SAMPLES !== i3.blurSamples && (d2.defines.VSM_SAMPLES = i3.blurSamples, p2.defines.VSM_SAMPLES = i3.blurSamples, d2.needsUpdate = true, p2.needsUpdate = true), null === i3.mapPass && (i3.mapPass = new oa(r2.x, r2.y)), d2.uniforms.shadow_pass.value = i3.map.texture, d2.uniforms.resolution.value = i3.mapSize, d2.uniforms.radius.value = i3.radius, t6.setRenderTarget(i3.mapPass), t6.clear(), t6.renderBufferDirect(n3, null, s3, d2, m2, null), p2.uniforms.shadow_pass.value = i3.mapPass.texture, p2.uniforms.resolution.value = i3.mapSize, p2.uniforms.radius.value = i3.radius, t6.setRenderTarget(i3.map), t6.clear(), t6.renderBufferDirect(n3, null, s3, p2, m2, null);
  }
  function y2(e3, i3, n3, r3, s3, o3) {
    let h3 = null;
    const d3 = true === n3.isPointLight ? e3.customDistanceMaterial : e3.customDepthMaterial;
    if (h3 = void 0 !== d3 ? d3 : true === n3.isPointLight ? l2 : a2, t6.localClippingEnabled && true === i3.clipShadows && Array.isArray(i3.clippingPlanes) && 0 !== i3.clippingPlanes.length || i3.displacementMap && 0 !== i3.displacementScale || i3.alphaMap && i3.alphaTest > 0) {
      const t7 = h3.uuid, e4 = i3.uuid;
      let n4 = c2[t7];
      void 0 === n4 && (n4 = {}, c2[t7] = n4);
      let r4 = n4[e4];
      void 0 === r4 && (r4 = h3.clone(), n4[e4] = r4), h3 = r4;
    }
    return h3.visible = i3.visible, h3.wireframe = i3.wireframe, h3.side = o3 === xn ? null !== i3.shadowSide ? i3.shadowSide : i3.side : null !== i3.shadowSide ? i3.shadowSide : u2[i3.side], h3.alphaMap = i3.alphaMap, h3.alphaTest = i3.alphaTest, h3.clipShadows = i3.clipShadows, h3.clippingPlanes = i3.clippingPlanes, h3.clipIntersection = i3.clipIntersection, h3.displacementMap = i3.displacementMap, h3.displacementScale = i3.displacementScale, h3.displacementBias = i3.displacementBias, h3.wireframeLinewidth = i3.wireframeLinewidth, h3.linewidth = i3.linewidth, true === n3.isPointLight && true === h3.isMeshDistanceMaterial && (h3.referencePosition.setFromMatrixPosition(n3.matrixWorld), h3.nearDistance = r3, h3.farDistance = s3), h3;
  }
  function x2(i3, r3, s3, o3, a3) {
    if (false === i3.visible) return;
    if (i3.layers.test(r3.layers) && (i3.isMesh || i3.isLine || i3.isPoints) && (i3.castShadow || i3.receiveShadow && a3 === xn) && (!i3.frustumCulled || n2.intersectsObject(i3))) {
      i3.modelViewMatrix.multiplyMatrices(s3.matrixWorldInverse, i3.matrixWorld);
      const n3 = e2.update(i3), r4 = i3.material;
      if (Array.isArray(r4)) {
        const e3 = n3.groups;
        for (let l4 = 0, c3 = e3.length; l4 < c3; l4++) {
          const c4 = e3[l4], h3 = r4[c4.materialIndex];
          if (h3 && h3.visible) {
            const e4 = y2(i3, h3, o3, s3.near, s3.far, a3);
            t6.renderBufferDirect(s3, null, n3, e4, i3, c4);
          }
        }
      } else if (r4.visible) {
        const e3 = y2(i3, r4, o3, s3.near, s3.far, a3);
        t6.renderBufferDirect(s3, null, n3, e3, i3, null);
      }
    }
    const l3 = i3.children;
    for (let t7 = 0, e3 = l3.length; t7 < e3; t7++) x2(l3[t7], r3, s3, o3, a3);
  }
  this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = vn, this.render = function(e3, i3, a3) {
    if (false === g2.enabled) return;
    if (false === g2.autoUpdate && false === g2.needsUpdate) return;
    if (0 === e3.length) return;
    const l3 = t6.getRenderTarget(), c3 = t6.getActiveCubeFace(), u3 = t6.getActiveMipmapLevel(), d3 = t6.state;
    d3.setBlending(Tn), d3.buffers.color.setClear(1, 1, 1, 1), d3.buffers.depth.setTest(true), d3.setScissorTest(false);
    for (let l4 = 0, c4 = e3.length; l4 < c4; l4++) {
      const c5 = e3[l4], u4 = c5.shadow;
      if (void 0 === u4) {
        console.warn("THREE.WebGLShadowMap:", c5, "has no shadow.");
        continue;
      }
      if (false === u4.autoUpdate && false === u4.needsUpdate) continue;
      r2.copy(u4.mapSize);
      const p3 = u4.getFrameExtents();
      if (r2.multiply(p3), s2.copy(u4.mapSize), (r2.x > h2 || r2.y > h2) && (r2.x > h2 && (s2.x = Math.floor(h2 / p3.x), r2.x = s2.x * p3.x, u4.mapSize.x = s2.x), r2.y > h2 && (s2.y = Math.floor(h2 / p3.y), r2.y = s2.y * p3.y, u4.mapSize.y = s2.y)), null === u4.map) {
        const t7 = this.type !== xn ? { minFilter: xr, magFilter: xr } : {};
        u4.map = new oa(r2.x, r2.y, t7), u4.map.texture.name = c5.name + ".shadowMap", u4.camera.updateProjectionMatrix();
      }
      t6.setRenderTarget(u4.map), t6.clear();
      const f3 = u4.getViewportCount();
      for (let t7 = 0; t7 < f3; t7++) {
        const e4 = u4.getViewport(t7);
        o2.set(s2.x * e4.x, s2.y * e4.y, s2.x * e4.z, s2.y * e4.w), d3.viewport(o2), u4.updateMatrices(c5, t7), n2 = u4.getFrustum(), x2(i3, a3, u4.camera, c5, this.type);
      }
      true !== u4.isPointLightShadow && this.type === xn && v2(u4, a3), u4.needsUpdate = false;
    }
    g2.needsUpdate = false, t6.setRenderTarget(l3, c3, u3);
  };
}
function sd(t6, e2, i2) {
  const n2 = i2.isWebGL2;
  const r2 = new function() {
    let e3 = false;
    const i3 = new sa();
    let n3 = null;
    const r3 = new sa(0, 0, 0, 0);
    return { setMask: function(i4) {
      n3 === i4 || e3 || (t6.colorMask(i4, i4, i4, i4), n3 = i4);
    }, setLocked: function(t7) {
      e3 = t7;
    }, setClear: function(e4, n4, s3, o3, a3) {
      true === a3 && (e4 *= o3, n4 *= o3, s3 *= o3), i3.set(e4, n4, s3, o3), false === r3.equals(i3) && (t6.clearColor(e4, n4, s3, o3), r3.copy(i3));
    }, reset: function() {
      e3 = false, n3 = null, r3.set(-1, 0, 0, 0);
    } };
  }(), s2 = new function() {
    let e3 = false, i3 = null, n3 = null, r3 = null;
    return { setTest: function(t7) {
      t7 ? U2(2929) : H2(2929);
    }, setMask: function(n4) {
      i3 === n4 || e3 || (t6.depthMask(n4), i3 = n4);
    }, setFunc: function(e4) {
      if (n3 !== e4) {
        if (e4) switch (e4) {
          case Xn:
            t6.depthFunc(512);
            break;
          case Yn:
            t6.depthFunc(519);
            break;
          case Zn:
            t6.depthFunc(513);
            break;
          case Jn:
            t6.depthFunc(515);
            break;
          case Kn:
            t6.depthFunc(514);
            break;
          case $n:
            t6.depthFunc(518);
            break;
          case Qn:
            t6.depthFunc(516);
            break;
          case tr:
            t6.depthFunc(517);
            break;
          default:
            t6.depthFunc(515);
        }
        else t6.depthFunc(515);
        n3 = e4;
      }
    }, setLocked: function(t7) {
      e3 = t7;
    }, setClear: function(e4) {
      r3 !== e4 && (t6.clearDepth(e4), r3 = e4);
    }, reset: function() {
      e3 = false, i3 = null, n3 = null, r3 = null;
    } };
  }(), o2 = new function() {
    let e3 = false, i3 = null, n3 = null, r3 = null, s3 = null, o3 = null, a3 = null, l3 = null, c3 = null;
    return { setTest: function(t7) {
      e3 || (t7 ? U2(2960) : H2(2960));
    }, setMask: function(n4) {
      i3 === n4 || e3 || (t6.stencilMask(n4), i3 = n4);
    }, setFunc: function(e4, i4, o4) {
      n3 === e4 && r3 === i4 && s3 === o4 || (t6.stencilFunc(e4, i4, o4), n3 = e4, r3 = i4, s3 = o4);
    }, setOp: function(e4, i4, n4) {
      o3 === e4 && a3 === i4 && l3 === n4 || (t6.stencilOp(e4, i4, n4), o3 = e4, a3 = i4, l3 = n4);
    }, setLocked: function(t7) {
      e3 = t7;
    }, setClear: function(e4) {
      c3 !== e4 && (t6.clearStencil(e4), c3 = e4);
    }, reset: function() {
      e3 = false, i3 = null, n3 = null, r3 = null, s3 = null, o3 = null, a3 = null, l3 = null, c3 = null;
    } };
  }(), a2 = /* @__PURE__ */ new WeakMap(), l2 = /* @__PURE__ */ new WeakMap();
  let c2 = {}, h2 = {}, u2 = /* @__PURE__ */ new WeakMap(), d2 = [], p2 = null, f2 = false, m2 = null, g2 = null, v2 = null, y2 = null, x2 = null, b2 = null, w2 = null, _2 = false, S2 = null, M2 = null, T2 = null, E2 = null, A2 = null;
  const C2 = t6.getParameter(35661);
  let R2 = false, P2 = 0;
  const L2 = t6.getParameter(7938);
  -1 !== L2.indexOf("WebGL") ? (P2 = parseFloat(/^WebGL (\d)/.exec(L2)[1]), R2 = P2 >= 1) : -1 !== L2.indexOf("OpenGL ES") && (P2 = parseFloat(/^OpenGL ES (\d)/.exec(L2)[1]), R2 = P2 >= 2);
  let I2 = null, D2 = {};
  const O2 = t6.getParameter(3088), z2 = t6.getParameter(2978), F2 = new sa().fromArray(O2), N2 = new sa().fromArray(z2);
  function B2(e3, i3, n3) {
    const r3 = new Uint8Array(4), s3 = t6.createTexture();
    t6.bindTexture(e3, s3), t6.texParameteri(e3, 10241, 9728), t6.texParameteri(e3, 10240, 9728);
    for (let e4 = 0; e4 < n3; e4++) t6.texImage2D(i3 + e4, 0, 6408, 1, 1, 0, 6408, 5121, r3);
    return s3;
  }
  const k2 = {};
  function U2(e3) {
    true !== c2[e3] && (t6.enable(e3), c2[e3] = true);
  }
  function H2(e3) {
    false !== c2[e3] && (t6.disable(e3), c2[e3] = false);
  }
  k2[3553] = B2(3553, 3553, 1), k2[34067] = B2(34067, 34069, 6), r2.setClear(0, 0, 0, 1), s2.setClear(1), o2.setClear(0), U2(2929), s2.setFunc(Jn), W2(false), q2(pn), U2(2884), G2(Tn);
  const V2 = { [Ln]: 32774, [In]: 32778, [Dn]: 32779 };
  if (n2) V2[On] = 32775, V2[zn] = 32776;
  else {
    const t7 = e2.get("EXT_blend_minmax");
    null !== t7 && (V2[On] = t7.MIN_EXT, V2[zn] = t7.MAX_EXT);
  }
  const j2 = { [Fn]: 0, [Nn]: 1, [Bn]: 768, [Un]: 770, [qn]: 776, [Gn]: 774, [Vn]: 772, [kn]: 769, [Hn]: 771, [Wn]: 775, [jn]: 773 };
  function G2(e3, i3, n3, r3, s3, o3, a3, l3) {
    if (e3 !== Tn) {
      if (false === f2 && (U2(3042), f2 = true), e3 === Pn) s3 = s3 || i3, o3 = o3 || n3, a3 = a3 || r3, i3 === g2 && s3 === x2 || (t6.blendEquationSeparate(V2[i3], V2[s3]), g2 = i3, x2 = s3), n3 === v2 && r3 === y2 && o3 === b2 && a3 === w2 || (t6.blendFuncSeparate(j2[n3], j2[r3], j2[o3], j2[a3]), v2 = n3, y2 = r3, b2 = o3, w2 = a3), m2 = e3, _2 = null;
      else if (e3 !== m2 || l3 !== _2) {
        if (g2 === Ln && x2 === Ln || (t6.blendEquation(32774), g2 = Ln, x2 = Ln), l3) switch (e3) {
          case En:
            t6.blendFuncSeparate(1, 771, 1, 771);
            break;
          case An:
            t6.blendFunc(1, 1);
            break;
          case Cn:
            t6.blendFuncSeparate(0, 769, 0, 1);
            break;
          case Rn:
            t6.blendFuncSeparate(0, 768, 0, 770);
            break;
          default:
            console.error("THREE.WebGLState: Invalid blending: ", e3);
        }
        else switch (e3) {
          case En:
            t6.blendFuncSeparate(770, 771, 1, 771);
            break;
          case An:
            t6.blendFunc(770, 1);
            break;
          case Cn:
            t6.blendFuncSeparate(0, 769, 0, 1);
            break;
          case Rn:
            t6.blendFunc(0, 768);
            break;
          default:
            console.error("THREE.WebGLState: Invalid blending: ", e3);
        }
        v2 = null, y2 = null, b2 = null, w2 = null, m2 = e3, _2 = l3;
      }
    } else true === f2 && (H2(3042), f2 = false);
  }
  function W2(e3) {
    S2 !== e3 && (e3 ? t6.frontFace(2304) : t6.frontFace(2305), S2 = e3);
  }
  function q2(e3) {
    e3 !== dn ? (U2(2884), e3 !== M2 && (e3 === pn ? t6.cullFace(1029) : e3 === fn ? t6.cullFace(1028) : t6.cullFace(1032))) : H2(2884), M2 = e3;
  }
  function X2(e3, i3, n3) {
    e3 ? (U2(32823), E2 === i3 && A2 === n3 || (t6.polygonOffset(i3, n3), E2 = i3, A2 = n3)) : H2(32823);
  }
  function Y2(e3) {
    void 0 === e3 && (e3 = 33984 + C2 - 1), I2 !== e3 && (t6.activeTexture(e3), I2 = e3);
  }
  return { buffers: { color: r2, depth: s2, stencil: o2 }, enable: U2, disable: H2, bindFramebuffer: function(e3, i3) {
    return h2[e3] !== i3 && (t6.bindFramebuffer(e3, i3), h2[e3] = i3, n2 && (36009 === e3 && (h2[36160] = i3), 36160 === e3 && (h2[36009] = i3)), true);
  }, drawBuffers: function(n3, r3) {
    let s3 = d2, o3 = false;
    if (n3) if (s3 = u2.get(r3), void 0 === s3 && (s3 = [], u2.set(r3, s3)), n3.isWebGLMultipleRenderTargets) {
      const t7 = n3.texture;
      if (s3.length !== t7.length || 36064 !== s3[0]) {
        for (let e3 = 0, i3 = t7.length; e3 < i3; e3++) s3[e3] = 36064 + e3;
        s3.length = t7.length, o3 = true;
      }
    } else 36064 !== s3[0] && (s3[0] = 36064, o3 = true);
    else 1029 !== s3[0] && (s3[0] = 1029, o3 = true);
    o3 && (i2.isWebGL2 ? t6.drawBuffers(s3) : e2.get("WEBGL_draw_buffers").drawBuffersWEBGL(s3));
  }, useProgram: function(e3) {
    return p2 !== e3 && (t6.useProgram(e3), p2 = e3, true);
  }, setBlending: G2, setMaterial: function(t7, e3) {
    t7.side === _n ? H2(2884) : U2(2884);
    let i3 = t7.side === wn;
    e3 && (i3 = !i3), W2(i3), t7.blending === En && false === t7.transparent ? G2(Tn) : G2(t7.blending, t7.blendEquation, t7.blendSrc, t7.blendDst, t7.blendEquationAlpha, t7.blendSrcAlpha, t7.blendDstAlpha, t7.premultipliedAlpha), s2.setFunc(t7.depthFunc), s2.setTest(t7.depthTest), s2.setMask(t7.depthWrite), r2.setMask(t7.colorWrite);
    const n3 = t7.stencilWrite;
    o2.setTest(n3), n3 && (o2.setMask(t7.stencilWriteMask), o2.setFunc(t7.stencilFunc, t7.stencilRef, t7.stencilFuncMask), o2.setOp(t7.stencilFail, t7.stencilZFail, t7.stencilZPass)), X2(t7.polygonOffset, t7.polygonOffsetFactor, t7.polygonOffsetUnits), true === t7.alphaToCoverage ? U2(32926) : H2(32926);
  }, setFlipSided: W2, setCullFace: q2, setLineWidth: function(e3) {
    e3 !== T2 && (R2 && t6.lineWidth(e3), T2 = e3);
  }, setPolygonOffset: X2, setScissorTest: function(t7) {
    t7 ? U2(3089) : H2(3089);
  }, activeTexture: Y2, bindTexture: function(e3, i3) {
    null === I2 && Y2();
    let n3 = D2[I2];
    void 0 === n3 && (n3 = { type: void 0, texture: void 0 }, D2[I2] = n3), n3.type === e3 && n3.texture === i3 || (t6.bindTexture(e3, i3 || k2[e3]), n3.type = e3, n3.texture = i3);
  }, unbindTexture: function() {
    const e3 = D2[I2];
    void 0 !== e3 && void 0 !== e3.type && (t6.bindTexture(e3.type, null), e3.type = void 0, e3.texture = void 0);
  }, compressedTexImage2D: function() {
    try {
      t6.compressedTexImage2D.apply(t6, arguments);
    } catch (t7) {
      console.error("THREE.WebGLState:", t7);
    }
  }, texImage2D: function() {
    try {
      t6.texImage2D.apply(t6, arguments);
    } catch (t7) {
      console.error("THREE.WebGLState:", t7);
    }
  }, texImage3D: function() {
    try {
      t6.texImage3D.apply(t6, arguments);
    } catch (t7) {
      console.error("THREE.WebGLState:", t7);
    }
  }, updateUBOMapping: function(e3, i3) {
    let n3 = l2.get(i3);
    void 0 === n3 && (n3 = /* @__PURE__ */ new WeakMap(), l2.set(i3, n3));
    let r3 = n3.get(e3);
    void 0 === r3 && (r3 = t6.getUniformBlockIndex(i3, e3.name), n3.set(e3, r3));
  }, uniformBlockBinding: function(e3, i3) {
    const n3 = l2.get(i3).get(e3);
    a2.get(e3) !== n3 && (t6.uniformBlockBinding(i3, n3, e3.__bindingPointIndex), a2.set(e3, n3));
  }, texStorage2D: function() {
    try {
      t6.texStorage2D.apply(t6, arguments);
    } catch (t7) {
      console.error("THREE.WebGLState:", t7);
    }
  }, texStorage3D: function() {
    try {
      t6.texStorage3D.apply(t6, arguments);
    } catch (t7) {
      console.error("THREE.WebGLState:", t7);
    }
  }, texSubImage2D: function() {
    try {
      t6.texSubImage2D.apply(t6, arguments);
    } catch (t7) {
      console.error("THREE.WebGLState:", t7);
    }
  }, texSubImage3D: function() {
    try {
      t6.texSubImage3D.apply(t6, arguments);
    } catch (t7) {
      console.error("THREE.WebGLState:", t7);
    }
  }, compressedTexSubImage2D: function() {
    try {
      t6.compressedTexSubImage2D.apply(t6, arguments);
    } catch (t7) {
      console.error("THREE.WebGLState:", t7);
    }
  }, scissor: function(e3) {
    false === F2.equals(e3) && (t6.scissor(e3.x, e3.y, e3.z, e3.w), F2.copy(e3));
  }, viewport: function(e3) {
    false === N2.equals(e3) && (t6.viewport(e3.x, e3.y, e3.z, e3.w), N2.copy(e3));
  }, reset: function() {
    t6.disable(3042), t6.disable(2884), t6.disable(2929), t6.disable(32823), t6.disable(3089), t6.disable(2960), t6.disable(32926), t6.blendEquation(32774), t6.blendFunc(1, 0), t6.blendFuncSeparate(1, 0, 1, 0), t6.colorMask(true, true, true, true), t6.clearColor(0, 0, 0, 0), t6.depthMask(true), t6.depthFunc(513), t6.clearDepth(1), t6.stencilMask(4294967295), t6.stencilFunc(519, 0, 4294967295), t6.stencilOp(7680, 7680, 7680), t6.clearStencil(0), t6.cullFace(1029), t6.frontFace(2305), t6.polygonOffset(0, 0), t6.activeTexture(33984), t6.bindFramebuffer(36160, null), true === n2 && (t6.bindFramebuffer(36009, null), t6.bindFramebuffer(36008, null)), t6.useProgram(null), t6.lineWidth(1), t6.scissor(0, 0, t6.canvas.width, t6.canvas.height), t6.viewport(0, 0, t6.canvas.width, t6.canvas.height), c2 = {}, I2 = null, D2 = {}, h2 = {}, u2 = /* @__PURE__ */ new WeakMap(), d2 = [], p2 = null, f2 = false, m2 = null, g2 = null, v2 = null, y2 = null, x2 = null, b2 = null, w2 = null, _2 = false, S2 = null, M2 = null, T2 = null, E2 = null, A2 = null, F2.set(0, 0, t6.canvas.width, t6.canvas.height), N2.set(0, 0, t6.canvas.width, t6.canvas.height), r2.reset(), s2.reset(), o2.reset();
  } };
}
function od(t6, e2, i2, n2, r2, s2, o2) {
  const a2 = r2.isWebGL2, l2 = r2.maxTextures, c2 = r2.maxCubemapSize, h2 = r2.maxTextureSize, u2 = r2.maxSamples, d2 = e2.has("WEBGL_multisampled_render_to_texture") ? e2.get("WEBGL_multisampled_render_to_texture") : null, p2 = /OculusBrowser/g.test(navigator.userAgent), f2 = /* @__PURE__ */ new WeakMap();
  let m2;
  const g2 = /* @__PURE__ */ new WeakMap();
  let v2 = false;
  try {
    v2 = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d");
  } catch (t7) {
  }
  function y2(t7, e3) {
    return v2 ? new OffscreenCanvas(t7, e3) : Ho("canvas");
  }
  function x2(t7, e3, i3, n3) {
    let r3 = 1;
    if ((t7.width > n3 || t7.height > n3) && (r3 = n3 / Math.max(t7.width, t7.height)), r3 < 1 || true === e3) {
      if ("undefined" != typeof HTMLImageElement && t7 instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t7 instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t7 instanceof ImageBitmap) {
        const n4 = e3 ? Oo : Math.floor, s3 = n4(r3 * t7.width), o3 = n4(r3 * t7.height);
        void 0 === m2 && (m2 = y2(s3, o3));
        const a3 = i3 ? y2(s3, o3) : m2;
        a3.width = s3, a3.height = o3;
        return a3.getContext("2d").drawImage(t7, 0, 0, s3, o3), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t7.width + "x" + t7.height + ") to (" + s3 + "x" + o3 + ")."), a3;
      }
      return "data" in t7 && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t7.width + "x" + t7.height + ")."), t7;
    }
    return t7;
  }
  function b2(t7) {
    return Io(t7.width) && Io(t7.height);
  }
  function w2(t7, e3) {
    return t7.generateMipmaps && e3 && t7.minFilter !== xr && t7.minFilter !== Mr;
  }
  function _2(e3) {
    t6.generateMipmap(e3);
  }
  function S2(i3, n3, r3, s3, o3 = false) {
    if (false === a2) return n3;
    if (null !== i3) {
      if (void 0 !== t6[i3]) return t6[i3];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + i3 + "'");
    }
    let l3 = n3;
    return 6403 === n3 && (5126 === r3 && (l3 = 33326), 5131 === r3 && (l3 = 33325), 5121 === r3 && (l3 = 33321)), 33319 === n3 && (5126 === r3 && (l3 = 33328), 5131 === r3 && (l3 = 33327), 5121 === r3 && (l3 = 33323)), 6408 === n3 && (5126 === r3 && (l3 = 34836), 5131 === r3 && (l3 = 34842), 5121 === r3 && (l3 = s3 === ks && false === o3 ? 35907 : 32856), 32819 === r3 && (l3 = 32854), 32820 === r3 && (l3 = 32855)), 33325 !== l3 && 33326 !== l3 && 33327 !== l3 && 33328 !== l3 && 34842 !== l3 && 34836 !== l3 || e2.get("EXT_color_buffer_float"), l3;
  }
  function M2(t7, e3, i3) {
    return true === w2(t7, i3) || t7.isFramebufferTexture && t7.minFilter !== xr && t7.minFilter !== Mr ? Math.log2(Math.max(e3.width, e3.height)) + 1 : void 0 !== t7.mipmaps && t7.mipmaps.length > 0 ? t7.mipmaps.length : t7.isCompressedTexture && Array.isArray(t7.image) ? e3.mipmaps.length : 1;
  }
  function T2(t7) {
    return t7 === xr || t7 === br || t7 === _r ? 9728 : 9729;
  }
  function E2(t7) {
    const e3 = t7.target;
    e3.removeEventListener("dispose", E2), (function(t8) {
      const e4 = n2.get(t8);
      if (void 0 === e4.__webglInit) return;
      const i3 = t8.source, r3 = g2.get(i3);
      if (r3) {
        const n3 = r3[e4.__cacheKey];
        n3.usedTimes--, 0 === n3.usedTimes && C2(t8), 0 === Object.keys(r3).length && g2.delete(i3);
      }
      n2.remove(t8);
    })(e3), e3.isVideoTexture && f2.delete(e3);
  }
  function A2(e3) {
    const i3 = e3.target;
    i3.removeEventListener("dispose", A2), (function(e4) {
      const i4 = e4.texture, r3 = n2.get(e4), s3 = n2.get(i4);
      void 0 !== s3.__webglTexture && (t6.deleteTexture(s3.__webglTexture), o2.memory.textures--);
      e4.depthTexture && e4.depthTexture.dispose();
      if (e4.isWebGLCubeRenderTarget) for (let e5 = 0; e5 < 6; e5++) t6.deleteFramebuffer(r3.__webglFramebuffer[e5]), r3.__webglDepthbuffer && t6.deleteRenderbuffer(r3.__webglDepthbuffer[e5]);
      else {
        if (t6.deleteFramebuffer(r3.__webglFramebuffer), r3.__webglDepthbuffer && t6.deleteRenderbuffer(r3.__webglDepthbuffer), r3.__webglMultisampledFramebuffer && t6.deleteFramebuffer(r3.__webglMultisampledFramebuffer), r3.__webglColorRenderbuffer) for (let e5 = 0; e5 < r3.__webglColorRenderbuffer.length; e5++) r3.__webglColorRenderbuffer[e5] && t6.deleteRenderbuffer(r3.__webglColorRenderbuffer[e5]);
        r3.__webglDepthRenderbuffer && t6.deleteRenderbuffer(r3.__webglDepthRenderbuffer);
      }
      if (e4.isWebGLMultipleRenderTargets) for (let e5 = 0, r4 = i4.length; e5 < r4; e5++) {
        const r5 = n2.get(i4[e5]);
        r5.__webglTexture && (t6.deleteTexture(r5.__webglTexture), o2.memory.textures--), n2.remove(i4[e5]);
      }
      n2.remove(i4), n2.remove(e4);
    })(i3);
  }
  function C2(e3) {
    const i3 = n2.get(e3);
    t6.deleteTexture(i3.__webglTexture);
    const r3 = e3.source;
    delete g2.get(r3)[i3.__cacheKey], o2.memory.textures--;
  }
  let R2 = 0;
  function P2(t7, e3) {
    const r3 = n2.get(t7);
    if (t7.isVideoTexture && (function(t8) {
      const e4 = o2.render.frame;
      f2.get(t8) !== e4 && (f2.set(t8, e4), t8.update());
    })(t7), false === t7.isRenderTargetTexture && t7.version > 0 && r3.__version !== t7.version) {
      const i3 = t7.image;
      if (null === i3) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else {
        if (false !== i3.complete) return void z2(r3, t7, e3);
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      }
    }
    i2.activeTexture(33984 + e3), i2.bindTexture(3553, r3.__webglTexture);
  }
  const L2 = { [gr]: 10497, [vr]: 33071, [yr]: 33648 }, I2 = { [xr]: 9728, [br]: 9984, [_r]: 9986, [Mr]: 9729, [Tr]: 9985, [Ar]: 9987 };
  function D2(i3, s3, o3) {
    if (o3 ? (t6.texParameteri(i3, 10242, L2[s3.wrapS]), t6.texParameteri(i3, 10243, L2[s3.wrapT]), 32879 !== i3 && 35866 !== i3 || t6.texParameteri(i3, 32882, L2[s3.wrapR]), t6.texParameteri(i3, 10240, I2[s3.magFilter]), t6.texParameteri(i3, 10241, I2[s3.minFilter])) : (t6.texParameteri(i3, 10242, 33071), t6.texParameteri(i3, 10243, 33071), 32879 !== i3 && 35866 !== i3 || t6.texParameteri(i3, 32882, 33071), s3.wrapS === vr && s3.wrapT === vr || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t6.texParameteri(i3, 10240, T2(s3.magFilter)), t6.texParameteri(i3, 10241, T2(s3.minFilter)), s3.minFilter !== xr && s3.minFilter !== Mr && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), true === e2.has("EXT_texture_filter_anisotropic")) {
      const o4 = e2.get("EXT_texture_filter_anisotropic");
      if (s3.type === zr && false === e2.has("OES_texture_float_linear")) return;
      if (false === a2 && s3.type === Fr && false === e2.has("OES_texture_half_float_linear")) return;
      (s3.anisotropy > 1 || n2.get(s3).__currentAnisotropy) && (t6.texParameterf(i3, o4.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s3.anisotropy, r2.getMaxAnisotropy())), n2.get(s3).__currentAnisotropy = s3.anisotropy);
    }
  }
  function O2(e3, i3) {
    let n3 = false;
    void 0 === e3.__webglInit && (e3.__webglInit = true, i3.addEventListener("dispose", E2));
    const r3 = i3.source;
    let s3 = g2.get(r3);
    void 0 === s3 && (s3 = {}, g2.set(r3, s3));
    const a3 = (function(t7) {
      const e4 = [];
      return e4.push(t7.wrapS), e4.push(t7.wrapT), e4.push(t7.magFilter), e4.push(t7.minFilter), e4.push(t7.anisotropy), e4.push(t7.internalFormat), e4.push(t7.format), e4.push(t7.type), e4.push(t7.generateMipmaps), e4.push(t7.premultiplyAlpha), e4.push(t7.flipY), e4.push(t7.unpackAlignment), e4.push(t7.encoding), e4.join();
    })(i3);
    if (a3 !== e3.__cacheKey) {
      void 0 === s3[a3] && (s3[a3] = { texture: t6.createTexture(), usedTimes: 0 }, o2.memory.textures++, n3 = true), s3[a3].usedTimes++;
      const r4 = s3[e3.__cacheKey];
      void 0 !== r4 && (s3[e3.__cacheKey].usedTimes--, 0 === r4.usedTimes && C2(i3)), e3.__cacheKey = a3, e3.__webglTexture = s3[a3].texture;
    }
    return n3;
  }
  function z2(e3, n3, r3) {
    let o3 = 3553;
    n3.isDataArrayTexture && (o3 = 35866), n3.isData3DTexture && (o3 = 32879);
    const l3 = O2(e3, n3), c3 = n3.source;
    if (i2.activeTexture(33984 + r3), i2.bindTexture(o3, e3.__webglTexture), c3.version !== c3.__currentVersion || true === l3) {
      t6.pixelStorei(37440, n3.flipY), t6.pixelStorei(37441, n3.premultiplyAlpha), t6.pixelStorei(3317, n3.unpackAlignment), t6.pixelStorei(37443, 0);
      const e4 = (function(t7) {
        return !a2 && (t7.wrapS !== vr || t7.wrapT !== vr || t7.minFilter !== xr && t7.minFilter !== Mr);
      })(n3) && false === b2(n3.image);
      let r4 = x2(n3.image, e4, false, h2);
      r4 = H2(n3, r4);
      const u3 = b2(r4) || a2, d3 = s2.convert(n3.format, n3.encoding);
      let p3, f3 = s2.convert(n3.type), m3 = S2(n3.internalFormat, d3, f3, n3.encoding, n3.isVideoTexture);
      D2(o3, n3, u3);
      const g3 = n3.mipmaps, v3 = a2 && true !== n3.isVideoTexture, y3 = void 0 === c3.__currentVersion || true === l3, T3 = M2(n3, r4, u3);
      if (n3.isDepthTexture) m3 = 6402, a2 ? m3 = n3.type === zr ? 36012 : n3.type === Or ? 33190 : n3.type === kr ? 35056 : 33189 : n3.type === zr && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), n3.format === Wr && 6402 === m3 && n3.type !== Ir && n3.type !== Or && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n3.type = Or, f3 = s2.convert(n3.type)), n3.format === qr && 6402 === m3 && (m3 = 34041, n3.type !== kr && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n3.type = kr, f3 = s2.convert(n3.type))), y3 && (v3 ? i2.texStorage2D(3553, 1, m3, r4.width, r4.height) : i2.texImage2D(3553, 0, m3, r4.width, r4.height, 0, d3, f3, null));
      else if (n3.isDataTexture) if (g3.length > 0 && u3) {
        v3 && y3 && i2.texStorage2D(3553, T3, m3, g3[0].width, g3[0].height);
        for (let t7 = 0, e5 = g3.length; t7 < e5; t7++) p3 = g3[t7], v3 ? i2.texSubImage2D(3553, t7, 0, 0, p3.width, p3.height, d3, f3, p3.data) : i2.texImage2D(3553, t7, m3, p3.width, p3.height, 0, d3, f3, p3.data);
        n3.generateMipmaps = false;
      } else v3 ? (y3 && i2.texStorage2D(3553, T3, m3, r4.width, r4.height), i2.texSubImage2D(3553, 0, 0, 0, r4.width, r4.height, d3, f3, r4.data)) : i2.texImage2D(3553, 0, m3, r4.width, r4.height, 0, d3, f3, r4.data);
      else if (n3.isCompressedTexture) {
        v3 && y3 && i2.texStorage2D(3553, T3, m3, g3[0].width, g3[0].height);
        for (let t7 = 0, e5 = g3.length; t7 < e5; t7++) p3 = g3[t7], n3.format !== Vr ? null !== d3 ? v3 ? i2.compressedTexSubImage2D(3553, t7, 0, 0, p3.width, p3.height, d3, p3.data) : i2.compressedTexImage2D(3553, t7, m3, p3.width, p3.height, 0, p3.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : v3 ? i2.texSubImage2D(3553, t7, 0, 0, p3.width, p3.height, d3, f3, p3.data) : i2.texImage2D(3553, t7, m3, p3.width, p3.height, 0, d3, f3, p3.data);
      } else if (n3.isDataArrayTexture) v3 ? (y3 && i2.texStorage3D(35866, T3, m3, r4.width, r4.height, r4.depth), i2.texSubImage3D(35866, 0, 0, 0, 0, r4.width, r4.height, r4.depth, d3, f3, r4.data)) : i2.texImage3D(35866, 0, m3, r4.width, r4.height, r4.depth, 0, d3, f3, r4.data);
      else if (n3.isData3DTexture) v3 ? (y3 && i2.texStorage3D(32879, T3, m3, r4.width, r4.height, r4.depth), i2.texSubImage3D(32879, 0, 0, 0, 0, r4.width, r4.height, r4.depth, d3, f3, r4.data)) : i2.texImage3D(32879, 0, m3, r4.width, r4.height, r4.depth, 0, d3, f3, r4.data);
      else if (n3.isFramebufferTexture) {
        if (y3) if (v3) i2.texStorage2D(3553, T3, m3, r4.width, r4.height);
        else {
          let t7 = r4.width, e5 = r4.height;
          for (let n4 = 0; n4 < T3; n4++) i2.texImage2D(3553, n4, m3, t7, e5, 0, d3, f3, null), t7 >>= 1, e5 >>= 1;
        }
      } else if (g3.length > 0 && u3) {
        v3 && y3 && i2.texStorage2D(3553, T3, m3, g3[0].width, g3[0].height);
        for (let t7 = 0, e5 = g3.length; t7 < e5; t7++) p3 = g3[t7], v3 ? i2.texSubImage2D(3553, t7, 0, 0, d3, f3, p3) : i2.texImage2D(3553, t7, m3, d3, f3, p3);
        n3.generateMipmaps = false;
      } else v3 ? (y3 && i2.texStorage2D(3553, T3, m3, r4.width, r4.height), i2.texSubImage2D(3553, 0, 0, 0, d3, f3, r4)) : i2.texImage2D(3553, 0, m3, d3, f3, r4);
      w2(n3, u3) && _2(o3), c3.__currentVersion = c3.version, n3.onUpdate && n3.onUpdate(n3);
    }
    e3.__version = n3.version;
  }
  function F2(e3, r3, o3, a3, l3) {
    const c3 = s2.convert(o3.format, o3.encoding), h3 = s2.convert(o3.type), u3 = S2(o3.internalFormat, c3, h3, o3.encoding);
    n2.get(r3).__hasExternalTextures || (32879 === l3 || 35866 === l3 ? i2.texImage3D(l3, 0, u3, r3.width, r3.height, r3.depth, 0, c3, h3, null) : i2.texImage2D(l3, 0, u3, r3.width, r3.height, 0, c3, h3, null)), i2.bindFramebuffer(36160, e3), U2(r3) ? d2.framebufferTexture2DMultisampleEXT(36160, a3, l3, n2.get(o3).__webglTexture, 0, k2(r3)) : t6.framebufferTexture2D(36160, a3, l3, n2.get(o3).__webglTexture, 0), i2.bindFramebuffer(36160, null);
  }
  function N2(e3, i3, n3) {
    if (t6.bindRenderbuffer(36161, e3), i3.depthBuffer && !i3.stencilBuffer) {
      let r3 = 33189;
      if (n3 || U2(i3)) {
        const e4 = i3.depthTexture;
        e4 && e4.isDepthTexture && (e4.type === zr ? r3 = 36012 : e4.type === Or && (r3 = 33190));
        const n4 = k2(i3);
        U2(i3) ? d2.renderbufferStorageMultisampleEXT(36161, n4, r3, i3.width, i3.height) : t6.renderbufferStorageMultisample(36161, n4, r3, i3.width, i3.height);
      } else t6.renderbufferStorage(36161, r3, i3.width, i3.height);
      t6.framebufferRenderbuffer(36160, 36096, 36161, e3);
    } else if (i3.depthBuffer && i3.stencilBuffer) {
      const r3 = k2(i3);
      n3 && false === U2(i3) ? t6.renderbufferStorageMultisample(36161, r3, 35056, i3.width, i3.height) : U2(i3) ? d2.renderbufferStorageMultisampleEXT(36161, r3, 35056, i3.width, i3.height) : t6.renderbufferStorage(36161, 34041, i3.width, i3.height), t6.framebufferRenderbuffer(36160, 33306, 36161, e3);
    } else {
      const e4 = true === i3.isWebGLMultipleRenderTargets ? i3.texture : [i3.texture];
      for (let r3 = 0; r3 < e4.length; r3++) {
        const o3 = e4[r3], a3 = s2.convert(o3.format, o3.encoding), l3 = s2.convert(o3.type), c3 = S2(o3.internalFormat, a3, l3, o3.encoding), h3 = k2(i3);
        n3 && false === U2(i3) ? t6.renderbufferStorageMultisample(36161, h3, c3, i3.width, i3.height) : U2(i3) ? d2.renderbufferStorageMultisampleEXT(36161, h3, c3, i3.width, i3.height) : t6.renderbufferStorage(36161, c3, i3.width, i3.height);
      }
    }
    t6.bindRenderbuffer(36161, null);
  }
  function B2(e3) {
    const r3 = n2.get(e3), s3 = true === e3.isWebGLCubeRenderTarget;
    if (e3.depthTexture && !r3.__autoAllocateDepthBuffer) {
      if (s3) throw new Error("target.depthTexture not supported in Cube render targets");
      !(function(e4, r4) {
        if (r4 && r4.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
        if (i2.bindFramebuffer(36160, e4), !r4.depthTexture || !r4.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        n2.get(r4.depthTexture).__webglTexture && r4.depthTexture.image.width === r4.width && r4.depthTexture.image.height === r4.height || (r4.depthTexture.image.width = r4.width, r4.depthTexture.image.height = r4.height, r4.depthTexture.needsUpdate = true), P2(r4.depthTexture, 0);
        const s4 = n2.get(r4.depthTexture).__webglTexture, o3 = k2(r4);
        if (r4.depthTexture.format === Wr) U2(r4) ? d2.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, s4, 0, o3) : t6.framebufferTexture2D(36160, 36096, 3553, s4, 0);
        else {
          if (r4.depthTexture.format !== qr) throw new Error("Unknown depthTexture format");
          U2(r4) ? d2.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, s4, 0, o3) : t6.framebufferTexture2D(36160, 33306, 3553, s4, 0);
        }
      })(r3.__webglFramebuffer, e3);
    } else if (s3) {
      r3.__webglDepthbuffer = [];
      for (let n3 = 0; n3 < 6; n3++) i2.bindFramebuffer(36160, r3.__webglFramebuffer[n3]), r3.__webglDepthbuffer[n3] = t6.createRenderbuffer(), N2(r3.__webglDepthbuffer[n3], e3, false);
    } else i2.bindFramebuffer(36160, r3.__webglFramebuffer), r3.__webglDepthbuffer = t6.createRenderbuffer(), N2(r3.__webglDepthbuffer, e3, false);
    i2.bindFramebuffer(36160, null);
  }
  function k2(t7) {
    return Math.min(u2, t7.samples);
  }
  function U2(t7) {
    const i3 = n2.get(t7);
    return a2 && t7.samples > 0 && true === e2.has("WEBGL_multisampled_render_to_texture") && false !== i3.__useRenderToTexture;
  }
  function H2(t7, i3) {
    const n3 = t7.encoding, r3 = t7.format, s3 = t7.type;
    return true === t7.isCompressedTexture || true === t7.isVideoTexture || t7.format === _o || n3 !== Bs && (n3 === ks ? false === a2 ? true === e2.has("EXT_sRGB") && r3 === Vr ? (t7.format = _o, t7.minFilter = Mr, t7.generateMipmaps = false) : i3 = ta.sRGBToLinear(i3) : r3 === Vr && s3 === Rr || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", n3)), i3;
  }
  this.allocateTextureUnit = function() {
    const t7 = R2;
    return t7 >= l2 && console.warn("THREE.WebGLTextures: Trying to use " + t7 + " texture units while this GPU supports only " + l2), R2 += 1, t7;
  }, this.resetTextureUnits = function() {
    R2 = 0;
  }, this.setTexture2D = P2, this.setTexture2DArray = function(t7, e3) {
    const r3 = n2.get(t7);
    t7.version > 0 && r3.__version !== t7.version ? z2(r3, t7, e3) : (i2.activeTexture(33984 + e3), i2.bindTexture(35866, r3.__webglTexture));
  }, this.setTexture3D = function(t7, e3) {
    const r3 = n2.get(t7);
    t7.version > 0 && r3.__version !== t7.version ? z2(r3, t7, e3) : (i2.activeTexture(33984 + e3), i2.bindTexture(32879, r3.__webglTexture));
  }, this.setTextureCube = function(e3, r3) {
    const o3 = n2.get(e3);
    e3.version > 0 && o3.__version !== e3.version ? (function(e4, n3, r4) {
      if (6 !== n3.image.length) return;
      const o4 = O2(e4, n3), l3 = n3.source;
      if (i2.activeTexture(33984 + r4), i2.bindTexture(34067, e4.__webglTexture), l3.version !== l3.__currentVersion || true === o4) {
        t6.pixelStorei(37440, n3.flipY), t6.pixelStorei(37441, n3.premultiplyAlpha), t6.pixelStorei(3317, n3.unpackAlignment), t6.pixelStorei(37443, 0);
        const e5 = n3.isCompressedTexture || n3.image[0].isCompressedTexture, r5 = n3.image[0] && n3.image[0].isDataTexture, h3 = [];
        for (let t7 = 0; t7 < 6; t7++) h3[t7] = e5 || r5 ? r5 ? n3.image[t7].image : n3.image[t7] : x2(n3.image[t7], false, true, c2), h3[t7] = H2(n3, h3[t7]);
        const u3 = h3[0], d3 = b2(u3) || a2, p3 = s2.convert(n3.format, n3.encoding), f3 = s2.convert(n3.type), m3 = S2(n3.internalFormat, p3, f3, n3.encoding), g3 = a2 && true !== n3.isVideoTexture, v3 = void 0 === l3.__currentVersion || true === o4;
        let y3, T3 = M2(n3, u3, d3);
        if (D2(34067, n3, d3), e5) {
          g3 && v3 && i2.texStorage2D(34067, T3, m3, u3.width, u3.height);
          for (let t7 = 0; t7 < 6; t7++) {
            y3 = h3[t7].mipmaps;
            for (let e6 = 0; e6 < y3.length; e6++) {
              const r6 = y3[e6];
              n3.format !== Vr ? null !== p3 ? g3 ? i2.compressedTexSubImage2D(34069 + t7, e6, 0, 0, r6.width, r6.height, p3, r6.data) : i2.compressedTexImage2D(34069 + t7, e6, m3, r6.width, r6.height, 0, r6.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : g3 ? i2.texSubImage2D(34069 + t7, e6, 0, 0, r6.width, r6.height, p3, f3, r6.data) : i2.texImage2D(34069 + t7, e6, m3, r6.width, r6.height, 0, p3, f3, r6.data);
            }
          }
        } else {
          y3 = n3.mipmaps, g3 && v3 && (y3.length > 0 && T3++, i2.texStorage2D(34067, T3, m3, h3[0].width, h3[0].height));
          for (let t7 = 0; t7 < 6; t7++) if (r5) {
            g3 ? i2.texSubImage2D(34069 + t7, 0, 0, 0, h3[t7].width, h3[t7].height, p3, f3, h3[t7].data) : i2.texImage2D(34069 + t7, 0, m3, h3[t7].width, h3[t7].height, 0, p3, f3, h3[t7].data);
            for (let e6 = 0; e6 < y3.length; e6++) {
              const n4 = y3[e6].image[t7].image;
              g3 ? i2.texSubImage2D(34069 + t7, e6 + 1, 0, 0, n4.width, n4.height, p3, f3, n4.data) : i2.texImage2D(34069 + t7, e6 + 1, m3, n4.width, n4.height, 0, p3, f3, n4.data);
            }
          } else {
            g3 ? i2.texSubImage2D(34069 + t7, 0, 0, 0, p3, f3, h3[t7]) : i2.texImage2D(34069 + t7, 0, m3, p3, f3, h3[t7]);
            for (let e6 = 0; e6 < y3.length; e6++) {
              const n4 = y3[e6];
              g3 ? i2.texSubImage2D(34069 + t7, e6 + 1, 0, 0, p3, f3, n4.image[t7]) : i2.texImage2D(34069 + t7, e6 + 1, m3, p3, f3, n4.image[t7]);
            }
          }
        }
        w2(n3, d3) && _2(34067), l3.__currentVersion = l3.version, n3.onUpdate && n3.onUpdate(n3);
      }
      e4.__version = n3.version;
    })(o3, e3, r3) : (i2.activeTexture(33984 + r3), i2.bindTexture(34067, o3.__webglTexture));
  }, this.rebindTextures = function(t7, e3, i3) {
    const r3 = n2.get(t7);
    void 0 !== e3 && F2(r3.__webglFramebuffer, t7, t7.texture, 36064, 3553), void 0 !== i3 && B2(t7);
  }, this.setupRenderTarget = function(e3) {
    const l3 = e3.texture, c3 = n2.get(e3), h3 = n2.get(l3);
    e3.addEventListener("dispose", A2), true !== e3.isWebGLMultipleRenderTargets && (void 0 === h3.__webglTexture && (h3.__webglTexture = t6.createTexture()), h3.__version = l3.version, o2.memory.textures++);
    const u3 = true === e3.isWebGLCubeRenderTarget, d3 = true === e3.isWebGLMultipleRenderTargets, p3 = b2(e3) || a2;
    if (u3) {
      c3.__webglFramebuffer = [];
      for (let e4 = 0; e4 < 6; e4++) c3.__webglFramebuffer[e4] = t6.createFramebuffer();
    } else {
      if (c3.__webglFramebuffer = t6.createFramebuffer(), d3) if (r2.drawBuffers) {
        const i3 = e3.texture;
        for (let e4 = 0, r3 = i3.length; e4 < r3; e4++) {
          const r4 = n2.get(i3[e4]);
          void 0 === r4.__webglTexture && (r4.__webglTexture = t6.createTexture(), o2.memory.textures++);
        }
      } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
      if (a2 && e3.samples > 0 && false === U2(e3)) {
        const n3 = d3 ? l3 : [l3];
        c3.__webglMultisampledFramebuffer = t6.createFramebuffer(), c3.__webglColorRenderbuffer = [], i2.bindFramebuffer(36160, c3.__webglMultisampledFramebuffer);
        for (let i3 = 0; i3 < n3.length; i3++) {
          const r3 = n3[i3];
          c3.__webglColorRenderbuffer[i3] = t6.createRenderbuffer(), t6.bindRenderbuffer(36161, c3.__webglColorRenderbuffer[i3]);
          const o3 = s2.convert(r3.format, r3.encoding), a3 = s2.convert(r3.type), l4 = S2(r3.internalFormat, o3, a3, r3.encoding), h4 = k2(e3);
          t6.renderbufferStorageMultisample(36161, h4, l4, e3.width, e3.height), t6.framebufferRenderbuffer(36160, 36064 + i3, 36161, c3.__webglColorRenderbuffer[i3]);
        }
        t6.bindRenderbuffer(36161, null), e3.depthBuffer && (c3.__webglDepthRenderbuffer = t6.createRenderbuffer(), N2(c3.__webglDepthRenderbuffer, e3, true)), i2.bindFramebuffer(36160, null);
      }
    }
    if (u3) {
      i2.bindTexture(34067, h3.__webglTexture), D2(34067, l3, p3);
      for (let t7 = 0; t7 < 6; t7++) F2(c3.__webglFramebuffer[t7], e3, l3, 36064, 34069 + t7);
      w2(l3, p3) && _2(34067), i2.unbindTexture();
    } else if (d3) {
      const t7 = e3.texture;
      for (let r3 = 0, s3 = t7.length; r3 < s3; r3++) {
        const s4 = t7[r3], o3 = n2.get(s4);
        i2.bindTexture(3553, o3.__webglTexture), D2(3553, s4, p3), F2(c3.__webglFramebuffer, e3, s4, 36064 + r3, 3553), w2(s4, p3) && _2(3553);
      }
      i2.unbindTexture();
    } else {
      let t7 = 3553;
      (e3.isWebGL3DRenderTarget || e3.isWebGLArrayRenderTarget) && (a2 ? t7 = e3.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), i2.bindTexture(t7, h3.__webglTexture), D2(t7, l3, p3), F2(c3.__webglFramebuffer, e3, l3, 36064, t7), w2(l3, p3) && _2(t7), i2.unbindTexture();
    }
    e3.depthBuffer && B2(e3);
  }, this.updateRenderTargetMipmap = function(t7) {
    const e3 = b2(t7) || a2, r3 = true === t7.isWebGLMultipleRenderTargets ? t7.texture : [t7.texture];
    for (let s3 = 0, o3 = r3.length; s3 < o3; s3++) {
      const o4 = r3[s3];
      if (w2(o4, e3)) {
        const e4 = t7.isWebGLCubeRenderTarget ? 34067 : 3553, r4 = n2.get(o4).__webglTexture;
        i2.bindTexture(e4, r4), _2(e4), i2.unbindTexture();
      }
    }
  }, this.updateMultisampleRenderTarget = function(e3) {
    if (a2 && e3.samples > 0 && false === U2(e3)) {
      const r3 = e3.isWebGLMultipleRenderTargets ? e3.texture : [e3.texture], s3 = e3.width, o3 = e3.height;
      let a3 = 16384;
      const l3 = [], c3 = e3.stencilBuffer ? 33306 : 36096, h3 = n2.get(e3), u3 = true === e3.isWebGLMultipleRenderTargets;
      if (u3) for (let e4 = 0; e4 < r3.length; e4++) i2.bindFramebuffer(36160, h3.__webglMultisampledFramebuffer), t6.framebufferRenderbuffer(36160, 36064 + e4, 36161, null), i2.bindFramebuffer(36160, h3.__webglFramebuffer), t6.framebufferTexture2D(36009, 36064 + e4, 3553, null, 0);
      i2.bindFramebuffer(36008, h3.__webglMultisampledFramebuffer), i2.bindFramebuffer(36009, h3.__webglFramebuffer);
      for (let i3 = 0; i3 < r3.length; i3++) {
        l3.push(36064 + i3), e3.depthBuffer && l3.push(c3);
        const d3 = void 0 !== h3.__ignoreDepthValues && h3.__ignoreDepthValues;
        if (false === d3 && (e3.depthBuffer && (a3 |= 256), e3.stencilBuffer && (a3 |= 1024)), u3 && t6.framebufferRenderbuffer(36008, 36064, 36161, h3.__webglColorRenderbuffer[i3]), true === d3 && (t6.invalidateFramebuffer(36008, [c3]), t6.invalidateFramebuffer(36009, [c3])), u3) {
          const e4 = n2.get(r3[i3]).__webglTexture;
          t6.framebufferTexture2D(36009, 36064, 3553, e4, 0);
        }
        t6.blitFramebuffer(0, 0, s3, o3, 0, 0, s3, o3, a3, 9728), p2 && t6.invalidateFramebuffer(36008, l3);
      }
      if (i2.bindFramebuffer(36008, null), i2.bindFramebuffer(36009, null), u3) for (let e4 = 0; e4 < r3.length; e4++) {
        i2.bindFramebuffer(36160, h3.__webglMultisampledFramebuffer), t6.framebufferRenderbuffer(36160, 36064 + e4, 36161, h3.__webglColorRenderbuffer[e4]);
        const s4 = n2.get(r3[e4]).__webglTexture;
        i2.bindFramebuffer(36160, h3.__webglFramebuffer), t6.framebufferTexture2D(36009, 36064 + e4, 3553, s4, 0);
      }
      i2.bindFramebuffer(36009, h3.__webglMultisampledFramebuffer);
    }
  }, this.setupDepthRenderbuffer = B2, this.setupFrameBufferTexture = F2, this.useMultisampledRTT = U2;
}
function ad(t6, e2, i2) {
  const n2 = i2.isWebGL2;
  return { convert: function(i3, r2 = null) {
    let s2;
    if (i3 === Rr) return 5121;
    if (i3 === Nr) return 32819;
    if (i3 === Br) return 32820;
    if (i3 === Pr) return 5120;
    if (i3 === Lr) return 5122;
    if (i3 === Ir) return 5123;
    if (i3 === Dr) return 5124;
    if (i3 === Or) return 5125;
    if (i3 === zr) return 5126;
    if (i3 === Fr) return n2 ? 5131 : (s2 = e2.get("OES_texture_half_float"), null !== s2 ? s2.HALF_FLOAT_OES : null);
    if (i3 === Ur) return 6406;
    if (i3 === Vr) return 6408;
    if (i3 === jr) return 6409;
    if (i3 === Gr) return 6410;
    if (i3 === Wr) return 6402;
    if (i3 === qr) return 34041;
    if (i3 === Xr) return 6403;
    if (i3 === Hr) return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"), 6408;
    if (i3 === _o) return s2 = e2.get("EXT_sRGB"), null !== s2 ? s2.SRGB_ALPHA_EXT : null;
    if (i3 === Yr) return 36244;
    if (i3 === Zr) return 33319;
    if (i3 === Jr) return 33320;
    if (i3 === Kr) return 36249;
    if (i3 === $r || i3 === Qr || i3 === ts || i3 === es) if (r2 === ks) {
      if (s2 = e2.get("WEBGL_compressed_texture_s3tc_srgb"), null === s2) return null;
      if (i3 === $r) return s2.COMPRESSED_SRGB_S3TC_DXT1_EXT;
      if (i3 === Qr) return s2.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
      if (i3 === ts) return s2.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
      if (i3 === es) return s2.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
    } else {
      if (s2 = e2.get("WEBGL_compressed_texture_s3tc"), null === s2) return null;
      if (i3 === $r) return s2.COMPRESSED_RGB_S3TC_DXT1_EXT;
      if (i3 === Qr) return s2.COMPRESSED_RGBA_S3TC_DXT1_EXT;
      if (i3 === ts) return s2.COMPRESSED_RGBA_S3TC_DXT3_EXT;
      if (i3 === es) return s2.COMPRESSED_RGBA_S3TC_DXT5_EXT;
    }
    if (i3 === is || i3 === ns || i3 === rs || i3 === ss) {
      if (s2 = e2.get("WEBGL_compressed_texture_pvrtc"), null === s2) return null;
      if (i3 === is) return s2.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
      if (i3 === ns) return s2.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
      if (i3 === rs) return s2.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
      if (i3 === ss) return s2.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
    }
    if (i3 === os) return s2 = e2.get("WEBGL_compressed_texture_etc1"), null !== s2 ? s2.COMPRESSED_RGB_ETC1_WEBGL : null;
    if (i3 === as || i3 === ls) {
      if (s2 = e2.get("WEBGL_compressed_texture_etc"), null === s2) return null;
      if (i3 === as) return r2 === ks ? s2.COMPRESSED_SRGB8_ETC2 : s2.COMPRESSED_RGB8_ETC2;
      if (i3 === ls) return r2 === ks ? s2.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s2.COMPRESSED_RGBA8_ETC2_EAC;
    }
    if (i3 === cs || i3 === hs || i3 === us || i3 === ds || i3 === ps || i3 === fs || i3 === ms || i3 === gs || i3 === vs || i3 === ys || i3 === xs || i3 === bs || i3 === ws || i3 === _s) {
      if (s2 = e2.get("WEBGL_compressed_texture_astc"), null === s2) return null;
      if (i3 === cs) return r2 === ks ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s2.COMPRESSED_RGBA_ASTC_4x4_KHR;
      if (i3 === hs) return r2 === ks ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s2.COMPRESSED_RGBA_ASTC_5x4_KHR;
      if (i3 === us) return r2 === ks ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s2.COMPRESSED_RGBA_ASTC_5x5_KHR;
      if (i3 === ds) return r2 === ks ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s2.COMPRESSED_RGBA_ASTC_6x5_KHR;
      if (i3 === ps) return r2 === ks ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s2.COMPRESSED_RGBA_ASTC_6x6_KHR;
      if (i3 === fs) return r2 === ks ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s2.COMPRESSED_RGBA_ASTC_8x5_KHR;
      if (i3 === ms) return r2 === ks ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s2.COMPRESSED_RGBA_ASTC_8x6_KHR;
      if (i3 === gs) return r2 === ks ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s2.COMPRESSED_RGBA_ASTC_8x8_KHR;
      if (i3 === vs) return r2 === ks ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s2.COMPRESSED_RGBA_ASTC_10x5_KHR;
      if (i3 === ys) return r2 === ks ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s2.COMPRESSED_RGBA_ASTC_10x6_KHR;
      if (i3 === xs) return r2 === ks ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s2.COMPRESSED_RGBA_ASTC_10x8_KHR;
      if (i3 === bs) return r2 === ks ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s2.COMPRESSED_RGBA_ASTC_10x10_KHR;
      if (i3 === ws) return r2 === ks ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s2.COMPRESSED_RGBA_ASTC_12x10_KHR;
      if (i3 === _s) return r2 === ks ? s2.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s2.COMPRESSED_RGBA_ASTC_12x12_KHR;
    }
    if (i3 === Ss) {
      if (s2 = e2.get("EXT_texture_compression_bptc"), null === s2) return null;
      if (i3 === Ss) return r2 === ks ? s2.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s2.COMPRESSED_RGBA_BPTC_UNORM_EXT;
    }
    return i3 === kr ? n2 ? 34042 : (s2 = e2.get("WEBGL_depth_texture"), null !== s2 ? s2.UNSIGNED_INT_24_8_WEBGL : null) : void 0 !== t6[i3] ? t6[i3] : null;
  } };
}
var ld = class extends _c {
  constructor(t6 = []) {
    super(), this.isArrayCamera = true, this.cameras = t6;
  }
};
var cd = class extends ml {
  constructor() {
    super(), this.isGroup = true, this.type = "Group";
  }
};
var hd = { type: "move" };
var ud = class {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return null === this._hand && (this._hand = new cd(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = { pinching: false }), this._hand;
  }
  getTargetRaySpace() {
    return null === this._targetRay && (this._targetRay = new cd(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new pa(), this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new pa()), this._targetRay;
  }
  getGripSpace() {
    return null === this._grip && (this._grip = new cd(), this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new pa(), this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new pa()), this._grip;
  }
  dispatchEvent(t6) {
    return null !== this._targetRay && this._targetRay.dispatchEvent(t6), null !== this._grip && this._grip.dispatchEvent(t6), null !== this._hand && this._hand.dispatchEvent(t6), this;
  }
  disconnect(t6) {
    return this.dispatchEvent({ type: "disconnected", data: t6 }), null !== this._targetRay && (this._targetRay.visible = false), null !== this._grip && (this._grip.visible = false), null !== this._hand && (this._hand.visible = false), this;
  }
  update(t6, e2, i2) {
    let n2 = null, r2 = null, s2 = null;
    const o2 = this._targetRay, a2 = this._grip, l2 = this._hand;
    if (t6 && "visible-blurred" !== e2.session.visibilityState) {
      if (l2 && t6.hand) {
        s2 = true;
        for (const n4 of t6.hand.values()) {
          const t7 = e2.getJointPose(n4, i2);
          if (void 0 === l2.joints[n4.jointName]) {
            const t8 = new cd();
            t8.matrixAutoUpdate = false, t8.visible = false, l2.joints[n4.jointName] = t8, l2.add(t8);
          }
          const r4 = l2.joints[n4.jointName];
          null !== t7 && (r4.matrix.fromArray(t7.transform.matrix), r4.matrix.decompose(r4.position, r4.rotation, r4.scale), r4.jointRadius = t7.radius), r4.visible = null !== t7;
        }
        const n3 = l2.joints["index-finger-tip"], r3 = l2.joints["thumb-tip"], o3 = n3.position.distanceTo(r3.position), a3 = 0.02, c2 = 5e-3;
        l2.inputState.pinching && o3 > a3 + c2 ? (l2.inputState.pinching = false, this.dispatchEvent({ type: "pinchend", handedness: t6.handedness, target: this })) : !l2.inputState.pinching && o3 <= a3 - c2 && (l2.inputState.pinching = true, this.dispatchEvent({ type: "pinchstart", handedness: t6.handedness, target: this }));
      } else null !== a2 && t6.gripSpace && (r2 = e2.getPose(t6.gripSpace, i2), null !== r2 && (a2.matrix.fromArray(r2.transform.matrix), a2.matrix.decompose(a2.position, a2.rotation, a2.scale), r2.linearVelocity ? (a2.hasLinearVelocity = true, a2.linearVelocity.copy(r2.linearVelocity)) : a2.hasLinearVelocity = false, r2.angularVelocity ? (a2.hasAngularVelocity = true, a2.angularVelocity.copy(r2.angularVelocity)) : a2.hasAngularVelocity = false));
      null !== o2 && (n2 = e2.getPose(t6.targetRaySpace, i2), null === n2 && null !== r2 && (n2 = r2), null !== n2 && (o2.matrix.fromArray(n2.transform.matrix), o2.matrix.decompose(o2.position, o2.rotation, o2.scale), n2.linearVelocity ? (o2.hasLinearVelocity = true, o2.linearVelocity.copy(n2.linearVelocity)) : o2.hasLinearVelocity = false, n2.angularVelocity ? (o2.hasAngularVelocity = true, o2.angularVelocity.copy(n2.angularVelocity)) : o2.hasAngularVelocity = false, this.dispatchEvent(hd)));
    }
    return null !== o2 && (o2.visible = null !== n2), null !== a2 && (a2.visible = null !== r2), null !== l2 && (l2.visible = null !== s2), this;
  }
};
var dd = class extends ra {
  constructor(t6, e2, i2, n2, r2, s2, o2, a2, l2, c2) {
    if ((c2 = void 0 !== c2 ? c2 : Wr) !== Wr && c2 !== qr) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    void 0 === i2 && c2 === Wr && (i2 = Or), void 0 === i2 && c2 === qr && (i2 = kr), super(null, n2, r2, s2, o2, a2, c2, i2, l2), this.isDepthTexture = true, this.image = { width: t6, height: e2 }, this.magFilter = void 0 !== o2 ? o2 : xr, this.minFilter = void 0 !== a2 ? a2 : xr, this.flipY = false, this.generateMipmaps = false;
  }
};
var pd = class extends So {
  constructor(t6, e2) {
    super();
    const i2 = this;
    let n2 = null, r2 = 1, s2 = null, o2 = "local-floor", a2 = null, l2 = null, c2 = null, h2 = null, u2 = null, d2 = null;
    const p2 = e2.getContextAttributes();
    let f2 = null, m2 = null;
    const g2 = [], v2 = [], y2 = new _c();
    y2.layers.enable(1), y2.viewport = new sa();
    const x2 = new _c();
    x2.layers.enable(2), x2.viewport = new sa();
    const b2 = [y2, x2], w2 = new ld();
    w2.layers.enable(1), w2.layers.enable(2);
    let _2 = null, S2 = null;
    function M2(t7) {
      const e3 = v2.indexOf(t7.inputSource);
      if (-1 === e3) return;
      const i3 = g2[e3];
      void 0 !== i3 && i3.dispatchEvent({ type: t7.type, data: t7.inputSource });
    }
    function T2() {
      n2.removeEventListener("select", M2), n2.removeEventListener("selectstart", M2), n2.removeEventListener("selectend", M2), n2.removeEventListener("squeeze", M2), n2.removeEventListener("squeezestart", M2), n2.removeEventListener("squeezeend", M2), n2.removeEventListener("end", T2), n2.removeEventListener("inputsourceschange", E2);
      for (let t7 = 0; t7 < g2.length; t7++) {
        const e3 = v2[t7];
        null !== e3 && (v2[t7] = null, g2[t7].disconnect(e3));
      }
      _2 = null, S2 = null, t6.setRenderTarget(f2), u2 = null, h2 = null, c2 = null, n2 = null, m2 = null, L2.stop(), i2.isPresenting = false, i2.dispatchEvent({ type: "sessionend" });
    }
    function E2(t7) {
      for (let e3 = 0; e3 < t7.removed.length; e3++) {
        const i3 = t7.removed[e3], n3 = v2.indexOf(i3);
        n3 >= 0 && (v2[n3] = null, g2[n3].dispatchEvent({ type: "disconnected", data: i3 }));
      }
      for (let e3 = 0; e3 < t7.added.length; e3++) {
        const i3 = t7.added[e3];
        let n3 = v2.indexOf(i3);
        if (-1 === n3) {
          for (let t8 = 0; t8 < g2.length; t8++) {
            if (t8 >= v2.length) {
              v2.push(i3), n3 = t8;
              break;
            }
            if (null === v2[t8]) {
              v2[t8] = i3, n3 = t8;
              break;
            }
          }
          if (-1 === n3) break;
        }
        const r3 = g2[n3];
        r3 && r3.dispatchEvent({ type: "connected", data: i3 });
      }
    }
    this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getController = function(t7) {
      let e3 = g2[t7];
      return void 0 === e3 && (e3 = new ud(), g2[t7] = e3), e3.getTargetRaySpace();
    }, this.getControllerGrip = function(t7) {
      let e3 = g2[t7];
      return void 0 === e3 && (e3 = new ud(), g2[t7] = e3), e3.getGripSpace();
    }, this.getHand = function(t7) {
      let e3 = g2[t7];
      return void 0 === e3 && (e3 = new ud(), g2[t7] = e3), e3.getHandSpace();
    }, this.setFramebufferScaleFactor = function(t7) {
      r2 = t7, true === i2.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(t7) {
      o2 = t7, true === i2.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return a2 || s2;
    }, this.setReferenceSpace = function(t7) {
      a2 = t7;
    }, this.getBaseLayer = function() {
      return null !== h2 ? h2 : u2;
    }, this.getBinding = function() {
      return c2;
    }, this.getFrame = function() {
      return d2;
    }, this.getSession = function() {
      return n2;
    }, this.setSession = async function(l3) {
      if (n2 = l3, null !== n2) {
        if (f2 = t6.getRenderTarget(), n2.addEventListener("select", M2), n2.addEventListener("selectstart", M2), n2.addEventListener("selectend", M2), n2.addEventListener("squeeze", M2), n2.addEventListener("squeezestart", M2), n2.addEventListener("squeezeend", M2), n2.addEventListener("end", T2), n2.addEventListener("inputsourceschange", E2), true !== p2.xrCompatible && await e2.makeXRCompatible(), void 0 === n2.renderState.layers || false === t6.capabilities.isWebGL2) {
          const i3 = { antialias: void 0 !== n2.renderState.layers || p2.antialias, alpha: p2.alpha, depth: p2.depth, stencil: p2.stencil, framebufferScaleFactor: r2 };
          u2 = new XRWebGLLayer(n2, e2, i3), n2.updateRenderState({ baseLayer: u2 }), m2 = new oa(u2.framebufferWidth, u2.framebufferHeight, { format: Vr, type: Rr, encoding: t6.outputEncoding });
        } else {
          let i3 = null, s3 = null, o3 = null;
          p2.depth && (o3 = p2.stencil ? 35056 : 33190, i3 = p2.stencil ? qr : Wr, s3 = p2.stencil ? kr : Or);
          const a3 = { colorFormat: 32856, depthFormat: o3, scaleFactor: r2 };
          c2 = new XRWebGLBinding(n2, e2), h2 = c2.createProjectionLayer(a3), n2.updateRenderState({ layers: [h2] }), m2 = new oa(h2.textureWidth, h2.textureHeight, { format: Vr, type: Rr, depthTexture: new dd(h2.textureWidth, h2.textureHeight, s3, void 0, void 0, void 0, void 0, void 0, void 0, i3), stencilBuffer: p2.stencil, encoding: t6.outputEncoding, samples: p2.antialias ? 4 : 0 });
          t6.properties.get(m2).__ignoreDepthValues = h2.ignoreDepthValues;
        }
        m2.isXRRenderTarget = true, this.setFoveation(1), a2 = null, s2 = await n2.requestReferenceSpace(o2), L2.setContext(n2), L2.start(), i2.isPresenting = true, i2.dispatchEvent({ type: "sessionstart" });
      }
    };
    const A2 = new pa(), C2 = new pa();
    function R2(t7, e3) {
      null === e3 ? t7.matrixWorld.copy(t7.matrix) : t7.matrixWorld.multiplyMatrices(e3.matrixWorld, t7.matrix), t7.matrixWorldInverse.copy(t7.matrixWorld).invert();
    }
    this.updateCamera = function(t7) {
      if (null === n2) return;
      w2.near = x2.near = y2.near = t7.near, w2.far = x2.far = y2.far = t7.far, _2 === w2.near && S2 === w2.far || (n2.updateRenderState({ depthNear: w2.near, depthFar: w2.far }), _2 = w2.near, S2 = w2.far);
      const e3 = t7.parent, i3 = w2.cameras;
      R2(w2, e3);
      for (let t8 = 0; t8 < i3.length; t8++) R2(i3[t8], e3);
      w2.matrixWorld.decompose(w2.position, w2.quaternion, w2.scale), t7.position.copy(w2.position), t7.quaternion.copy(w2.quaternion), t7.scale.copy(w2.scale), t7.matrix.copy(w2.matrix), t7.matrixWorld.copy(w2.matrixWorld);
      const r3 = t7.children;
      for (let t8 = 0, e4 = r3.length; t8 < e4; t8++) r3[t8].updateMatrixWorld(true);
      2 === i3.length ? (function(t8, e4, i4) {
        A2.setFromMatrixPosition(e4.matrixWorld), C2.setFromMatrixPosition(i4.matrixWorld);
        const n3 = A2.distanceTo(C2), r4 = e4.projectionMatrix.elements, s3 = i4.projectionMatrix.elements, o3 = r4[14] / (r4[10] - 1), a3 = r4[14] / (r4[10] + 1), l3 = (r4[9] + 1) / r4[5], c3 = (r4[9] - 1) / r4[5], h3 = (r4[8] - 1) / r4[0], u3 = (s3[8] + 1) / s3[0], d3 = o3 * h3, p3 = o3 * u3, f3 = n3 / (-h3 + u3), m3 = f3 * -h3;
        e4.matrixWorld.decompose(t8.position, t8.quaternion, t8.scale), t8.translateX(m3), t8.translateZ(f3), t8.matrixWorld.compose(t8.position, t8.quaternion, t8.scale), t8.matrixWorldInverse.copy(t8.matrixWorld).invert();
        const g3 = o3 + f3, v3 = a3 + f3, y3 = d3 - m3, x3 = p3 + (n3 - m3), b3 = l3 * a3 / v3 * g3, w3 = c3 * a3 / v3 * g3;
        t8.projectionMatrix.makePerspective(y3, x3, b3, w3, g3, v3);
      })(w2, y2, x2) : w2.projectionMatrix.copy(y2.projectionMatrix);
    }, this.getCamera = function() {
      return w2;
    }, this.getFoveation = function() {
      return null !== h2 ? h2.fixedFoveation : null !== u2 ? u2.fixedFoveation : void 0;
    }, this.setFoveation = function(t7) {
      null !== h2 && (h2.fixedFoveation = t7), null !== u2 && void 0 !== u2.fixedFoveation && (u2.fixedFoveation = t7);
    };
    let P2 = null;
    const L2 = new Oc();
    L2.setAnimationLoop((function(e3, i3) {
      if (l2 = i3.getViewerPose(a2 || s2), d2 = i3, null !== l2) {
        const e4 = l2.views;
        null !== u2 && (t6.setRenderTargetFramebuffer(m2, u2.framebuffer), t6.setRenderTarget(m2));
        let i4 = false;
        e4.length !== w2.cameras.length && (w2.cameras.length = 0, i4 = true);
        for (let n3 = 0; n3 < e4.length; n3++) {
          const r3 = e4[n3];
          let s3 = null;
          if (null !== u2) s3 = u2.getViewport(r3);
          else {
            const e5 = c2.getViewSubImage(h2, r3);
            s3 = e5.viewport, 0 === n3 && (t6.setRenderTargetTextures(m2, e5.colorTexture, h2.ignoreDepthValues ? void 0 : e5.depthStencilTexture), t6.setRenderTarget(m2));
          }
          let o3 = b2[n3];
          void 0 === o3 && (o3 = new _c(), o3.layers.enable(n3), o3.viewport = new sa(), b2[n3] = o3), o3.matrix.fromArray(r3.transform.matrix), o3.projectionMatrix.fromArray(r3.projectionMatrix), o3.viewport.set(s3.x, s3.y, s3.width, s3.height), 0 === n3 && w2.matrix.copy(o3.matrix), true === i4 && w2.cameras.push(o3);
        }
      }
      for (let t7 = 0; t7 < g2.length; t7++) {
        const e4 = v2[t7], n3 = g2[t7];
        null !== e4 && void 0 !== n3 && n3.update(e4, i3, a2 || s2);
      }
      P2 && P2(e3, i3), d2 = null;
    })), this.setAnimationLoop = function(t7) {
      P2 = t7;
    }, this.dispose = function() {
    };
  }
};
function fd(t6, e2) {
  function i2(i3, n2) {
    i3.opacity.value = n2.opacity, n2.color && i3.diffuse.value.copy(n2.color), n2.emissive && i3.emissive.value.copy(n2.emissive).multiplyScalar(n2.emissiveIntensity), n2.map && (i3.map.value = n2.map), n2.alphaMap && (i3.alphaMap.value = n2.alphaMap), n2.bumpMap && (i3.bumpMap.value = n2.bumpMap, i3.bumpScale.value = n2.bumpScale, n2.side === wn && (i3.bumpScale.value *= -1)), n2.displacementMap && (i3.displacementMap.value = n2.displacementMap, i3.displacementScale.value = n2.displacementScale, i3.displacementBias.value = n2.displacementBias), n2.emissiveMap && (i3.emissiveMap.value = n2.emissiveMap), n2.normalMap && (i3.normalMap.value = n2.normalMap, i3.normalScale.value.copy(n2.normalScale), n2.side === wn && i3.normalScale.value.negate()), n2.specularMap && (i3.specularMap.value = n2.specularMap), n2.alphaTest > 0 && (i3.alphaTest.value = n2.alphaTest);
    const r2 = e2.get(n2).envMap;
    if (r2 && (i3.envMap.value = r2, i3.flipEnvMap.value = r2.isCubeTexture && false === r2.isRenderTargetTexture ? -1 : 1, i3.reflectivity.value = n2.reflectivity, i3.ior.value = n2.ior, i3.refractionRatio.value = n2.refractionRatio), n2.lightMap) {
      i3.lightMap.value = n2.lightMap;
      const e3 = true !== t6.physicallyCorrectLights ? Math.PI : 1;
      i3.lightMapIntensity.value = n2.lightMapIntensity * e3;
    }
    let s2, o2;
    n2.aoMap && (i3.aoMap.value = n2.aoMap, i3.aoMapIntensity.value = n2.aoMapIntensity), n2.map ? s2 = n2.map : n2.specularMap ? s2 = n2.specularMap : n2.displacementMap ? s2 = n2.displacementMap : n2.normalMap ? s2 = n2.normalMap : n2.bumpMap ? s2 = n2.bumpMap : n2.roughnessMap ? s2 = n2.roughnessMap : n2.metalnessMap ? s2 = n2.metalnessMap : n2.alphaMap ? s2 = n2.alphaMap : n2.emissiveMap ? s2 = n2.emissiveMap : n2.clearcoatMap ? s2 = n2.clearcoatMap : n2.clearcoatNormalMap ? s2 = n2.clearcoatNormalMap : n2.clearcoatRoughnessMap ? s2 = n2.clearcoatRoughnessMap : n2.iridescenceMap ? s2 = n2.iridescenceMap : n2.iridescenceThicknessMap ? s2 = n2.iridescenceThicknessMap : n2.specularIntensityMap ? s2 = n2.specularIntensityMap : n2.specularColorMap ? s2 = n2.specularColorMap : n2.transmissionMap ? s2 = n2.transmissionMap : n2.thicknessMap ? s2 = n2.thicknessMap : n2.sheenColorMap ? s2 = n2.sheenColorMap : n2.sheenRoughnessMap && (s2 = n2.sheenRoughnessMap), void 0 !== s2 && (s2.isWebGLRenderTarget && (s2 = s2.texture), true === s2.matrixAutoUpdate && s2.updateMatrix(), i3.uvTransform.value.copy(s2.matrix)), n2.aoMap ? o2 = n2.aoMap : n2.lightMap && (o2 = n2.lightMap), void 0 !== o2 && (o2.isWebGLRenderTarget && (o2 = o2.texture), true === o2.matrixAutoUpdate && o2.updateMatrix(), i3.uv2Transform.value.copy(o2.matrix));
  }
  return { refreshFogUniforms: function(t7, e3) {
    t7.fogColor.value.copy(e3.color), e3.isFog ? (t7.fogNear.value = e3.near, t7.fogFar.value = e3.far) : e3.isFogExp2 && (t7.fogDensity.value = e3.density);
  }, refreshMaterialUniforms: function(t7, n2, r2, s2, o2) {
    n2.isMeshBasicMaterial || n2.isMeshLambertMaterial ? i2(t7, n2) : n2.isMeshToonMaterial ? (i2(t7, n2), (function(t8, e3) {
      e3.gradientMap && (t8.gradientMap.value = e3.gradientMap);
    })(t7, n2)) : n2.isMeshPhongMaterial ? (i2(t7, n2), (function(t8, e3) {
      t8.specular.value.copy(e3.specular), t8.shininess.value = Math.max(e3.shininess, 1e-4);
    })(t7, n2)) : n2.isMeshStandardMaterial ? (i2(t7, n2), (function(t8, i3) {
      t8.roughness.value = i3.roughness, t8.metalness.value = i3.metalness, i3.roughnessMap && (t8.roughnessMap.value = i3.roughnessMap);
      i3.metalnessMap && (t8.metalnessMap.value = i3.metalnessMap);
      const n3 = e2.get(i3).envMap;
      n3 && (t8.envMapIntensity.value = i3.envMapIntensity);
    })(t7, n2), n2.isMeshPhysicalMaterial && (function(t8, e3, i3) {
      t8.ior.value = e3.ior, e3.sheen > 0 && (t8.sheenColor.value.copy(e3.sheenColor).multiplyScalar(e3.sheen), t8.sheenRoughness.value = e3.sheenRoughness, e3.sheenColorMap && (t8.sheenColorMap.value = e3.sheenColorMap), e3.sheenRoughnessMap && (t8.sheenRoughnessMap.value = e3.sheenRoughnessMap));
      e3.clearcoat > 0 && (t8.clearcoat.value = e3.clearcoat, t8.clearcoatRoughness.value = e3.clearcoatRoughness, e3.clearcoatMap && (t8.clearcoatMap.value = e3.clearcoatMap), e3.clearcoatRoughnessMap && (t8.clearcoatRoughnessMap.value = e3.clearcoatRoughnessMap), e3.clearcoatNormalMap && (t8.clearcoatNormalScale.value.copy(e3.clearcoatNormalScale), t8.clearcoatNormalMap.value = e3.clearcoatNormalMap, e3.side === wn && t8.clearcoatNormalScale.value.negate()));
      e3.iridescence > 0 && (t8.iridescence.value = e3.iridescence, t8.iridescenceIOR.value = e3.iridescenceIOR, t8.iridescenceThicknessMinimum.value = e3.iridescenceThicknessRange[0], t8.iridescenceThicknessMaximum.value = e3.iridescenceThicknessRange[1], e3.iridescenceMap && (t8.iridescenceMap.value = e3.iridescenceMap), e3.iridescenceThicknessMap && (t8.iridescenceThicknessMap.value = e3.iridescenceThicknessMap));
      e3.transmission > 0 && (t8.transmission.value = e3.transmission, t8.transmissionSamplerMap.value = i3.texture, t8.transmissionSamplerSize.value.set(i3.width, i3.height), e3.transmissionMap && (t8.transmissionMap.value = e3.transmissionMap), t8.thickness.value = e3.thickness, e3.thicknessMap && (t8.thicknessMap.value = e3.thicknessMap), t8.attenuationDistance.value = e3.attenuationDistance, t8.attenuationColor.value.copy(e3.attenuationColor));
      t8.specularIntensity.value = e3.specularIntensity, t8.specularColor.value.copy(e3.specularColor), e3.specularIntensityMap && (t8.specularIntensityMap.value = e3.specularIntensityMap);
      e3.specularColorMap && (t8.specularColorMap.value = e3.specularColorMap);
    })(t7, n2, o2)) : n2.isMeshMatcapMaterial ? (i2(t7, n2), (function(t8, e3) {
      e3.matcap && (t8.matcap.value = e3.matcap);
    })(t7, n2)) : n2.isMeshDepthMaterial ? i2(t7, n2) : n2.isMeshDistanceMaterial ? (i2(t7, n2), (function(t8, e3) {
      t8.referencePosition.value.copy(e3.referencePosition), t8.nearDistance.value = e3.nearDistance, t8.farDistance.value = e3.farDistance;
    })(t7, n2)) : n2.isMeshNormalMaterial ? i2(t7, n2) : n2.isLineBasicMaterial ? ((function(t8, e3) {
      t8.diffuse.value.copy(e3.color), t8.opacity.value = e3.opacity;
    })(t7, n2), n2.isLineDashedMaterial && (function(t8, e3) {
      t8.dashSize.value = e3.dashSize, t8.totalSize.value = e3.dashSize + e3.gapSize, t8.scale.value = e3.scale;
    })(t7, n2)) : n2.isPointsMaterial ? (function(t8, e3, i3, n3) {
      t8.diffuse.value.copy(e3.color), t8.opacity.value = e3.opacity, t8.size.value = e3.size * i3, t8.scale.value = 0.5 * n3, e3.map && (t8.map.value = e3.map);
      e3.alphaMap && (t8.alphaMap.value = e3.alphaMap);
      e3.alphaTest > 0 && (t8.alphaTest.value = e3.alphaTest);
      let r3;
      e3.map ? r3 = e3.map : e3.alphaMap && (r3 = e3.alphaMap);
      void 0 !== r3 && (true === r3.matrixAutoUpdate && r3.updateMatrix(), t8.uvTransform.value.copy(r3.matrix));
    })(t7, n2, r2, s2) : n2.isSpriteMaterial ? (function(t8, e3) {
      t8.diffuse.value.copy(e3.color), t8.opacity.value = e3.opacity, t8.rotation.value = e3.rotation, e3.map && (t8.map.value = e3.map);
      e3.alphaMap && (t8.alphaMap.value = e3.alphaMap);
      e3.alphaTest > 0 && (t8.alphaTest.value = e3.alphaTest);
      let i3;
      e3.map ? i3 = e3.map : e3.alphaMap && (i3 = e3.alphaMap);
      void 0 !== i3 && (true === i3.matrixAutoUpdate && i3.updateMatrix(), t8.uvTransform.value.copy(i3.matrix));
    })(t7, n2) : n2.isShadowMaterial ? (t7.color.value.copy(n2.color), t7.opacity.value = n2.opacity) : n2.isShaderMaterial && (n2.uniformsNeedUpdate = false);
  } };
}
function md(t6, e2, i2, n2) {
  let r2 = {}, s2 = {}, o2 = [];
  const a2 = i2.isWebGL2 ? t6.getParameter(35375) : 0;
  function l2(t7, e3, i3) {
    const n3 = t7.value;
    if (void 0 === i3[e3]) return i3[e3] = "number" == typeof n3 ? n3 : n3.clone(), true;
    if ("number" == typeof n3) {
      if (i3[e3] !== n3) return i3[e3] = n3, true;
    } else {
      const t8 = i3[e3];
      if (false === t8.equals(n3)) return t8.copy(n3), true;
    }
    return false;
  }
  function c2(t7) {
    const e3 = t7.value, i3 = { boundary: 0, storage: 0 };
    return "number" == typeof e3 ? (i3.boundary = 4, i3.storage = 4) : e3.isVector2 ? (i3.boundary = 8, i3.storage = 8) : e3.isVector3 || e3.isColor ? (i3.boundary = 16, i3.storage = 12) : e3.isVector4 ? (i3.boundary = 16, i3.storage = 16) : e3.isMatrix3 ? (i3.boundary = 48, i3.storage = 48) : e3.isMatrix4 ? (i3.boundary = 64, i3.storage = 64) : e3.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", e3), i3;
  }
  function h2(e3) {
    const i3 = e3.target;
    i3.removeEventListener("dispose", h2);
    const n3 = o2.indexOf(i3.__bindingPointIndex);
    o2.splice(n3, 1), t6.deleteBuffer(r2[i3.id]), delete r2[i3.id], delete s2[i3.id];
  }
  return { bind: function(t7, e3) {
    const i3 = e3.program;
    n2.uniformBlockBinding(t7, i3);
  }, update: function(i3, u2) {
    let d2 = r2[i3.id];
    void 0 === d2 && (!(function(t7) {
      const e3 = t7.uniforms;
      let i4 = 0;
      const n3 = 16;
      let r3 = 0;
      for (let t8 = 0, s3 = e3.length; t8 < s3; t8++) {
        const s4 = e3[t8], o3 = c2(s4);
        if (s4.__data = new Float32Array(o3.storage / Float32Array.BYTES_PER_ELEMENT), s4.__offset = i4, t8 > 0) {
          r3 = i4 % n3;
          0 !== r3 && n3 - r3 - o3.boundary < 0 && (i4 += n3 - r3, s4.__offset = i4);
        }
        i4 += o3.storage;
      }
      r3 = i4 % n3, r3 > 0 && (i4 += n3 - r3);
      t7.__size = i4, t7.__cache = {};
    })(i3), d2 = (function(e3) {
      const i4 = (function() {
        for (let t7 = 0; t7 < a2; t7++) if (-1 === o2.indexOf(t7)) return o2.push(t7), t7;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
      })();
      e3.__bindingPointIndex = i4;
      const n3 = t6.createBuffer(), r3 = e3.__size, s3 = e3.usage;
      return t6.bindBuffer(35345, n3), t6.bufferData(35345, r3, s3), t6.bindBuffer(35345, null), t6.bindBufferBase(35345, i4, n3), n3;
    })(i3), r2[i3.id] = d2, i3.addEventListener("dispose", h2));
    const p2 = u2.program;
    n2.updateUBOMapping(i3, p2);
    const f2 = e2.render.frame;
    s2[i3.id] !== f2 && (!(function(e3) {
      const i4 = r2[e3.id], n3 = e3.uniforms, s3 = e3.__cache;
      t6.bindBuffer(35345, i4);
      for (let e4 = 0, i5 = n3.length; e4 < i5; e4++) {
        const i6 = n3[e4];
        if (true === l2(i6, e4, s3)) {
          const e5 = i6.value, n4 = i6.__offset;
          "number" == typeof e5 ? (i6.__data[0] = e5, t6.bufferSubData(35345, n4, i6.__data)) : (i6.value.isMatrix3 ? (i6.__data[0] = i6.value.elements[0], i6.__data[1] = i6.value.elements[1], i6.__data[2] = i6.value.elements[2], i6.__data[3] = i6.value.elements[0], i6.__data[4] = i6.value.elements[3], i6.__data[5] = i6.value.elements[4], i6.__data[6] = i6.value.elements[5], i6.__data[7] = i6.value.elements[0], i6.__data[8] = i6.value.elements[6], i6.__data[9] = i6.value.elements[7], i6.__data[10] = i6.value.elements[8], i6.__data[11] = i6.value.elements[0]) : e5.toArray(i6.__data), t6.bufferSubData(35345, n4, i6.__data));
        }
      }
      t6.bindBuffer(35345, null);
    })(i3), s2[i3.id] = f2);
  }, dispose: function() {
    for (const e3 in r2) t6.deleteBuffer(r2[e3]);
    o2 = [], r2 = {}, s2 = {};
  } };
}
function gd(t6 = {}) {
  this.isWebGLRenderer = true;
  const e2 = void 0 !== t6.canvas ? t6.canvas : (function() {
    const t7 = Ho("canvas");
    return t7.style.display = "block", t7;
  })(), i2 = void 0 !== t6.context ? t6.context : null, n2 = void 0 === t6.depth || t6.depth, r2 = void 0 === t6.stencil || t6.stencil, s2 = void 0 !== t6.antialias && t6.antialias, o2 = void 0 === t6.premultipliedAlpha || t6.premultipliedAlpha, a2 = void 0 !== t6.preserveDrawingBuffer && t6.preserveDrawingBuffer, l2 = void 0 !== t6.powerPreference ? t6.powerPreference : "default", c2 = void 0 !== t6.failIfMajorPerformanceCaveat && t6.failIfMajorPerformanceCaveat;
  let h2;
  h2 = null !== i2 ? i2.getContextAttributes().alpha : void 0 !== t6.alpha && t6.alpha;
  let u2 = null, d2 = null;
  const p2 = [], f2 = [];
  this.domElement = e2, this.debug = { checkShaderErrors: true }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this.outputEncoding = Bs, this.physicallyCorrectLights = false, this.toneMapping = rr, this.toneMappingExposure = 1, Object.defineProperties(this, { gammaFactor: { get: function() {
    return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2;
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
  } } });
  const m2 = this;
  let g2 = false, v2 = 0, y2 = 0, x2 = null, b2 = -1, w2 = null;
  const _2 = new sa(), S2 = new sa();
  let M2 = null, T2 = e2.width, E2 = e2.height, A2 = 1, C2 = null, R2 = null;
  const P2 = new sa(0, 0, T2, E2), L2 = new sa(0, 0, T2, E2);
  let I2 = false;
  const D2 = new Dc();
  let O2 = false, z2 = false, F2 = null;
  const N2 = new Ga(), B2 = new Fo(), k2 = new pa(), U2 = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
  function H2() {
    return null === x2 ? A2 : 1;
  }
  let V2, j2, G2, W2, q2, X2, Y2, Z2, J2, K2, $2, Q2, tt2, et2, it2, nt2, rt2, st2, ot2, at2, lt2, ct2, ht2, ut2, dt2 = i2;
  function pt2(t7, i3) {
    for (let n3 = 0; n3 < t7.length; n3++) {
      const r3 = t7[n3], s3 = e2.getContext(r3, i3);
      if (null !== s3) return s3;
    }
    return null;
  }
  try {
    const t7 = { alpha: true, depth: n2, stencil: r2, antialias: s2, premultipliedAlpha: o2, preserveDrawingBuffer: a2, powerPreference: l2, failIfMajorPerformanceCaveat: c2 };
    if ("setAttribute" in e2 && e2.setAttribute("data-engine", `three.js r${cn}`), e2.addEventListener("webglcontextlost", gt2, false), e2.addEventListener("webglcontextrestored", vt2, false), e2.addEventListener("webglcontextcreationerror", yt2, false), null === dt2) {
      const e3 = ["webgl2", "webgl", "experimental-webgl"];
      if (true === m2.isWebGL1Renderer && e3.shift(), dt2 = pt2(e3, t7), null === dt2) throw pt2(e3) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
    }
    void 0 === dt2.getShaderPrecisionFormat && (dt2.getShaderPrecisionFormat = function() {
      return { rangeMin: 1, rangeMax: 1, precision: 1 };
    });
  } catch (t7) {
    throw console.error("THREE.WebGLRenderer: " + t7.message), t7;
  }
  function ft2() {
    V2 = new lh(dt2), j2 = new jc(dt2, V2, t6), V2.init(j2), ct2 = new ad(dt2, V2, j2), G2 = new sd(dt2, V2, j2), W2 = new uh(), q2 = new ju(), X2 = new od(dt2, V2, G2, q2, j2, ct2, W2), Y2 = new Wc(m2), Z2 = new ah(m2), J2 = new zc(dt2, j2), ht2 = new Hc(dt2, V2, J2, j2), K2 = new ch(dt2, J2, W2, ht2), $2 = new gh(dt2, K2, J2, W2), ot2 = new mh(dt2, j2, X2), nt2 = new Gc(q2), Q2 = new Vu(m2, Y2, Z2, V2, j2, ht2, nt2), tt2 = new fd(m2, q2), et2 = new Xu(), it2 = new Qu(V2, j2), st2 = new Uc(m2, Y2, G2, $2, h2, o2), rt2 = new rd(m2, $2, j2), ut2 = new md(dt2, W2, j2, G2), at2 = new Vc(dt2, V2, W2, j2), lt2 = new hh(dt2, V2, W2, j2), W2.programs = Q2.programs, m2.capabilities = j2, m2.extensions = V2, m2.properties = q2, m2.renderLists = et2, m2.shadowMap = rt2, m2.state = G2, m2.info = W2;
  }
  ft2();
  const mt2 = new pd(m2, dt2);
  function gt2(t7) {
    t7.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), g2 = true;
  }
  function vt2() {
    console.log("THREE.WebGLRenderer: Context Restored."), g2 = false;
    const t7 = W2.autoReset, e3 = rt2.enabled, i3 = rt2.autoUpdate, n3 = rt2.needsUpdate, r3 = rt2.type;
    ft2(), W2.autoReset = t7, rt2.enabled = e3, rt2.autoUpdate = i3, rt2.needsUpdate = n3, rt2.type = r3;
  }
  function yt2(t7) {
    console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", t7.statusMessage);
  }
  function xt2(t7) {
    const e3 = t7.target;
    e3.removeEventListener("dispose", xt2), (function(t8) {
      (function(t9) {
        const e4 = q2.get(t9).programs;
        void 0 !== e4 && (e4.forEach((function(t10) {
          Q2.releaseProgram(t10);
        })), t9.isShaderMaterial && Q2.releaseShaderCache(t9));
      })(t8), q2.remove(t8);
    })(e3);
  }
  this.xr = mt2, this.getContext = function() {
    return dt2;
  }, this.getContextAttributes = function() {
    return dt2.getContextAttributes();
  }, this.forceContextLoss = function() {
    const t7 = V2.get("WEBGL_lose_context");
    t7 && t7.loseContext();
  }, this.forceContextRestore = function() {
    const t7 = V2.get("WEBGL_lose_context");
    t7 && t7.restoreContext();
  }, this.getPixelRatio = function() {
    return A2;
  }, this.setPixelRatio = function(t7) {
    void 0 !== t7 && (A2 = t7, this.setSize(T2, E2, false));
  }, this.getSize = function(t7) {
    return t7.set(T2, E2);
  }, this.setSize = function(t7, i3, n3) {
    mt2.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (T2 = t7, E2 = i3, e2.width = Math.floor(t7 * A2), e2.height = Math.floor(i3 * A2), false !== n3 && (e2.style.width = t7 + "px", e2.style.height = i3 + "px"), this.setViewport(0, 0, t7, i3));
  }, this.getDrawingBufferSize = function(t7) {
    return t7.set(T2 * A2, E2 * A2).floor();
  }, this.setDrawingBufferSize = function(t7, i3, n3) {
    T2 = t7, E2 = i3, A2 = n3, e2.width = Math.floor(t7 * n3), e2.height = Math.floor(i3 * n3), this.setViewport(0, 0, t7, i3);
  }, this.getCurrentViewport = function(t7) {
    return t7.copy(_2);
  }, this.getViewport = function(t7) {
    return t7.copy(P2);
  }, this.setViewport = function(t7, e3, i3, n3) {
    t7.isVector4 ? P2.set(t7.x, t7.y, t7.z, t7.w) : P2.set(t7, e3, i3, n3), G2.viewport(_2.copy(P2).multiplyScalar(A2).floor());
  }, this.getScissor = function(t7) {
    return t7.copy(L2);
  }, this.setScissor = function(t7, e3, i3, n3) {
    t7.isVector4 ? L2.set(t7.x, t7.y, t7.z, t7.w) : L2.set(t7, e3, i3, n3), G2.scissor(S2.copy(L2).multiplyScalar(A2).floor());
  }, this.getScissorTest = function() {
    return I2;
  }, this.setScissorTest = function(t7) {
    G2.setScissorTest(I2 = t7);
  }, this.setOpaqueSort = function(t7) {
    C2 = t7;
  }, this.setTransparentSort = function(t7) {
    R2 = t7;
  }, this.getClearColor = function(t7) {
    return t7.copy(st2.getClearColor());
  }, this.setClearColor = function() {
    st2.setClearColor.apply(st2, arguments);
  }, this.getClearAlpha = function() {
    return st2.getClearAlpha();
  }, this.setClearAlpha = function() {
    st2.setClearAlpha.apply(st2, arguments);
  }, this.clear = function(t7 = true, e3 = true, i3 = true) {
    let n3 = 0;
    t7 && (n3 |= 16384), e3 && (n3 |= 256), i3 && (n3 |= 1024), dt2.clear(n3);
  }, this.clearColor = function() {
    this.clear(true, false, false);
  }, this.clearDepth = function() {
    this.clear(false, true, false);
  }, this.clearStencil = function() {
    this.clear(false, false, true);
  }, this.dispose = function() {
    e2.removeEventListener("webglcontextlost", gt2, false), e2.removeEventListener("webglcontextrestored", vt2, false), e2.removeEventListener("webglcontextcreationerror", yt2, false), et2.dispose(), it2.dispose(), q2.dispose(), Y2.dispose(), Z2.dispose(), $2.dispose(), ht2.dispose(), ut2.dispose(), Q2.dispose(), mt2.dispose(), mt2.removeEventListener("sessionstart", wt2), mt2.removeEventListener("sessionend", _t2), F2 && (F2.dispose(), F2 = null), St2.stop();
  }, this.renderBufferDirect = function(t7, e3, i3, n3, r3, s3) {
    null === e3 && (e3 = U2);
    const o3 = r3.isMesh && r3.matrixWorld.determinant() < 0, a3 = (function(t8, e4, i4, n4, r4) {
      true !== e4.isScene && (e4 = U2);
      X2.resetTextureUnits();
      const s4 = e4.fog, o4 = n4.isMeshStandardMaterial ? e4.environment : null, a4 = null === x2 ? m2.outputEncoding : true === x2.isXRRenderTarget ? x2.texture.encoding : Bs, l4 = (n4.isMeshStandardMaterial ? Z2 : Y2).get(n4.envMap || o4), c4 = true === n4.vertexColors && !!i4.attributes.color && 4 === i4.attributes.color.itemSize, h4 = !!n4.normalMap && !!i4.attributes.tangent, u4 = !!i4.morphAttributes.position, p4 = !!i4.morphAttributes.normal, f4 = !!i4.morphAttributes.color, g4 = n4.toneMapped ? m2.toneMapping : rr, v4 = i4.morphAttributes.position || i4.morphAttributes.normal || i4.morphAttributes.color, y4 = void 0 !== v4 ? v4.length : 0, _4 = q2.get(n4), S4 = d2.state.lights;
      if (true === O2 && (true === z2 || t8 !== w2)) {
        const e5 = t8 === w2 && n4.id === b2;
        nt2.setState(n4, t8, e5);
      }
      let M4 = false;
      n4.version === _4.__version ? _4.needsLights && _4.lightsStateVersion !== S4.state.version || _4.outputEncoding !== a4 || r4.isInstancedMesh && false === _4.instancing ? M4 = true : r4.isInstancedMesh || true !== _4.instancing ? r4.isSkinnedMesh && false === _4.skinning ? M4 = true : r4.isSkinnedMesh || true !== _4.skinning ? _4.envMap !== l4 || true === n4.fog && _4.fog !== s4 ? M4 = true : void 0 === _4.numClippingPlanes || _4.numClippingPlanes === nt2.numPlanes && _4.numIntersection === nt2.numIntersection ? (_4.vertexAlphas !== c4 || _4.vertexTangents !== h4 || _4.morphTargets !== u4 || _4.morphNormals !== p4 || _4.morphColors !== f4 || _4.toneMapping !== g4 || true === j2.isWebGL2 && _4.morphTargetsCount !== y4) && (M4 = true) : M4 = true : M4 = true : M4 = true : (M4 = true, _4.__version = n4.version);
      let T4 = _4.currentProgram;
      true === M4 && (T4 = Ct2(n4, e4, r4));
      let C3 = false, R3 = false, P3 = false;
      const L3 = T4.getUniforms(), I3 = _4.uniforms;
      G2.useProgram(T4.program) && (C3 = true, R3 = true, P3 = true);
      n4.id !== b2 && (b2 = n4.id, R3 = true);
      if (C3 || w2 !== t8) {
        if (L3.setValue(dt2, "projectionMatrix", t8.projectionMatrix), j2.logarithmicDepthBuffer && L3.setValue(dt2, "logDepthBufFC", 2 / (Math.log(t8.far + 1) / Math.LN2)), w2 !== t8 && (w2 = t8, R3 = true, P3 = true), n4.isShaderMaterial || n4.isMeshPhongMaterial || n4.isMeshToonMaterial || n4.isMeshStandardMaterial || n4.envMap) {
          const e5 = L3.map.cameraPosition;
          void 0 !== e5 && e5.setValue(dt2, k2.setFromMatrixPosition(t8.matrixWorld));
        }
        (n4.isMeshPhongMaterial || n4.isMeshToonMaterial || n4.isMeshLambertMaterial || n4.isMeshBasicMaterial || n4.isMeshStandardMaterial || n4.isShaderMaterial) && L3.setValue(dt2, "isOrthographic", true === t8.isOrthographicCamera), (n4.isMeshPhongMaterial || n4.isMeshToonMaterial || n4.isMeshLambertMaterial || n4.isMeshBasicMaterial || n4.isMeshStandardMaterial || n4.isShaderMaterial || n4.isShadowMaterial || r4.isSkinnedMesh) && L3.setValue(dt2, "viewMatrix", t8.matrixWorldInverse);
      }
      if (r4.isSkinnedMesh) {
        L3.setOptional(dt2, r4, "bindMatrix"), L3.setOptional(dt2, r4, "bindMatrixInverse");
        const t9 = r4.skeleton;
        t9 && (j2.floatVertexTextures ? (null === t9.boneTexture && t9.computeBoneTexture(), L3.setValue(dt2, "boneTexture", t9.boneTexture, X2), L3.setValue(dt2, "boneTextureSize", t9.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
      }
      const D3 = i4.morphAttributes;
      (void 0 !== D3.position || void 0 !== D3.normal || void 0 !== D3.color && true === j2.isWebGL2) && ot2.update(r4, i4, n4, T4);
      (R3 || _4.receiveShadow !== r4.receiveShadow) && (_4.receiveShadow = r4.receiveShadow, L3.setValue(dt2, "receiveShadow", r4.receiveShadow));
      R3 && (L3.setValue(dt2, "toneMappingExposure", m2.toneMappingExposure), _4.needsLights && (B3 = P3, (N3 = I3).ambientLightColor.needsUpdate = B3, N3.lightProbe.needsUpdate = B3, N3.directionalLights.needsUpdate = B3, N3.directionalLightShadows.needsUpdate = B3, N3.pointLights.needsUpdate = B3, N3.pointLightShadows.needsUpdate = B3, N3.spotLights.needsUpdate = B3, N3.spotLightShadows.needsUpdate = B3, N3.rectAreaLights.needsUpdate = B3, N3.hemisphereLights.needsUpdate = B3), s4 && true === n4.fog && tt2.refreshFogUniforms(I3, s4), tt2.refreshMaterialUniforms(I3, n4, A2, E2, F2), bu.upload(dt2, _4.uniformsList, I3, X2));
      var N3, B3;
      n4.isShaderMaterial && true === n4.uniformsNeedUpdate && (bu.upload(dt2, _4.uniformsList, I3, X2), n4.uniformsNeedUpdate = false);
      n4.isSpriteMaterial && L3.setValue(dt2, "center", r4.center);
      if (L3.setValue(dt2, "modelViewMatrix", r4.modelViewMatrix), L3.setValue(dt2, "normalMatrix", r4.normalMatrix), L3.setValue(dt2, "modelMatrix", r4.matrixWorld), n4.isShaderMaterial || n4.isRawShaderMaterial) {
        const t9 = n4.uniformsGroups;
        for (let e5 = 0, i5 = t9.length; e5 < i5; e5++) if (j2.isWebGL2) {
          const i6 = t9[e5];
          ut2.update(i6, T4), ut2.bind(i6, T4);
        } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
      }
      return T4;
    })(t7, e3, i3, n3, r3);
    G2.setMaterial(n3, o3);
    let l3 = i3.index;
    const c3 = i3.attributes.position;
    if (null === l3) {
      if (void 0 === c3 || 0 === c3.count) return;
    } else if (0 === l3.count) return;
    let h3, u3 = 1;
    true === n3.wireframe && (l3 = K2.getWireframeAttribute(i3), u3 = 2), ht2.setup(r3, n3, a3, i3, l3);
    let p3 = at2;
    null !== l3 && (h3 = J2.get(l3), p3 = lt2, p3.setIndex(h3));
    const f3 = null !== l3 ? l3.count : c3.count, g3 = i3.drawRange.start * u3, v3 = i3.drawRange.count * u3, y3 = null !== s3 ? s3.start * u3 : 0, _3 = null !== s3 ? s3.count * u3 : 1 / 0, S3 = Math.max(g3, y3), M3 = Math.min(f3, g3 + v3, y3 + _3) - 1, T3 = Math.max(0, M3 - S3 + 1);
    if (0 !== T3) {
      if (r3.isMesh) true === n3.wireframe ? (G2.setLineWidth(n3.wireframeLinewidth * H2()), p3.setMode(1)) : p3.setMode(4);
      else if (r3.isLine) {
        let t8 = n3.linewidth;
        void 0 === t8 && (t8 = 1), G2.setLineWidth(t8 * H2()), r3.isLineSegments ? p3.setMode(1) : r3.isLineLoop ? p3.setMode(2) : p3.setMode(3);
      } else r3.isPoints ? p3.setMode(0) : r3.isSprite && p3.setMode(4);
      if (r3.isInstancedMesh) p3.renderInstances(S3, T3, r3.count);
      else if (i3.isInstancedBufferGeometry) {
        const t8 = Math.min(i3.instanceCount, i3._maxInstanceCount);
        p3.renderInstances(S3, T3, t8);
      } else p3.render(S3, T3);
    }
  }, this.compile = function(t7, e3) {
    d2 = it2.get(t7), d2.init(), f2.push(d2), t7.traverseVisible((function(t8) {
      t8.isLight && t8.layers.test(e3.layers) && (d2.pushLight(t8), t8.castShadow && d2.pushShadow(t8));
    })), d2.setupLights(m2.physicallyCorrectLights), t7.traverse((function(e4) {
      const i3 = e4.material;
      if (i3) if (Array.isArray(i3)) for (let n3 = 0; n3 < i3.length; n3++) {
        Ct2(i3[n3], t7, e4);
      }
      else Ct2(i3, t7, e4);
    })), f2.pop(), d2 = null;
  };
  let bt2 = null;
  function wt2() {
    St2.stop();
  }
  function _t2() {
    St2.start();
  }
  const St2 = new Oc();
  function Mt2(t7, e3, i3, n3) {
    if (false === t7.visible) return;
    if (t7.layers.test(e3.layers)) {
      if (t7.isGroup) i3 = t7.renderOrder;
      else if (t7.isLOD) true === t7.autoUpdate && t7.update(e3);
      else if (t7.isLight) d2.pushLight(t7), t7.castShadow && d2.pushShadow(t7);
      else if (t7.isSprite) {
        if (!t7.frustumCulled || D2.intersectsSprite(t7)) {
          n3 && k2.setFromMatrixPosition(t7.matrixWorld).applyMatrix4(N2);
          const e4 = $2.update(t7), r4 = t7.material;
          r4.visible && u2.push(t7, e4, r4, i3, k2.z, null);
        }
      } else if ((t7.isMesh || t7.isLine || t7.isPoints) && (t7.isSkinnedMesh && t7.skeleton.frame !== W2.render.frame && (t7.skeleton.update(), t7.skeleton.frame = W2.render.frame), !t7.frustumCulled || D2.intersectsObject(t7))) {
        n3 && k2.setFromMatrixPosition(t7.matrixWorld).applyMatrix4(N2);
        const e4 = $2.update(t7), r4 = t7.material;
        if (Array.isArray(r4)) {
          const n4 = e4.groups;
          for (let s3 = 0, o3 = n4.length; s3 < o3; s3++) {
            const o4 = n4[s3], a3 = r4[o4.materialIndex];
            a3 && a3.visible && u2.push(t7, e4, a3, i3, k2.z, o4);
          }
        } else r4.visible && u2.push(t7, e4, r4, i3, k2.z, null);
      }
    }
    const r3 = t7.children;
    for (let t8 = 0, s3 = r3.length; t8 < s3; t8++) Mt2(r3[t8], e3, i3, n3);
  }
  function Tt2(t7, e3, i3, n3) {
    const r3 = t7.opaque, o3 = t7.transmissive, a3 = t7.transparent;
    d2.setupLightsView(i3), o3.length > 0 && (function(t8, e4, i4) {
      const n4 = j2.isWebGL2;
      null === F2 && (F2 = new oa(1, 1, { generateMipmaps: true, type: V2.has("EXT_color_buffer_half_float") ? Fr : Rr, minFilter: Ar, samples: n4 && true === s2 ? 4 : 0 }));
      m2.getDrawingBufferSize(B2), n4 ? F2.setSize(B2.x, B2.y) : F2.setSize(Oo(B2.x), Oo(B2.y));
      const r4 = m2.getRenderTarget();
      m2.setRenderTarget(F2), m2.clear();
      const o4 = m2.toneMapping;
      m2.toneMapping = rr, Et2(t8, e4, i4), m2.toneMapping = o4, X2.updateMultisampleRenderTarget(F2), X2.updateRenderTargetMipmap(F2), m2.setRenderTarget(r4);
    })(r3, e3, i3), n3 && G2.viewport(_2.copy(n3)), r3.length > 0 && Et2(r3, e3, i3), o3.length > 0 && Et2(o3, e3, i3), a3.length > 0 && Et2(a3, e3, i3), G2.buffers.depth.setTest(true), G2.buffers.depth.setMask(true), G2.buffers.color.setMask(true), G2.setPolygonOffset(false);
  }
  function Et2(t7, e3, i3) {
    const n3 = true === e3.isScene ? e3.overrideMaterial : null;
    for (let r3 = 0, s3 = t7.length; r3 < s3; r3++) {
      const s4 = t7[r3], o3 = s4.object, a3 = s4.geometry, l3 = null === n3 ? s4.material : n3, c3 = s4.group;
      o3.layers.test(i3.layers) && At2(o3, e3, i3, a3, l3, c3);
    }
  }
  function At2(t7, e3, i3, n3, r3, s3) {
    t7.onBeforeRender(m2, e3, i3, n3, r3, s3), t7.modelViewMatrix.multiplyMatrices(i3.matrixWorldInverse, t7.matrixWorld), t7.normalMatrix.getNormalMatrix(t7.modelViewMatrix), r3.onBeforeRender(m2, e3, i3, n3, t7, s3), true === r3.transparent && r3.side === _n ? (r3.side = wn, r3.needsUpdate = true, m2.renderBufferDirect(i3, e3, n3, r3, t7, s3), r3.side = bn, r3.needsUpdate = true, m2.renderBufferDirect(i3, e3, n3, r3, t7, s3), r3.side = _n) : m2.renderBufferDirect(i3, e3, n3, r3, t7, s3), t7.onAfterRender(m2, e3, i3, n3, r3, s3);
  }
  function Ct2(t7, e3, i3) {
    true !== e3.isScene && (e3 = U2);
    const n3 = q2.get(t7), r3 = d2.state.lights, s3 = d2.state.shadowsArray, o3 = r3.state.version, a3 = Q2.getParameters(t7, r3.state, s3, e3, i3), l3 = Q2.getProgramCacheKey(a3);
    let c3 = n3.programs;
    n3.environment = t7.isMeshStandardMaterial ? e3.environment : null, n3.fog = e3.fog, n3.envMap = (t7.isMeshStandardMaterial ? Z2 : Y2).get(t7.envMap || n3.environment), void 0 === c3 && (t7.addEventListener("dispose", xt2), c3 = /* @__PURE__ */ new Map(), n3.programs = c3);
    let h3 = c3.get(l3);
    if (void 0 !== h3) {
      if (n3.currentProgram === h3 && n3.lightsStateVersion === o3) return Rt2(t7, a3), h3;
    } else a3.uniforms = Q2.getUniforms(t7), t7.onBuild(i3, a3, m2), t7.onBeforeCompile(a3, m2), h3 = Q2.acquireProgram(a3, l3), c3.set(l3, h3), n3.uniforms = a3.uniforms;
    const u3 = n3.uniforms;
    (t7.isShaderMaterial || t7.isRawShaderMaterial) && true !== t7.clipping || (u3.clippingPlanes = nt2.uniform), Rt2(t7, a3), n3.needsLights = (function(t8) {
      return t8.isMeshLambertMaterial || t8.isMeshToonMaterial || t8.isMeshPhongMaterial || t8.isMeshStandardMaterial || t8.isShadowMaterial || t8.isShaderMaterial && true === t8.lights;
    })(t7), n3.lightsStateVersion = o3, n3.needsLights && (u3.ambientLightColor.value = r3.state.ambient, u3.lightProbe.value = r3.state.probe, u3.directionalLights.value = r3.state.directional, u3.directionalLightShadows.value = r3.state.directionalShadow, u3.spotLights.value = r3.state.spot, u3.spotLightShadows.value = r3.state.spotShadow, u3.rectAreaLights.value = r3.state.rectArea, u3.ltc_1.value = r3.state.rectAreaLTC1, u3.ltc_2.value = r3.state.rectAreaLTC2, u3.pointLights.value = r3.state.point, u3.pointLightShadows.value = r3.state.pointShadow, u3.hemisphereLights.value = r3.state.hemi, u3.directionalShadowMap.value = r3.state.directionalShadowMap, u3.directionalShadowMatrix.value = r3.state.directionalShadowMatrix, u3.spotShadowMap.value = r3.state.spotShadowMap, u3.spotShadowMatrix.value = r3.state.spotShadowMatrix, u3.pointShadowMap.value = r3.state.pointShadowMap, u3.pointShadowMatrix.value = r3.state.pointShadowMatrix);
    const p3 = h3.getUniforms(), f3 = bu.seqWithValue(p3.seq, u3);
    return n3.currentProgram = h3, n3.uniformsList = f3, h3;
  }
  function Rt2(t7, e3) {
    const i3 = q2.get(t7);
    i3.outputEncoding = e3.outputEncoding, i3.instancing = e3.instancing, i3.skinning = e3.skinning, i3.morphTargets = e3.morphTargets, i3.morphNormals = e3.morphNormals, i3.morphColors = e3.morphColors, i3.morphTargetsCount = e3.morphTargetsCount, i3.numClippingPlanes = e3.numClippingPlanes, i3.numIntersection = e3.numClipIntersection, i3.vertexAlphas = e3.vertexAlphas, i3.vertexTangents = e3.vertexTangents, i3.toneMapping = e3.toneMapping;
  }
  St2.setAnimationLoop((function(t7) {
    bt2 && bt2(t7);
  })), "undefined" != typeof self && St2.setContext(self), this.setAnimationLoop = function(t7) {
    bt2 = t7, mt2.setAnimationLoop(t7), null === t7 ? St2.stop() : St2.start();
  }, mt2.addEventListener("sessionstart", wt2), mt2.addEventListener("sessionend", _t2), this.render = function(t7, e3) {
    if (void 0 !== e3 && true !== e3.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
    if (true === g2) return;
    true === t7.autoUpdate && t7.updateMatrixWorld(), null === e3.parent && e3.updateMatrixWorld(), true === mt2.enabled && true === mt2.isPresenting && (true === mt2.cameraAutoUpdate && mt2.updateCamera(e3), e3 = mt2.getCamera()), true === t7.isScene && t7.onBeforeRender(m2, t7, e3, x2), d2 = it2.get(t7, f2.length), d2.init(), f2.push(d2), N2.multiplyMatrices(e3.projectionMatrix, e3.matrixWorldInverse), D2.setFromProjectionMatrix(N2), z2 = this.localClippingEnabled, O2 = nt2.init(this.clippingPlanes, z2, e3), u2 = et2.get(t7, p2.length), u2.init(), p2.push(u2), Mt2(t7, e3, 0, m2.sortObjects), u2.finish(), true === m2.sortObjects && u2.sort(C2, R2), true === O2 && nt2.beginShadows();
    const i3 = d2.state.shadowsArray;
    if (rt2.render(i3, t7, e3), true === O2 && nt2.endShadows(), true === this.info.autoReset && this.info.reset(), st2.render(u2, t7), d2.setupLights(m2.physicallyCorrectLights), e3.isArrayCamera) {
      const i4 = e3.cameras;
      for (let e4 = 0, n3 = i4.length; e4 < n3; e4++) {
        const n4 = i4[e4];
        Tt2(u2, t7, n4, n4.viewport);
      }
    } else Tt2(u2, t7, e3);
    null !== x2 && (X2.updateMultisampleRenderTarget(x2), X2.updateRenderTargetMipmap(x2)), true === t7.isScene && t7.onAfterRender(m2, t7, e3), ht2.resetDefaultState(), b2 = -1, w2 = null, f2.pop(), d2 = f2.length > 0 ? f2[f2.length - 1] : null, p2.pop(), u2 = p2.length > 0 ? p2[p2.length - 1] : null;
  }, this.getActiveCubeFace = function() {
    return v2;
  }, this.getActiveMipmapLevel = function() {
    return y2;
  }, this.getRenderTarget = function() {
    return x2;
  }, this.setRenderTargetTextures = function(t7, e3, i3) {
    q2.get(t7.texture).__webglTexture = e3, q2.get(t7.depthTexture).__webglTexture = i3;
    const n3 = q2.get(t7);
    n3.__hasExternalTextures = true, n3.__hasExternalTextures && (n3.__autoAllocateDepthBuffer = void 0 === i3, n3.__autoAllocateDepthBuffer || true === V2.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), n3.__useRenderToTexture = false));
  }, this.setRenderTargetFramebuffer = function(t7, e3) {
    const i3 = q2.get(t7);
    i3.__webglFramebuffer = e3, i3.__useDefaultFramebuffer = void 0 === e3;
  }, this.setRenderTarget = function(t7, e3 = 0, i3 = 0) {
    x2 = t7, v2 = e3, y2 = i3;
    let n3 = true;
    if (t7) {
      const e4 = q2.get(t7);
      void 0 !== e4.__useDefaultFramebuffer ? (G2.bindFramebuffer(36160, null), n3 = false) : void 0 === e4.__webglFramebuffer ? X2.setupRenderTarget(t7) : e4.__hasExternalTextures && X2.rebindTextures(t7, q2.get(t7.texture).__webglTexture, q2.get(t7.depthTexture).__webglTexture);
    }
    let r3 = null, s3 = false, o3 = false;
    if (t7) {
      const i4 = t7.texture;
      (i4.isData3DTexture || i4.isDataArrayTexture) && (o3 = true);
      const n4 = q2.get(t7).__webglFramebuffer;
      t7.isWebGLCubeRenderTarget ? (r3 = n4[e3], s3 = true) : r3 = j2.isWebGL2 && t7.samples > 0 && false === X2.useMultisampledRTT(t7) ? q2.get(t7).__webglMultisampledFramebuffer : n4, _2.copy(t7.viewport), S2.copy(t7.scissor), M2 = t7.scissorTest;
    } else _2.copy(P2).multiplyScalar(A2).floor(), S2.copy(L2).multiplyScalar(A2).floor(), M2 = I2;
    if (G2.bindFramebuffer(36160, r3) && j2.drawBuffers && n3 && G2.drawBuffers(t7, r3), G2.viewport(_2), G2.scissor(S2), G2.setScissorTest(M2), s3) {
      const n4 = q2.get(t7.texture);
      dt2.framebufferTexture2D(36160, 36064, 34069 + e3, n4.__webglTexture, i3);
    } else if (o3) {
      const n4 = q2.get(t7.texture), r4 = e3 || 0;
      dt2.framebufferTextureLayer(36160, 36064, n4.__webglTexture, i3 || 0, r4);
    }
    b2 = -1;
  }, this.readRenderTargetPixels = function(t7, e3, i3, n3, r3, s3, o3) {
    if (!t7 || !t7.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
    let a3 = q2.get(t7).__webglFramebuffer;
    if (t7.isWebGLCubeRenderTarget && void 0 !== o3 && (a3 = a3[o3]), a3) {
      G2.bindFramebuffer(36160, a3);
      try {
        const o4 = t7.texture, a4 = o4.format, l3 = o4.type;
        if (a4 !== Vr && ct2.convert(a4) !== dt2.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
        const c3 = l3 === Fr && (V2.has("EXT_color_buffer_half_float") || j2.isWebGL2 && V2.has("EXT_color_buffer_float"));
        if (!(l3 === Rr || ct2.convert(l3) === dt2.getParameter(35738) || l3 === zr && (j2.isWebGL2 || V2.has("OES_texture_float") || V2.has("WEBGL_color_buffer_float")) || c3)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
        e3 >= 0 && e3 <= t7.width - n3 && i3 >= 0 && i3 <= t7.height - r3 && dt2.readPixels(e3, i3, n3, r3, ct2.convert(a4), ct2.convert(l3), s3);
      } finally {
        const t8 = null !== x2 ? q2.get(x2).__webglFramebuffer : null;
        G2.bindFramebuffer(36160, t8);
      }
    }
  }, this.copyFramebufferToTexture = function(t7, e3, i3 = 0) {
    const n3 = Math.pow(2, -i3), r3 = Math.floor(e3.image.width * n3), s3 = Math.floor(e3.image.height * n3);
    X2.setTexture2D(e3, 0), dt2.copyTexSubImage2D(3553, i3, 0, 0, t7.x, t7.y, r3, s3), G2.unbindTexture();
  }, this.copyTextureToTexture = function(t7, e3, i3, n3 = 0) {
    const r3 = e3.image.width, s3 = e3.image.height, o3 = ct2.convert(i3.format), a3 = ct2.convert(i3.type);
    X2.setTexture2D(i3, 0), dt2.pixelStorei(37440, i3.flipY), dt2.pixelStorei(37441, i3.premultiplyAlpha), dt2.pixelStorei(3317, i3.unpackAlignment), e3.isDataTexture ? dt2.texSubImage2D(3553, n3, t7.x, t7.y, r3, s3, o3, a3, e3.image.data) : e3.isCompressedTexture ? dt2.compressedTexSubImage2D(3553, n3, t7.x, t7.y, e3.mipmaps[0].width, e3.mipmaps[0].height, o3, e3.mipmaps[0].data) : dt2.texSubImage2D(3553, n3, t7.x, t7.y, o3, a3, e3.image), 0 === n3 && i3.generateMipmaps && dt2.generateMipmap(3553), G2.unbindTexture();
  }, this.copyTextureToTexture3D = function(t7, e3, i3, n3, r3 = 0) {
    if (m2.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
    const s3 = t7.max.x - t7.min.x + 1, o3 = t7.max.y - t7.min.y + 1, a3 = t7.max.z - t7.min.z + 1, l3 = ct2.convert(n3.format), c3 = ct2.convert(n3.type);
    let h3;
    if (n3.isData3DTexture) X2.setTexture3D(n3, 0), h3 = 32879;
    else {
      if (!n3.isDataArrayTexture) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
      X2.setTexture2DArray(n3, 0), h3 = 35866;
    }
    dt2.pixelStorei(37440, n3.flipY), dt2.pixelStorei(37441, n3.premultiplyAlpha), dt2.pixelStorei(3317, n3.unpackAlignment);
    const u3 = dt2.getParameter(3314), d3 = dt2.getParameter(32878), p3 = dt2.getParameter(3316), f3 = dt2.getParameter(3315), g3 = dt2.getParameter(32877), v3 = i3.isCompressedTexture ? i3.mipmaps[0] : i3.image;
    dt2.pixelStorei(3314, v3.width), dt2.pixelStorei(32878, v3.height), dt2.pixelStorei(3316, t7.min.x), dt2.pixelStorei(3315, t7.min.y), dt2.pixelStorei(32877, t7.min.z), i3.isDataTexture || i3.isData3DTexture ? dt2.texSubImage3D(h3, r3, e3.x, e3.y, e3.z, s3, o3, a3, l3, c3, v3.data) : i3.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), dt2.compressedTexSubImage3D(h3, r3, e3.x, e3.y, e3.z, s3, o3, a3, l3, v3.data)) : dt2.texSubImage3D(h3, r3, e3.x, e3.y, e3.z, s3, o3, a3, l3, c3, v3), dt2.pixelStorei(3314, u3), dt2.pixelStorei(32878, d3), dt2.pixelStorei(3316, p3), dt2.pixelStorei(3315, f3), dt2.pixelStorei(32877, g3), 0 === r3 && n3.generateMipmaps && dt2.generateMipmap(h3), G2.unbindTexture();
  }, this.initTexture = function(t7) {
    t7.isCubeTexture ? X2.setTextureCube(t7, 0) : t7.isData3DTexture ? X2.setTexture3D(t7, 0) : t7.isDataArrayTexture ? X2.setTexture2DArray(t7, 0) : X2.setTexture2D(t7, 0), G2.unbindTexture();
  }, this.resetState = function() {
    v2 = 0, y2 = 0, x2 = null, G2.reset(), ht2.reset();
  }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
}
var vd = class extends gd {
};
vd.prototype.isWebGL1Renderer = true;
var yd = class _yd {
  constructor(t6, e2 = 25e-5) {
    this.isFogExp2 = true, this.name = "", this.color = new $o(t6), this.density = e2;
  }
  clone() {
    return new _yd(this.color, this.density);
  }
  toJSON() {
    return { type: "FogExp2", color: this.color.getHex(), density: this.density };
  }
};
var xd = class _xd {
  constructor(t6, e2 = 1, i2 = 1e3) {
    this.isFog = true, this.name = "", this.color = new $o(t6), this.near = e2, this.far = i2;
  }
  clone() {
    return new _xd(this.color, this.near, this.far);
  }
  toJSON() {
    return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far };
  }
};
var bd = class extends ml {
  constructor() {
    super(), this.isScene = true, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = true, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(t6, e2) {
    return super.copy(t6, e2), null !== t6.background && (this.background = t6.background.clone()), null !== t6.environment && (this.environment = t6.environment.clone()), null !== t6.fog && (this.fog = t6.fog.clone()), null !== t6.overrideMaterial && (this.overrideMaterial = t6.overrideMaterial.clone()), this.autoUpdate = t6.autoUpdate, this.matrixAutoUpdate = t6.matrixAutoUpdate, this;
  }
  toJSON(t6) {
    const e2 = super.toJSON(t6);
    return null !== this.fog && (e2.object.fog = this.fog.toJSON()), e2;
  }
};
var wd = class {
  constructor(t6, e2) {
    this.isInterleavedBuffer = true, this.array = t6, this.stride = e2, this.count = void 0 !== t6 ? t6.length / e2 : 0, this.usage = ho, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = Co();
  }
  onUploadCallback() {
  }
  set needsUpdate(t6) {
    true === t6 && this.version++;
  }
  setUsage(t6) {
    return this.usage = t6, this;
  }
  copy(t6) {
    return this.array = new t6.array.constructor(t6.array), this.count = t6.count, this.stride = t6.stride, this.usage = t6.usage, this;
  }
  copyAt(t6, e2, i2) {
    t6 *= this.stride, i2 *= e2.stride;
    for (let n2 = 0, r2 = this.stride; n2 < r2; n2++) this.array[t6 + n2] = e2.array[i2 + n2];
    return this;
  }
  set(t6, e2 = 0) {
    return this.array.set(t6, e2), this;
  }
  clone(t6) {
    void 0 === t6.arrayBuffers && (t6.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Co()), void 0 === t6.arrayBuffers[this.array.buffer._uuid] && (t6.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const e2 = new this.array.constructor(t6.arrayBuffers[this.array.buffer._uuid]), i2 = new this.constructor(e2, this.stride);
    return i2.setUsage(this.usage), i2;
  }
  onUpload(t6) {
    return this.onUploadCallback = t6, this;
  }
  toJSON(t6) {
    return void 0 === t6.arrayBuffers && (t6.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Co()), void 0 === t6.arrayBuffers[this.array.buffer._uuid] && (t6.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride };
  }
};
var _d = new pa();
var Sd = class _Sd {
  constructor(t6, e2, i2, n2 = false) {
    this.isInterleavedBufferAttribute = true, this.name = "", this.data = t6, this.itemSize = e2, this.offset = i2, this.normalized = true === n2;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(t6) {
    this.data.needsUpdate = t6;
  }
  applyMatrix4(t6) {
    for (let e2 = 0, i2 = this.data.count; e2 < i2; e2++) _d.fromBufferAttribute(this, e2), _d.applyMatrix4(t6), this.setXYZ(e2, _d.x, _d.y, _d.z);
    return this;
  }
  applyNormalMatrix(t6) {
    for (let e2 = 0, i2 = this.count; e2 < i2; e2++) _d.fromBufferAttribute(this, e2), _d.applyNormalMatrix(t6), this.setXYZ(e2, _d.x, _d.y, _d.z);
    return this;
  }
  transformDirection(t6) {
    for (let e2 = 0, i2 = this.count; e2 < i2; e2++) _d.fromBufferAttribute(this, e2), _d.transformDirection(t6), this.setXYZ(e2, _d.x, _d.y, _d.z);
    return this;
  }
  setX(t6, e2) {
    return this.data.array[t6 * this.data.stride + this.offset] = e2, this;
  }
  setY(t6, e2) {
    return this.data.array[t6 * this.data.stride + this.offset + 1] = e2, this;
  }
  setZ(t6, e2) {
    return this.data.array[t6 * this.data.stride + this.offset + 2] = e2, this;
  }
  setW(t6, e2) {
    return this.data.array[t6 * this.data.stride + this.offset + 3] = e2, this;
  }
  getX(t6) {
    return this.data.array[t6 * this.data.stride + this.offset];
  }
  getY(t6) {
    return this.data.array[t6 * this.data.stride + this.offset + 1];
  }
  getZ(t6) {
    return this.data.array[t6 * this.data.stride + this.offset + 2];
  }
  getW(t6) {
    return this.data.array[t6 * this.data.stride + this.offset + 3];
  }
  setXY(t6, e2, i2) {
    return t6 = t6 * this.data.stride + this.offset, this.data.array[t6 + 0] = e2, this.data.array[t6 + 1] = i2, this;
  }
  setXYZ(t6, e2, i2, n2) {
    return t6 = t6 * this.data.stride + this.offset, this.data.array[t6 + 0] = e2, this.data.array[t6 + 1] = i2, this.data.array[t6 + 2] = n2, this;
  }
  setXYZW(t6, e2, i2, n2, r2) {
    return t6 = t6 * this.data.stride + this.offset, this.data.array[t6 + 0] = e2, this.data.array[t6 + 1] = i2, this.data.array[t6 + 2] = n2, this.data.array[t6 + 3] = r2, this;
  }
  clone(t6) {
    if (void 0 === t6) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data.");
      const t7 = [];
      for (let e2 = 0; e2 < this.count; e2++) {
        const i2 = e2 * this.data.stride + this.offset;
        for (let e3 = 0; e3 < this.itemSize; e3++) t7.push(this.data.array[i2 + e3]);
      }
      return new Il(new this.array.constructor(t7), this.itemSize, this.normalized);
    }
    return void 0 === t6.interleavedBuffers && (t6.interleavedBuffers = {}), void 0 === t6.interleavedBuffers[this.data.uuid] && (t6.interleavedBuffers[this.data.uuid] = this.data.clone(t6)), new _Sd(t6.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(t6) {
    if (void 0 === t6) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data.");
      const t7 = [];
      for (let e2 = 0; e2 < this.count; e2++) {
        const i2 = e2 * this.data.stride + this.offset;
        for (let e3 = 0; e3 < this.itemSize; e3++) t7.push(this.data.array[i2 + e3]);
      }
      return { itemSize: this.itemSize, type: this.array.constructor.name, array: t7, normalized: this.normalized };
    }
    return void 0 === t6.interleavedBuffers && (t6.interleavedBuffers = {}), void 0 === t6.interleavedBuffers[this.data.uuid] && (t6.interleavedBuffers[this.data.uuid] = this.data.toJSON(t6)), { isInterleavedBufferAttribute: true, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized };
  }
};
var Md = class extends Cl {
  constructor(t6) {
    super(), this.isSpriteMaterial = true, this.type = "SpriteMaterial", this.color = new $o(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = true, this.transparent = true, this.fog = true, this.setValues(t6);
  }
  copy(t6) {
    return super.copy(t6), this.color.copy(t6.color), this.map = t6.map, this.alphaMap = t6.alphaMap, this.rotation = t6.rotation, this.sizeAttenuation = t6.sizeAttenuation, this.fog = t6.fog, this;
  }
};
var Td;
var Ed = new pa();
var Ad = new pa();
var Cd = new pa();
var Rd = new Fo();
var Pd = new Fo();
var Ld = new Ga();
var Id = new pa();
var Dd = new pa();
var Od = new pa();
var zd = new Fo();
var Fd = new Fo();
var Nd = new Fo();
var Bd = class extends ml {
  constructor(t6) {
    if (super(), this.isSprite = true, this.type = "Sprite", void 0 === Td) {
      Td = new Jl();
      const t7 = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]), e2 = new wd(t7, 5);
      Td.setIndex([0, 1, 2, 0, 2, 3]), Td.setAttribute("position", new Sd(e2, 3, 0, false)), Td.setAttribute("uv", new Sd(e2, 2, 3, false));
    }
    this.geometry = Td, this.material = void 0 !== t6 ? t6 : new Md(), this.center = new Fo(0.5, 0.5);
  }
  raycast(t6, e2) {
    null === t6.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Ad.setFromMatrixScale(this.matrixWorld), Ld.copy(t6.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t6.camera.matrixWorldInverse, this.matrixWorld), Cd.setFromMatrixPosition(this.modelViewMatrix), t6.camera.isPerspectiveCamera && false === this.material.sizeAttenuation && Ad.multiplyScalar(-Cd.z);
    const i2 = this.material.rotation;
    let n2, r2;
    0 !== i2 && (r2 = Math.cos(i2), n2 = Math.sin(i2));
    const s2 = this.center;
    kd(Id.set(-0.5, -0.5, 0), Cd, s2, Ad, n2, r2), kd(Dd.set(0.5, -0.5, 0), Cd, s2, Ad, n2, r2), kd(Od.set(0.5, 0.5, 0), Cd, s2, Ad, n2, r2), zd.set(0, 0), Fd.set(1, 0), Nd.set(1, 1);
    let o2 = t6.ray.intersectTriangle(Id, Dd, Od, false, Ed);
    if (null === o2 && (kd(Dd.set(-0.5, 0.5, 0), Cd, s2, Ad, n2, r2), Fd.set(0, 1), o2 = t6.ray.intersectTriangle(Id, Od, Dd, false, Ed), null === o2)) return;
    const a2 = t6.ray.origin.distanceTo(Ed);
    a2 < t6.near || a2 > t6.far || e2.push({ distance: a2, point: Ed.clone(), uv: El.getUV(Ed, Id, Dd, Od, zd, Fd, Nd, new Fo()), face: null, object: this });
  }
  copy(t6, e2) {
    return super.copy(t6, e2), void 0 !== t6.center && this.center.copy(t6.center), this.material = t6.material, this;
  }
};
function kd(t6, e2, i2, n2, r2, s2) {
  Rd.subVectors(t6, i2).addScalar(0.5).multiply(n2), void 0 !== r2 ? (Pd.x = s2 * Rd.x - r2 * Rd.y, Pd.y = r2 * Rd.x + s2 * Rd.y) : Pd.copy(Rd), t6.copy(e2), t6.x += Pd.x, t6.y += Pd.y, t6.applyMatrix4(Ld);
}
var Ud = new pa();
var Hd = new pa();
var Vd = class extends ml {
  constructor() {
    super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: true, value: [] }, isLOD: { value: true } }), this.autoUpdate = true;
  }
  copy(t6) {
    super.copy(t6, false);
    const e2 = t6.levels;
    for (let t7 = 0, i2 = e2.length; t7 < i2; t7++) {
      const i3 = e2[t7];
      this.addLevel(i3.object.clone(), i3.distance);
    }
    return this.autoUpdate = t6.autoUpdate, this;
  }
  addLevel(t6, e2 = 0) {
    e2 = Math.abs(e2);
    const i2 = this.levels;
    let n2;
    for (n2 = 0; n2 < i2.length && !(e2 < i2[n2].distance); n2++) ;
    return i2.splice(n2, 0, { distance: e2, object: t6 }), this.add(t6), this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(t6) {
    const e2 = this.levels;
    if (e2.length > 0) {
      let i2, n2;
      for (i2 = 1, n2 = e2.length; i2 < n2 && !(t6 < e2[i2].distance); i2++) ;
      return e2[i2 - 1].object;
    }
    return null;
  }
  raycast(t6, e2) {
    if (this.levels.length > 0) {
      Ud.setFromMatrixPosition(this.matrixWorld);
      const i2 = t6.ray.origin.distanceTo(Ud);
      this.getObjectForDistance(i2).raycast(t6, e2);
    }
  }
  update(t6) {
    const e2 = this.levels;
    if (e2.length > 1) {
      Ud.setFromMatrixPosition(t6.matrixWorld), Hd.setFromMatrixPosition(this.matrixWorld);
      const i2 = Ud.distanceTo(Hd) / t6.zoom;
      let n2, r2;
      for (e2[0].object.visible = true, n2 = 1, r2 = e2.length; n2 < r2 && i2 >= e2[n2].distance; n2++) e2[n2 - 1].object.visible = false, e2[n2].object.visible = true;
      for (this._currentLevel = n2 - 1; n2 < r2; n2++) e2[n2].object.visible = false;
    }
  }
  toJSON(t6) {
    const e2 = super.toJSON(t6);
    false === this.autoUpdate && (e2.object.autoUpdate = false), e2.object.levels = [];
    const i2 = this.levels;
    for (let t7 = 0, n2 = i2.length; t7 < n2; t7++) {
      const n3 = i2[t7];
      e2.object.levels.push({ object: n3.object.uuid, distance: n3.distance });
    }
    return e2;
  }
};
var jd = new pa();
var Gd = new sa();
var Wd = new sa();
var qd = new pa();
var Xd = new Ga();
var Yd = class extends fc {
  constructor(t6, e2) {
    super(t6, e2), this.isSkinnedMesh = true, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Ga(), this.bindMatrixInverse = new Ga();
  }
  copy(t6, e2) {
    return super.copy(t6, e2), this.bindMode = t6.bindMode, this.bindMatrix.copy(t6.bindMatrix), this.bindMatrixInverse.copy(t6.bindMatrixInverse), this.skeleton = t6.skeleton, this;
  }
  bind(t6, e2) {
    this.skeleton = t6, void 0 === e2 && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), e2 = this.matrixWorld), this.bindMatrix.copy(e2), this.bindMatrixInverse.copy(e2).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const t6 = new sa(), e2 = this.geometry.attributes.skinWeight;
    for (let i2 = 0, n2 = e2.count; i2 < n2; i2++) {
      t6.fromBufferAttribute(e2, i2);
      const n3 = 1 / t6.manhattanLength();
      n3 !== 1 / 0 ? t6.multiplyScalar(n3) : t6.set(1, 0, 0, 0), e2.setXYZW(i2, t6.x, t6.y, t6.z, t6.w);
    }
  }
  updateMatrixWorld(t6) {
    super.updateMatrixWorld(t6), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  boneTransform(t6, e2) {
    const i2 = this.skeleton, n2 = this.geometry;
    Gd.fromBufferAttribute(n2.attributes.skinIndex, t6), Wd.fromBufferAttribute(n2.attributes.skinWeight, t6), jd.copy(e2).applyMatrix4(this.bindMatrix), e2.set(0, 0, 0);
    for (let t7 = 0; t7 < 4; t7++) {
      const n3 = Wd.getComponent(t7);
      if (0 !== n3) {
        const r2 = Gd.getComponent(t7);
        Xd.multiplyMatrices(i2.bones[r2].matrixWorld, i2.boneInverses[r2]), e2.addScaledVector(qd.copy(jd).applyMatrix4(Xd), n3);
      }
    }
    return e2.applyMatrix4(this.bindMatrixInverse);
  }
};
var Zd = class extends ml {
  constructor() {
    super(), this.isBone = true, this.type = "Bone";
  }
};
var Jd = class extends ra {
  constructor(t6 = null, e2 = 1, i2 = 1, n2, r2, s2, o2, a2, l2 = xr, c2 = xr, h2, u2) {
    super(null, s2, o2, a2, l2, c2, n2, r2, h2, u2), this.isDataTexture = true, this.image = { data: t6, width: e2, height: i2 }, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
  }
};
var Kd = new Ga();
var $d = new Ga();
var Qd = class _Qd {
  constructor(t6 = [], e2 = []) {
    this.uuid = Co(), this.bones = t6.slice(0), this.boneInverses = e2, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init();
  }
  init() {
    const t6 = this.bones, e2 = this.boneInverses;
    if (this.boneMatrices = new Float32Array(16 * t6.length), 0 === e2.length) this.calculateInverses();
    else if (t6.length !== e2.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let t7 = 0, e3 = this.bones.length; t7 < e3; t7++) this.boneInverses.push(new Ga());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let t6 = 0, e2 = this.bones.length; t6 < e2; t6++) {
      const e3 = new Ga();
      this.bones[t6] && e3.copy(this.bones[t6].matrixWorld).invert(), this.boneInverses.push(e3);
    }
  }
  pose() {
    for (let t6 = 0, e2 = this.bones.length; t6 < e2; t6++) {
      const e3 = this.bones[t6];
      e3 && e3.matrixWorld.copy(this.boneInverses[t6]).invert();
    }
    for (let t6 = 0, e2 = this.bones.length; t6 < e2; t6++) {
      const e3 = this.bones[t6];
      e3 && (e3.parent && e3.parent.isBone ? (e3.matrix.copy(e3.parent.matrixWorld).invert(), e3.matrix.multiply(e3.matrixWorld)) : e3.matrix.copy(e3.matrixWorld), e3.matrix.decompose(e3.position, e3.quaternion, e3.scale));
    }
  }
  update() {
    const t6 = this.bones, e2 = this.boneInverses, i2 = this.boneMatrices, n2 = this.boneTexture;
    for (let n3 = 0, r2 = t6.length; n3 < r2; n3++) {
      const r3 = t6[n3] ? t6[n3].matrixWorld : $d;
      Kd.multiplyMatrices(r3, e2[n3]), Kd.toArray(i2, 16 * n3);
    }
    null !== n2 && (n2.needsUpdate = true);
  }
  clone() {
    return new _Qd(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let t6 = Math.sqrt(4 * this.bones.length);
    t6 = Do(t6), t6 = Math.max(t6, 4);
    const e2 = new Float32Array(t6 * t6 * 4);
    e2.set(this.boneMatrices);
    const i2 = new Jd(e2, t6, t6, Vr, zr);
    return i2.needsUpdate = true, this.boneMatrices = e2, this.boneTexture = i2, this.boneTextureSize = t6, this;
  }
  getBoneByName(t6) {
    for (let e2 = 0, i2 = this.bones.length; e2 < i2; e2++) {
      const i3 = this.bones[e2];
      if (i3.name === t6) return i3;
    }
  }
  dispose() {
    null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(t6, e2) {
    this.uuid = t6.uuid;
    for (let i2 = 0, n2 = t6.bones.length; i2 < n2; i2++) {
      const n3 = t6.bones[i2];
      let r2 = e2[n3];
      void 0 === r2 && (console.warn("THREE.Skeleton: No bone found with UUID:", n3), r2 = new Zd()), this.bones.push(r2), this.boneInverses.push(new Ga().fromArray(t6.boneInverses[i2]));
    }
    return this.init(), this;
  }
  toJSON() {
    const t6 = { metadata: { version: 4.5, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] };
    t6.uuid = this.uuid;
    const e2 = this.bones, i2 = this.boneInverses;
    for (let n2 = 0, r2 = e2.length; n2 < r2; n2++) {
      const r3 = e2[n2];
      t6.bones.push(r3.uuid);
      const s2 = i2[n2];
      t6.boneInverses.push(s2.toArray());
    }
    return t6;
  }
};
var tp = class extends Il {
  constructor(t6, e2, i2, n2 = 1) {
    "number" == typeof i2 && (n2 = i2, i2 = false, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(t6, e2, i2), this.isInstancedBufferAttribute = true, this.meshPerAttribute = n2;
  }
  copy(t6) {
    return super.copy(t6), this.meshPerAttribute = t6.meshPerAttribute, this;
  }
  toJSON() {
    const t6 = super.toJSON();
    return t6.meshPerAttribute = this.meshPerAttribute, t6.isInstancedBufferAttribute = true, t6;
  }
};
var ep = new Ga();
var ip = new Ga();
var np = [];
var rp = new fc();
var sp = class extends fc {
  constructor(t6, e2, i2) {
    super(t6, e2), this.isInstancedMesh = true, this.instanceMatrix = new tp(new Float32Array(16 * i2), 16), this.instanceColor = null, this.count = i2, this.frustumCulled = false;
  }
  copy(t6, e2) {
    return super.copy(t6, e2), this.instanceMatrix.copy(t6.instanceMatrix), null !== t6.instanceColor && (this.instanceColor = t6.instanceColor.clone()), this.count = t6.count, this;
  }
  getColorAt(t6, e2) {
    e2.fromArray(this.instanceColor.array, 3 * t6);
  }
  getMatrixAt(t6, e2) {
    e2.fromArray(this.instanceMatrix.array, 16 * t6);
  }
  raycast(t6, e2) {
    const i2 = this.matrixWorld, n2 = this.count;
    if (rp.geometry = this.geometry, rp.material = this.material, void 0 !== rp.material) for (let r2 = 0; r2 < n2; r2++) {
      this.getMatrixAt(r2, ep), ip.multiplyMatrices(i2, ep), rp.matrixWorld = ip, rp.raycast(t6, np);
      for (let t7 = 0, i3 = np.length; t7 < i3; t7++) {
        const i4 = np[t7];
        i4.instanceId = r2, i4.object = this, e2.push(i4);
      }
      np.length = 0;
    }
  }
  setColorAt(t6, e2) {
    null === this.instanceColor && (this.instanceColor = new tp(new Float32Array(3 * this.instanceMatrix.count), 3)), e2.toArray(this.instanceColor.array, 3 * t6);
  }
  setMatrixAt(t6, e2) {
    e2.toArray(this.instanceMatrix.array, 16 * t6);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
var op = class extends Cl {
  constructor(t6) {
    super(), this.isLineBasicMaterial = true, this.type = "LineBasicMaterial", this.color = new $o(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = true, this.setValues(t6);
  }
  copy(t6) {
    return super.copy(t6), this.color.copy(t6.color), this.linewidth = t6.linewidth, this.linecap = t6.linecap, this.linejoin = t6.linejoin, this.fog = t6.fog, this;
  }
};
var ap = new pa();
var lp = new pa();
var cp = new Ga();
var hp = new ja();
var up = new za();
var dp = class extends ml {
  constructor(t6 = new Jl(), e2 = new op()) {
    super(), this.isLine = true, this.type = "Line", this.geometry = t6, this.material = e2, this.updateMorphTargets();
  }
  copy(t6, e2) {
    return super.copy(t6, e2), this.material = t6.material, this.geometry = t6.geometry, this;
  }
  computeLineDistances() {
    const t6 = this.geometry;
    if (null === t6.index) {
      const e2 = t6.attributes.position, i2 = [0];
      for (let t7 = 1, n2 = e2.count; t7 < n2; t7++) ap.fromBufferAttribute(e2, t7 - 1), lp.fromBufferAttribute(e2, t7), i2[t7] = i2[t7 - 1], i2[t7] += ap.distanceTo(lp);
      t6.setAttribute("lineDistance", new Hl(i2, 1));
    } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(t6, e2) {
    const i2 = this.geometry, n2 = this.matrixWorld, r2 = t6.params.Line.threshold, s2 = i2.drawRange;
    if (null === i2.boundingSphere && i2.computeBoundingSphere(), up.copy(i2.boundingSphere), up.applyMatrix4(n2), up.radius += r2, false === t6.ray.intersectsSphere(up)) return;
    cp.copy(n2).invert(), hp.copy(t6.ray).applyMatrix4(cp);
    const o2 = r2 / ((this.scale.x + this.scale.y + this.scale.z) / 3), a2 = o2 * o2, l2 = new pa(), c2 = new pa(), h2 = new pa(), u2 = new pa(), d2 = this.isLineSegments ? 2 : 1, p2 = i2.index, f2 = i2.attributes.position;
    if (null !== p2) {
      for (let i3 = Math.max(0, s2.start), n3 = Math.min(p2.count, s2.start + s2.count) - 1; i3 < n3; i3 += d2) {
        const n4 = p2.getX(i3), r3 = p2.getX(i3 + 1);
        l2.fromBufferAttribute(f2, n4), c2.fromBufferAttribute(f2, r3);
        if (hp.distanceSqToSegment(l2, c2, u2, h2) > a2) continue;
        u2.applyMatrix4(this.matrixWorld);
        const s3 = t6.ray.origin.distanceTo(u2);
        s3 < t6.near || s3 > t6.far || e2.push({ distance: s3, point: h2.clone().applyMatrix4(this.matrixWorld), index: i3, face: null, faceIndex: null, object: this });
      }
    } else {
      for (let i3 = Math.max(0, s2.start), n3 = Math.min(f2.count, s2.start + s2.count) - 1; i3 < n3; i3 += d2) {
        l2.fromBufferAttribute(f2, i3), c2.fromBufferAttribute(f2, i3 + 1);
        if (hp.distanceSqToSegment(l2, c2, u2, h2) > a2) continue;
        u2.applyMatrix4(this.matrixWorld);
        const n4 = t6.ray.origin.distanceTo(u2);
        n4 < t6.near || n4 > t6.far || e2.push({ distance: n4, point: h2.clone().applyMatrix4(this.matrixWorld), index: i3, face: null, faceIndex: null, object: this });
      }
    }
  }
  updateMorphTargets() {
    const t6 = this.geometry.morphAttributes, e2 = Object.keys(t6);
    if (e2.length > 0) {
      const i2 = t6[e2[0]];
      if (void 0 !== i2) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let t7 = 0, e3 = i2.length; t7 < e3; t7++) {
          const e4 = i2[t7].name || String(t7);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[e4] = t7;
        }
      }
    }
  }
};
var pp = new pa();
var fp = new pa();
var mp = class extends dp {
  constructor(t6, e2) {
    super(t6, e2), this.isLineSegments = true, this.type = "LineSegments";
  }
  computeLineDistances() {
    const t6 = this.geometry;
    if (null === t6.index) {
      const e2 = t6.attributes.position, i2 = [];
      for (let t7 = 0, n2 = e2.count; t7 < n2; t7 += 2) pp.fromBufferAttribute(e2, t7), fp.fromBufferAttribute(e2, t7 + 1), i2[t7] = 0 === t7 ? 0 : i2[t7 - 1], i2[t7 + 1] = i2[t7] + pp.distanceTo(fp);
      t6.setAttribute("lineDistance", new Hl(i2, 1));
    } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
};
var gp = class extends dp {
  constructor(t6, e2) {
    super(t6, e2), this.isLineLoop = true, this.type = "LineLoop";
  }
};
var vp = class extends Cl {
  constructor(t6) {
    super(), this.isPointsMaterial = true, this.type = "PointsMaterial", this.color = new $o(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.fog = true, this.setValues(t6);
  }
  copy(t6) {
    return super.copy(t6), this.color.copy(t6.color), this.map = t6.map, this.alphaMap = t6.alphaMap, this.size = t6.size, this.sizeAttenuation = t6.sizeAttenuation, this.fog = t6.fog, this;
  }
};
var yp = new Ga();
var xp = new ja();
var bp = new za();
var wp = new pa();
var _p = class extends ml {
  constructor(t6 = new Jl(), e2 = new vp()) {
    super(), this.isPoints = true, this.type = "Points", this.geometry = t6, this.material = e2, this.updateMorphTargets();
  }
  copy(t6, e2) {
    return super.copy(t6, e2), this.material = t6.material, this.geometry = t6.geometry, this;
  }
  raycast(t6, e2) {
    const i2 = this.geometry, n2 = this.matrixWorld, r2 = t6.params.Points.threshold, s2 = i2.drawRange;
    if (null === i2.boundingSphere && i2.computeBoundingSphere(), bp.copy(i2.boundingSphere), bp.applyMatrix4(n2), bp.radius += r2, false === t6.ray.intersectsSphere(bp)) return;
    yp.copy(n2).invert(), xp.copy(t6.ray).applyMatrix4(yp);
    const o2 = r2 / ((this.scale.x + this.scale.y + this.scale.z) / 3), a2 = o2 * o2, l2 = i2.index, c2 = i2.attributes.position;
    if (null !== l2) {
      for (let i3 = Math.max(0, s2.start), r3 = Math.min(l2.count, s2.start + s2.count); i3 < r3; i3++) {
        const r4 = l2.getX(i3);
        wp.fromBufferAttribute(c2, r4), Sp(wp, r4, a2, n2, t6, e2, this);
      }
    } else {
      for (let i3 = Math.max(0, s2.start), r3 = Math.min(c2.count, s2.start + s2.count); i3 < r3; i3++) wp.fromBufferAttribute(c2, i3), Sp(wp, i3, a2, n2, t6, e2, this);
    }
  }
  updateMorphTargets() {
    const t6 = this.geometry.morphAttributes, e2 = Object.keys(t6);
    if (e2.length > 0) {
      const i2 = t6[e2[0]];
      if (void 0 !== i2) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let t7 = 0, e3 = i2.length; t7 < e3; t7++) {
          const e4 = i2[t7].name || String(t7);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[e4] = t7;
        }
      }
    }
  }
};
function Sp(t6, e2, i2, n2, r2, s2, o2) {
  const a2 = xp.distanceSqToPoint(t6);
  if (a2 < i2) {
    const i3 = new pa();
    xp.closestPointToPoint(t6, i3), i3.applyMatrix4(n2);
    const l2 = r2.ray.origin.distanceTo(i3);
    if (l2 < r2.near || l2 > r2.far) return;
    s2.push({ distance: l2, distanceToRay: Math.sqrt(a2), point: i3, index: e2, face: null, object: o2 });
  }
}
var Mp = class extends ra {
  constructor(t6, e2, i2, n2, r2, s2, o2, a2, l2) {
    super(t6, e2, i2, n2, r2, s2, o2, a2, l2), this.isVideoTexture = true, this.minFilter = void 0 !== s2 ? s2 : Mr, this.magFilter = void 0 !== r2 ? r2 : Mr, this.generateMipmaps = false;
    const c2 = this;
    "requestVideoFrameCallback" in t6 && t6.requestVideoFrameCallback((function e3() {
      c2.needsUpdate = true, t6.requestVideoFrameCallback(e3);
    }));
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const t6 = this.image;
    false === "requestVideoFrameCallback" in t6 && t6.readyState >= t6.HAVE_CURRENT_DATA && (this.needsUpdate = true);
  }
};
var Tp = class extends ra {
  constructor(t6, e2, i2) {
    super({ width: t6, height: e2 }), this.isFramebufferTexture = true, this.format = i2, this.magFilter = xr, this.minFilter = xr, this.generateMipmaps = false, this.needsUpdate = true;
  }
};
var Ep = class extends ra {
  constructor(t6, e2, i2, n2, r2, s2, o2, a2, l2, c2, h2, u2) {
    super(null, s2, o2, a2, l2, c2, n2, r2, h2, u2), this.isCompressedTexture = true, this.image = { width: e2, height: i2 }, this.mipmaps = t6, this.flipY = false, this.generateMipmaps = false;
  }
};
var Ap = class extends ra {
  constructor(t6, e2, i2, n2, r2, s2, o2, a2, l2) {
    super(t6, e2, i2, n2, r2, s2, o2, a2, l2), this.isCanvasTexture = true, this.needsUpdate = true;
  }
};
var Cp = class {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(t6, e2) {
    const i2 = this.getUtoTmapping(t6);
    return this.getPoint(i2, e2);
  }
  getPoints(t6 = 5) {
    const e2 = [];
    for (let i2 = 0; i2 <= t6; i2++) e2.push(this.getPoint(i2 / t6));
    return e2;
  }
  getSpacedPoints(t6 = 5) {
    const e2 = [];
    for (let i2 = 0; i2 <= t6; i2++) e2.push(this.getPointAt(i2 / t6));
    return e2;
  }
  getLength() {
    const t6 = this.getLengths();
    return t6[t6.length - 1];
  }
  getLengths(t6 = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === t6 + 1 && !this.needsUpdate) return this.cacheArcLengths;
    this.needsUpdate = false;
    const e2 = [];
    let i2, n2 = this.getPoint(0), r2 = 0;
    e2.push(0);
    for (let s2 = 1; s2 <= t6; s2++) i2 = this.getPoint(s2 / t6), r2 += i2.distanceTo(n2), e2.push(r2), n2 = i2;
    return this.cacheArcLengths = e2, e2;
  }
  updateArcLengths() {
    this.needsUpdate = true, this.getLengths();
  }
  getUtoTmapping(t6, e2) {
    const i2 = this.getLengths();
    let n2 = 0;
    const r2 = i2.length;
    let s2;
    s2 = e2 || t6 * i2[r2 - 1];
    let o2, a2 = 0, l2 = r2 - 1;
    for (; a2 <= l2; ) if (n2 = Math.floor(a2 + (l2 - a2) / 2), o2 = i2[n2] - s2, o2 < 0) a2 = n2 + 1;
    else {
      if (!(o2 > 0)) {
        l2 = n2;
        break;
      }
      l2 = n2 - 1;
    }
    if (n2 = l2, i2[n2] === s2) return n2 / (r2 - 1);
    const c2 = i2[n2];
    return (n2 + (s2 - c2) / (i2[n2 + 1] - c2)) / (r2 - 1);
  }
  getTangent(t6, e2) {
    const i2 = 1e-4;
    let n2 = t6 - i2, r2 = t6 + i2;
    n2 < 0 && (n2 = 0), r2 > 1 && (r2 = 1);
    const s2 = this.getPoint(n2), o2 = this.getPoint(r2), a2 = e2 || (s2.isVector2 ? new Fo() : new pa());
    return a2.copy(o2).sub(s2).normalize(), a2;
  }
  getTangentAt(t6, e2) {
    const i2 = this.getUtoTmapping(t6);
    return this.getTangent(i2, e2);
  }
  computeFrenetFrames(t6, e2) {
    const i2 = new pa(), n2 = [], r2 = [], s2 = [], o2 = new pa(), a2 = new Ga();
    for (let e3 = 0; e3 <= t6; e3++) {
      const i3 = e3 / t6;
      n2[e3] = this.getTangentAt(i3, new pa());
    }
    r2[0] = new pa(), s2[0] = new pa();
    let l2 = Number.MAX_VALUE;
    const c2 = Math.abs(n2[0].x), h2 = Math.abs(n2[0].y), u2 = Math.abs(n2[0].z);
    c2 <= l2 && (l2 = c2, i2.set(1, 0, 0)), h2 <= l2 && (l2 = h2, i2.set(0, 1, 0)), u2 <= l2 && i2.set(0, 0, 1), o2.crossVectors(n2[0], i2).normalize(), r2[0].crossVectors(n2[0], o2), s2[0].crossVectors(n2[0], r2[0]);
    for (let e3 = 1; e3 <= t6; e3++) {
      if (r2[e3] = r2[e3 - 1].clone(), s2[e3] = s2[e3 - 1].clone(), o2.crossVectors(n2[e3 - 1], n2[e3]), o2.length() > Number.EPSILON) {
        o2.normalize();
        const t7 = Math.acos(Ro(n2[e3 - 1].dot(n2[e3]), -1, 1));
        r2[e3].applyMatrix4(a2.makeRotationAxis(o2, t7));
      }
      s2[e3].crossVectors(n2[e3], r2[e3]);
    }
    if (true === e2) {
      let e3 = Math.acos(Ro(r2[0].dot(r2[t6]), -1, 1));
      e3 /= t6, n2[0].dot(o2.crossVectors(r2[0], r2[t6])) > 0 && (e3 = -e3);
      for (let i3 = 1; i3 <= t6; i3++) r2[i3].applyMatrix4(a2.makeRotationAxis(n2[i3], e3 * i3)), s2[i3].crossVectors(n2[i3], r2[i3]);
    }
    return { tangents: n2, normals: r2, binormals: s2 };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t6) {
    return this.arcLengthDivisions = t6.arcLengthDivisions, this;
  }
  toJSON() {
    const t6 = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } };
    return t6.arcLengthDivisions = this.arcLengthDivisions, t6.type = this.type, t6;
  }
  fromJSON(t6) {
    return this.arcLengthDivisions = t6.arcLengthDivisions, this;
  }
};
var Rp = class extends Cp {
  constructor(t6 = 0, e2 = 0, i2 = 1, n2 = 1, r2 = 0, s2 = 2 * Math.PI, o2 = false, a2 = 0) {
    super(), this.isEllipseCurve = true, this.type = "EllipseCurve", this.aX = t6, this.aY = e2, this.xRadius = i2, this.yRadius = n2, this.aStartAngle = r2, this.aEndAngle = s2, this.aClockwise = o2, this.aRotation = a2;
  }
  getPoint(t6, e2) {
    const i2 = e2 || new Fo(), n2 = 2 * Math.PI;
    let r2 = this.aEndAngle - this.aStartAngle;
    const s2 = Math.abs(r2) < Number.EPSILON;
    for (; r2 < 0; ) r2 += n2;
    for (; r2 > n2; ) r2 -= n2;
    r2 < Number.EPSILON && (r2 = s2 ? 0 : n2), true !== this.aClockwise || s2 || (r2 === n2 ? r2 = -n2 : r2 -= n2);
    const o2 = this.aStartAngle + t6 * r2;
    let a2 = this.aX + this.xRadius * Math.cos(o2), l2 = this.aY + this.yRadius * Math.sin(o2);
    if (0 !== this.aRotation) {
      const t7 = Math.cos(this.aRotation), e3 = Math.sin(this.aRotation), i3 = a2 - this.aX, n3 = l2 - this.aY;
      a2 = i3 * t7 - n3 * e3 + this.aX, l2 = i3 * e3 + n3 * t7 + this.aY;
    }
    return i2.set(a2, l2);
  }
  copy(t6) {
    return super.copy(t6), this.aX = t6.aX, this.aY = t6.aY, this.xRadius = t6.xRadius, this.yRadius = t6.yRadius, this.aStartAngle = t6.aStartAngle, this.aEndAngle = t6.aEndAngle, this.aClockwise = t6.aClockwise, this.aRotation = t6.aRotation, this;
  }
  toJSON() {
    const t6 = super.toJSON();
    return t6.aX = this.aX, t6.aY = this.aY, t6.xRadius = this.xRadius, t6.yRadius = this.yRadius, t6.aStartAngle = this.aStartAngle, t6.aEndAngle = this.aEndAngle, t6.aClockwise = this.aClockwise, t6.aRotation = this.aRotation, t6;
  }
  fromJSON(t6) {
    return super.fromJSON(t6), this.aX = t6.aX, this.aY = t6.aY, this.xRadius = t6.xRadius, this.yRadius = t6.yRadius, this.aStartAngle = t6.aStartAngle, this.aEndAngle = t6.aEndAngle, this.aClockwise = t6.aClockwise, this.aRotation = t6.aRotation, this;
  }
};
var Pp = class extends Rp {
  constructor(t6, e2, i2, n2, r2, s2) {
    super(t6, e2, i2, i2, n2, r2, s2), this.isArcCurve = true, this.type = "ArcCurve";
  }
};
function Lp() {
  let t6 = 0, e2 = 0, i2 = 0, n2 = 0;
  function r2(r3, s2, o2, a2) {
    t6 = r3, e2 = o2, i2 = -3 * r3 + 3 * s2 - 2 * o2 - a2, n2 = 2 * r3 - 2 * s2 + o2 + a2;
  }
  return { initCatmullRom: function(t7, e3, i3, n3, s2) {
    r2(e3, i3, s2 * (i3 - t7), s2 * (n3 - e3));
  }, initNonuniformCatmullRom: function(t7, e3, i3, n3, s2, o2, a2) {
    let l2 = (e3 - t7) / s2 - (i3 - t7) / (s2 + o2) + (i3 - e3) / o2, c2 = (i3 - e3) / o2 - (n3 - e3) / (o2 + a2) + (n3 - i3) / a2;
    l2 *= o2, c2 *= o2, r2(e3, i3, l2, c2);
  }, calc: function(r3) {
    const s2 = r3 * r3;
    return t6 + e2 * r3 + i2 * s2 + n2 * (s2 * r3);
  } };
}
var Ip = new pa();
var Dp = new Lp();
var Op = new Lp();
var zp = new Lp();
var Fp = class extends Cp {
  constructor(t6 = [], e2 = false, i2 = "centripetal", n2 = 0.5) {
    super(), this.isCatmullRomCurve3 = true, this.type = "CatmullRomCurve3", this.points = t6, this.closed = e2, this.curveType = i2, this.tension = n2;
  }
  getPoint(t6, e2 = new pa()) {
    const i2 = e2, n2 = this.points, r2 = n2.length, s2 = (r2 - (this.closed ? 0 : 1)) * t6;
    let o2, a2, l2 = Math.floor(s2), c2 = s2 - l2;
    this.closed ? l2 += l2 > 0 ? 0 : (Math.floor(Math.abs(l2) / r2) + 1) * r2 : 0 === c2 && l2 === r2 - 1 && (l2 = r2 - 2, c2 = 1), this.closed || l2 > 0 ? o2 = n2[(l2 - 1) % r2] : (Ip.subVectors(n2[0], n2[1]).add(n2[0]), o2 = Ip);
    const h2 = n2[l2 % r2], u2 = n2[(l2 + 1) % r2];
    if (this.closed || l2 + 2 < r2 ? a2 = n2[(l2 + 2) % r2] : (Ip.subVectors(n2[r2 - 1], n2[r2 - 2]).add(n2[r2 - 1]), a2 = Ip), "centripetal" === this.curveType || "chordal" === this.curveType) {
      const t7 = "chordal" === this.curveType ? 0.5 : 0.25;
      let e3 = Math.pow(o2.distanceToSquared(h2), t7), i3 = Math.pow(h2.distanceToSquared(u2), t7), n3 = Math.pow(u2.distanceToSquared(a2), t7);
      i3 < 1e-4 && (i3 = 1), e3 < 1e-4 && (e3 = i3), n3 < 1e-4 && (n3 = i3), Dp.initNonuniformCatmullRom(o2.x, h2.x, u2.x, a2.x, e3, i3, n3), Op.initNonuniformCatmullRom(o2.y, h2.y, u2.y, a2.y, e3, i3, n3), zp.initNonuniformCatmullRom(o2.z, h2.z, u2.z, a2.z, e3, i3, n3);
    } else "catmullrom" === this.curveType && (Dp.initCatmullRom(o2.x, h2.x, u2.x, a2.x, this.tension), Op.initCatmullRom(o2.y, h2.y, u2.y, a2.y, this.tension), zp.initCatmullRom(o2.z, h2.z, u2.z, a2.z, this.tension));
    return i2.set(Dp.calc(c2), Op.calc(c2), zp.calc(c2)), i2;
  }
  copy(t6) {
    super.copy(t6), this.points = [];
    for (let e2 = 0, i2 = t6.points.length; e2 < i2; e2++) {
      const i3 = t6.points[e2];
      this.points.push(i3.clone());
    }
    return this.closed = t6.closed, this.curveType = t6.curveType, this.tension = t6.tension, this;
  }
  toJSON() {
    const t6 = super.toJSON();
    t6.points = [];
    for (let e2 = 0, i2 = this.points.length; e2 < i2; e2++) {
      const i3 = this.points[e2];
      t6.points.push(i3.toArray());
    }
    return t6.closed = this.closed, t6.curveType = this.curveType, t6.tension = this.tension, t6;
  }
  fromJSON(t6) {
    super.fromJSON(t6), this.points = [];
    for (let e2 = 0, i2 = t6.points.length; e2 < i2; e2++) {
      const i3 = t6.points[e2];
      this.points.push(new pa().fromArray(i3));
    }
    return this.closed = t6.closed, this.curveType = t6.curveType, this.tension = t6.tension, this;
  }
};
function Np(t6, e2, i2, n2, r2) {
  const s2 = 0.5 * (n2 - e2), o2 = 0.5 * (r2 - i2), a2 = t6 * t6;
  return (2 * i2 - 2 * n2 + s2 + o2) * (t6 * a2) + (-3 * i2 + 3 * n2 - 2 * s2 - o2) * a2 + s2 * t6 + i2;
}
function Bp(t6, e2, i2, n2) {
  return (function(t7, e3) {
    const i3 = 1 - t7;
    return i3 * i3 * e3;
  })(t6, e2) + (function(t7, e3) {
    return 2 * (1 - t7) * t7 * e3;
  })(t6, i2) + (function(t7, e3) {
    return t7 * t7 * e3;
  })(t6, n2);
}
function kp(t6, e2, i2, n2, r2) {
  return (function(t7, e3) {
    const i3 = 1 - t7;
    return i3 * i3 * i3 * e3;
  })(t6, e2) + (function(t7, e3) {
    const i3 = 1 - t7;
    return 3 * i3 * i3 * t7 * e3;
  })(t6, i2) + (function(t7, e3) {
    return 3 * (1 - t7) * t7 * t7 * e3;
  })(t6, n2) + (function(t7, e3) {
    return t7 * t7 * t7 * e3;
  })(t6, r2);
}
var Up = class extends Cp {
  constructor(t6 = new Fo(), e2 = new Fo(), i2 = new Fo(), n2 = new Fo()) {
    super(), this.isCubicBezierCurve = true, this.type = "CubicBezierCurve", this.v0 = t6, this.v1 = e2, this.v2 = i2, this.v3 = n2;
  }
  getPoint(t6, e2 = new Fo()) {
    const i2 = e2, n2 = this.v0, r2 = this.v1, s2 = this.v2, o2 = this.v3;
    return i2.set(kp(t6, n2.x, r2.x, s2.x, o2.x), kp(t6, n2.y, r2.y, s2.y, o2.y)), i2;
  }
  copy(t6) {
    return super.copy(t6), this.v0.copy(t6.v0), this.v1.copy(t6.v1), this.v2.copy(t6.v2), this.v3.copy(t6.v3), this;
  }
  toJSON() {
    const t6 = super.toJSON();
    return t6.v0 = this.v0.toArray(), t6.v1 = this.v1.toArray(), t6.v2 = this.v2.toArray(), t6.v3 = this.v3.toArray(), t6;
  }
  fromJSON(t6) {
    return super.fromJSON(t6), this.v0.fromArray(t6.v0), this.v1.fromArray(t6.v1), this.v2.fromArray(t6.v2), this.v3.fromArray(t6.v3), this;
  }
};
var Hp = class extends Cp {
  constructor(t6 = new pa(), e2 = new pa(), i2 = new pa(), n2 = new pa()) {
    super(), this.isCubicBezierCurve3 = true, this.type = "CubicBezierCurve3", this.v0 = t6, this.v1 = e2, this.v2 = i2, this.v3 = n2;
  }
  getPoint(t6, e2 = new pa()) {
    const i2 = e2, n2 = this.v0, r2 = this.v1, s2 = this.v2, o2 = this.v3;
    return i2.set(kp(t6, n2.x, r2.x, s2.x, o2.x), kp(t6, n2.y, r2.y, s2.y, o2.y), kp(t6, n2.z, r2.z, s2.z, o2.z)), i2;
  }
  copy(t6) {
    return super.copy(t6), this.v0.copy(t6.v0), this.v1.copy(t6.v1), this.v2.copy(t6.v2), this.v3.copy(t6.v3), this;
  }
  toJSON() {
    const t6 = super.toJSON();
    return t6.v0 = this.v0.toArray(), t6.v1 = this.v1.toArray(), t6.v2 = this.v2.toArray(), t6.v3 = this.v3.toArray(), t6;
  }
  fromJSON(t6) {
    return super.fromJSON(t6), this.v0.fromArray(t6.v0), this.v1.fromArray(t6.v1), this.v2.fromArray(t6.v2), this.v3.fromArray(t6.v3), this;
  }
};
var Vp = class extends Cp {
  constructor(t6 = new Fo(), e2 = new Fo()) {
    super(), this.isLineCurve = true, this.type = "LineCurve", this.v1 = t6, this.v2 = e2;
  }
  getPoint(t6, e2 = new Fo()) {
    const i2 = e2;
    return 1 === t6 ? i2.copy(this.v2) : (i2.copy(this.v2).sub(this.v1), i2.multiplyScalar(t6).add(this.v1)), i2;
  }
  getPointAt(t6, e2) {
    return this.getPoint(t6, e2);
  }
  getTangent(t6, e2) {
    const i2 = e2 || new Fo();
    return i2.copy(this.v2).sub(this.v1).normalize(), i2;
  }
  copy(t6) {
    return super.copy(t6), this.v1.copy(t6.v1), this.v2.copy(t6.v2), this;
  }
  toJSON() {
    const t6 = super.toJSON();
    return t6.v1 = this.v1.toArray(), t6.v2 = this.v2.toArray(), t6;
  }
  fromJSON(t6) {
    return super.fromJSON(t6), this.v1.fromArray(t6.v1), this.v2.fromArray(t6.v2), this;
  }
};
var jp = class extends Cp {
  constructor(t6 = new pa(), e2 = new pa()) {
    super(), this.isLineCurve3 = true, this.type = "LineCurve3", this.v1 = t6, this.v2 = e2;
  }
  getPoint(t6, e2 = new pa()) {
    const i2 = e2;
    return 1 === t6 ? i2.copy(this.v2) : (i2.copy(this.v2).sub(this.v1), i2.multiplyScalar(t6).add(this.v1)), i2;
  }
  getPointAt(t6, e2) {
    return this.getPoint(t6, e2);
  }
  copy(t6) {
    return super.copy(t6), this.v1.copy(t6.v1), this.v2.copy(t6.v2), this;
  }
  toJSON() {
    const t6 = super.toJSON();
    return t6.v1 = this.v1.toArray(), t6.v2 = this.v2.toArray(), t6;
  }
  fromJSON(t6) {
    return super.fromJSON(t6), this.v1.fromArray(t6.v1), this.v2.fromArray(t6.v2), this;
  }
};
var Gp = class extends Cp {
  constructor(t6 = new Fo(), e2 = new Fo(), i2 = new Fo()) {
    super(), this.isQuadraticBezierCurve = true, this.type = "QuadraticBezierCurve", this.v0 = t6, this.v1 = e2, this.v2 = i2;
  }
  getPoint(t6, e2 = new Fo()) {
    const i2 = e2, n2 = this.v0, r2 = this.v1, s2 = this.v2;
    return i2.set(Bp(t6, n2.x, r2.x, s2.x), Bp(t6, n2.y, r2.y, s2.y)), i2;
  }
  copy(t6) {
    return super.copy(t6), this.v0.copy(t6.v0), this.v1.copy(t6.v1), this.v2.copy(t6.v2), this;
  }
  toJSON() {
    const t6 = super.toJSON();
    return t6.v0 = this.v0.toArray(), t6.v1 = this.v1.toArray(), t6.v2 = this.v2.toArray(), t6;
  }
  fromJSON(t6) {
    return super.fromJSON(t6), this.v0.fromArray(t6.v0), this.v1.fromArray(t6.v1), this.v2.fromArray(t6.v2), this;
  }
};
var Wp = class extends Cp {
  constructor(t6 = new pa(), e2 = new pa(), i2 = new pa()) {
    super(), this.isQuadraticBezierCurve3 = true, this.type = "QuadraticBezierCurve3", this.v0 = t6, this.v1 = e2, this.v2 = i2;
  }
  getPoint(t6, e2 = new pa()) {
    const i2 = e2, n2 = this.v0, r2 = this.v1, s2 = this.v2;
    return i2.set(Bp(t6, n2.x, r2.x, s2.x), Bp(t6, n2.y, r2.y, s2.y), Bp(t6, n2.z, r2.z, s2.z)), i2;
  }
  copy(t6) {
    return super.copy(t6), this.v0.copy(t6.v0), this.v1.copy(t6.v1), this.v2.copy(t6.v2), this;
  }
  toJSON() {
    const t6 = super.toJSON();
    return t6.v0 = this.v0.toArray(), t6.v1 = this.v1.toArray(), t6.v2 = this.v2.toArray(), t6;
  }
  fromJSON(t6) {
    return super.fromJSON(t6), this.v0.fromArray(t6.v0), this.v1.fromArray(t6.v1), this.v2.fromArray(t6.v2), this;
  }
};
var qp = class extends Cp {
  constructor(t6 = []) {
    super(), this.isSplineCurve = true, this.type = "SplineCurve", this.points = t6;
  }
  getPoint(t6, e2 = new Fo()) {
    const i2 = e2, n2 = this.points, r2 = (n2.length - 1) * t6, s2 = Math.floor(r2), o2 = r2 - s2, a2 = n2[0 === s2 ? s2 : s2 - 1], l2 = n2[s2], c2 = n2[s2 > n2.length - 2 ? n2.length - 1 : s2 + 1], h2 = n2[s2 > n2.length - 3 ? n2.length - 1 : s2 + 2];
    return i2.set(Np(o2, a2.x, l2.x, c2.x, h2.x), Np(o2, a2.y, l2.y, c2.y, h2.y)), i2;
  }
  copy(t6) {
    super.copy(t6), this.points = [];
    for (let e2 = 0, i2 = t6.points.length; e2 < i2; e2++) {
      const i3 = t6.points[e2];
      this.points.push(i3.clone());
    }
    return this;
  }
  toJSON() {
    const t6 = super.toJSON();
    t6.points = [];
    for (let e2 = 0, i2 = this.points.length; e2 < i2; e2++) {
      const i3 = this.points[e2];
      t6.points.push(i3.toArray());
    }
    return t6;
  }
  fromJSON(t6) {
    super.fromJSON(t6), this.points = [];
    for (let e2 = 0, i2 = t6.points.length; e2 < i2; e2++) {
      const i3 = t6.points[e2];
      this.points.push(new Fo().fromArray(i3));
    }
    return this;
  }
};
var Xp = Object.freeze({ __proto__: null, ArcCurve: Pp, CatmullRomCurve3: Fp, CubicBezierCurve: Up, CubicBezierCurve3: Hp, EllipseCurve: Rp, LineCurve: Vp, LineCurve3: jp, QuadraticBezierCurve: Gp, QuadraticBezierCurve3: Wp, SplineCurve: qp });
var Yp = class extends Cp {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = false;
  }
  add(t6) {
    this.curves.push(t6);
  }
  closePath() {
    const t6 = this.curves[0].getPoint(0), e2 = this.curves[this.curves.length - 1].getPoint(1);
    t6.equals(e2) || this.curves.push(new Vp(e2, t6));
  }
  getPoint(t6, e2) {
    const i2 = t6 * this.getLength(), n2 = this.getCurveLengths();
    let r2 = 0;
    for (; r2 < n2.length; ) {
      if (n2[r2] >= i2) {
        const t7 = n2[r2] - i2, s2 = this.curves[r2], o2 = s2.getLength(), a2 = 0 === o2 ? 0 : 1 - t7 / o2;
        return s2.getPointAt(a2, e2);
      }
      r2++;
    }
    return null;
  }
  getLength() {
    const t6 = this.getCurveLengths();
    return t6[t6.length - 1];
  }
  updateArcLengths() {
    this.needsUpdate = true, this.cacheLengths = null, this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
    const t6 = [];
    let e2 = 0;
    for (let i2 = 0, n2 = this.curves.length; i2 < n2; i2++) e2 += this.curves[i2].getLength(), t6.push(e2);
    return this.cacheLengths = t6, t6;
  }
  getSpacedPoints(t6 = 40) {
    const e2 = [];
    for (let i2 = 0; i2 <= t6; i2++) e2.push(this.getPoint(i2 / t6));
    return this.autoClose && e2.push(e2[0]), e2;
  }
  getPoints(t6 = 12) {
    const e2 = [];
    let i2;
    for (let n2 = 0, r2 = this.curves; n2 < r2.length; n2++) {
      const s2 = r2[n2], o2 = s2.isEllipseCurve ? 2 * t6 : s2.isLineCurve || s2.isLineCurve3 ? 1 : s2.isSplineCurve ? t6 * s2.points.length : t6, a2 = s2.getPoints(o2);
      for (let t7 = 0; t7 < a2.length; t7++) {
        const n3 = a2[t7];
        i2 && i2.equals(n3) || (e2.push(n3), i2 = n3);
      }
    }
    return this.autoClose && e2.length > 1 && !e2[e2.length - 1].equals(e2[0]) && e2.push(e2[0]), e2;
  }
  copy(t6) {
    super.copy(t6), this.curves = [];
    for (let e2 = 0, i2 = t6.curves.length; e2 < i2; e2++) {
      const i3 = t6.curves[e2];
      this.curves.push(i3.clone());
    }
    return this.autoClose = t6.autoClose, this;
  }
  toJSON() {
    const t6 = super.toJSON();
    t6.autoClose = this.autoClose, t6.curves = [];
    for (let e2 = 0, i2 = this.curves.length; e2 < i2; e2++) {
      const i3 = this.curves[e2];
      t6.curves.push(i3.toJSON());
    }
    return t6;
  }
  fromJSON(t6) {
    super.fromJSON(t6), this.autoClose = t6.autoClose, this.curves = [];
    for (let e2 = 0, i2 = t6.curves.length; e2 < i2; e2++) {
      const i3 = t6.curves[e2];
      this.curves.push(new Xp[i3.type]().fromJSON(i3));
    }
    return this;
  }
};
var Zp = class extends Yp {
  constructor(t6) {
    super(), this.type = "Path", this.currentPoint = new Fo(), t6 && this.setFromPoints(t6);
  }
  setFromPoints(t6) {
    this.moveTo(t6[0].x, t6[0].y);
    for (let e2 = 1, i2 = t6.length; e2 < i2; e2++) this.lineTo(t6[e2].x, t6[e2].y);
    return this;
  }
  moveTo(t6, e2) {
    return this.currentPoint.set(t6, e2), this;
  }
  lineTo(t6, e2) {
    const i2 = new Vp(this.currentPoint.clone(), new Fo(t6, e2));
    return this.curves.push(i2), this.currentPoint.set(t6, e2), this;
  }
  quadraticCurveTo(t6, e2, i2, n2) {
    const r2 = new Gp(this.currentPoint.clone(), new Fo(t6, e2), new Fo(i2, n2));
    return this.curves.push(r2), this.currentPoint.set(i2, n2), this;
  }
  bezierCurveTo(t6, e2, i2, n2, r2, s2) {
    const o2 = new Up(this.currentPoint.clone(), new Fo(t6, e2), new Fo(i2, n2), new Fo(r2, s2));
    return this.curves.push(o2), this.currentPoint.set(r2, s2), this;
  }
  splineThru(t6) {
    const e2 = [this.currentPoint.clone()].concat(t6), i2 = new qp(e2);
    return this.curves.push(i2), this.currentPoint.copy(t6[t6.length - 1]), this;
  }
  arc(t6, e2, i2, n2, r2, s2) {
    const o2 = this.currentPoint.x, a2 = this.currentPoint.y;
    return this.absarc(t6 + o2, e2 + a2, i2, n2, r2, s2), this;
  }
  absarc(t6, e2, i2, n2, r2, s2) {
    return this.absellipse(t6, e2, i2, i2, n2, r2, s2), this;
  }
  ellipse(t6, e2, i2, n2, r2, s2, o2, a2) {
    const l2 = this.currentPoint.x, c2 = this.currentPoint.y;
    return this.absellipse(t6 + l2, e2 + c2, i2, n2, r2, s2, o2, a2), this;
  }
  absellipse(t6, e2, i2, n2, r2, s2, o2, a2) {
    const l2 = new Rp(t6, e2, i2, n2, r2, s2, o2, a2);
    if (this.curves.length > 0) {
      const t7 = l2.getPoint(0);
      t7.equals(this.currentPoint) || this.lineTo(t7.x, t7.y);
    }
    this.curves.push(l2);
    const c2 = l2.getPoint(1);
    return this.currentPoint.copy(c2), this;
  }
  copy(t6) {
    return super.copy(t6), this.currentPoint.copy(t6.currentPoint), this;
  }
  toJSON() {
    const t6 = super.toJSON();
    return t6.currentPoint = this.currentPoint.toArray(), t6;
  }
  fromJSON(t6) {
    return super.fromJSON(t6), this.currentPoint.fromArray(t6.currentPoint), this;
  }
};
var Jp = class _Jp extends Jl {
  constructor(t6 = [new Fo(0, -0.5), new Fo(0.5, 0), new Fo(0, 0.5)], e2 = 12, i2 = 0, n2 = 2 * Math.PI) {
    super(), this.type = "LatheGeometry", this.parameters = { points: t6, segments: e2, phiStart: i2, phiLength: n2 }, e2 = Math.floor(e2), n2 = Ro(n2, 0, 2 * Math.PI);
    const r2 = [], s2 = [], o2 = [], a2 = [], l2 = [], c2 = 1 / e2, h2 = new pa(), u2 = new Fo(), d2 = new pa(), p2 = new pa(), f2 = new pa();
    let m2 = 0, g2 = 0;
    for (let e3 = 0; e3 <= t6.length - 1; e3++) switch (e3) {
      case 0:
        m2 = t6[e3 + 1].x - t6[e3].x, g2 = t6[e3 + 1].y - t6[e3].y, d2.x = 1 * g2, d2.y = -m2, d2.z = 0 * g2, f2.copy(d2), d2.normalize(), a2.push(d2.x, d2.y, d2.z);
        break;
      case t6.length - 1:
        a2.push(f2.x, f2.y, f2.z);
        break;
      default:
        m2 = t6[e3 + 1].x - t6[e3].x, g2 = t6[e3 + 1].y - t6[e3].y, d2.x = 1 * g2, d2.y = -m2, d2.z = 0 * g2, p2.copy(d2), d2.x += f2.x, d2.y += f2.y, d2.z += f2.z, d2.normalize(), a2.push(d2.x, d2.y, d2.z), f2.copy(p2);
    }
    for (let r3 = 0; r3 <= e2; r3++) {
      const d3 = i2 + r3 * c2 * n2, p3 = Math.sin(d3), f3 = Math.cos(d3);
      for (let i3 = 0; i3 <= t6.length - 1; i3++) {
        h2.x = t6[i3].x * p3, h2.y = t6[i3].y, h2.z = t6[i3].x * f3, s2.push(h2.x, h2.y, h2.z), u2.x = r3 / e2, u2.y = i3 / (t6.length - 1), o2.push(u2.x, u2.y);
        const n3 = a2[3 * i3 + 0] * p3, c3 = a2[3 * i3 + 1], d4 = a2[3 * i3 + 0] * f3;
        l2.push(n3, c3, d4);
      }
    }
    for (let i3 = 0; i3 < e2; i3++) for (let e3 = 0; e3 < t6.length - 1; e3++) {
      const n3 = e3 + i3 * t6.length, s3 = n3, o3 = n3 + t6.length, a3 = n3 + t6.length + 1, l3 = n3 + 1;
      r2.push(s3, o3, l3), r2.push(a3, l3, o3);
    }
    this.setIndex(r2), this.setAttribute("position", new Hl(s2, 3)), this.setAttribute("uv", new Hl(o2, 2)), this.setAttribute("normal", new Hl(l2, 3));
  }
  static fromJSON(t6) {
    return new _Jp(t6.points, t6.segments, t6.phiStart, t6.phiLength);
  }
};
var Kp = class _Kp extends Jp {
  constructor(t6 = 1, e2 = 1, i2 = 4, n2 = 8) {
    const r2 = new Zp();
    r2.absarc(0, -e2 / 2, t6, 1.5 * Math.PI, 0), r2.absarc(0, e2 / 2, t6, 0, 0.5 * Math.PI), super(r2.getPoints(i2), n2), this.type = "CapsuleGeometry", this.parameters = { radius: t6, height: e2, capSegments: i2, radialSegments: n2 };
  }
  static fromJSON(t6) {
    return new _Kp(t6.radius, t6.length, t6.capSegments, t6.radialSegments);
  }
};
var $p = class _$p extends Jl {
  constructor(t6 = 1, e2 = 8, i2 = 0, n2 = 2 * Math.PI) {
    super(), this.type = "CircleGeometry", this.parameters = { radius: t6, segments: e2, thetaStart: i2, thetaLength: n2 }, e2 = Math.max(3, e2);
    const r2 = [], s2 = [], o2 = [], a2 = [], l2 = new pa(), c2 = new Fo();
    s2.push(0, 0, 0), o2.push(0, 0, 1), a2.push(0.5, 0.5);
    for (let r3 = 0, h2 = 3; r3 <= e2; r3++, h2 += 3) {
      const u2 = i2 + r3 / e2 * n2;
      l2.x = t6 * Math.cos(u2), l2.y = t6 * Math.sin(u2), s2.push(l2.x, l2.y, l2.z), o2.push(0, 0, 1), c2.x = (s2[h2] / t6 + 1) / 2, c2.y = (s2[h2 + 1] / t6 + 1) / 2, a2.push(c2.x, c2.y);
    }
    for (let t7 = 1; t7 <= e2; t7++) r2.push(t7, t7 + 1, 0);
    this.setIndex(r2), this.setAttribute("position", new Hl(s2, 3)), this.setAttribute("normal", new Hl(o2, 3)), this.setAttribute("uv", new Hl(a2, 2));
  }
  static fromJSON(t6) {
    return new _$p(t6.radius, t6.segments, t6.thetaStart, t6.thetaLength);
  }
};
var Qp = class _Qp extends Jl {
  constructor(t6 = 1, e2 = 1, i2 = 1, n2 = 8, r2 = 1, s2 = false, o2 = 0, a2 = 2 * Math.PI) {
    super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: t6, radiusBottom: e2, height: i2, radialSegments: n2, heightSegments: r2, openEnded: s2, thetaStart: o2, thetaLength: a2 };
    const l2 = this;
    n2 = Math.floor(n2), r2 = Math.floor(r2);
    const c2 = [], h2 = [], u2 = [], d2 = [];
    let p2 = 0;
    const f2 = [], m2 = i2 / 2;
    let g2 = 0;
    function v2(i3) {
      const r3 = p2, s3 = new Fo(), f3 = new pa();
      let v3 = 0;
      const y2 = true === i3 ? t6 : e2, x2 = true === i3 ? 1 : -1;
      for (let t7 = 1; t7 <= n2; t7++) h2.push(0, m2 * x2, 0), u2.push(0, x2, 0), d2.push(0.5, 0.5), p2++;
      const b2 = p2;
      for (let t7 = 0; t7 <= n2; t7++) {
        const e3 = t7 / n2 * a2 + o2, i4 = Math.cos(e3), r4 = Math.sin(e3);
        f3.x = y2 * r4, f3.y = m2 * x2, f3.z = y2 * i4, h2.push(f3.x, f3.y, f3.z), u2.push(0, x2, 0), s3.x = 0.5 * i4 + 0.5, s3.y = 0.5 * r4 * x2 + 0.5, d2.push(s3.x, s3.y), p2++;
      }
      for (let t7 = 0; t7 < n2; t7++) {
        const e3 = r3 + t7, n3 = b2 + t7;
        true === i3 ? c2.push(n3, n3 + 1, e3) : c2.push(n3 + 1, n3, e3), v3 += 3;
      }
      l2.addGroup(g2, v3, true === i3 ? 1 : 2), g2 += v3;
    }
    !(function() {
      const s3 = new pa(), v3 = new pa();
      let y2 = 0;
      const x2 = (e2 - t6) / i2;
      for (let l3 = 0; l3 <= r2; l3++) {
        const c3 = [], g3 = l3 / r2, y3 = g3 * (e2 - t6) + t6;
        for (let t7 = 0; t7 <= n2; t7++) {
          const e3 = t7 / n2, r3 = e3 * a2 + o2, l4 = Math.sin(r3), f3 = Math.cos(r3);
          v3.x = y3 * l4, v3.y = -g3 * i2 + m2, v3.z = y3 * f3, h2.push(v3.x, v3.y, v3.z), s3.set(l4, x2, f3).normalize(), u2.push(s3.x, s3.y, s3.z), d2.push(e3, 1 - g3), c3.push(p2++);
        }
        f2.push(c3);
      }
      for (let t7 = 0; t7 < n2; t7++) for (let e3 = 0; e3 < r2; e3++) {
        const i3 = f2[e3][t7], n3 = f2[e3 + 1][t7], r3 = f2[e3 + 1][t7 + 1], s4 = f2[e3][t7 + 1];
        c2.push(i3, n3, s4), c2.push(n3, r3, s4), y2 += 6;
      }
      l2.addGroup(g2, y2, 0), g2 += y2;
    })(), false === s2 && (t6 > 0 && v2(true), e2 > 0 && v2(false)), this.setIndex(c2), this.setAttribute("position", new Hl(h2, 3)), this.setAttribute("normal", new Hl(u2, 3)), this.setAttribute("uv", new Hl(d2, 2));
  }
  static fromJSON(t6) {
    return new _Qp(t6.radiusTop, t6.radiusBottom, t6.height, t6.radialSegments, t6.heightSegments, t6.openEnded, t6.thetaStart, t6.thetaLength);
  }
};
var tf = class _tf extends Qp {
  constructor(t6 = 1, e2 = 1, i2 = 8, n2 = 1, r2 = false, s2 = 0, o2 = 2 * Math.PI) {
    super(0, t6, e2, i2, n2, r2, s2, o2), this.type = "ConeGeometry", this.parameters = { radius: t6, height: e2, radialSegments: i2, heightSegments: n2, openEnded: r2, thetaStart: s2, thetaLength: o2 };
  }
  static fromJSON(t6) {
    return new _tf(t6.radius, t6.height, t6.radialSegments, t6.heightSegments, t6.openEnded, t6.thetaStart, t6.thetaLength);
  }
};
var ef = class _ef extends Jl {
  constructor(t6 = [], e2 = [], i2 = 1, n2 = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: t6, indices: e2, radius: i2, detail: n2 };
    const r2 = [], s2 = [];
    function o2(t7, e3, i3, n3) {
      const r3 = n3 + 1, s3 = [];
      for (let n4 = 0; n4 <= r3; n4++) {
        s3[n4] = [];
        const o3 = t7.clone().lerp(i3, n4 / r3), a3 = e3.clone().lerp(i3, n4 / r3), l3 = r3 - n4;
        for (let t8 = 0; t8 <= l3; t8++) s3[n4][t8] = 0 === t8 && n4 === r3 ? o3 : o3.clone().lerp(a3, t8 / l3);
      }
      for (let t8 = 0; t8 < r3; t8++) for (let e4 = 0; e4 < 2 * (r3 - t8) - 1; e4++) {
        const i4 = Math.floor(e4 / 2);
        e4 % 2 == 0 ? (a2(s3[t8][i4 + 1]), a2(s3[t8 + 1][i4]), a2(s3[t8][i4])) : (a2(s3[t8][i4 + 1]), a2(s3[t8 + 1][i4 + 1]), a2(s3[t8 + 1][i4]));
      }
    }
    function a2(t7) {
      r2.push(t7.x, t7.y, t7.z);
    }
    function l2(e3, i3) {
      const n3 = 3 * e3;
      i3.x = t6[n3 + 0], i3.y = t6[n3 + 1], i3.z = t6[n3 + 2];
    }
    function c2(t7, e3, i3, n3) {
      n3 < 0 && 1 === t7.x && (s2[e3] = t7.x - 1), 0 === i3.x && 0 === i3.z && (s2[e3] = n3 / 2 / Math.PI + 0.5);
    }
    function h2(t7) {
      return Math.atan2(t7.z, -t7.x);
    }
    !(function(t7) {
      const i3 = new pa(), n3 = new pa(), r3 = new pa();
      for (let s3 = 0; s3 < e2.length; s3 += 3) l2(e2[s3 + 0], i3), l2(e2[s3 + 1], n3), l2(e2[s3 + 2], r3), o2(i3, n3, r3, t7);
    })(n2), (function(t7) {
      const e3 = new pa();
      for (let i3 = 0; i3 < r2.length; i3 += 3) e3.x = r2[i3 + 0], e3.y = r2[i3 + 1], e3.z = r2[i3 + 2], e3.normalize().multiplyScalar(t7), r2[i3 + 0] = e3.x, r2[i3 + 1] = e3.y, r2[i3 + 2] = e3.z;
    })(i2), (function() {
      const t7 = new pa();
      for (let i3 = 0; i3 < r2.length; i3 += 3) {
        t7.x = r2[i3 + 0], t7.y = r2[i3 + 1], t7.z = r2[i3 + 2];
        const n3 = h2(t7) / 2 / Math.PI + 0.5, o3 = (e3 = t7, Math.atan2(-e3.y, Math.sqrt(e3.x * e3.x + e3.z * e3.z)) / Math.PI + 0.5);
        s2.push(n3, 1 - o3);
      }
      var e3;
      (function() {
        const t8 = new pa(), e4 = new pa(), i3 = new pa(), n3 = new pa(), o3 = new Fo(), a3 = new Fo(), l3 = new Fo();
        for (let u2 = 0, d2 = 0; u2 < r2.length; u2 += 9, d2 += 6) {
          t8.set(r2[u2 + 0], r2[u2 + 1], r2[u2 + 2]), e4.set(r2[u2 + 3], r2[u2 + 4], r2[u2 + 5]), i3.set(r2[u2 + 6], r2[u2 + 7], r2[u2 + 8]), o3.set(s2[d2 + 0], s2[d2 + 1]), a3.set(s2[d2 + 2], s2[d2 + 3]), l3.set(s2[d2 + 4], s2[d2 + 5]), n3.copy(t8).add(e4).add(i3).divideScalar(3);
          const p2 = h2(n3);
          c2(o3, d2 + 0, t8, p2), c2(a3, d2 + 2, e4, p2), c2(l3, d2 + 4, i3, p2);
        }
      })(), (function() {
        for (let t8 = 0; t8 < s2.length; t8 += 6) {
          const e4 = s2[t8 + 0], i3 = s2[t8 + 2], n3 = s2[t8 + 4], r3 = Math.max(e4, i3, n3), o3 = Math.min(e4, i3, n3);
          r3 > 0.9 && o3 < 0.1 && (e4 < 0.2 && (s2[t8 + 0] += 1), i3 < 0.2 && (s2[t8 + 2] += 1), n3 < 0.2 && (s2[t8 + 4] += 1));
        }
      })();
    })(), this.setAttribute("position", new Hl(r2, 3)), this.setAttribute("normal", new Hl(r2.slice(), 3)), this.setAttribute("uv", new Hl(s2, 2)), 0 === n2 ? this.computeVertexNormals() : this.normalizeNormals();
  }
  static fromJSON(t6) {
    return new _ef(t6.vertices, t6.indices, t6.radius, t6.details);
  }
};
var nf = class _nf extends ef {
  constructor(t6 = 1, e2 = 0) {
    const i2 = (1 + Math.sqrt(5)) / 2, n2 = 1 / i2;
    super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n2, -i2, 0, -n2, i2, 0, n2, -i2, 0, n2, i2, -n2, -i2, 0, -n2, i2, 0, n2, -i2, 0, n2, i2, 0, -i2, 0, -n2, i2, 0, -n2, -i2, 0, n2, i2, 0, n2], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t6, e2), this.type = "DodecahedronGeometry", this.parameters = { radius: t6, detail: e2 };
  }
  static fromJSON(t6) {
    return new _nf(t6.radius, t6.detail);
  }
};
var rf = new pa();
var sf = new pa();
var of = new pa();
var af = new El();
var lf = class extends Jl {
  constructor(t6 = null, e2 = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = { geometry: t6, thresholdAngle: e2 }, null !== t6) {
      const i2 = 4, n2 = Math.pow(10, i2), r2 = Math.cos(Eo * e2), s2 = t6.getIndex(), o2 = t6.getAttribute("position"), a2 = s2 ? s2.count : o2.count, l2 = [0, 0, 0], c2 = ["a", "b", "c"], h2 = new Array(3), u2 = {}, d2 = [];
      for (let t7 = 0; t7 < a2; t7 += 3) {
        s2 ? (l2[0] = s2.getX(t7), l2[1] = s2.getX(t7 + 1), l2[2] = s2.getX(t7 + 2)) : (l2[0] = t7, l2[1] = t7 + 1, l2[2] = t7 + 2);
        const { a: e3, b: i3, c: a3 } = af;
        if (e3.fromBufferAttribute(o2, l2[0]), i3.fromBufferAttribute(o2, l2[1]), a3.fromBufferAttribute(o2, l2[2]), af.getNormal(of), h2[0] = `${Math.round(e3.x * n2)},${Math.round(e3.y * n2)},${Math.round(e3.z * n2)}`, h2[1] = `${Math.round(i3.x * n2)},${Math.round(i3.y * n2)},${Math.round(i3.z * n2)}`, h2[2] = `${Math.round(a3.x * n2)},${Math.round(a3.y * n2)},${Math.round(a3.z * n2)}`, h2[0] !== h2[1] && h2[1] !== h2[2] && h2[2] !== h2[0]) for (let t8 = 0; t8 < 3; t8++) {
          const e4 = (t8 + 1) % 3, i4 = h2[t8], n3 = h2[e4], s3 = af[c2[t8]], o3 = af[c2[e4]], a4 = `${i4}_${n3}`, p2 = `${n3}_${i4}`;
          p2 in u2 && u2[p2] ? (of.dot(u2[p2].normal) <= r2 && (d2.push(s3.x, s3.y, s3.z), d2.push(o3.x, o3.y, o3.z)), u2[p2] = null) : a4 in u2 || (u2[a4] = { index0: l2[t8], index1: l2[e4], normal: of.clone() });
        }
      }
      for (const t7 in u2) if (u2[t7]) {
        const { index0: e3, index1: i3 } = u2[t7];
        rf.fromBufferAttribute(o2, e3), sf.fromBufferAttribute(o2, i3), d2.push(rf.x, rf.y, rf.z), d2.push(sf.x, sf.y, sf.z);
      }
      this.setAttribute("position", new Hl(d2, 3));
    }
  }
};
var cf = class extends Zp {
  constructor(t6) {
    super(t6), this.uuid = Co(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(t6) {
    const e2 = [];
    for (let i2 = 0, n2 = this.holes.length; i2 < n2; i2++) e2[i2] = this.holes[i2].getPoints(t6);
    return e2;
  }
  extractPoints(t6) {
    return { shape: this.getPoints(t6), holes: this.getPointsHoles(t6) };
  }
  copy(t6) {
    super.copy(t6), this.holes = [];
    for (let e2 = 0, i2 = t6.holes.length; e2 < i2; e2++) {
      const i3 = t6.holes[e2];
      this.holes.push(i3.clone());
    }
    return this;
  }
  toJSON() {
    const t6 = super.toJSON();
    t6.uuid = this.uuid, t6.holes = [];
    for (let e2 = 0, i2 = this.holes.length; e2 < i2; e2++) {
      const i3 = this.holes[e2];
      t6.holes.push(i3.toJSON());
    }
    return t6;
  }
  fromJSON(t6) {
    super.fromJSON(t6), this.uuid = t6.uuid, this.holes = [];
    for (let e2 = 0, i2 = t6.holes.length; e2 < i2; e2++) {
      const i3 = t6.holes[e2];
      this.holes.push(new Zp().fromJSON(i3));
    }
    return this;
  }
};
var hf = function(t6, e2, i2 = 2) {
  const n2 = e2 && e2.length, r2 = n2 ? e2[0] * i2 : t6.length;
  let s2 = uf(t6, 0, r2, i2, true);
  const o2 = [];
  if (!s2 || s2.next === s2.prev) return o2;
  let a2, l2, c2, h2, u2, d2, p2;
  if (n2 && (s2 = (function(t7, e3, i3, n3) {
    const r3 = [];
    let s3, o3, a3, l3, c3;
    for (s3 = 0, o3 = e3.length; s3 < o3; s3++) a3 = e3[s3] * n3, l3 = s3 < o3 - 1 ? e3[s3 + 1] * n3 : t7.length, c3 = uf(t7, a3, l3, n3, false), c3 === c3.next && (c3.steiner = true), r3.push(_f(c3));
    for (r3.sort(yf), s3 = 0; s3 < r3.length; s3++) xf(r3[s3], i3), i3 = df(i3, i3.next);
    return i3;
  })(t6, e2, s2, i2)), t6.length > 80 * i2) {
    a2 = c2 = t6[0], l2 = h2 = t6[1];
    for (let e3 = i2; e3 < r2; e3 += i2) u2 = t6[e3], d2 = t6[e3 + 1], u2 < a2 && (a2 = u2), d2 < l2 && (l2 = d2), u2 > c2 && (c2 = u2), d2 > h2 && (h2 = d2);
    p2 = Math.max(c2 - a2, h2 - l2), p2 = 0 !== p2 ? 1 / p2 : 0;
  }
  return pf(s2, o2, i2, a2, l2, p2), o2;
};
function uf(t6, e2, i2, n2, r2) {
  let s2, o2;
  if (r2 === (function(t7, e3, i3, n3) {
    let r3 = 0;
    for (let s3 = e3, o3 = i3 - n3; s3 < i3; s3 += n3) r3 += (t7[o3] - t7[s3]) * (t7[s3 + 1] + t7[o3 + 1]), o3 = s3;
    return r3;
  })(t6, e2, i2, n2) > 0) for (s2 = e2; s2 < i2; s2 += n2) o2 = If(s2, t6[s2], t6[s2 + 1], o2);
  else for (s2 = i2 - n2; s2 >= e2; s2 -= n2) o2 = If(s2, t6[s2], t6[s2 + 1], o2);
  return o2 && Ef(o2, o2.next) && (Df(o2), o2 = o2.next), o2;
}
function df(t6, e2) {
  if (!t6) return t6;
  e2 || (e2 = t6);
  let i2, n2 = t6;
  do {
    if (i2 = false, n2.steiner || !Ef(n2, n2.next) && 0 !== Tf(n2.prev, n2, n2.next)) n2 = n2.next;
    else {
      if (Df(n2), n2 = e2 = n2.prev, n2 === n2.next) break;
      i2 = true;
    }
  } while (i2 || n2 !== e2);
  return e2;
}
function pf(t6, e2, i2, n2, r2, s2, o2) {
  if (!t6) return;
  !o2 && s2 && (function(t7, e3, i3, n3) {
    let r3 = t7;
    do {
      null === r3.z && (r3.z = wf(r3.x, r3.y, e3, i3, n3)), r3.prevZ = r3.prev, r3.nextZ = r3.next, r3 = r3.next;
    } while (r3 !== t7);
    r3.prevZ.nextZ = null, r3.prevZ = null, (function(t8) {
      let e4, i4, n4, r4, s3, o3, a3, l3, c3 = 1;
      do {
        for (i4 = t8, t8 = null, s3 = null, o3 = 0; i4; ) {
          for (o3++, n4 = i4, a3 = 0, e4 = 0; e4 < c3 && (a3++, n4 = n4.nextZ, n4); e4++) ;
          for (l3 = c3; a3 > 0 || l3 > 0 && n4; ) 0 !== a3 && (0 === l3 || !n4 || i4.z <= n4.z) ? (r4 = i4, i4 = i4.nextZ, a3--) : (r4 = n4, n4 = n4.nextZ, l3--), s3 ? s3.nextZ = r4 : t8 = r4, r4.prevZ = s3, s3 = r4;
          i4 = n4;
        }
        s3.nextZ = null, c3 *= 2;
      } while (o3 > 1);
    })(r3);
  })(t6, n2, r2, s2);
  let a2, l2, c2 = t6;
  for (; t6.prev !== t6.next; ) if (a2 = t6.prev, l2 = t6.next, s2 ? mf(t6, n2, r2, s2) : ff(t6)) e2.push(a2.i / i2), e2.push(t6.i / i2), e2.push(l2.i / i2), Df(t6), t6 = l2.next, c2 = l2.next;
  else if ((t6 = l2) === c2) {
    o2 ? 1 === o2 ? pf(t6 = gf(df(t6), e2, i2), e2, i2, n2, r2, s2, 2) : 2 === o2 && vf(t6, e2, i2, n2, r2, s2) : pf(df(t6), e2, i2, n2, r2, s2, 1);
    break;
  }
}
function ff(t6) {
  const e2 = t6.prev, i2 = t6, n2 = t6.next;
  if (Tf(e2, i2, n2) >= 0) return false;
  let r2 = t6.next.next;
  for (; r2 !== t6.prev; ) {
    if (Sf(e2.x, e2.y, i2.x, i2.y, n2.x, n2.y, r2.x, r2.y) && Tf(r2.prev, r2, r2.next) >= 0) return false;
    r2 = r2.next;
  }
  return true;
}
function mf(t6, e2, i2, n2) {
  const r2 = t6.prev, s2 = t6, o2 = t6.next;
  if (Tf(r2, s2, o2) >= 0) return false;
  const a2 = r2.x < s2.x ? r2.x < o2.x ? r2.x : o2.x : s2.x < o2.x ? s2.x : o2.x, l2 = r2.y < s2.y ? r2.y < o2.y ? r2.y : o2.y : s2.y < o2.y ? s2.y : o2.y, c2 = r2.x > s2.x ? r2.x > o2.x ? r2.x : o2.x : s2.x > o2.x ? s2.x : o2.x, h2 = r2.y > s2.y ? r2.y > o2.y ? r2.y : o2.y : s2.y > o2.y ? s2.y : o2.y, u2 = wf(a2, l2, e2, i2, n2), d2 = wf(c2, h2, e2, i2, n2);
  let p2 = t6.prevZ, f2 = t6.nextZ;
  for (; p2 && p2.z >= u2 && f2 && f2.z <= d2; ) {
    if (p2 !== t6.prev && p2 !== t6.next && Sf(r2.x, r2.y, s2.x, s2.y, o2.x, o2.y, p2.x, p2.y) && Tf(p2.prev, p2, p2.next) >= 0) return false;
    if (p2 = p2.prevZ, f2 !== t6.prev && f2 !== t6.next && Sf(r2.x, r2.y, s2.x, s2.y, o2.x, o2.y, f2.x, f2.y) && Tf(f2.prev, f2, f2.next) >= 0) return false;
    f2 = f2.nextZ;
  }
  for (; p2 && p2.z >= u2; ) {
    if (p2 !== t6.prev && p2 !== t6.next && Sf(r2.x, r2.y, s2.x, s2.y, o2.x, o2.y, p2.x, p2.y) && Tf(p2.prev, p2, p2.next) >= 0) return false;
    p2 = p2.prevZ;
  }
  for (; f2 && f2.z <= d2; ) {
    if (f2 !== t6.prev && f2 !== t6.next && Sf(r2.x, r2.y, s2.x, s2.y, o2.x, o2.y, f2.x, f2.y) && Tf(f2.prev, f2, f2.next) >= 0) return false;
    f2 = f2.nextZ;
  }
  return true;
}
function gf(t6, e2, i2) {
  let n2 = t6;
  do {
    const r2 = n2.prev, s2 = n2.next.next;
    !Ef(r2, s2) && Af(r2, n2, n2.next, s2) && Pf(r2, s2) && Pf(s2, r2) && (e2.push(r2.i / i2), e2.push(n2.i / i2), e2.push(s2.i / i2), Df(n2), Df(n2.next), n2 = t6 = s2), n2 = n2.next;
  } while (n2 !== t6);
  return df(n2);
}
function vf(t6, e2, i2, n2, r2, s2) {
  let o2 = t6;
  do {
    let t7 = o2.next.next;
    for (; t7 !== o2.prev; ) {
      if (o2.i !== t7.i && Mf(o2, t7)) {
        let a2 = Lf(o2, t7);
        return o2 = df(o2, o2.next), a2 = df(a2, a2.next), pf(o2, e2, i2, n2, r2, s2), void pf(a2, e2, i2, n2, r2, s2);
      }
      t7 = t7.next;
    }
    o2 = o2.next;
  } while (o2 !== t6);
}
function yf(t6, e2) {
  return t6.x - e2.x;
}
function xf(t6, e2) {
  if (e2 = (function(t7, e3) {
    let i2 = e3;
    const n2 = t7.x, r2 = t7.y;
    let s2, o2 = -1 / 0;
    do {
      if (r2 <= i2.y && r2 >= i2.next.y && i2.next.y !== i2.y) {
        const t8 = i2.x + (r2 - i2.y) * (i2.next.x - i2.x) / (i2.next.y - i2.y);
        if (t8 <= n2 && t8 > o2) {
          if (o2 = t8, t8 === n2) {
            if (r2 === i2.y) return i2;
            if (r2 === i2.next.y) return i2.next;
          }
          s2 = i2.x < i2.next.x ? i2 : i2.next;
        }
      }
      i2 = i2.next;
    } while (i2 !== e3);
    if (!s2) return null;
    if (n2 === o2) return s2;
    const a2 = s2, l2 = s2.x, c2 = s2.y;
    let h2, u2 = 1 / 0;
    i2 = s2;
    do {
      n2 >= i2.x && i2.x >= l2 && n2 !== i2.x && Sf(r2 < c2 ? n2 : o2, r2, l2, c2, r2 < c2 ? o2 : n2, r2, i2.x, i2.y) && (h2 = Math.abs(r2 - i2.y) / (n2 - i2.x), Pf(i2, t7) && (h2 < u2 || h2 === u2 && (i2.x > s2.x || i2.x === s2.x && bf(s2, i2))) && (s2 = i2, u2 = h2)), i2 = i2.next;
    } while (i2 !== a2);
    return s2;
  })(t6, e2), e2) {
    const i2 = Lf(e2, t6);
    df(e2, e2.next), df(i2, i2.next);
  }
}
function bf(t6, e2) {
  return Tf(t6.prev, t6, e2.prev) < 0 && Tf(e2.next, t6, t6.next) < 0;
}
function wf(t6, e2, i2, n2, r2) {
  return (t6 = 1431655765 & ((t6 = 858993459 & ((t6 = 252645135 & ((t6 = 16711935 & ((t6 = 32767 * (t6 - i2) * r2) | t6 << 8)) | t6 << 4)) | t6 << 2)) | t6 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = 32767 * (e2 - n2) * r2) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
}
function _f(t6) {
  let e2 = t6, i2 = t6;
  do {
    (e2.x < i2.x || e2.x === i2.x && e2.y < i2.y) && (i2 = e2), e2 = e2.next;
  } while (e2 !== t6);
  return i2;
}
function Sf(t6, e2, i2, n2, r2, s2, o2, a2) {
  return (r2 - o2) * (e2 - a2) - (t6 - o2) * (s2 - a2) >= 0 && (t6 - o2) * (n2 - a2) - (i2 - o2) * (e2 - a2) >= 0 && (i2 - o2) * (s2 - a2) - (r2 - o2) * (n2 - a2) >= 0;
}
function Mf(t6, e2) {
  return t6.next.i !== e2.i && t6.prev.i !== e2.i && !(function(t7, e3) {
    let i2 = t7;
    do {
      if (i2.i !== t7.i && i2.next.i !== t7.i && i2.i !== e3.i && i2.next.i !== e3.i && Af(i2, i2.next, t7, e3)) return true;
      i2 = i2.next;
    } while (i2 !== t7);
    return false;
  })(t6, e2) && (Pf(t6, e2) && Pf(e2, t6) && (function(t7, e3) {
    let i2 = t7, n2 = false;
    const r2 = (t7.x + e3.x) / 2, s2 = (t7.y + e3.y) / 2;
    do {
      i2.y > s2 != i2.next.y > s2 && i2.next.y !== i2.y && r2 < (i2.next.x - i2.x) * (s2 - i2.y) / (i2.next.y - i2.y) + i2.x && (n2 = !n2), i2 = i2.next;
    } while (i2 !== t7);
    return n2;
  })(t6, e2) && (Tf(t6.prev, t6, e2.prev) || Tf(t6, e2.prev, e2)) || Ef(t6, e2) && Tf(t6.prev, t6, t6.next) > 0 && Tf(e2.prev, e2, e2.next) > 0);
}
function Tf(t6, e2, i2) {
  return (e2.y - t6.y) * (i2.x - e2.x) - (e2.x - t6.x) * (i2.y - e2.y);
}
function Ef(t6, e2) {
  return t6.x === e2.x && t6.y === e2.y;
}
function Af(t6, e2, i2, n2) {
  const r2 = Rf(Tf(t6, e2, i2)), s2 = Rf(Tf(t6, e2, n2)), o2 = Rf(Tf(i2, n2, t6)), a2 = Rf(Tf(i2, n2, e2));
  return r2 !== s2 && o2 !== a2 || (!(0 !== r2 || !Cf(t6, i2, e2)) || (!(0 !== s2 || !Cf(t6, n2, e2)) || (!(0 !== o2 || !Cf(i2, t6, n2)) || !(0 !== a2 || !Cf(i2, e2, n2)))));
}
function Cf(t6, e2, i2) {
  return e2.x <= Math.max(t6.x, i2.x) && e2.x >= Math.min(t6.x, i2.x) && e2.y <= Math.max(t6.y, i2.y) && e2.y >= Math.min(t6.y, i2.y);
}
function Rf(t6) {
  return t6 > 0 ? 1 : t6 < 0 ? -1 : 0;
}
function Pf(t6, e2) {
  return Tf(t6.prev, t6, t6.next) < 0 ? Tf(t6, e2, t6.next) >= 0 && Tf(t6, t6.prev, e2) >= 0 : Tf(t6, e2, t6.prev) < 0 || Tf(t6, t6.next, e2) < 0;
}
function Lf(t6, e2) {
  const i2 = new Of(t6.i, t6.x, t6.y), n2 = new Of(e2.i, e2.x, e2.y), r2 = t6.next, s2 = e2.prev;
  return t6.next = e2, e2.prev = t6, i2.next = r2, r2.prev = i2, n2.next = i2, i2.prev = n2, s2.next = n2, n2.prev = s2, n2;
}
function If(t6, e2, i2, n2) {
  const r2 = new Of(t6, e2, i2);
  return n2 ? (r2.next = n2.next, r2.prev = n2, n2.next.prev = r2, n2.next = r2) : (r2.prev = r2, r2.next = r2), r2;
}
function Df(t6) {
  t6.next.prev = t6.prev, t6.prev.next = t6.next, t6.prevZ && (t6.prevZ.nextZ = t6.nextZ), t6.nextZ && (t6.nextZ.prevZ = t6.prevZ);
}
function Of(t6, e2, i2) {
  this.i = t6, this.x = e2, this.y = i2, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
}
var zf = class _zf {
  static area(t6) {
    const e2 = t6.length;
    let i2 = 0;
    for (let n2 = e2 - 1, r2 = 0; r2 < e2; n2 = r2++) i2 += t6[n2].x * t6[r2].y - t6[r2].x * t6[n2].y;
    return 0.5 * i2;
  }
  static isClockWise(t6) {
    return _zf.area(t6) < 0;
  }
  static triangulateShape(t6, e2) {
    const i2 = [], n2 = [], r2 = [];
    Ff(t6), Nf(i2, t6);
    let s2 = t6.length;
    e2.forEach(Ff);
    for (let t7 = 0; t7 < e2.length; t7++) n2.push(s2), s2 += e2[t7].length, Nf(i2, e2[t7]);
    const o2 = hf(i2, n2);
    for (let t7 = 0; t7 < o2.length; t7 += 3) r2.push(o2.slice(t7, t7 + 3));
    return r2;
  }
};
function Ff(t6) {
  const e2 = t6.length;
  e2 > 2 && t6[e2 - 1].equals(t6[0]) && t6.pop();
}
function Nf(t6, e2) {
  for (let i2 = 0; i2 < e2.length; i2++) t6.push(e2[i2].x), t6.push(e2[i2].y);
}
var Bf = class _Bf extends Jl {
  constructor(t6 = new cf([new Fo(0.5, 0.5), new Fo(-0.5, 0.5), new Fo(-0.5, -0.5), new Fo(0.5, -0.5)]), e2 = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: t6, options: e2 }, t6 = Array.isArray(t6) ? t6 : [t6];
    const i2 = this, n2 = [], r2 = [];
    for (let e3 = 0, i3 = t6.length; e3 < i3; e3++) {
      s2(t6[e3]);
    }
    function s2(t7) {
      const s3 = [], o2 = void 0 !== e2.curveSegments ? e2.curveSegments : 12, a2 = void 0 !== e2.steps ? e2.steps : 1, l2 = void 0 !== e2.depth ? e2.depth : 1;
      let c2 = void 0 === e2.bevelEnabled || e2.bevelEnabled, h2 = void 0 !== e2.bevelThickness ? e2.bevelThickness : 0.2, u2 = void 0 !== e2.bevelSize ? e2.bevelSize : h2 - 0.1, d2 = void 0 !== e2.bevelOffset ? e2.bevelOffset : 0, p2 = void 0 !== e2.bevelSegments ? e2.bevelSegments : 3;
      const f2 = e2.extrudePath, m2 = void 0 !== e2.UVGenerator ? e2.UVGenerator : kf;
      let g2, v2, y2, x2, b2, w2 = false;
      f2 && (g2 = f2.getSpacedPoints(a2), w2 = true, c2 = false, v2 = f2.computeFrenetFrames(a2, false), y2 = new pa(), x2 = new pa(), b2 = new pa()), c2 || (p2 = 0, h2 = 0, u2 = 0, d2 = 0);
      const _2 = t7.extractPoints(o2);
      let S2 = _2.shape;
      const M2 = _2.holes;
      if (!zf.isClockWise(S2)) {
        S2 = S2.reverse();
        for (let t8 = 0, e3 = M2.length; t8 < e3; t8++) {
          const e4 = M2[t8];
          zf.isClockWise(e4) && (M2[t8] = e4.reverse());
        }
      }
      const T2 = zf.triangulateShape(S2, M2), E2 = S2;
      for (let t8 = 0, e3 = M2.length; t8 < e3; t8++) {
        const e4 = M2[t8];
        S2 = S2.concat(e4);
      }
      function A2(t8, e3, i3) {
        return e3 || console.error("THREE.ExtrudeGeometry: vec does not exist"), e3.clone().multiplyScalar(i3).add(t8);
      }
      const C2 = S2.length, R2 = T2.length;
      function P2(t8, e3, i3) {
        let n3, r3, s4;
        const o3 = t8.x - e3.x, a3 = t8.y - e3.y, l3 = i3.x - t8.x, c3 = i3.y - t8.y, h3 = o3 * o3 + a3 * a3, u3 = o3 * c3 - a3 * l3;
        if (Math.abs(u3) > Number.EPSILON) {
          const u4 = Math.sqrt(h3), d3 = Math.sqrt(l3 * l3 + c3 * c3), p3 = e3.x - a3 / u4, f3 = e3.y + o3 / u4, m3 = ((i3.x - c3 / d3 - p3) * c3 - (i3.y + l3 / d3 - f3) * l3) / (o3 * c3 - a3 * l3);
          n3 = p3 + o3 * m3 - t8.x, r3 = f3 + a3 * m3 - t8.y;
          const g3 = n3 * n3 + r3 * r3;
          if (g3 <= 2) return new Fo(n3, r3);
          s4 = Math.sqrt(g3 / 2);
        } else {
          let t9 = false;
          o3 > Number.EPSILON ? l3 > Number.EPSILON && (t9 = true) : o3 < -Number.EPSILON ? l3 < -Number.EPSILON && (t9 = true) : Math.sign(a3) === Math.sign(c3) && (t9 = true), t9 ? (n3 = -a3, r3 = o3, s4 = Math.sqrt(h3)) : (n3 = o3, r3 = a3, s4 = Math.sqrt(h3 / 2));
        }
        return new Fo(n3 / s4, r3 / s4);
      }
      const L2 = [];
      for (let t8 = 0, e3 = E2.length, i3 = e3 - 1, n3 = t8 + 1; t8 < e3; t8++, i3++, n3++) i3 === e3 && (i3 = 0), n3 === e3 && (n3 = 0), L2[t8] = P2(E2[t8], E2[i3], E2[n3]);
      const I2 = [];
      let D2, O2 = L2.concat();
      for (let t8 = 0, e3 = M2.length; t8 < e3; t8++) {
        const e4 = M2[t8];
        D2 = [];
        for (let t9 = 0, i3 = e4.length, n3 = i3 - 1, r3 = t9 + 1; t9 < i3; t9++, n3++, r3++) n3 === i3 && (n3 = 0), r3 === i3 && (r3 = 0), D2[t9] = P2(e4[t9], e4[n3], e4[r3]);
        I2.push(D2), O2 = O2.concat(D2);
      }
      for (let t8 = 0; t8 < p2; t8++) {
        const e3 = t8 / p2, i3 = h2 * Math.cos(e3 * Math.PI / 2), n3 = u2 * Math.sin(e3 * Math.PI / 2) + d2;
        for (let t9 = 0, e4 = E2.length; t9 < e4; t9++) {
          const e5 = A2(E2[t9], L2[t9], n3);
          N2(e5.x, e5.y, -i3);
        }
        for (let t9 = 0, e4 = M2.length; t9 < e4; t9++) {
          const e5 = M2[t9];
          D2 = I2[t9];
          for (let t10 = 0, r3 = e5.length; t10 < r3; t10++) {
            const r4 = A2(e5[t10], D2[t10], n3);
            N2(r4.x, r4.y, -i3);
          }
        }
      }
      const z2 = u2 + d2;
      for (let t8 = 0; t8 < C2; t8++) {
        const e3 = c2 ? A2(S2[t8], O2[t8], z2) : S2[t8];
        w2 ? (x2.copy(v2.normals[0]).multiplyScalar(e3.x), y2.copy(v2.binormals[0]).multiplyScalar(e3.y), b2.copy(g2[0]).add(x2).add(y2), N2(b2.x, b2.y, b2.z)) : N2(e3.x, e3.y, 0);
      }
      for (let t8 = 1; t8 <= a2; t8++) for (let e3 = 0; e3 < C2; e3++) {
        const i3 = c2 ? A2(S2[e3], O2[e3], z2) : S2[e3];
        w2 ? (x2.copy(v2.normals[t8]).multiplyScalar(i3.x), y2.copy(v2.binormals[t8]).multiplyScalar(i3.y), b2.copy(g2[t8]).add(x2).add(y2), N2(b2.x, b2.y, b2.z)) : N2(i3.x, i3.y, l2 / a2 * t8);
      }
      for (let t8 = p2 - 1; t8 >= 0; t8--) {
        const e3 = t8 / p2, i3 = h2 * Math.cos(e3 * Math.PI / 2), n3 = u2 * Math.sin(e3 * Math.PI / 2) + d2;
        for (let t9 = 0, e4 = E2.length; t9 < e4; t9++) {
          const e5 = A2(E2[t9], L2[t9], n3);
          N2(e5.x, e5.y, l2 + i3);
        }
        for (let t9 = 0, e4 = M2.length; t9 < e4; t9++) {
          const e5 = M2[t9];
          D2 = I2[t9];
          for (let t10 = 0, r3 = e5.length; t10 < r3; t10++) {
            const r4 = A2(e5[t10], D2[t10], n3);
            w2 ? N2(r4.x, r4.y + g2[a2 - 1].y, g2[a2 - 1].x + i3) : N2(r4.x, r4.y, l2 + i3);
          }
        }
      }
      function F2(t8, e3) {
        let i3 = t8.length;
        for (; --i3 >= 0; ) {
          const n3 = i3;
          let r3 = i3 - 1;
          r3 < 0 && (r3 = t8.length - 1);
          for (let t9 = 0, i4 = a2 + 2 * p2; t9 < i4; t9++) {
            const i5 = C2 * t9, s4 = C2 * (t9 + 1);
            k2(e3 + n3 + i5, e3 + r3 + i5, e3 + r3 + s4, e3 + n3 + s4);
          }
        }
      }
      function N2(t8, e3, i3) {
        s3.push(t8), s3.push(e3), s3.push(i3);
      }
      function B2(t8, e3, r3) {
        U2(t8), U2(e3), U2(r3);
        const s4 = n2.length / 3, o3 = m2.generateTopUV(i2, n2, s4 - 3, s4 - 2, s4 - 1);
        H2(o3[0]), H2(o3[1]), H2(o3[2]);
      }
      function k2(t8, e3, r3, s4) {
        U2(t8), U2(e3), U2(s4), U2(e3), U2(r3), U2(s4);
        const o3 = n2.length / 3, a3 = m2.generateSideWallUV(i2, n2, o3 - 6, o3 - 3, o3 - 2, o3 - 1);
        H2(a3[0]), H2(a3[1]), H2(a3[3]), H2(a3[1]), H2(a3[2]), H2(a3[3]);
      }
      function U2(t8) {
        n2.push(s3[3 * t8 + 0]), n2.push(s3[3 * t8 + 1]), n2.push(s3[3 * t8 + 2]);
      }
      function H2(t8) {
        r2.push(t8.x), r2.push(t8.y);
      }
      !(function() {
        const t8 = n2.length / 3;
        if (c2) {
          let t9 = 0, e3 = C2 * t9;
          for (let t10 = 0; t10 < R2; t10++) {
            const i3 = T2[t10];
            B2(i3[2] + e3, i3[1] + e3, i3[0] + e3);
          }
          t9 = a2 + 2 * p2, e3 = C2 * t9;
          for (let t10 = 0; t10 < R2; t10++) {
            const i3 = T2[t10];
            B2(i3[0] + e3, i3[1] + e3, i3[2] + e3);
          }
        } else {
          for (let t9 = 0; t9 < R2; t9++) {
            const e3 = T2[t9];
            B2(e3[2], e3[1], e3[0]);
          }
          for (let t9 = 0; t9 < R2; t9++) {
            const e3 = T2[t9];
            B2(e3[0] + C2 * a2, e3[1] + C2 * a2, e3[2] + C2 * a2);
          }
        }
        i2.addGroup(t8, n2.length / 3 - t8, 0);
      })(), (function() {
        const t8 = n2.length / 3;
        let e3 = 0;
        F2(E2, e3), e3 += E2.length;
        for (let t9 = 0, i3 = M2.length; t9 < i3; t9++) {
          const i4 = M2[t9];
          F2(i4, e3), e3 += i4.length;
        }
        i2.addGroup(t8, n2.length / 3 - t8, 1);
      })();
    }
    this.setAttribute("position", new Hl(n2, 3)), this.setAttribute("uv", new Hl(r2, 2)), this.computeVertexNormals();
  }
  toJSON() {
    const t6 = super.toJSON();
    return (function(t7, e2, i2) {
      if (i2.shapes = [], Array.isArray(t7)) for (let e3 = 0, n2 = t7.length; e3 < n2; e3++) {
        const n3 = t7[e3];
        i2.shapes.push(n3.uuid);
      }
      else i2.shapes.push(t7.uuid);
      i2.options = Object.assign({}, e2), void 0 !== e2.extrudePath && (i2.options.extrudePath = e2.extrudePath.toJSON());
      return i2;
    })(this.parameters.shapes, this.parameters.options, t6);
  }
  static fromJSON(t6, e2) {
    const i2 = [];
    for (let n3 = 0, r2 = t6.shapes.length; n3 < r2; n3++) {
      const r3 = e2[t6.shapes[n3]];
      i2.push(r3);
    }
    const n2 = t6.options.extrudePath;
    return void 0 !== n2 && (t6.options.extrudePath = new Xp[n2.type]().fromJSON(n2)), new _Bf(i2, t6.options);
  }
};
var kf = { generateTopUV: function(t6, e2, i2, n2, r2) {
  const s2 = e2[3 * i2], o2 = e2[3 * i2 + 1], a2 = e2[3 * n2], l2 = e2[3 * n2 + 1], c2 = e2[3 * r2], h2 = e2[3 * r2 + 1];
  return [new Fo(s2, o2), new Fo(a2, l2), new Fo(c2, h2)];
}, generateSideWallUV: function(t6, e2, i2, n2, r2, s2) {
  const o2 = e2[3 * i2], a2 = e2[3 * i2 + 1], l2 = e2[3 * i2 + 2], c2 = e2[3 * n2], h2 = e2[3 * n2 + 1], u2 = e2[3 * n2 + 2], d2 = e2[3 * r2], p2 = e2[3 * r2 + 1], f2 = e2[3 * r2 + 2], m2 = e2[3 * s2], g2 = e2[3 * s2 + 1], v2 = e2[3 * s2 + 2];
  return Math.abs(a2 - h2) < Math.abs(o2 - c2) ? [new Fo(o2, 1 - l2), new Fo(c2, 1 - u2), new Fo(d2, 1 - f2), new Fo(m2, 1 - v2)] : [new Fo(a2, 1 - l2), new Fo(h2, 1 - u2), new Fo(p2, 1 - f2), new Fo(g2, 1 - v2)];
} };
var Uf = class _Uf extends ef {
  constructor(t6 = 1, e2 = 0) {
    const i2 = (1 + Math.sqrt(5)) / 2;
    super([-1, i2, 0, 1, i2, 0, -1, -i2, 0, 1, -i2, 0, 0, -1, i2, 0, 1, i2, 0, -1, -i2, 0, 1, -i2, i2, 0, -1, i2, 0, 1, -i2, 0, -1, -i2, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t6, e2), this.type = "IcosahedronGeometry", this.parameters = { radius: t6, detail: e2 };
  }
  static fromJSON(t6) {
    return new _Uf(t6.radius, t6.detail);
  }
};
var Hf = class _Hf extends ef {
  constructor(t6 = 1, e2 = 0) {
    super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t6, e2), this.type = "OctahedronGeometry", this.parameters = { radius: t6, detail: e2 };
  }
  static fromJSON(t6) {
    return new _Hf(t6.radius, t6.detail);
  }
};
var Vf = class _Vf extends Jl {
  constructor(t6 = 0.5, e2 = 1, i2 = 8, n2 = 1, r2 = 0, s2 = 2 * Math.PI) {
    super(), this.type = "RingGeometry", this.parameters = { innerRadius: t6, outerRadius: e2, thetaSegments: i2, phiSegments: n2, thetaStart: r2, thetaLength: s2 }, i2 = Math.max(3, i2);
    const o2 = [], a2 = [], l2 = [], c2 = [];
    let h2 = t6;
    const u2 = (e2 - t6) / (n2 = Math.max(1, n2)), d2 = new pa(), p2 = new Fo();
    for (let t7 = 0; t7 <= n2; t7++) {
      for (let t8 = 0; t8 <= i2; t8++) {
        const n3 = r2 + t8 / i2 * s2;
        d2.x = h2 * Math.cos(n3), d2.y = h2 * Math.sin(n3), a2.push(d2.x, d2.y, d2.z), l2.push(0, 0, 1), p2.x = (d2.x / e2 + 1) / 2, p2.y = (d2.y / e2 + 1) / 2, c2.push(p2.x, p2.y);
      }
      h2 += u2;
    }
    for (let t7 = 0; t7 < n2; t7++) {
      const e3 = t7 * (i2 + 1);
      for (let t8 = 0; t8 < i2; t8++) {
        const n3 = t8 + e3, r3 = n3, s3 = n3 + i2 + 1, a3 = n3 + i2 + 2, l3 = n3 + 1;
        o2.push(r3, s3, l3), o2.push(s3, a3, l3);
      }
    }
    this.setIndex(o2), this.setAttribute("position", new Hl(a2, 3)), this.setAttribute("normal", new Hl(l2, 3)), this.setAttribute("uv", new Hl(c2, 2));
  }
  static fromJSON(t6) {
    return new _Vf(t6.innerRadius, t6.outerRadius, t6.thetaSegments, t6.phiSegments, t6.thetaStart, t6.thetaLength);
  }
};
var jf = class _jf extends Jl {
  constructor(t6 = new cf([new Fo(0, 0.5), new Fo(-0.5, -0.5), new Fo(0.5, -0.5)]), e2 = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = { shapes: t6, curveSegments: e2 };
    const i2 = [], n2 = [], r2 = [], s2 = [];
    let o2 = 0, a2 = 0;
    if (false === Array.isArray(t6)) l2(t6);
    else for (let e3 = 0; e3 < t6.length; e3++) l2(t6[e3]), this.addGroup(o2, a2, e3), o2 += a2, a2 = 0;
    function l2(t7) {
      const o3 = n2.length / 3, l3 = t7.extractPoints(e2);
      let c2 = l3.shape;
      const h2 = l3.holes;
      false === zf.isClockWise(c2) && (c2 = c2.reverse());
      for (let t8 = 0, e3 = h2.length; t8 < e3; t8++) {
        const e4 = h2[t8];
        true === zf.isClockWise(e4) && (h2[t8] = e4.reverse());
      }
      const u2 = zf.triangulateShape(c2, h2);
      for (let t8 = 0, e3 = h2.length; t8 < e3; t8++) {
        const e4 = h2[t8];
        c2 = c2.concat(e4);
      }
      for (let t8 = 0, e3 = c2.length; t8 < e3; t8++) {
        const e4 = c2[t8];
        n2.push(e4.x, e4.y, 0), r2.push(0, 0, 1), s2.push(e4.x, e4.y);
      }
      for (let t8 = 0, e3 = u2.length; t8 < e3; t8++) {
        const e4 = u2[t8], n3 = e4[0] + o3, r3 = e4[1] + o3, s3 = e4[2] + o3;
        i2.push(n3, r3, s3), a2 += 3;
      }
    }
    this.setIndex(i2), this.setAttribute("position", new Hl(n2, 3)), this.setAttribute("normal", new Hl(r2, 3)), this.setAttribute("uv", new Hl(s2, 2));
  }
  toJSON() {
    const t6 = super.toJSON();
    return (function(t7, e2) {
      if (e2.shapes = [], Array.isArray(t7)) for (let i2 = 0, n2 = t7.length; i2 < n2; i2++) {
        const n3 = t7[i2];
        e2.shapes.push(n3.uuid);
      }
      else e2.shapes.push(t7.uuid);
      return e2;
    })(this.parameters.shapes, t6);
  }
  static fromJSON(t6, e2) {
    const i2 = [];
    for (let n2 = 0, r2 = t6.shapes.length; n2 < r2; n2++) {
      const r3 = e2[t6.shapes[n2]];
      i2.push(r3);
    }
    return new _jf(i2, t6.curveSegments);
  }
};
var Gf = class _Gf extends Jl {
  constructor(t6 = 1, e2 = 32, i2 = 16, n2 = 0, r2 = 2 * Math.PI, s2 = 0, o2 = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = { radius: t6, widthSegments: e2, heightSegments: i2, phiStart: n2, phiLength: r2, thetaStart: s2, thetaLength: o2 }, e2 = Math.max(3, Math.floor(e2)), i2 = Math.max(2, Math.floor(i2));
    const a2 = Math.min(s2 + o2, Math.PI);
    let l2 = 0;
    const c2 = [], h2 = new pa(), u2 = new pa(), d2 = [], p2 = [], f2 = [], m2 = [];
    for (let d3 = 0; d3 <= i2; d3++) {
      const g2 = [], v2 = d3 / i2;
      let y2 = 0;
      0 == d3 && 0 == s2 ? y2 = 0.5 / e2 : d3 == i2 && a2 == Math.PI && (y2 = -0.5 / e2);
      for (let i3 = 0; i3 <= e2; i3++) {
        const a3 = i3 / e2;
        h2.x = -t6 * Math.cos(n2 + a3 * r2) * Math.sin(s2 + v2 * o2), h2.y = t6 * Math.cos(s2 + v2 * o2), h2.z = t6 * Math.sin(n2 + a3 * r2) * Math.sin(s2 + v2 * o2), p2.push(h2.x, h2.y, h2.z), u2.copy(h2).normalize(), f2.push(u2.x, u2.y, u2.z), m2.push(a3 + y2, 1 - v2), g2.push(l2++);
      }
      c2.push(g2);
    }
    for (let t7 = 0; t7 < i2; t7++) for (let n3 = 0; n3 < e2; n3++) {
      const e3 = c2[t7][n3 + 1], r3 = c2[t7][n3], o3 = c2[t7 + 1][n3], l3 = c2[t7 + 1][n3 + 1];
      (0 !== t7 || s2 > 0) && d2.push(e3, r3, l3), (t7 !== i2 - 1 || a2 < Math.PI) && d2.push(r3, o3, l3);
    }
    this.setIndex(d2), this.setAttribute("position", new Hl(p2, 3)), this.setAttribute("normal", new Hl(f2, 3)), this.setAttribute("uv", new Hl(m2, 2));
  }
  static fromJSON(t6) {
    return new _Gf(t6.radius, t6.widthSegments, t6.heightSegments, t6.phiStart, t6.phiLength, t6.thetaStart, t6.thetaLength);
  }
};
var Wf = class _Wf extends ef {
  constructor(t6 = 1, e2 = 0) {
    super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t6, e2), this.type = "TetrahedronGeometry", this.parameters = { radius: t6, detail: e2 };
  }
  static fromJSON(t6) {
    return new _Wf(t6.radius, t6.detail);
  }
};
var qf = class _qf extends Jl {
  constructor(t6 = 1, e2 = 0.4, i2 = 8, n2 = 6, r2 = 2 * Math.PI) {
    super(), this.type = "TorusGeometry", this.parameters = { radius: t6, tube: e2, radialSegments: i2, tubularSegments: n2, arc: r2 }, i2 = Math.floor(i2), n2 = Math.floor(n2);
    const s2 = [], o2 = [], a2 = [], l2 = [], c2 = new pa(), h2 = new pa(), u2 = new pa();
    for (let s3 = 0; s3 <= i2; s3++) for (let d2 = 0; d2 <= n2; d2++) {
      const p2 = d2 / n2 * r2, f2 = s3 / i2 * Math.PI * 2;
      h2.x = (t6 + e2 * Math.cos(f2)) * Math.cos(p2), h2.y = (t6 + e2 * Math.cos(f2)) * Math.sin(p2), h2.z = e2 * Math.sin(f2), o2.push(h2.x, h2.y, h2.z), c2.x = t6 * Math.cos(p2), c2.y = t6 * Math.sin(p2), u2.subVectors(h2, c2).normalize(), a2.push(u2.x, u2.y, u2.z), l2.push(d2 / n2), l2.push(s3 / i2);
    }
    for (let t7 = 1; t7 <= i2; t7++) for (let e3 = 1; e3 <= n2; e3++) {
      const i3 = (n2 + 1) * t7 + e3 - 1, r3 = (n2 + 1) * (t7 - 1) + e3 - 1, o3 = (n2 + 1) * (t7 - 1) + e3, a3 = (n2 + 1) * t7 + e3;
      s2.push(i3, r3, a3), s2.push(r3, o3, a3);
    }
    this.setIndex(s2), this.setAttribute("position", new Hl(o2, 3)), this.setAttribute("normal", new Hl(a2, 3)), this.setAttribute("uv", new Hl(l2, 2));
  }
  static fromJSON(t6) {
    return new _qf(t6.radius, t6.tube, t6.radialSegments, t6.tubularSegments, t6.arc);
  }
};
var Xf = class _Xf extends Jl {
  constructor(t6 = 1, e2 = 0.4, i2 = 64, n2 = 8, r2 = 2, s2 = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = { radius: t6, tube: e2, tubularSegments: i2, radialSegments: n2, p: r2, q: s2 }, i2 = Math.floor(i2), n2 = Math.floor(n2);
    const o2 = [], a2 = [], l2 = [], c2 = [], h2 = new pa(), u2 = new pa(), d2 = new pa(), p2 = new pa(), f2 = new pa(), m2 = new pa(), g2 = new pa();
    for (let o3 = 0; o3 <= i2; ++o3) {
      const y2 = o3 / i2 * r2 * Math.PI * 2;
      v2(y2, r2, s2, t6, d2), v2(y2 + 0.01, r2, s2, t6, p2), m2.subVectors(p2, d2), g2.addVectors(p2, d2), f2.crossVectors(m2, g2), g2.crossVectors(f2, m2), f2.normalize(), g2.normalize();
      for (let t7 = 0; t7 <= n2; ++t7) {
        const r3 = t7 / n2 * Math.PI * 2, s3 = -e2 * Math.cos(r3), p3 = e2 * Math.sin(r3);
        h2.x = d2.x + (s3 * g2.x + p3 * f2.x), h2.y = d2.y + (s3 * g2.y + p3 * f2.y), h2.z = d2.z + (s3 * g2.z + p3 * f2.z), a2.push(h2.x, h2.y, h2.z), u2.subVectors(h2, d2).normalize(), l2.push(u2.x, u2.y, u2.z), c2.push(o3 / i2), c2.push(t7 / n2);
      }
    }
    for (let t7 = 1; t7 <= i2; t7++) for (let e3 = 1; e3 <= n2; e3++) {
      const i3 = (n2 + 1) * (t7 - 1) + (e3 - 1), r3 = (n2 + 1) * t7 + (e3 - 1), s3 = (n2 + 1) * t7 + e3, a3 = (n2 + 1) * (t7 - 1) + e3;
      o2.push(i3, r3, a3), o2.push(r3, s3, a3);
    }
    function v2(t7, e3, i3, n3, r3) {
      const s3 = Math.cos(t7), o3 = Math.sin(t7), a3 = i3 / e3 * t7, l3 = Math.cos(a3);
      r3.x = n3 * (2 + l3) * 0.5 * s3, r3.y = n3 * (2 + l3) * o3 * 0.5, r3.z = n3 * Math.sin(a3) * 0.5;
    }
    this.setIndex(o2), this.setAttribute("position", new Hl(a2, 3)), this.setAttribute("normal", new Hl(l2, 3)), this.setAttribute("uv", new Hl(c2, 2));
  }
  static fromJSON(t6) {
    return new _Xf(t6.radius, t6.tube, t6.tubularSegments, t6.radialSegments, t6.p, t6.q);
  }
};
var Yf = class _Yf extends Jl {
  constructor(t6 = new Wp(new pa(-1, -1, 0), new pa(-1, 1, 0), new pa(1, 1, 0)), e2 = 64, i2 = 1, n2 = 8, r2 = false) {
    super(), this.type = "TubeGeometry", this.parameters = { path: t6, tubularSegments: e2, radius: i2, radialSegments: n2, closed: r2 };
    const s2 = t6.computeFrenetFrames(e2, r2);
    this.tangents = s2.tangents, this.normals = s2.normals, this.binormals = s2.binormals;
    const o2 = new pa(), a2 = new pa(), l2 = new Fo();
    let c2 = new pa();
    const h2 = [], u2 = [], d2 = [], p2 = [];
    function f2(r3) {
      c2 = t6.getPointAt(r3 / e2, c2);
      const l3 = s2.normals[r3], d3 = s2.binormals[r3];
      for (let t7 = 0; t7 <= n2; t7++) {
        const e3 = t7 / n2 * Math.PI * 2, r4 = Math.sin(e3), s3 = -Math.cos(e3);
        a2.x = s3 * l3.x + r4 * d3.x, a2.y = s3 * l3.y + r4 * d3.y, a2.z = s3 * l3.z + r4 * d3.z, a2.normalize(), u2.push(a2.x, a2.y, a2.z), o2.x = c2.x + i2 * a2.x, o2.y = c2.y + i2 * a2.y, o2.z = c2.z + i2 * a2.z, h2.push(o2.x, o2.y, o2.z);
      }
    }
    !(function() {
      for (let t7 = 0; t7 < e2; t7++) f2(t7);
      f2(false === r2 ? e2 : 0), (function() {
        for (let t7 = 0; t7 <= e2; t7++) for (let i3 = 0; i3 <= n2; i3++) l2.x = t7 / e2, l2.y = i3 / n2, d2.push(l2.x, l2.y);
      })(), (function() {
        for (let t7 = 1; t7 <= e2; t7++) for (let e3 = 1; e3 <= n2; e3++) {
          const i3 = (n2 + 1) * (t7 - 1) + (e3 - 1), r3 = (n2 + 1) * t7 + (e3 - 1), s3 = (n2 + 1) * t7 + e3, o3 = (n2 + 1) * (t7 - 1) + e3;
          p2.push(i3, r3, o3), p2.push(r3, s3, o3);
        }
      })();
    })(), this.setIndex(p2), this.setAttribute("position", new Hl(h2, 3)), this.setAttribute("normal", new Hl(u2, 3)), this.setAttribute("uv", new Hl(d2, 2));
  }
  toJSON() {
    const t6 = super.toJSON();
    return t6.path = this.parameters.path.toJSON(), t6;
  }
  static fromJSON(t6) {
    return new _Yf(new Xp[t6.path.type]().fromJSON(t6.path), t6.tubularSegments, t6.radius, t6.radialSegments, t6.closed);
  }
};
var Zf = class extends Jl {
  constructor(t6 = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = { geometry: t6 }, null !== t6) {
      const e2 = [], i2 = /* @__PURE__ */ new Set(), n2 = new pa(), r2 = new pa();
      if (null !== t6.index) {
        const s2 = t6.attributes.position, o2 = t6.index;
        let a2 = t6.groups;
        0 === a2.length && (a2 = [{ start: 0, count: o2.count, materialIndex: 0 }]);
        for (let t7 = 0, l2 = a2.length; t7 < l2; ++t7) {
          const l3 = a2[t7], c2 = l3.start;
          for (let t8 = c2, a3 = c2 + l3.count; t8 < a3; t8 += 3) for (let a4 = 0; a4 < 3; a4++) {
            const l4 = o2.getX(t8 + a4), c3 = o2.getX(t8 + (a4 + 1) % 3);
            n2.fromBufferAttribute(s2, l4), r2.fromBufferAttribute(s2, c3), true === Jf(n2, r2, i2) && (e2.push(n2.x, n2.y, n2.z), e2.push(r2.x, r2.y, r2.z));
          }
        }
      } else {
        const s2 = t6.attributes.position;
        for (let t7 = 0, o2 = s2.count / 3; t7 < o2; t7++) for (let o3 = 0; o3 < 3; o3++) {
          const a2 = 3 * t7 + o3, l2 = 3 * t7 + (o3 + 1) % 3;
          n2.fromBufferAttribute(s2, a2), r2.fromBufferAttribute(s2, l2), true === Jf(n2, r2, i2) && (e2.push(n2.x, n2.y, n2.z), e2.push(r2.x, r2.y, r2.z));
        }
      }
      this.setAttribute("position", new Hl(e2, 3));
    }
  }
};
function Jf(t6, e2, i2) {
  const n2 = `${t6.x},${t6.y},${t6.z}-${e2.x},${e2.y},${e2.z}`, r2 = `${e2.x},${e2.y},${e2.z}-${t6.x},${t6.y},${t6.z}`;
  return true !== i2.has(n2) && true !== i2.has(r2) && (i2.add(n2), i2.add(r2), true);
}
var Kf = Object.freeze({ __proto__: null, BoxGeometry: gc, BoxBufferGeometry: gc, CapsuleGeometry: Kp, CapsuleBufferGeometry: Kp, CircleGeometry: $p, CircleBufferGeometry: $p, ConeGeometry: tf, ConeBufferGeometry: tf, CylinderGeometry: Qp, CylinderBufferGeometry: Qp, DodecahedronGeometry: nf, DodecahedronBufferGeometry: nf, EdgesGeometry: lf, ExtrudeGeometry: Bf, ExtrudeBufferGeometry: Bf, IcosahedronGeometry: Uf, IcosahedronBufferGeometry: Uf, LatheGeometry: Jp, LatheBufferGeometry: Jp, OctahedronGeometry: Hf, OctahedronBufferGeometry: Hf, PlaneGeometry: Fc, PlaneBufferGeometry: Fc, PolyhedronGeometry: ef, PolyhedronBufferGeometry: ef, RingGeometry: Vf, RingBufferGeometry: Vf, ShapeGeometry: jf, ShapeBufferGeometry: jf, SphereGeometry: Gf, SphereBufferGeometry: Gf, TetrahedronGeometry: Wf, TetrahedronBufferGeometry: Wf, TorusGeometry: qf, TorusBufferGeometry: qf, TorusKnotGeometry: Xf, TorusKnotBufferGeometry: Xf, TubeGeometry: Yf, TubeBufferGeometry: Yf, WireframeGeometry: Zf });
var $f = class extends Cl {
  constructor(t6) {
    super(), this.isShadowMaterial = true, this.type = "ShadowMaterial", this.color = new $o(0), this.transparent = true, this.fog = true, this.setValues(t6);
  }
  copy(t6) {
    return super.copy(t6), this.color.copy(t6.color), this.fog = t6.fog, this;
  }
};
var Qf = class extends bc {
  constructor(t6) {
    super(t6), this.isRawShaderMaterial = true, this.type = "RawShaderMaterial";
  }
};
var tm = class extends Cl {
  constructor(t6) {
    super(), this.isMeshStandardMaterial = true, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new $o(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new $o(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Vs, this.normalScale = new Fo(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(t6);
  }
  copy(t6) {
    return super.copy(t6), this.defines = { STANDARD: "" }, this.color.copy(t6.color), this.roughness = t6.roughness, this.metalness = t6.metalness, this.map = t6.map, this.lightMap = t6.lightMap, this.lightMapIntensity = t6.lightMapIntensity, this.aoMap = t6.aoMap, this.aoMapIntensity = t6.aoMapIntensity, this.emissive.copy(t6.emissive), this.emissiveMap = t6.emissiveMap, this.emissiveIntensity = t6.emissiveIntensity, this.bumpMap = t6.bumpMap, this.bumpScale = t6.bumpScale, this.normalMap = t6.normalMap, this.normalMapType = t6.normalMapType, this.normalScale.copy(t6.normalScale), this.displacementMap = t6.displacementMap, this.displacementScale = t6.displacementScale, this.displacementBias = t6.displacementBias, this.roughnessMap = t6.roughnessMap, this.metalnessMap = t6.metalnessMap, this.alphaMap = t6.alphaMap, this.envMap = t6.envMap, this.envMapIntensity = t6.envMapIntensity, this.wireframe = t6.wireframe, this.wireframeLinewidth = t6.wireframeLinewidth, this.wireframeLinecap = t6.wireframeLinecap, this.wireframeLinejoin = t6.wireframeLinejoin, this.flatShading = t6.flatShading, this.fog = t6.fog, this;
  }
};
var em = class extends tm {
  constructor(t6) {
    super(), this.isMeshPhysicalMaterial = true, this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Fo(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function() {
      return Ro(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
    }, set: function(t7) {
      this.ior = (1 + 0.4 * t7) / (1 - 0.4 * t7);
    } }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new $o(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new $o(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new $o(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._iridescence = 0, this._transmission = 0, this.setValues(t6);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(t6) {
    this._sheen > 0 != t6 > 0 && this.version++, this._sheen = t6;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(t6) {
    this._clearcoat > 0 != t6 > 0 && this.version++, this._clearcoat = t6;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(t6) {
    this._iridescence > 0 != t6 > 0 && this.version++, this._iridescence = t6;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(t6) {
    this._transmission > 0 != t6 > 0 && this.version++, this._transmission = t6;
  }
  copy(t6) {
    return super.copy(t6), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = t6.clearcoat, this.clearcoatMap = t6.clearcoatMap, this.clearcoatRoughness = t6.clearcoatRoughness, this.clearcoatRoughnessMap = t6.clearcoatRoughnessMap, this.clearcoatNormalMap = t6.clearcoatNormalMap, this.clearcoatNormalScale.copy(t6.clearcoatNormalScale), this.ior = t6.ior, this.iridescence = t6.iridescence, this.iridescenceMap = t6.iridescenceMap, this.iridescenceIOR = t6.iridescenceIOR, this.iridescenceThicknessRange = [...t6.iridescenceThicknessRange], this.iridescenceThicknessMap = t6.iridescenceThicknessMap, this.sheen = t6.sheen, this.sheenColor.copy(t6.sheenColor), this.sheenColorMap = t6.sheenColorMap, this.sheenRoughness = t6.sheenRoughness, this.sheenRoughnessMap = t6.sheenRoughnessMap, this.transmission = t6.transmission, this.transmissionMap = t6.transmissionMap, this.thickness = t6.thickness, this.thicknessMap = t6.thicknessMap, this.attenuationDistance = t6.attenuationDistance, this.attenuationColor.copy(t6.attenuationColor), this.specularIntensity = t6.specularIntensity, this.specularIntensityMap = t6.specularIntensityMap, this.specularColor.copy(t6.specularColor), this.specularColorMap = t6.specularColorMap, this;
  }
};
var im = class extends Cl {
  constructor(t6) {
    super(), this.isMeshPhongMaterial = true, this.type = "MeshPhongMaterial", this.color = new $o(16777215), this.specular = new $o(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new $o(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Vs, this.normalScale = new Fo(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = er, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(t6);
  }
  copy(t6) {
    return super.copy(t6), this.color.copy(t6.color), this.specular.copy(t6.specular), this.shininess = t6.shininess, this.map = t6.map, this.lightMap = t6.lightMap, this.lightMapIntensity = t6.lightMapIntensity, this.aoMap = t6.aoMap, this.aoMapIntensity = t6.aoMapIntensity, this.emissive.copy(t6.emissive), this.emissiveMap = t6.emissiveMap, this.emissiveIntensity = t6.emissiveIntensity, this.bumpMap = t6.bumpMap, this.bumpScale = t6.bumpScale, this.normalMap = t6.normalMap, this.normalMapType = t6.normalMapType, this.normalScale.copy(t6.normalScale), this.displacementMap = t6.displacementMap, this.displacementScale = t6.displacementScale, this.displacementBias = t6.displacementBias, this.specularMap = t6.specularMap, this.alphaMap = t6.alphaMap, this.envMap = t6.envMap, this.combine = t6.combine, this.reflectivity = t6.reflectivity, this.refractionRatio = t6.refractionRatio, this.wireframe = t6.wireframe, this.wireframeLinewidth = t6.wireframeLinewidth, this.wireframeLinecap = t6.wireframeLinecap, this.wireframeLinejoin = t6.wireframeLinejoin, this.flatShading = t6.flatShading, this.fog = t6.fog, this;
  }
};
var nm = class extends Cl {
  constructor(t6) {
    super(), this.isMeshToonMaterial = true, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new $o(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new $o(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Vs, this.normalScale = new Fo(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(t6);
  }
  copy(t6) {
    return super.copy(t6), this.color.copy(t6.color), this.map = t6.map, this.gradientMap = t6.gradientMap, this.lightMap = t6.lightMap, this.lightMapIntensity = t6.lightMapIntensity, this.aoMap = t6.aoMap, this.aoMapIntensity = t6.aoMapIntensity, this.emissive.copy(t6.emissive), this.emissiveMap = t6.emissiveMap, this.emissiveIntensity = t6.emissiveIntensity, this.bumpMap = t6.bumpMap, this.bumpScale = t6.bumpScale, this.normalMap = t6.normalMap, this.normalMapType = t6.normalMapType, this.normalScale.copy(t6.normalScale), this.displacementMap = t6.displacementMap, this.displacementScale = t6.displacementScale, this.displacementBias = t6.displacementBias, this.alphaMap = t6.alphaMap, this.wireframe = t6.wireframe, this.wireframeLinewidth = t6.wireframeLinewidth, this.wireframeLinecap = t6.wireframeLinecap, this.wireframeLinejoin = t6.wireframeLinejoin, this.fog = t6.fog, this;
  }
};
var rm = class extends Cl {
  constructor(t6) {
    super(), this.isMeshNormalMaterial = true, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Vs, this.normalScale = new Fo(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.flatShading = false, this.setValues(t6);
  }
  copy(t6) {
    return super.copy(t6), this.bumpMap = t6.bumpMap, this.bumpScale = t6.bumpScale, this.normalMap = t6.normalMap, this.normalMapType = t6.normalMapType, this.normalScale.copy(t6.normalScale), this.displacementMap = t6.displacementMap, this.displacementScale = t6.displacementScale, this.displacementBias = t6.displacementBias, this.wireframe = t6.wireframe, this.wireframeLinewidth = t6.wireframeLinewidth, this.flatShading = t6.flatShading, this;
  }
};
var sm = class extends Cl {
  constructor(t6) {
    super(), this.isMeshLambertMaterial = true, this.type = "MeshLambertMaterial", this.color = new $o(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new $o(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = er, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(t6);
  }
  copy(t6) {
    return super.copy(t6), this.color.copy(t6.color), this.map = t6.map, this.lightMap = t6.lightMap, this.lightMapIntensity = t6.lightMapIntensity, this.aoMap = t6.aoMap, this.aoMapIntensity = t6.aoMapIntensity, this.emissive.copy(t6.emissive), this.emissiveMap = t6.emissiveMap, this.emissiveIntensity = t6.emissiveIntensity, this.specularMap = t6.specularMap, this.alphaMap = t6.alphaMap, this.envMap = t6.envMap, this.combine = t6.combine, this.reflectivity = t6.reflectivity, this.refractionRatio = t6.refractionRatio, this.wireframe = t6.wireframe, this.wireframeLinewidth = t6.wireframeLinewidth, this.wireframeLinecap = t6.wireframeLinecap, this.wireframeLinejoin = t6.wireframeLinejoin, this.fog = t6.fog, this;
  }
};
var om = class extends Cl {
  constructor(t6) {
    super(), this.isMeshMatcapMaterial = true, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new $o(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Vs, this.normalScale = new Fo(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = false, this.fog = true, this.setValues(t6);
  }
  copy(t6) {
    return super.copy(t6), this.defines = { MATCAP: "" }, this.color.copy(t6.color), this.matcap = t6.matcap, this.map = t6.map, this.bumpMap = t6.bumpMap, this.bumpScale = t6.bumpScale, this.normalMap = t6.normalMap, this.normalMapType = t6.normalMapType, this.normalScale.copy(t6.normalScale), this.displacementMap = t6.displacementMap, this.displacementScale = t6.displacementScale, this.displacementBias = t6.displacementBias, this.alphaMap = t6.alphaMap, this.flatShading = t6.flatShading, this.fog = t6.fog, this;
  }
};
var am = class extends op {
  constructor(t6) {
    super(), this.isLineDashedMaterial = true, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t6);
  }
  copy(t6) {
    return super.copy(t6), this.scale = t6.scale, this.dashSize = t6.dashSize, this.gapSize = t6.gapSize, this;
  }
};
function lm(t6, e2, i2) {
  return hm(t6) ? new t6.constructor(t6.subarray(e2, void 0 !== i2 ? i2 : t6.length)) : t6.slice(e2, i2);
}
function cm(t6, e2, i2) {
  return !t6 || !i2 && t6.constructor === e2 ? t6 : "number" == typeof e2.BYTES_PER_ELEMENT ? new e2(t6) : Array.prototype.slice.call(t6);
}
function hm(t6) {
  return ArrayBuffer.isView(t6) && !(t6 instanceof DataView);
}
function um(t6) {
  const e2 = t6.length, i2 = new Array(e2);
  for (let t7 = 0; t7 !== e2; ++t7) i2[t7] = t7;
  return i2.sort((function(e3, i3) {
    return t6[e3] - t6[i3];
  })), i2;
}
function dm(t6, e2, i2) {
  const n2 = t6.length, r2 = new t6.constructor(n2);
  for (let s2 = 0, o2 = 0; o2 !== n2; ++s2) {
    const n3 = i2[s2] * e2;
    for (let i3 = 0; i3 !== e2; ++i3) r2[o2++] = t6[n3 + i3];
  }
  return r2;
}
function pm(t6, e2, i2, n2) {
  let r2 = 1, s2 = t6[0];
  for (; void 0 !== s2 && void 0 === s2[n2]; ) s2 = t6[r2++];
  if (void 0 === s2) return;
  let o2 = s2[n2];
  if (void 0 !== o2) if (Array.isArray(o2)) do {
    o2 = s2[n2], void 0 !== o2 && (e2.push(s2.time), i2.push.apply(i2, o2)), s2 = t6[r2++];
  } while (void 0 !== s2);
  else if (void 0 !== o2.toArray) do {
    o2 = s2[n2], void 0 !== o2 && (e2.push(s2.time), o2.toArray(i2, i2.length)), s2 = t6[r2++];
  } while (void 0 !== s2);
  else do {
    o2 = s2[n2], void 0 !== o2 && (e2.push(s2.time), i2.push(o2)), s2 = t6[r2++];
  } while (void 0 !== s2);
}
var fm = Object.freeze({ __proto__: null, arraySlice: lm, convertArray: cm, isTypedArray: hm, getKeyframeOrder: um, sortedArray: dm, flattenJSON: pm, subclip: function(t6, e2, i2, n2, r2 = 30) {
  const s2 = t6.clone();
  s2.name = e2;
  const o2 = [];
  for (let t7 = 0; t7 < s2.tracks.length; ++t7) {
    const e3 = s2.tracks[t7], a3 = e3.getValueSize(), l2 = [], c2 = [];
    for (let t8 = 0; t8 < e3.times.length; ++t8) {
      const s3 = e3.times[t8] * r2;
      if (!(s3 < i2 || s3 >= n2)) {
        l2.push(e3.times[t8]);
        for (let i3 = 0; i3 < a3; ++i3) c2.push(e3.values[t8 * a3 + i3]);
      }
    }
    0 !== l2.length && (e3.times = cm(l2, e3.times.constructor), e3.values = cm(c2, e3.values.constructor), o2.push(e3));
  }
  s2.tracks = o2;
  let a2 = 1 / 0;
  for (let t7 = 0; t7 < s2.tracks.length; ++t7) a2 > s2.tracks[t7].times[0] && (a2 = s2.tracks[t7].times[0]);
  for (let t7 = 0; t7 < s2.tracks.length; ++t7) s2.tracks[t7].shift(-1 * a2);
  return s2.resetDuration(), s2;
}, makeClipAdditive: function(t6, e2 = 0, i2 = t6, n2 = 30) {
  n2 <= 0 && (n2 = 30);
  const r2 = i2.tracks.length, s2 = e2 / n2;
  for (let e3 = 0; e3 < r2; ++e3) {
    const n3 = i2.tracks[e3], r3 = n3.ValueTypeName;
    if ("bool" === r3 || "string" === r3) continue;
    const o2 = t6.tracks.find((function(t7) {
      return t7.name === n3.name && t7.ValueTypeName === r3;
    }));
    if (void 0 === o2) continue;
    let a2 = 0;
    const l2 = n3.getValueSize();
    n3.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a2 = l2 / 3);
    let c2 = 0;
    const h2 = o2.getValueSize();
    o2.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c2 = h2 / 3);
    const u2 = n3.times.length - 1;
    let d2;
    if (s2 <= n3.times[0]) {
      const t7 = a2, e4 = l2 - a2;
      d2 = lm(n3.values, t7, e4);
    } else if (s2 >= n3.times[u2]) {
      const t7 = u2 * l2 + a2, e4 = t7 + l2 - a2;
      d2 = lm(n3.values, t7, e4);
    } else {
      const t7 = n3.createInterpolant(), e4 = a2, i3 = l2 - a2;
      t7.evaluate(s2), d2 = lm(t7.resultBuffer, e4, i3);
    }
    if ("quaternion" === r3) {
      new da().fromArray(d2).normalize().conjugate().toArray(d2);
    }
    const p2 = o2.times.length;
    for (let t7 = 0; t7 < p2; ++t7) {
      const e4 = t7 * h2 + c2;
      if ("quaternion" === r3) da.multiplyQuaternionsFlat(o2.values, e4, d2, 0, o2.values, e4);
      else {
        const t8 = h2 - 2 * c2;
        for (let i3 = 0; i3 < t8; ++i3) o2.values[e4 + i3] -= d2[i3];
      }
    }
  }
  return t6.blendMode = Os, t6;
} });
var mm = class {
  constructor(t6, e2, i2, n2) {
    this.parameterPositions = t6, this._cachedIndex = 0, this.resultBuffer = void 0 !== n2 ? n2 : new e2.constructor(i2), this.sampleValues = e2, this.valueSize = i2, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(t6) {
    const e2 = this.parameterPositions;
    let i2 = this._cachedIndex, n2 = e2[i2], r2 = e2[i2 - 1];
    t: {
      e: {
        let s2;
        i: {
          n: if (!(t6 < n2)) {
            for (let s3 = i2 + 2; ; ) {
              if (void 0 === n2) {
                if (t6 < r2) break n;
                return i2 = e2.length, this._cachedIndex = i2, this.copySampleValue_(i2 - 1);
              }
              if (i2 === s3) break;
              if (r2 = n2, n2 = e2[++i2], t6 < n2) break e;
            }
            s2 = e2.length;
            break i;
          }
          if (t6 >= r2) break t;
          {
            const o2 = e2[1];
            t6 < o2 && (i2 = 2, r2 = o2);
            for (let s3 = i2 - 2; ; ) {
              if (void 0 === r2) return this._cachedIndex = 0, this.copySampleValue_(0);
              if (i2 === s3) break;
              if (n2 = r2, r2 = e2[--i2 - 1], t6 >= r2) break e;
            }
            s2 = i2, i2 = 0;
          }
        }
        for (; i2 < s2; ) {
          const n3 = i2 + s2 >>> 1;
          t6 < e2[n3] ? s2 = n3 : i2 = n3 + 1;
        }
        if (n2 = e2[i2], r2 = e2[i2 - 1], void 0 === r2) return this._cachedIndex = 0, this.copySampleValue_(0);
        if (void 0 === n2) return i2 = e2.length, this._cachedIndex = i2, this.copySampleValue_(i2 - 1);
      }
      this._cachedIndex = i2, this.intervalChanged_(i2, r2, n2);
    }
    return this.interpolate_(i2, r2, t6, n2);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(t6) {
    const e2 = this.resultBuffer, i2 = this.sampleValues, n2 = this.valueSize, r2 = t6 * n2;
    for (let t7 = 0; t7 !== n2; ++t7) e2[t7] = i2[r2 + t7];
    return e2;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
};
var gm = class extends mm {
  constructor(t6, e2, i2, n2) {
    super(t6, e2, i2, n2), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: Ps, endingEnd: Ps };
  }
  intervalChanged_(t6, e2, i2) {
    const n2 = this.parameterPositions;
    let r2 = t6 - 2, s2 = t6 + 1, o2 = n2[r2], a2 = n2[s2];
    if (void 0 === o2) switch (this.getSettings_().endingStart) {
      case Ls:
        r2 = t6, o2 = 2 * e2 - i2;
        break;
      case Is:
        r2 = n2.length - 2, o2 = e2 + n2[r2] - n2[r2 + 1];
        break;
      default:
        r2 = t6, o2 = i2;
    }
    if (void 0 === a2) switch (this.getSettings_().endingEnd) {
      case Ls:
        s2 = t6, a2 = 2 * i2 - e2;
        break;
      case Is:
        s2 = 1, a2 = i2 + n2[1] - n2[0];
        break;
      default:
        s2 = t6 - 1, a2 = e2;
    }
    const l2 = 0.5 * (i2 - e2), c2 = this.valueSize;
    this._weightPrev = l2 / (e2 - o2), this._weightNext = l2 / (a2 - i2), this._offsetPrev = r2 * c2, this._offsetNext = s2 * c2;
  }
  interpolate_(t6, e2, i2, n2) {
    const r2 = this.resultBuffer, s2 = this.sampleValues, o2 = this.valueSize, a2 = t6 * o2, l2 = a2 - o2, c2 = this._offsetPrev, h2 = this._offsetNext, u2 = this._weightPrev, d2 = this._weightNext, p2 = (i2 - e2) / (n2 - e2), f2 = p2 * p2, m2 = f2 * p2, g2 = -u2 * m2 + 2 * u2 * f2 - u2 * p2, v2 = (1 + u2) * m2 + (-1.5 - 2 * u2) * f2 + (-0.5 + u2) * p2 + 1, y2 = (-1 - d2) * m2 + (1.5 + d2) * f2 + 0.5 * p2, x2 = d2 * m2 - d2 * f2;
    for (let t7 = 0; t7 !== o2; ++t7) r2[t7] = g2 * s2[c2 + t7] + v2 * s2[l2 + t7] + y2 * s2[a2 + t7] + x2 * s2[h2 + t7];
    return r2;
  }
};
var vm = class extends mm {
  constructor(t6, e2, i2, n2) {
    super(t6, e2, i2, n2);
  }
  interpolate_(t6, e2, i2, n2) {
    const r2 = this.resultBuffer, s2 = this.sampleValues, o2 = this.valueSize, a2 = t6 * o2, l2 = a2 - o2, c2 = (i2 - e2) / (n2 - e2), h2 = 1 - c2;
    for (let t7 = 0; t7 !== o2; ++t7) r2[t7] = s2[l2 + t7] * h2 + s2[a2 + t7] * c2;
    return r2;
  }
};
var ym = class extends mm {
  constructor(t6, e2, i2, n2) {
    super(t6, e2, i2, n2);
  }
  interpolate_(t6) {
    return this.copySampleValue_(t6 - 1);
  }
};
var xm = class {
  constructor(t6, e2, i2, n2) {
    if (void 0 === t6) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (void 0 === e2 || 0 === e2.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t6);
    this.name = t6, this.times = cm(e2, this.TimeBufferType), this.values = cm(i2, this.ValueBufferType), this.setInterpolation(n2 || this.DefaultInterpolation);
  }
  static toJSON(t6) {
    const e2 = t6.constructor;
    let i2;
    if (e2.toJSON !== this.toJSON) i2 = e2.toJSON(t6);
    else {
      i2 = { name: t6.name, times: cm(t6.times, Array), values: cm(t6.values, Array) };
      const e3 = t6.getInterpolation();
      e3 !== t6.DefaultInterpolation && (i2.interpolation = e3);
    }
    return i2.type = t6.ValueTypeName, i2;
  }
  InterpolantFactoryMethodDiscrete(t6) {
    return new ym(this.times, this.values, this.getValueSize(), t6);
  }
  InterpolantFactoryMethodLinear(t6) {
    return new vm(this.times, this.values, this.getValueSize(), t6);
  }
  InterpolantFactoryMethodSmooth(t6) {
    return new gm(this.times, this.values, this.getValueSize(), t6);
  }
  setInterpolation(t6) {
    let e2;
    switch (t6) {
      case As:
        e2 = this.InterpolantFactoryMethodDiscrete;
        break;
      case Cs:
        e2 = this.InterpolantFactoryMethodLinear;
        break;
      case Rs:
        e2 = this.InterpolantFactoryMethodSmooth;
    }
    if (void 0 === e2) {
      const e3 = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (void 0 === this.createInterpolant) {
        if (t6 === this.DefaultInterpolation) throw new Error(e3);
        this.setInterpolation(this.DefaultInterpolation);
      }
      return console.warn("THREE.KeyframeTrack:", e3), this;
    }
    return this.createInterpolant = e2, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return As;
      case this.InterpolantFactoryMethodLinear:
        return Cs;
      case this.InterpolantFactoryMethodSmooth:
        return Rs;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(t6) {
    if (0 !== t6) {
      const e2 = this.times;
      for (let i2 = 0, n2 = e2.length; i2 !== n2; ++i2) e2[i2] += t6;
    }
    return this;
  }
  scale(t6) {
    if (1 !== t6) {
      const e2 = this.times;
      for (let i2 = 0, n2 = e2.length; i2 !== n2; ++i2) e2[i2] *= t6;
    }
    return this;
  }
  trim(t6, e2) {
    const i2 = this.times, n2 = i2.length;
    let r2 = 0, s2 = n2 - 1;
    for (; r2 !== n2 && i2[r2] < t6; ) ++r2;
    for (; -1 !== s2 && i2[s2] > e2; ) --s2;
    if (++s2, 0 !== r2 || s2 !== n2) {
      r2 >= s2 && (s2 = Math.max(s2, 1), r2 = s2 - 1);
      const t7 = this.getValueSize();
      this.times = lm(i2, r2, s2), this.values = lm(this.values, r2 * t7, s2 * t7);
    }
    return this;
  }
  validate() {
    let t6 = true;
    const e2 = this.getValueSize();
    e2 - Math.floor(e2) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t6 = false);
    const i2 = this.times, n2 = this.values, r2 = i2.length;
    0 === r2 && (console.error("THREE.KeyframeTrack: Track is empty.", this), t6 = false);
    let s2 = null;
    for (let e3 = 0; e3 !== r2; e3++) {
      const n3 = i2[e3];
      if ("number" == typeof n3 && isNaN(n3)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e3, n3), t6 = false;
        break;
      }
      if (null !== s2 && s2 > n3) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, e3, n3, s2), t6 = false;
        break;
      }
      s2 = n3;
    }
    if (void 0 !== n2 && hm(n2)) for (let e3 = 0, i3 = n2.length; e3 !== i3; ++e3) {
      const i4 = n2[e3];
      if (isNaN(i4)) {
        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e3, i4), t6 = false;
        break;
      }
    }
    return t6;
  }
  optimize() {
    const t6 = lm(this.times), e2 = lm(this.values), i2 = this.getValueSize(), n2 = this.getInterpolation() === Rs, r2 = t6.length - 1;
    let s2 = 1;
    for (let o2 = 1; o2 < r2; ++o2) {
      let r3 = false;
      const a2 = t6[o2];
      if (a2 !== t6[o2 + 1] && (1 !== o2 || a2 !== t6[0])) if (n2) r3 = true;
      else {
        const t7 = o2 * i2, n3 = t7 - i2, s3 = t7 + i2;
        for (let o3 = 0; o3 !== i2; ++o3) {
          const i3 = e2[t7 + o3];
          if (i3 !== e2[n3 + o3] || i3 !== e2[s3 + o3]) {
            r3 = true;
            break;
          }
        }
      }
      if (r3) {
        if (o2 !== s2) {
          t6[s2] = t6[o2];
          const n3 = o2 * i2, r4 = s2 * i2;
          for (let t7 = 0; t7 !== i2; ++t7) e2[r4 + t7] = e2[n3 + t7];
        }
        ++s2;
      }
    }
    if (r2 > 0) {
      t6[s2] = t6[r2];
      for (let t7 = r2 * i2, n3 = s2 * i2, o2 = 0; o2 !== i2; ++o2) e2[n3 + o2] = e2[t7 + o2];
      ++s2;
    }
    return s2 !== t6.length ? (this.times = lm(t6, 0, s2), this.values = lm(e2, 0, s2 * i2)) : (this.times = t6, this.values = e2), this;
  }
  clone() {
    const t6 = lm(this.times, 0), e2 = lm(this.values, 0), i2 = new (0, this.constructor)(this.name, t6, e2);
    return i2.createInterpolant = this.createInterpolant, i2;
  }
};
xm.prototype.TimeBufferType = Float32Array, xm.prototype.ValueBufferType = Float32Array, xm.prototype.DefaultInterpolation = Cs;
var bm = class extends xm {
};
bm.prototype.ValueTypeName = "bool", bm.prototype.ValueBufferType = Array, bm.prototype.DefaultInterpolation = As, bm.prototype.InterpolantFactoryMethodLinear = void 0, bm.prototype.InterpolantFactoryMethodSmooth = void 0;
var wm = class extends xm {
};
wm.prototype.ValueTypeName = "color";
var _m = class extends xm {
};
_m.prototype.ValueTypeName = "number";
var Sm = class extends mm {
  constructor(t6, e2, i2, n2) {
    super(t6, e2, i2, n2);
  }
  interpolate_(t6, e2, i2, n2) {
    const r2 = this.resultBuffer, s2 = this.sampleValues, o2 = this.valueSize, a2 = (i2 - e2) / (n2 - e2);
    let l2 = t6 * o2;
    for (let t7 = l2 + o2; l2 !== t7; l2 += 4) da.slerpFlat(r2, 0, s2, l2 - o2, s2, l2, a2);
    return r2;
  }
};
var Mm = class extends xm {
  InterpolantFactoryMethodLinear(t6) {
    return new Sm(this.times, this.values, this.getValueSize(), t6);
  }
};
Mm.prototype.ValueTypeName = "quaternion", Mm.prototype.DefaultInterpolation = Cs, Mm.prototype.InterpolantFactoryMethodSmooth = void 0;
var Tm = class extends xm {
};
Tm.prototype.ValueTypeName = "string", Tm.prototype.ValueBufferType = Array, Tm.prototype.DefaultInterpolation = As, Tm.prototype.InterpolantFactoryMethodLinear = void 0, Tm.prototype.InterpolantFactoryMethodSmooth = void 0;
var Em = class extends xm {
};
Em.prototype.ValueTypeName = "vector";
var Am = class {
  constructor(t6, e2 = -1, i2, n2 = Ds) {
    this.name = t6, this.tracks = i2, this.duration = e2, this.blendMode = n2, this.uuid = Co(), this.duration < 0 && this.resetDuration();
  }
  static parse(t6) {
    const e2 = [], i2 = t6.tracks, n2 = 1 / (t6.fps || 1);
    for (let t7 = 0, r3 = i2.length; t7 !== r3; ++t7) e2.push(Cm(i2[t7]).scale(n2));
    const r2 = new this(t6.name, t6.duration, e2, t6.blendMode);
    return r2.uuid = t6.uuid, r2;
  }
  static toJSON(t6) {
    const e2 = [], i2 = t6.tracks, n2 = { name: t6.name, duration: t6.duration, tracks: e2, uuid: t6.uuid, blendMode: t6.blendMode };
    for (let t7 = 0, n3 = i2.length; t7 !== n3; ++t7) e2.push(xm.toJSON(i2[t7]));
    return n2;
  }
  static CreateFromMorphTargetSequence(t6, e2, i2, n2) {
    const r2 = e2.length, s2 = [];
    for (let t7 = 0; t7 < r2; t7++) {
      let o2 = [], a2 = [];
      o2.push((t7 + r2 - 1) % r2, t7, (t7 + 1) % r2), a2.push(0, 1, 0);
      const l2 = um(o2);
      o2 = dm(o2, 1, l2), a2 = dm(a2, 1, l2), n2 || 0 !== o2[0] || (o2.push(r2), a2.push(a2[0])), s2.push(new _m(".morphTargetInfluences[" + e2[t7].name + "]", o2, a2).scale(1 / i2));
    }
    return new this(t6, -1, s2);
  }
  static findByName(t6, e2) {
    let i2 = t6;
    if (!Array.isArray(t6)) {
      const e3 = t6;
      i2 = e3.geometry && e3.geometry.animations || e3.animations;
    }
    for (let t7 = 0; t7 < i2.length; t7++) if (i2[t7].name === e2) return i2[t7];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(t6, e2, i2) {
    const n2 = {}, r2 = /^([\w-]*?)([\d]+)$/;
    for (let e3 = 0, i3 = t6.length; e3 < i3; e3++) {
      const i4 = t6[e3], s3 = i4.name.match(r2);
      if (s3 && s3.length > 1) {
        const t7 = s3[1];
        let e4 = n2[t7];
        e4 || (n2[t7] = e4 = []), e4.push(i4);
      }
    }
    const s2 = [];
    for (const t7 in n2) s2.push(this.CreateFromMorphTargetSequence(t7, n2[t7], e2, i2));
    return s2;
  }
  static parseAnimation(t6, e2) {
    if (!t6) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const i2 = function(t7, e3, i3, n3, r3) {
      if (0 !== i3.length) {
        const s3 = [], o3 = [];
        pm(i3, s3, o3, n3), 0 !== s3.length && r3.push(new t7(e3, s3, o3));
      }
    }, n2 = [], r2 = t6.name || "default", s2 = t6.fps || 30, o2 = t6.blendMode;
    let a2 = t6.length || -1;
    const l2 = t6.hierarchy || [];
    for (let t7 = 0; t7 < l2.length; t7++) {
      const r3 = l2[t7].keys;
      if (r3 && 0 !== r3.length) if (r3[0].morphTargets) {
        const t8 = {};
        let e3;
        for (e3 = 0; e3 < r3.length; e3++) if (r3[e3].morphTargets) for (let i3 = 0; i3 < r3[e3].morphTargets.length; i3++) t8[r3[e3].morphTargets[i3]] = -1;
        for (const i3 in t8) {
          const t9 = [], s3 = [];
          for (let n3 = 0; n3 !== r3[e3].morphTargets.length; ++n3) {
            const n4 = r3[e3];
            t9.push(n4.time), s3.push(n4.morphTarget === i3 ? 1 : 0);
          }
          n2.push(new _m(".morphTargetInfluence[" + i3 + "]", t9, s3));
        }
        a2 = t8.length * s2;
      } else {
        const s3 = ".bones[" + e2[t7].name + "]";
        i2(Em, s3 + ".position", r3, "pos", n2), i2(Mm, s3 + ".quaternion", r3, "rot", n2), i2(Em, s3 + ".scale", r3, "scl", n2);
      }
    }
    if (0 === n2.length) return null;
    return new this(r2, a2, n2, o2);
  }
  resetDuration() {
    let t6 = 0;
    for (let e2 = 0, i2 = this.tracks.length; e2 !== i2; ++e2) {
      const i3 = this.tracks[e2];
      t6 = Math.max(t6, i3.times[i3.times.length - 1]);
    }
    return this.duration = t6, this;
  }
  trim() {
    for (let t6 = 0; t6 < this.tracks.length; t6++) this.tracks[t6].trim(0, this.duration);
    return this;
  }
  validate() {
    let t6 = true;
    for (let e2 = 0; e2 < this.tracks.length; e2++) t6 = t6 && this.tracks[e2].validate();
    return t6;
  }
  optimize() {
    for (let t6 = 0; t6 < this.tracks.length; t6++) this.tracks[t6].optimize();
    return this;
  }
  clone() {
    const t6 = [];
    for (let e2 = 0; e2 < this.tracks.length; e2++) t6.push(this.tracks[e2].clone());
    return new this.constructor(this.name, this.duration, t6, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
};
function Cm(t6) {
  if (void 0 === t6.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e2 = (function(t7) {
    switch (t7.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return _m;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return Em;
      case "color":
        return wm;
      case "quaternion":
        return Mm;
      case "bool":
      case "boolean":
        return bm;
      case "string":
        return Tm;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t7);
  })(t6.type);
  if (void 0 === t6.times) {
    const e3 = [], i2 = [];
    pm(t6.keys, e3, i2, "value"), t6.times = e3, t6.values = i2;
  }
  return void 0 !== e2.parse ? e2.parse(t6) : new e2(t6.name, t6.times, t6.values, t6.interpolation);
}
var Rm = { enabled: false, files: {}, add: function(t6, e2) {
  false !== this.enabled && (this.files[t6] = e2);
}, get: function(t6) {
  if (false !== this.enabled) return this.files[t6];
}, remove: function(t6) {
  delete this.files[t6];
}, clear: function() {
  this.files = {};
} };
var Pm = class {
  constructor(t6, e2, i2) {
    const n2 = this;
    let r2, s2 = false, o2 = 0, a2 = 0;
    const l2 = [];
    this.onStart = void 0, this.onLoad = t6, this.onProgress = e2, this.onError = i2, this.itemStart = function(t7) {
      a2++, false === s2 && void 0 !== n2.onStart && n2.onStart(t7, o2, a2), s2 = true;
    }, this.itemEnd = function(t7) {
      o2++, void 0 !== n2.onProgress && n2.onProgress(t7, o2, a2), o2 === a2 && (s2 = false, void 0 !== n2.onLoad && n2.onLoad());
    }, this.itemError = function(t7) {
      void 0 !== n2.onError && n2.onError(t7);
    }, this.resolveURL = function(t7) {
      return r2 ? r2(t7) : t7;
    }, this.setURLModifier = function(t7) {
      return r2 = t7, this;
    }, this.addHandler = function(t7, e3) {
      return l2.push(t7, e3), this;
    }, this.removeHandler = function(t7) {
      const e3 = l2.indexOf(t7);
      return -1 !== e3 && l2.splice(e3, 2), this;
    }, this.getHandler = function(t7) {
      for (let e3 = 0, i3 = l2.length; e3 < i3; e3 += 2) {
        const i4 = l2[e3], n3 = l2[e3 + 1];
        if (i4.global && (i4.lastIndex = 0), i4.test(t7)) return n3;
      }
      return null;
    };
  }
};
var Lm = new Pm();
var Im = class {
  constructor(t6) {
    this.manager = void 0 !== t6 ? t6 : Lm, this.crossOrigin = "anonymous", this.withCredentials = false, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(t6, e2) {
    const i2 = this;
    return new Promise((function(n2, r2) {
      i2.load(t6, n2, e2, r2);
    }));
  }
  parse() {
  }
  setCrossOrigin(t6) {
    return this.crossOrigin = t6, this;
  }
  setWithCredentials(t6) {
    return this.withCredentials = t6, this;
  }
  setPath(t6) {
    return this.path = t6, this;
  }
  setResourcePath(t6) {
    return this.resourcePath = t6, this;
  }
  setRequestHeader(t6) {
    return this.requestHeader = t6, this;
  }
};
var Dm = {};
var Om = class extends Error {
  constructor(t6, e2) {
    super(t6), this.response = e2;
  }
};
var zm = class extends Im {
  constructor(t6) {
    super(t6);
  }
  load(t6, e2, i2, n2) {
    void 0 === t6 && (t6 = ""), void 0 !== this.path && (t6 = this.path + t6), t6 = this.manager.resolveURL(t6);
    const r2 = Rm.get(t6);
    if (void 0 !== r2) return this.manager.itemStart(t6), setTimeout((() => {
      e2 && e2(r2), this.manager.itemEnd(t6);
    }), 0), r2;
    if (void 0 !== Dm[t6]) return void Dm[t6].push({ onLoad: e2, onProgress: i2, onError: n2 });
    Dm[t6] = [], Dm[t6].push({ onLoad: e2, onProgress: i2, onError: n2 });
    const s2 = new Request(t6, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" }), o2 = this.mimeType, a2 = this.responseType;
    fetch(s2).then(((e3) => {
      if (200 === e3.status || 0 === e3.status) {
        if (0 === e3.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === e3.body || void 0 === e3.body.getReader) return e3;
        const i3 = Dm[t6], n3 = e3.body.getReader(), r3 = e3.headers.get("Content-Length"), s3 = r3 ? parseInt(r3) : 0, o3 = 0 !== s3;
        let a3 = 0;
        const l2 = new ReadableStream({ start(t7) {
          !(function e4() {
            n3.read().then((({ done: n4, value: r4 }) => {
              if (n4) t7.close();
              else {
                a3 += r4.byteLength;
                const n5 = new ProgressEvent("progress", { lengthComputable: o3, loaded: a3, total: s3 });
                for (let t8 = 0, e5 = i3.length; t8 < e5; t8++) {
                  const e6 = i3[t8];
                  e6.onProgress && e6.onProgress(n5);
                }
                t7.enqueue(r4), e4();
              }
            }));
          })();
        } });
        return new Response(l2);
      }
      throw new Om(`fetch for "${e3.url}" responded with ${e3.status}: ${e3.statusText}`, e3);
    })).then(((t7) => {
      switch (a2) {
        case "arraybuffer":
          return t7.arrayBuffer();
        case "blob":
          return t7.blob();
        case "document":
          return t7.text().then(((t8) => new DOMParser().parseFromString(t8, o2)));
        case "json":
          return t7.json();
        default:
          if (void 0 === o2) return t7.text();
          {
            const e3 = /charset="?([^;"\s]*)"?/i.exec(o2), i3 = e3 && e3[1] ? e3[1].toLowerCase() : void 0, n3 = new TextDecoder(i3);
            return t7.arrayBuffer().then(((t8) => n3.decode(t8)));
          }
      }
    })).then(((e3) => {
      Rm.add(t6, e3);
      const i3 = Dm[t6];
      delete Dm[t6];
      for (let t7 = 0, n3 = i3.length; t7 < n3; t7++) {
        const n4 = i3[t7];
        n4.onLoad && n4.onLoad(e3);
      }
    })).catch(((e3) => {
      const i3 = Dm[t6];
      if (void 0 === i3) throw this.manager.itemError(t6), e3;
      delete Dm[t6];
      for (let t7 = 0, n3 = i3.length; t7 < n3; t7++) {
        const n4 = i3[t7];
        n4.onError && n4.onError(e3);
      }
      this.manager.itemError(t6);
    })).finally((() => {
      this.manager.itemEnd(t6);
    })), this.manager.itemStart(t6);
  }
  setResponseType(t6) {
    return this.responseType = t6, this;
  }
  setMimeType(t6) {
    return this.mimeType = t6, this;
  }
};
var Fm = class extends Im {
  constructor(t6) {
    super(t6);
  }
  load(t6, e2, i2, n2) {
    const r2 = this, s2 = new zm(this.manager);
    s2.setPath(this.path), s2.setRequestHeader(this.requestHeader), s2.setWithCredentials(this.withCredentials), s2.load(t6, (function(i3) {
      try {
        e2(r2.parse(JSON.parse(i3)));
      } catch (e3) {
        n2 ? n2(e3) : console.error(e3), r2.manager.itemError(t6);
      }
    }), i2, n2);
  }
  parse(t6) {
    const e2 = [];
    for (let i2 = 0; i2 < t6.length; i2++) {
      const n2 = Am.parse(t6[i2]);
      e2.push(n2);
    }
    return e2;
  }
};
var Nm = class extends Im {
  constructor(t6) {
    super(t6);
  }
  load(t6, e2, i2, n2) {
    const r2 = this, s2 = [], o2 = new Ep(), a2 = new zm(this.manager);
    a2.setPath(this.path), a2.setResponseType("arraybuffer"), a2.setRequestHeader(this.requestHeader), a2.setWithCredentials(r2.withCredentials);
    let l2 = 0;
    function c2(c3) {
      a2.load(t6[c3], (function(t7) {
        const i3 = r2.parse(t7, true);
        s2[c3] = { width: i3.width, height: i3.height, format: i3.format, mipmaps: i3.mipmaps }, l2 += 1, 6 === l2 && (1 === i3.mipmapCount && (o2.minFilter = Mr), o2.image = s2, o2.format = i3.format, o2.needsUpdate = true, e2 && e2(o2));
      }), i2, n2);
    }
    if (Array.isArray(t6)) for (let e3 = 0, i3 = t6.length; e3 < i3; ++e3) c2(e3);
    else a2.load(t6, (function(t7) {
      const i3 = r2.parse(t7, true);
      if (i3.isCubemap) {
        const t8 = i3.mipmaps.length / i3.mipmapCount;
        for (let e3 = 0; e3 < t8; e3++) {
          s2[e3] = { mipmaps: [] };
          for (let t9 = 0; t9 < i3.mipmapCount; t9++) s2[e3].mipmaps.push(i3.mipmaps[e3 * i3.mipmapCount + t9]), s2[e3].format = i3.format, s2[e3].width = i3.width, s2[e3].height = i3.height;
        }
        o2.image = s2;
      } else o2.image.width = i3.width, o2.image.height = i3.height, o2.mipmaps = i3.mipmaps;
      1 === i3.mipmapCount && (o2.minFilter = Mr), o2.format = i3.format, o2.needsUpdate = true, e2 && e2(o2);
    }), i2, n2);
    return o2;
  }
};
var Bm = class extends Im {
  constructor(t6) {
    super(t6);
  }
  load(t6, e2, i2, n2) {
    void 0 !== this.path && (t6 = this.path + t6), t6 = this.manager.resolveURL(t6);
    const r2 = this, s2 = Rm.get(t6);
    if (void 0 !== s2) return r2.manager.itemStart(t6), setTimeout((function() {
      e2 && e2(s2), r2.manager.itemEnd(t6);
    }), 0), s2;
    const o2 = Ho("img");
    function a2() {
      c2(), Rm.add(t6, this), e2 && e2(this), r2.manager.itemEnd(t6);
    }
    function l2(e3) {
      c2(), n2 && n2(e3), r2.manager.itemError(t6), r2.manager.itemEnd(t6);
    }
    function c2() {
      o2.removeEventListener("load", a2, false), o2.removeEventListener("error", l2, false);
    }
    return o2.addEventListener("load", a2, false), o2.addEventListener("error", l2, false), "data:" !== t6.slice(0, 5) && void 0 !== this.crossOrigin && (o2.crossOrigin = this.crossOrigin), r2.manager.itemStart(t6), o2.src = t6, o2;
  }
};
var km = class extends Im {
  constructor(t6) {
    super(t6);
  }
  load(t6, e2, i2, n2) {
    const r2 = new Tc(), s2 = new Bm(this.manager);
    s2.setCrossOrigin(this.crossOrigin), s2.setPath(this.path);
    let o2 = 0;
    function a2(i3) {
      s2.load(t6[i3], (function(t7) {
        r2.images[i3] = t7, o2++, 6 === o2 && (r2.needsUpdate = true, e2 && e2(r2));
      }), void 0, n2);
    }
    for (let e3 = 0; e3 < t6.length; ++e3) a2(e3);
    return r2;
  }
};
var Um = class extends Im {
  constructor(t6) {
    super(t6);
  }
  load(t6, e2, i2, n2) {
    const r2 = this, s2 = new Jd(), o2 = new zm(this.manager);
    return o2.setResponseType("arraybuffer"), o2.setRequestHeader(this.requestHeader), o2.setPath(this.path), o2.setWithCredentials(r2.withCredentials), o2.load(t6, (function(t7) {
      const i3 = r2.parse(t7);
      i3 && (void 0 !== i3.image ? s2.image = i3.image : void 0 !== i3.data && (s2.image.width = i3.width, s2.image.height = i3.height, s2.image.data = i3.data), s2.wrapS = void 0 !== i3.wrapS ? i3.wrapS : vr, s2.wrapT = void 0 !== i3.wrapT ? i3.wrapT : vr, s2.magFilter = void 0 !== i3.magFilter ? i3.magFilter : Mr, s2.minFilter = void 0 !== i3.minFilter ? i3.minFilter : Mr, s2.anisotropy = void 0 !== i3.anisotropy ? i3.anisotropy : 1, void 0 !== i3.encoding && (s2.encoding = i3.encoding), void 0 !== i3.flipY && (s2.flipY = i3.flipY), void 0 !== i3.format && (s2.format = i3.format), void 0 !== i3.type && (s2.type = i3.type), void 0 !== i3.mipmaps && (s2.mipmaps = i3.mipmaps, s2.minFilter = Ar), 1 === i3.mipmapCount && (s2.minFilter = Mr), void 0 !== i3.generateMipmaps && (s2.generateMipmaps = i3.generateMipmaps), s2.needsUpdate = true, e2 && e2(s2, i3));
    }), i2, n2), s2;
  }
};
var Hm = class extends Im {
  constructor(t6) {
    super(t6);
  }
  load(t6, e2, i2, n2) {
    const r2 = new ra(), s2 = new Bm(this.manager);
    return s2.setCrossOrigin(this.crossOrigin), s2.setPath(this.path), s2.load(t6, (function(t7) {
      r2.image = t7, r2.needsUpdate = true, void 0 !== e2 && e2(r2);
    }), i2, n2), r2;
  }
};
var Vm = class extends ml {
  constructor(t6, e2 = 1) {
    super(), this.isLight = true, this.type = "Light", this.color = new $o(t6), this.intensity = e2;
  }
  dispose() {
  }
  copy(t6, e2) {
    return super.copy(t6, e2), this.color.copy(t6.color), this.intensity = t6.intensity, this;
  }
  toJSON(t6) {
    const e2 = super.toJSON(t6);
    return e2.object.color = this.color.getHex(), e2.object.intensity = this.intensity, void 0 !== this.groundColor && (e2.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e2.object.distance = this.distance), void 0 !== this.angle && (e2.object.angle = this.angle), void 0 !== this.decay && (e2.object.decay = this.decay), void 0 !== this.penumbra && (e2.object.penumbra = this.penumbra), void 0 !== this.shadow && (e2.object.shadow = this.shadow.toJSON()), e2;
  }
};
var jm = class extends Vm {
  constructor(t6, e2, i2) {
    super(t6, i2), this.isHemisphereLight = true, this.type = "HemisphereLight", this.position.copy(ml.DefaultUp), this.updateMatrix(), this.groundColor = new $o(e2);
  }
  copy(t6, e2) {
    return super.copy(t6, e2), this.groundColor.copy(t6.groundColor), this;
  }
};
var Gm = new Ga();
var Wm = new pa();
var qm = new pa();
var Xm = class {
  constructor(t6) {
    this.camera = t6, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Fo(512, 512), this.map = null, this.mapPass = null, this.matrix = new Ga(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new Dc(), this._frameExtents = new Fo(1, 1), this._viewportCount = 1, this._viewports = [new sa(0, 0, 1, 1)];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(t6) {
    const e2 = this.camera, i2 = this.matrix;
    Wm.setFromMatrixPosition(t6.matrixWorld), e2.position.copy(Wm), qm.setFromMatrixPosition(t6.target.matrixWorld), e2.lookAt(qm), e2.updateMatrixWorld(), Gm.multiplyMatrices(e2.projectionMatrix, e2.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Gm), i2.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), i2.multiply(e2.projectionMatrix), i2.multiply(e2.matrixWorldInverse);
  }
  getViewport(t6) {
    return this._viewports[t6];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(t6) {
    return this.camera = t6.camera.clone(), this.bias = t6.bias, this.radius = t6.radius, this.mapSize.copy(t6.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const t6 = {};
    return 0 !== this.bias && (t6.bias = this.bias), 0 !== this.normalBias && (t6.normalBias = this.normalBias), 1 !== this.radius && (t6.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t6.mapSize = this.mapSize.toArray()), t6.camera = this.camera.toJSON(false).object, delete t6.camera.matrix, t6;
  }
};
var Ym = class extends Xm {
  constructor() {
    super(new _c(50, 1, 0.5, 500)), this.isSpotLightShadow = true, this.focus = 1;
  }
  updateMatrices(t6) {
    const e2 = this.camera, i2 = 2 * Ao * t6.angle * this.focus, n2 = this.mapSize.width / this.mapSize.height, r2 = t6.distance || e2.far;
    i2 === e2.fov && n2 === e2.aspect && r2 === e2.far || (e2.fov = i2, e2.aspect = n2, e2.far = r2, e2.updateProjectionMatrix()), super.updateMatrices(t6);
  }
  copy(t6) {
    return super.copy(t6), this.focus = t6.focus, this;
  }
};
var Zm = class extends Vm {
  constructor(t6, e2, i2 = 0, n2 = Math.PI / 3, r2 = 0, s2 = 1) {
    super(t6, e2), this.isSpotLight = true, this.type = "SpotLight", this.position.copy(ml.DefaultUp), this.updateMatrix(), this.target = new ml(), this.distance = i2, this.angle = n2, this.penumbra = r2, this.decay = s2, this.shadow = new Ym();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(t6) {
    this.intensity = t6 / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(t6, e2) {
    return super.copy(t6, e2), this.distance = t6.distance, this.angle = t6.angle, this.penumbra = t6.penumbra, this.decay = t6.decay, this.target = t6.target.clone(), this.shadow = t6.shadow.clone(), this;
  }
};
var Jm = new Ga();
var Km = new pa();
var $m = new pa();
var Qm = class extends Xm {
  constructor() {
    super(new _c(90, 1, 0.5, 500)), this.isPointLightShadow = true, this._frameExtents = new Fo(4, 2), this._viewportCount = 6, this._viewports = [new sa(2, 1, 1, 1), new sa(0, 1, 1, 1), new sa(3, 1, 1, 1), new sa(1, 1, 1, 1), new sa(3, 0, 1, 1), new sa(1, 0, 1, 1)], this._cubeDirections = [new pa(1, 0, 0), new pa(-1, 0, 0), new pa(0, 0, 1), new pa(0, 0, -1), new pa(0, 1, 0), new pa(0, -1, 0)], this._cubeUps = [new pa(0, 1, 0), new pa(0, 1, 0), new pa(0, 1, 0), new pa(0, 1, 0), new pa(0, 0, 1), new pa(0, 0, -1)];
  }
  updateMatrices(t6, e2 = 0) {
    const i2 = this.camera, n2 = this.matrix, r2 = t6.distance || i2.far;
    r2 !== i2.far && (i2.far = r2, i2.updateProjectionMatrix()), Km.setFromMatrixPosition(t6.matrixWorld), i2.position.copy(Km), $m.copy(i2.position), $m.add(this._cubeDirections[e2]), i2.up.copy(this._cubeUps[e2]), i2.lookAt($m), i2.updateMatrixWorld(), n2.makeTranslation(-Km.x, -Km.y, -Km.z), Jm.multiplyMatrices(i2.projectionMatrix, i2.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Jm);
  }
};
var tg = class extends Vm {
  constructor(t6, e2, i2 = 0, n2 = 1) {
    super(t6, e2), this.isPointLight = true, this.type = "PointLight", this.distance = i2, this.decay = n2, this.shadow = new Qm();
  }
  get power() {
    return 4 * this.intensity * Math.PI;
  }
  set power(t6) {
    this.intensity = t6 / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(t6, e2) {
    return super.copy(t6, e2), this.distance = t6.distance, this.decay = t6.decay, this.shadow = t6.shadow.clone(), this;
  }
};
var eg = class extends Xm {
  constructor() {
    super(new qc(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = true;
  }
};
var ig = class extends Vm {
  constructor(t6, e2) {
    super(t6, e2), this.isDirectionalLight = true, this.type = "DirectionalLight", this.position.copy(ml.DefaultUp), this.updateMatrix(), this.target = new ml(), this.shadow = new eg();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(t6) {
    return super.copy(t6), this.target = t6.target.clone(), this.shadow = t6.shadow.clone(), this;
  }
};
var ng = class extends Vm {
  constructor(t6, e2) {
    super(t6, e2), this.isAmbientLight = true, this.type = "AmbientLight";
  }
};
var rg = class extends Vm {
  constructor(t6, e2, i2 = 10, n2 = 10) {
    super(t6, e2), this.isRectAreaLight = true, this.type = "RectAreaLight", this.width = i2, this.height = n2;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(t6) {
    this.intensity = t6 / (this.width * this.height * Math.PI);
  }
  copy(t6) {
    return super.copy(t6), this.width = t6.width, this.height = t6.height, this;
  }
  toJSON(t6) {
    const e2 = super.toJSON(t6);
    return e2.object.width = this.width, e2.object.height = this.height, e2;
  }
};
var sg = class {
  constructor() {
    this.isSphericalHarmonics3 = true, this.coefficients = [];
    for (let t6 = 0; t6 < 9; t6++) this.coefficients.push(new pa());
  }
  set(t6) {
    for (let e2 = 0; e2 < 9; e2++) this.coefficients[e2].copy(t6[e2]);
    return this;
  }
  zero() {
    for (let t6 = 0; t6 < 9; t6++) this.coefficients[t6].set(0, 0, 0);
    return this;
  }
  getAt(t6, e2) {
    const i2 = t6.x, n2 = t6.y, r2 = t6.z, s2 = this.coefficients;
    return e2.copy(s2[0]).multiplyScalar(0.282095), e2.addScaledVector(s2[1], 0.488603 * n2), e2.addScaledVector(s2[2], 0.488603 * r2), e2.addScaledVector(s2[3], 0.488603 * i2), e2.addScaledVector(s2[4], i2 * n2 * 1.092548), e2.addScaledVector(s2[5], n2 * r2 * 1.092548), e2.addScaledVector(s2[6], 0.315392 * (3 * r2 * r2 - 1)), e2.addScaledVector(s2[7], i2 * r2 * 1.092548), e2.addScaledVector(s2[8], 0.546274 * (i2 * i2 - n2 * n2)), e2;
  }
  getIrradianceAt(t6, e2) {
    const i2 = t6.x, n2 = t6.y, r2 = t6.z, s2 = this.coefficients;
    return e2.copy(s2[0]).multiplyScalar(0.886227), e2.addScaledVector(s2[1], 1.023328 * n2), e2.addScaledVector(s2[2], 1.023328 * r2), e2.addScaledVector(s2[3], 1.023328 * i2), e2.addScaledVector(s2[4], 0.858086 * i2 * n2), e2.addScaledVector(s2[5], 0.858086 * n2 * r2), e2.addScaledVector(s2[6], 0.743125 * r2 * r2 - 0.247708), e2.addScaledVector(s2[7], 0.858086 * i2 * r2), e2.addScaledVector(s2[8], 0.429043 * (i2 * i2 - n2 * n2)), e2;
  }
  add(t6) {
    for (let e2 = 0; e2 < 9; e2++) this.coefficients[e2].add(t6.coefficients[e2]);
    return this;
  }
  addScaledSH(t6, e2) {
    for (let i2 = 0; i2 < 9; i2++) this.coefficients[i2].addScaledVector(t6.coefficients[i2], e2);
    return this;
  }
  scale(t6) {
    for (let e2 = 0; e2 < 9; e2++) this.coefficients[e2].multiplyScalar(t6);
    return this;
  }
  lerp(t6, e2) {
    for (let i2 = 0; i2 < 9; i2++) this.coefficients[i2].lerp(t6.coefficients[i2], e2);
    return this;
  }
  equals(t6) {
    for (let e2 = 0; e2 < 9; e2++) if (!this.coefficients[e2].equals(t6.coefficients[e2])) return false;
    return true;
  }
  copy(t6) {
    return this.set(t6.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(t6, e2 = 0) {
    const i2 = this.coefficients;
    for (let n2 = 0; n2 < 9; n2++) i2[n2].fromArray(t6, e2 + 3 * n2);
    return this;
  }
  toArray(t6 = [], e2 = 0) {
    const i2 = this.coefficients;
    for (let n2 = 0; n2 < 9; n2++) i2[n2].toArray(t6, e2 + 3 * n2);
    return t6;
  }
  static getBasisAt(t6, e2) {
    const i2 = t6.x, n2 = t6.y, r2 = t6.z;
    e2[0] = 0.282095, e2[1] = 0.488603 * n2, e2[2] = 0.488603 * r2, e2[3] = 0.488603 * i2, e2[4] = 1.092548 * i2 * n2, e2[5] = 1.092548 * n2 * r2, e2[6] = 0.315392 * (3 * r2 * r2 - 1), e2[7] = 1.092548 * i2 * r2, e2[8] = 0.546274 * (i2 * i2 - n2 * n2);
  }
};
var og = class extends Vm {
  constructor(t6 = new sg(), e2 = 1) {
    super(void 0, e2), this.isLightProbe = true, this.sh = t6;
  }
  copy(t6) {
    return super.copy(t6), this.sh.copy(t6.sh), this;
  }
  fromJSON(t6) {
    return this.intensity = t6.intensity, this.sh.fromArray(t6.sh), this;
  }
  toJSON(t6) {
    const e2 = super.toJSON(t6);
    return e2.object.sh = this.sh.toArray(), e2;
  }
};
var ag = class _ag extends Im {
  constructor(t6) {
    super(t6), this.textures = {};
  }
  load(t6, e2, i2, n2) {
    const r2 = this, s2 = new zm(r2.manager);
    s2.setPath(r2.path), s2.setRequestHeader(r2.requestHeader), s2.setWithCredentials(r2.withCredentials), s2.load(t6, (function(i3) {
      try {
        e2(r2.parse(JSON.parse(i3)));
      } catch (e3) {
        n2 ? n2(e3) : console.error(e3), r2.manager.itemError(t6);
      }
    }), i2, n2);
  }
  parse(t6) {
    const e2 = this.textures;
    function i2(t7) {
      return void 0 === e2[t7] && console.warn("THREE.MaterialLoader: Undefined texture", t7), e2[t7];
    }
    const n2 = _ag.createMaterialFromType(t6.type);
    if (void 0 !== t6.uuid && (n2.uuid = t6.uuid), void 0 !== t6.name && (n2.name = t6.name), void 0 !== t6.color && void 0 !== n2.color && n2.color.setHex(t6.color), void 0 !== t6.roughness && (n2.roughness = t6.roughness), void 0 !== t6.metalness && (n2.metalness = t6.metalness), void 0 !== t6.sheen && (n2.sheen = t6.sheen), void 0 !== t6.sheenColor && (n2.sheenColor = new $o().setHex(t6.sheenColor)), void 0 !== t6.sheenRoughness && (n2.sheenRoughness = t6.sheenRoughness), void 0 !== t6.emissive && void 0 !== n2.emissive && n2.emissive.setHex(t6.emissive), void 0 !== t6.specular && void 0 !== n2.specular && n2.specular.setHex(t6.specular), void 0 !== t6.specularIntensity && (n2.specularIntensity = t6.specularIntensity), void 0 !== t6.specularColor && void 0 !== n2.specularColor && n2.specularColor.setHex(t6.specularColor), void 0 !== t6.shininess && (n2.shininess = t6.shininess), void 0 !== t6.clearcoat && (n2.clearcoat = t6.clearcoat), void 0 !== t6.clearcoatRoughness && (n2.clearcoatRoughness = t6.clearcoatRoughness), void 0 !== t6.iridescence && (n2.iridescence = t6.iridescence), void 0 !== t6.iridescenceIOR && (n2.iridescenceIOR = t6.iridescenceIOR), void 0 !== t6.iridescenceThicknessRange && (n2.iridescenceThicknessRange = t6.iridescenceThicknessRange), void 0 !== t6.transmission && (n2.transmission = t6.transmission), void 0 !== t6.thickness && (n2.thickness = t6.thickness), void 0 !== t6.attenuationDistance && (n2.attenuationDistance = t6.attenuationDistance), void 0 !== t6.attenuationColor && void 0 !== n2.attenuationColor && n2.attenuationColor.setHex(t6.attenuationColor), void 0 !== t6.fog && (n2.fog = t6.fog), void 0 !== t6.flatShading && (n2.flatShading = t6.flatShading), void 0 !== t6.blending && (n2.blending = t6.blending), void 0 !== t6.combine && (n2.combine = t6.combine), void 0 !== t6.side && (n2.side = t6.side), void 0 !== t6.shadowSide && (n2.shadowSide = t6.shadowSide), void 0 !== t6.opacity && (n2.opacity = t6.opacity), void 0 !== t6.transparent && (n2.transparent = t6.transparent), void 0 !== t6.alphaTest && (n2.alphaTest = t6.alphaTest), void 0 !== t6.depthTest && (n2.depthTest = t6.depthTest), void 0 !== t6.depthWrite && (n2.depthWrite = t6.depthWrite), void 0 !== t6.colorWrite && (n2.colorWrite = t6.colorWrite), void 0 !== t6.stencilWrite && (n2.stencilWrite = t6.stencilWrite), void 0 !== t6.stencilWriteMask && (n2.stencilWriteMask = t6.stencilWriteMask), void 0 !== t6.stencilFunc && (n2.stencilFunc = t6.stencilFunc), void 0 !== t6.stencilRef && (n2.stencilRef = t6.stencilRef), void 0 !== t6.stencilFuncMask && (n2.stencilFuncMask = t6.stencilFuncMask), void 0 !== t6.stencilFail && (n2.stencilFail = t6.stencilFail), void 0 !== t6.stencilZFail && (n2.stencilZFail = t6.stencilZFail), void 0 !== t6.stencilZPass && (n2.stencilZPass = t6.stencilZPass), void 0 !== t6.wireframe && (n2.wireframe = t6.wireframe), void 0 !== t6.wireframeLinewidth && (n2.wireframeLinewidth = t6.wireframeLinewidth), void 0 !== t6.wireframeLinecap && (n2.wireframeLinecap = t6.wireframeLinecap), void 0 !== t6.wireframeLinejoin && (n2.wireframeLinejoin = t6.wireframeLinejoin), void 0 !== t6.rotation && (n2.rotation = t6.rotation), 1 !== t6.linewidth && (n2.linewidth = t6.linewidth), void 0 !== t6.dashSize && (n2.dashSize = t6.dashSize), void 0 !== t6.gapSize && (n2.gapSize = t6.gapSize), void 0 !== t6.scale && (n2.scale = t6.scale), void 0 !== t6.polygonOffset && (n2.polygonOffset = t6.polygonOffset), void 0 !== t6.polygonOffsetFactor && (n2.polygonOffsetFactor = t6.polygonOffsetFactor), void 0 !== t6.polygonOffsetUnits && (n2.polygonOffsetUnits = t6.polygonOffsetUnits), void 0 !== t6.dithering && (n2.dithering = t6.dithering), void 0 !== t6.alphaToCoverage && (n2.alphaToCoverage = t6.alphaToCoverage), void 0 !== t6.premultipliedAlpha && (n2.premultipliedAlpha = t6.premultipliedAlpha), void 0 !== t6.visible && (n2.visible = t6.visible), void 0 !== t6.toneMapped && (n2.toneMapped = t6.toneMapped), void 0 !== t6.userData && (n2.userData = t6.userData), void 0 !== t6.vertexColors && ("number" == typeof t6.vertexColors ? n2.vertexColors = t6.vertexColors > 0 : n2.vertexColors = t6.vertexColors), void 0 !== t6.uniforms) for (const e3 in t6.uniforms) {
      const r2 = t6.uniforms[e3];
      switch (n2.uniforms[e3] = {}, r2.type) {
        case "t":
          n2.uniforms[e3].value = i2(r2.value);
          break;
        case "c":
          n2.uniforms[e3].value = new $o().setHex(r2.value);
          break;
        case "v2":
          n2.uniforms[e3].value = new Fo().fromArray(r2.value);
          break;
        case "v3":
          n2.uniforms[e3].value = new pa().fromArray(r2.value);
          break;
        case "v4":
          n2.uniforms[e3].value = new sa().fromArray(r2.value);
          break;
        case "m3":
          n2.uniforms[e3].value = new No().fromArray(r2.value);
          break;
        case "m4":
          n2.uniforms[e3].value = new Ga().fromArray(r2.value);
          break;
        default:
          n2.uniforms[e3].value = r2.value;
      }
    }
    if (void 0 !== t6.defines && (n2.defines = t6.defines), void 0 !== t6.vertexShader && (n2.vertexShader = t6.vertexShader), void 0 !== t6.fragmentShader && (n2.fragmentShader = t6.fragmentShader), void 0 !== t6.extensions) for (const e3 in t6.extensions) n2.extensions[e3] = t6.extensions[e3];
    if (void 0 !== t6.shading && (n2.flatShading = 1 === t6.shading), void 0 !== t6.size && (n2.size = t6.size), void 0 !== t6.sizeAttenuation && (n2.sizeAttenuation = t6.sizeAttenuation), void 0 !== t6.map && (n2.map = i2(t6.map)), void 0 !== t6.matcap && (n2.matcap = i2(t6.matcap)), void 0 !== t6.alphaMap && (n2.alphaMap = i2(t6.alphaMap)), void 0 !== t6.bumpMap && (n2.bumpMap = i2(t6.bumpMap)), void 0 !== t6.bumpScale && (n2.bumpScale = t6.bumpScale), void 0 !== t6.normalMap && (n2.normalMap = i2(t6.normalMap)), void 0 !== t6.normalMapType && (n2.normalMapType = t6.normalMapType), void 0 !== t6.normalScale) {
      let e3 = t6.normalScale;
      false === Array.isArray(e3) && (e3 = [e3, e3]), n2.normalScale = new Fo().fromArray(e3);
    }
    return void 0 !== t6.displacementMap && (n2.displacementMap = i2(t6.displacementMap)), void 0 !== t6.displacementScale && (n2.displacementScale = t6.displacementScale), void 0 !== t6.displacementBias && (n2.displacementBias = t6.displacementBias), void 0 !== t6.roughnessMap && (n2.roughnessMap = i2(t6.roughnessMap)), void 0 !== t6.metalnessMap && (n2.metalnessMap = i2(t6.metalnessMap)), void 0 !== t6.emissiveMap && (n2.emissiveMap = i2(t6.emissiveMap)), void 0 !== t6.emissiveIntensity && (n2.emissiveIntensity = t6.emissiveIntensity), void 0 !== t6.specularMap && (n2.specularMap = i2(t6.specularMap)), void 0 !== t6.specularIntensityMap && (n2.specularIntensityMap = i2(t6.specularIntensityMap)), void 0 !== t6.specularColorMap && (n2.specularColorMap = i2(t6.specularColorMap)), void 0 !== t6.envMap && (n2.envMap = i2(t6.envMap)), void 0 !== t6.envMapIntensity && (n2.envMapIntensity = t6.envMapIntensity), void 0 !== t6.reflectivity && (n2.reflectivity = t6.reflectivity), void 0 !== t6.refractionRatio && (n2.refractionRatio = t6.refractionRatio), void 0 !== t6.lightMap && (n2.lightMap = i2(t6.lightMap)), void 0 !== t6.lightMapIntensity && (n2.lightMapIntensity = t6.lightMapIntensity), void 0 !== t6.aoMap && (n2.aoMap = i2(t6.aoMap)), void 0 !== t6.aoMapIntensity && (n2.aoMapIntensity = t6.aoMapIntensity), void 0 !== t6.gradientMap && (n2.gradientMap = i2(t6.gradientMap)), void 0 !== t6.clearcoatMap && (n2.clearcoatMap = i2(t6.clearcoatMap)), void 0 !== t6.clearcoatRoughnessMap && (n2.clearcoatRoughnessMap = i2(t6.clearcoatRoughnessMap)), void 0 !== t6.clearcoatNormalMap && (n2.clearcoatNormalMap = i2(t6.clearcoatNormalMap)), void 0 !== t6.clearcoatNormalScale && (n2.clearcoatNormalScale = new Fo().fromArray(t6.clearcoatNormalScale)), void 0 !== t6.iridescenceMap && (n2.iridescenceMap = i2(t6.iridescenceMap)), void 0 !== t6.iridescenceThicknessMap && (n2.iridescenceThicknessMap = i2(t6.iridescenceThicknessMap)), void 0 !== t6.transmissionMap && (n2.transmissionMap = i2(t6.transmissionMap)), void 0 !== t6.thicknessMap && (n2.thicknessMap = i2(t6.thicknessMap)), void 0 !== t6.sheenColorMap && (n2.sheenColorMap = i2(t6.sheenColorMap)), void 0 !== t6.sheenRoughnessMap && (n2.sheenRoughnessMap = i2(t6.sheenRoughnessMap)), n2;
  }
  setTextures(t6) {
    return this.textures = t6, this;
  }
  static createMaterialFromType(t6) {
    return new { ShadowMaterial: $f, SpriteMaterial: Md, RawShaderMaterial: Qf, ShaderMaterial: bc, PointsMaterial: vp, MeshPhysicalMaterial: em, MeshStandardMaterial: tm, MeshPhongMaterial: im, MeshToonMaterial: nm, MeshNormalMaterial: rm, MeshLambertMaterial: sm, MeshDepthMaterial: td, MeshDistanceMaterial: ed, MeshBasicMaterial: Rl, MeshMatcapMaterial: om, LineDashedMaterial: am, LineBasicMaterial: op, Material: Cl }[t6]();
  }
};
var lg = class {
  static decodeText(t6) {
    if ("undefined" != typeof TextDecoder) return new TextDecoder().decode(t6);
    let e2 = "";
    for (let i2 = 0, n2 = t6.length; i2 < n2; i2++) e2 += String.fromCharCode(t6[i2]);
    try {
      return decodeURIComponent(escape(e2));
    } catch (t7) {
      return e2;
    }
  }
  static extractUrlBase(t6) {
    const e2 = t6.lastIndexOf("/");
    return -1 === e2 ? "./" : t6.slice(0, e2 + 1);
  }
  static resolveURL(t6, e2) {
    return "string" != typeof t6 || "" === t6 ? "" : (/^https?:\/\//i.test(e2) && /^\//.test(t6) && (e2 = e2.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t6) || /^data:.*,.*$/i.test(t6) || /^blob:.*$/i.test(t6) ? t6 : e2 + t6);
  }
};
var cg = class extends Jl {
  constructor() {
    super(), this.isInstancedBufferGeometry = true, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(t6) {
    return super.copy(t6), this.instanceCount = t6.instanceCount, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const t6 = super.toJSON(this);
    return t6.instanceCount = this.instanceCount, t6.isInstancedBufferGeometry = true, t6;
  }
};
var hg = class extends Im {
  constructor(t6) {
    super(t6);
  }
  load(t6, e2, i2, n2) {
    const r2 = this, s2 = new zm(r2.manager);
    s2.setPath(r2.path), s2.setRequestHeader(r2.requestHeader), s2.setWithCredentials(r2.withCredentials), s2.load(t6, (function(i3) {
      try {
        e2(r2.parse(JSON.parse(i3)));
      } catch (e3) {
        n2 ? n2(e3) : console.error(e3), r2.manager.itemError(t6);
      }
    }), i2, n2);
  }
  parse(t6) {
    const e2 = {}, i2 = {};
    function n2(t7, n3) {
      if (void 0 !== e2[n3]) return e2[n3];
      const r3 = t7.interleavedBuffers[n3], s3 = (function(t8, e3) {
        if (void 0 !== i2[e3]) return i2[e3];
        const n4 = t8.arrayBuffers, r4 = n4[e3], s4 = new Uint32Array(r4).buffer;
        return i2[e3] = s4, s4;
      })(t7, r3.buffer), o3 = Uo(r3.type, s3), a3 = new wd(o3, r3.stride);
      return a3.uuid = r3.uuid, e2[n3] = a3, a3;
    }
    const r2 = t6.isInstancedBufferGeometry ? new cg() : new Jl(), s2 = t6.data.index;
    if (void 0 !== s2) {
      const t7 = Uo(s2.type, s2.array);
      r2.setIndex(new Il(t7, 1));
    }
    const o2 = t6.data.attributes;
    for (const e3 in o2) {
      const i3 = o2[e3];
      let s3;
      if (i3.isInterleavedBufferAttribute) {
        const e4 = n2(t6.data, i3.data);
        s3 = new Sd(e4, i3.itemSize, i3.offset, i3.normalized);
      } else {
        const t7 = Uo(i3.type, i3.array);
        s3 = new (i3.isInstancedBufferAttribute ? tp : Il)(t7, i3.itemSize, i3.normalized);
      }
      void 0 !== i3.name && (s3.name = i3.name), void 0 !== i3.usage && s3.setUsage(i3.usage), void 0 !== i3.updateRange && (s3.updateRange.offset = i3.updateRange.offset, s3.updateRange.count = i3.updateRange.count), r2.setAttribute(e3, s3);
    }
    const a2 = t6.data.morphAttributes;
    if (a2) for (const e3 in a2) {
      const i3 = a2[e3], s3 = [];
      for (let e4 = 0, r3 = i3.length; e4 < r3; e4++) {
        const r4 = i3[e4];
        let o3;
        if (r4.isInterleavedBufferAttribute) {
          const e5 = n2(t6.data, r4.data);
          o3 = new Sd(e5, r4.itemSize, r4.offset, r4.normalized);
        } else {
          const t7 = Uo(r4.type, r4.array);
          o3 = new Il(t7, r4.itemSize, r4.normalized);
        }
        void 0 !== r4.name && (o3.name = r4.name), s3.push(o3);
      }
      r2.morphAttributes[e3] = s3;
    }
    t6.data.morphTargetsRelative && (r2.morphTargetsRelative = true);
    const l2 = t6.data.groups || t6.data.drawcalls || t6.data.offsets;
    if (void 0 !== l2) for (let t7 = 0, e3 = l2.length; t7 !== e3; ++t7) {
      const e4 = l2[t7];
      r2.addGroup(e4.start, e4.count, e4.materialIndex);
    }
    const c2 = t6.data.boundingSphere;
    if (void 0 !== c2) {
      const t7 = new pa();
      void 0 !== c2.center && t7.fromArray(c2.center), r2.boundingSphere = new za(t7, c2.radius);
    }
    return t6.name && (r2.name = t6.name), t6.userData && (r2.userData = t6.userData), r2;
  }
};
var ug = class extends Im {
  constructor(t6) {
    super(t6);
  }
  load(t6, e2, i2, n2) {
    const r2 = this, s2 = "" === this.path ? lg.extractUrlBase(t6) : this.path;
    this.resourcePath = this.resourcePath || s2;
    const o2 = new zm(this.manager);
    o2.setPath(this.path), o2.setRequestHeader(this.requestHeader), o2.setWithCredentials(this.withCredentials), o2.load(t6, (function(i3) {
      let s3 = null;
      try {
        s3 = JSON.parse(i3);
      } catch (e3) {
        return void 0 !== n2 && n2(e3), void console.error("THREE:ObjectLoader: Can't parse " + t6 + ".", e3.message);
      }
      const o3 = s3.metadata;
      void 0 !== o3 && void 0 !== o3.type && "geometry" !== o3.type.toLowerCase() ? r2.parse(s3, e2) : console.error("THREE.ObjectLoader: Can't load " + t6);
    }), i2, n2);
  }
  async loadAsync(t6, e2) {
    const i2 = "" === this.path ? lg.extractUrlBase(t6) : this.path;
    this.resourcePath = this.resourcePath || i2;
    const n2 = new zm(this.manager);
    n2.setPath(this.path), n2.setRequestHeader(this.requestHeader), n2.setWithCredentials(this.withCredentials);
    const r2 = await n2.loadAsync(t6, e2), s2 = JSON.parse(r2), o2 = s2.metadata;
    if (void 0 === o2 || void 0 === o2.type || "geometry" === o2.type.toLowerCase()) throw new Error("THREE.ObjectLoader: Can't load " + t6);
    return await this.parseAsync(s2);
  }
  parse(t6, e2) {
    const i2 = this.parseAnimations(t6.animations), n2 = this.parseShapes(t6.shapes), r2 = this.parseGeometries(t6.geometries, n2), s2 = this.parseImages(t6.images, (function() {
      void 0 !== e2 && e2(l2);
    })), o2 = this.parseTextures(t6.textures, s2), a2 = this.parseMaterials(t6.materials, o2), l2 = this.parseObject(t6.object, r2, a2, o2, i2), c2 = this.parseSkeletons(t6.skeletons, l2);
    if (this.bindSkeletons(l2, c2), void 0 !== e2) {
      let t7 = false;
      for (const e3 in s2) if (s2[e3].data instanceof HTMLImageElement) {
        t7 = true;
        break;
      }
      false === t7 && e2(l2);
    }
    return l2;
  }
  async parseAsync(t6) {
    const e2 = this.parseAnimations(t6.animations), i2 = this.parseShapes(t6.shapes), n2 = this.parseGeometries(t6.geometries, i2), r2 = await this.parseImagesAsync(t6.images), s2 = this.parseTextures(t6.textures, r2), o2 = this.parseMaterials(t6.materials, s2), a2 = this.parseObject(t6.object, n2, o2, s2, e2), l2 = this.parseSkeletons(t6.skeletons, a2);
    return this.bindSkeletons(a2, l2), a2;
  }
  parseShapes(t6) {
    const e2 = {};
    if (void 0 !== t6) for (let i2 = 0, n2 = t6.length; i2 < n2; i2++) {
      const n3 = new cf().fromJSON(t6[i2]);
      e2[n3.uuid] = n3;
    }
    return e2;
  }
  parseSkeletons(t6, e2) {
    const i2 = {}, n2 = {};
    if (e2.traverse((function(t7) {
      t7.isBone && (n2[t7.uuid] = t7);
    })), void 0 !== t6) for (let e3 = 0, r2 = t6.length; e3 < r2; e3++) {
      const r3 = new Qd().fromJSON(t6[e3], n2);
      i2[r3.uuid] = r3;
    }
    return i2;
  }
  parseGeometries(t6, e2) {
    const i2 = {};
    if (void 0 !== t6) {
      const n2 = new hg();
      for (let r2 = 0, s2 = t6.length; r2 < s2; r2++) {
        let s3;
        const o2 = t6[r2];
        switch (o2.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            s3 = n2.parse(o2);
            break;
          case "Geometry":
            console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");
            break;
          default:
            o2.type in Kf ? s3 = Kf[o2.type].fromJSON(o2, e2) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${o2.type}"`);
        }
        s3.uuid = o2.uuid, void 0 !== o2.name && (s3.name = o2.name), true === s3.isBufferGeometry && void 0 !== o2.userData && (s3.userData = o2.userData), i2[o2.uuid] = s3;
      }
    }
    return i2;
  }
  parseMaterials(t6, e2) {
    const i2 = {}, n2 = {};
    if (void 0 !== t6) {
      const r2 = new ag();
      r2.setTextures(e2);
      for (let e3 = 0, s2 = t6.length; e3 < s2; e3++) {
        const s3 = t6[e3];
        if ("MultiMaterial" === s3.type) {
          const t7 = [];
          for (let e4 = 0; e4 < s3.materials.length; e4++) {
            const n3 = s3.materials[e4];
            void 0 === i2[n3.uuid] && (i2[n3.uuid] = r2.parse(n3)), t7.push(i2[n3.uuid]);
          }
          n2[s3.uuid] = t7;
        } else void 0 === i2[s3.uuid] && (i2[s3.uuid] = r2.parse(s3)), n2[s3.uuid] = i2[s3.uuid];
      }
    }
    return n2;
  }
  parseAnimations(t6) {
    const e2 = {};
    if (void 0 !== t6) for (let i2 = 0; i2 < t6.length; i2++) {
      const n2 = t6[i2], r2 = Am.parse(n2);
      e2[r2.uuid] = r2;
    }
    return e2;
  }
  parseImages(t6, e2) {
    const i2 = this, n2 = {};
    let r2;
    function s2(t7) {
      if ("string" == typeof t7) {
        const e3 = t7;
        return (function(t8) {
          return i2.manager.itemStart(t8), r2.load(t8, (function() {
            i2.manager.itemEnd(t8);
          }), void 0, (function() {
            i2.manager.itemError(t8), i2.manager.itemEnd(t8);
          }));
        })(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(e3) ? e3 : i2.resourcePath + e3);
      }
      return t7.data ? { data: Uo(t7.type, t7.data), width: t7.width, height: t7.height } : null;
    }
    if (void 0 !== t6 && t6.length > 0) {
      const i3 = new Pm(e2);
      r2 = new Bm(i3), r2.setCrossOrigin(this.crossOrigin);
      for (let e3 = 0, i4 = t6.length; e3 < i4; e3++) {
        const i5 = t6[e3], r3 = i5.url;
        if (Array.isArray(r3)) {
          const t7 = [];
          for (let e4 = 0, i6 = r3.length; e4 < i6; e4++) {
            const i7 = s2(r3[e4]);
            null !== i7 && (i7 instanceof HTMLImageElement ? t7.push(i7) : t7.push(new Jd(i7.data, i7.width, i7.height)));
          }
          n2[i5.uuid] = new ea(t7);
        } else {
          const t7 = s2(i5.url);
          n2[i5.uuid] = new ea(t7);
        }
      }
    }
    return n2;
  }
  async parseImagesAsync(t6) {
    const e2 = this, i2 = {};
    let n2;
    async function r2(t7) {
      if ("string" == typeof t7) {
        const i3 = t7, r3 = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(i3) ? i3 : e2.resourcePath + i3;
        return await n2.loadAsync(r3);
      }
      return t7.data ? { data: Uo(t7.type, t7.data), width: t7.width, height: t7.height } : null;
    }
    if (void 0 !== t6 && t6.length > 0) {
      n2 = new Bm(this.manager), n2.setCrossOrigin(this.crossOrigin);
      for (let e3 = 0, n3 = t6.length; e3 < n3; e3++) {
        const n4 = t6[e3], s2 = n4.url;
        if (Array.isArray(s2)) {
          const t7 = [];
          for (let e4 = 0, i3 = s2.length; e4 < i3; e4++) {
            const i4 = s2[e4], n5 = await r2(i4);
            null !== n5 && (n5 instanceof HTMLImageElement ? t7.push(n5) : t7.push(new Jd(n5.data, n5.width, n5.height)));
          }
          i2[n4.uuid] = new ea(t7);
        } else {
          const t7 = await r2(n4.url);
          i2[n4.uuid] = new ea(t7);
        }
      }
    }
    return i2;
  }
  parseTextures(t6, e2) {
    function i2(t7, e3) {
      return "number" == typeof t7 ? t7 : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t7), e3[t7]);
    }
    const n2 = {};
    if (void 0 !== t6) for (let r2 = 0, s2 = t6.length; r2 < s2; r2++) {
      const s3 = t6[r2];
      void 0 === s3.image && console.warn('THREE.ObjectLoader: No "image" specified for', s3.uuid), void 0 === e2[s3.image] && console.warn("THREE.ObjectLoader: Undefined image", s3.image);
      const o2 = e2[s3.image], a2 = o2.data;
      let l2;
      Array.isArray(a2) ? (l2 = new Tc(), 6 === a2.length && (l2.needsUpdate = true)) : (l2 = a2 && a2.data ? new Jd() : new ra(), a2 && (l2.needsUpdate = true)), l2.source = o2, l2.uuid = s3.uuid, void 0 !== s3.name && (l2.name = s3.name), void 0 !== s3.mapping && (l2.mapping = i2(s3.mapping, dg)), void 0 !== s3.offset && l2.offset.fromArray(s3.offset), void 0 !== s3.repeat && l2.repeat.fromArray(s3.repeat), void 0 !== s3.center && l2.center.fromArray(s3.center), void 0 !== s3.rotation && (l2.rotation = s3.rotation), void 0 !== s3.wrap && (l2.wrapS = i2(s3.wrap[0], pg), l2.wrapT = i2(s3.wrap[1], pg)), void 0 !== s3.format && (l2.format = s3.format), void 0 !== s3.type && (l2.type = s3.type), void 0 !== s3.encoding && (l2.encoding = s3.encoding), void 0 !== s3.minFilter && (l2.minFilter = i2(s3.minFilter, fg)), void 0 !== s3.magFilter && (l2.magFilter = i2(s3.magFilter, fg)), void 0 !== s3.anisotropy && (l2.anisotropy = s3.anisotropy), void 0 !== s3.flipY && (l2.flipY = s3.flipY), void 0 !== s3.premultiplyAlpha && (l2.premultiplyAlpha = s3.premultiplyAlpha), void 0 !== s3.unpackAlignment && (l2.unpackAlignment = s3.unpackAlignment), void 0 !== s3.userData && (l2.userData = s3.userData), n2[s3.uuid] = l2;
    }
    return n2;
  }
  parseObject(t6, e2, i2, n2, r2) {
    let s2, o2, a2;
    function l2(t7) {
      return void 0 === e2[t7] && console.warn("THREE.ObjectLoader: Undefined geometry", t7), e2[t7];
    }
    function c2(t7) {
      if (void 0 !== t7) {
        if (Array.isArray(t7)) {
          const e3 = [];
          for (let n3 = 0, r3 = t7.length; n3 < r3; n3++) {
            const r4 = t7[n3];
            void 0 === i2[r4] && console.warn("THREE.ObjectLoader: Undefined material", r4), e3.push(i2[r4]);
          }
          return e3;
        }
        return void 0 === i2[t7] && console.warn("THREE.ObjectLoader: Undefined material", t7), i2[t7];
      }
    }
    function h2(t7) {
      return void 0 === n2[t7] && console.warn("THREE.ObjectLoader: Undefined texture", t7), n2[t7];
    }
    switch (t6.type) {
      case "Scene":
        s2 = new bd(), void 0 !== t6.background && (Number.isInteger(t6.background) ? s2.background = new $o(t6.background) : s2.background = h2(t6.background)), void 0 !== t6.environment && (s2.environment = h2(t6.environment)), void 0 !== t6.fog && ("Fog" === t6.fog.type ? s2.fog = new xd(t6.fog.color, t6.fog.near, t6.fog.far) : "FogExp2" === t6.fog.type && (s2.fog = new yd(t6.fog.color, t6.fog.density)));
        break;
      case "PerspectiveCamera":
        s2 = new _c(t6.fov, t6.aspect, t6.near, t6.far), void 0 !== t6.focus && (s2.focus = t6.focus), void 0 !== t6.zoom && (s2.zoom = t6.zoom), void 0 !== t6.filmGauge && (s2.filmGauge = t6.filmGauge), void 0 !== t6.filmOffset && (s2.filmOffset = t6.filmOffset), void 0 !== t6.view && (s2.view = Object.assign({}, t6.view));
        break;
      case "OrthographicCamera":
        s2 = new qc(t6.left, t6.right, t6.top, t6.bottom, t6.near, t6.far), void 0 !== t6.zoom && (s2.zoom = t6.zoom), void 0 !== t6.view && (s2.view = Object.assign({}, t6.view));
        break;
      case "AmbientLight":
        s2 = new ng(t6.color, t6.intensity);
        break;
      case "DirectionalLight":
        s2 = new ig(t6.color, t6.intensity);
        break;
      case "PointLight":
        s2 = new tg(t6.color, t6.intensity, t6.distance, t6.decay);
        break;
      case "RectAreaLight":
        s2 = new rg(t6.color, t6.intensity, t6.width, t6.height);
        break;
      case "SpotLight":
        s2 = new Zm(t6.color, t6.intensity, t6.distance, t6.angle, t6.penumbra, t6.decay);
        break;
      case "HemisphereLight":
        s2 = new jm(t6.color, t6.groundColor, t6.intensity);
        break;
      case "LightProbe":
        s2 = new og().fromJSON(t6);
        break;
      case "SkinnedMesh":
        o2 = l2(t6.geometry), a2 = c2(t6.material), s2 = new Yd(o2, a2), void 0 !== t6.bindMode && (s2.bindMode = t6.bindMode), void 0 !== t6.bindMatrix && s2.bindMatrix.fromArray(t6.bindMatrix), void 0 !== t6.skeleton && (s2.skeleton = t6.skeleton);
        break;
      case "Mesh":
        o2 = l2(t6.geometry), a2 = c2(t6.material), s2 = new fc(o2, a2);
        break;
      case "InstancedMesh":
        o2 = l2(t6.geometry), a2 = c2(t6.material);
        const e3 = t6.count, i3 = t6.instanceMatrix, n3 = t6.instanceColor;
        s2 = new sp(o2, a2, e3), s2.instanceMatrix = new tp(new Float32Array(i3.array), 16), void 0 !== n3 && (s2.instanceColor = new tp(new Float32Array(n3.array), n3.itemSize));
        break;
      case "LOD":
        s2 = new Vd();
        break;
      case "Line":
        s2 = new dp(l2(t6.geometry), c2(t6.material));
        break;
      case "LineLoop":
        s2 = new gp(l2(t6.geometry), c2(t6.material));
        break;
      case "LineSegments":
        s2 = new mp(l2(t6.geometry), c2(t6.material));
        break;
      case "PointCloud":
      case "Points":
        s2 = new _p(l2(t6.geometry), c2(t6.material));
        break;
      case "Sprite":
        s2 = new Bd(c2(t6.material));
        break;
      case "Group":
        s2 = new cd();
        break;
      case "Bone":
        s2 = new Zd();
        break;
      default:
        s2 = new ml();
    }
    if (s2.uuid = t6.uuid, void 0 !== t6.name && (s2.name = t6.name), void 0 !== t6.matrix ? (s2.matrix.fromArray(t6.matrix), void 0 !== t6.matrixAutoUpdate && (s2.matrixAutoUpdate = t6.matrixAutoUpdate), s2.matrixAutoUpdate && s2.matrix.decompose(s2.position, s2.quaternion, s2.scale)) : (void 0 !== t6.position && s2.position.fromArray(t6.position), void 0 !== t6.rotation && s2.rotation.fromArray(t6.rotation), void 0 !== t6.quaternion && s2.quaternion.fromArray(t6.quaternion), void 0 !== t6.scale && s2.scale.fromArray(t6.scale)), void 0 !== t6.castShadow && (s2.castShadow = t6.castShadow), void 0 !== t6.receiveShadow && (s2.receiveShadow = t6.receiveShadow), t6.shadow && (void 0 !== t6.shadow.bias && (s2.shadow.bias = t6.shadow.bias), void 0 !== t6.shadow.normalBias && (s2.shadow.normalBias = t6.shadow.normalBias), void 0 !== t6.shadow.radius && (s2.shadow.radius = t6.shadow.radius), void 0 !== t6.shadow.mapSize && s2.shadow.mapSize.fromArray(t6.shadow.mapSize), void 0 !== t6.shadow.camera && (s2.shadow.camera = this.parseObject(t6.shadow.camera))), void 0 !== t6.visible && (s2.visible = t6.visible), void 0 !== t6.frustumCulled && (s2.frustumCulled = t6.frustumCulled), void 0 !== t6.renderOrder && (s2.renderOrder = t6.renderOrder), void 0 !== t6.userData && (s2.userData = t6.userData), void 0 !== t6.layers && (s2.layers.mask = t6.layers), void 0 !== t6.children) {
      const o3 = t6.children;
      for (let t7 = 0; t7 < o3.length; t7++) s2.add(this.parseObject(o3[t7], e2, i2, n2, r2));
    }
    if (void 0 !== t6.animations) {
      const e3 = t6.animations;
      for (let t7 = 0; t7 < e3.length; t7++) {
        const i3 = e3[t7];
        s2.animations.push(r2[i3]);
      }
    }
    if ("LOD" === t6.type) {
      void 0 !== t6.autoUpdate && (s2.autoUpdate = t6.autoUpdate);
      const e3 = t6.levels;
      for (let t7 = 0; t7 < e3.length; t7++) {
        const i3 = e3[t7], n3 = s2.getObjectByProperty("uuid", i3.object);
        void 0 !== n3 && s2.addLevel(n3, i3.distance);
      }
    }
    return s2;
  }
  bindSkeletons(t6, e2) {
    0 !== Object.keys(e2).length && t6.traverse((function(t7) {
      if (true === t7.isSkinnedMesh && void 0 !== t7.skeleton) {
        const i2 = e2[t7.skeleton];
        void 0 === i2 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", t7.skeleton) : t7.bind(i2, t7.bindMatrix);
      }
    }));
  }
};
var dg = { UVMapping: hr, CubeReflectionMapping: ur, CubeRefractionMapping: dr, EquirectangularReflectionMapping: pr, EquirectangularRefractionMapping: fr, CubeUVReflectionMapping: mr };
var pg = { RepeatWrapping: gr, ClampToEdgeWrapping: vr, MirroredRepeatWrapping: yr };
var fg = { NearestFilter: xr, NearestMipmapNearestFilter: br, NearestMipmapLinearFilter: _r, LinearFilter: Mr, LinearMipmapNearestFilter: Tr, LinearMipmapLinearFilter: Ar };
var mg = class extends Im {
  constructor(t6) {
    super(t6), this.isImageBitmapLoader = true, "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(t6) {
    return this.options = t6, this;
  }
  load(t6, e2, i2, n2) {
    void 0 === t6 && (t6 = ""), void 0 !== this.path && (t6 = this.path + t6), t6 = this.manager.resolveURL(t6);
    const r2 = this, s2 = Rm.get(t6);
    if (void 0 !== s2) return r2.manager.itemStart(t6), setTimeout((function() {
      e2 && e2(s2), r2.manager.itemEnd(t6);
    }), 0), s2;
    const o2 = {};
    o2.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", o2.headers = this.requestHeader, fetch(t6, o2).then((function(t7) {
      return t7.blob();
    })).then((function(t7) {
      return createImageBitmap(t7, Object.assign(r2.options, { colorSpaceConversion: "none" }));
    })).then((function(i3) {
      Rm.add(t6, i3), e2 && e2(i3), r2.manager.itemEnd(t6);
    })).catch((function(e3) {
      n2 && n2(e3), r2.manager.itemError(t6), r2.manager.itemEnd(t6);
    })), r2.manager.itemStart(t6);
  }
};
var gg;
var vg = { getContext: function() {
  return void 0 === gg && (gg = new (window.AudioContext || window.webkitAudioContext)()), gg;
}, setContext: function(t6) {
  gg = t6;
} };
var yg = class extends Im {
  constructor(t6) {
    super(t6);
  }
  load(t6, e2, i2, n2) {
    const r2 = this, s2 = new zm(this.manager);
    s2.setResponseType("arraybuffer"), s2.setPath(this.path), s2.setRequestHeader(this.requestHeader), s2.setWithCredentials(this.withCredentials), s2.load(t6, (function(i3) {
      try {
        const t7 = i3.slice(0);
        vg.getContext().decodeAudioData(t7, (function(t8) {
          e2(t8);
        }));
      } catch (e3) {
        n2 ? n2(e3) : console.error(e3), r2.manager.itemError(t6);
      }
    }), i2, n2);
  }
};
var xg = class extends og {
  constructor(t6, e2, i2 = 1) {
    super(void 0, i2), this.isHemisphereLightProbe = true;
    const n2 = new $o().set(t6), r2 = new $o().set(e2), s2 = new pa(n2.r, n2.g, n2.b), o2 = new pa(r2.r, r2.g, r2.b), a2 = Math.sqrt(Math.PI), l2 = a2 * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(s2).add(o2).multiplyScalar(a2), this.sh.coefficients[1].copy(s2).sub(o2).multiplyScalar(l2);
  }
};
var bg = class extends og {
  constructor(t6, e2 = 1) {
    super(void 0, e2), this.isAmbientLightProbe = true;
    const i2 = new $o().set(t6);
    this.sh.coefficients[0].set(i2.r, i2.g, i2.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  }
};
var wg = new Ga();
var _g = new Ga();
var Sg = new Ga();
var Mg = class {
  constructor() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new _c(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = false, this.cameraR = new _c(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = false, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null };
  }
  update(t6) {
    const e2 = this._cache;
    if (e2.focus !== t6.focus || e2.fov !== t6.fov || e2.aspect !== t6.aspect * this.aspect || e2.near !== t6.near || e2.far !== t6.far || e2.zoom !== t6.zoom || e2.eyeSep !== this.eyeSep) {
      e2.focus = t6.focus, e2.fov = t6.fov, e2.aspect = t6.aspect * this.aspect, e2.near = t6.near, e2.far = t6.far, e2.zoom = t6.zoom, e2.eyeSep = this.eyeSep, Sg.copy(t6.projectionMatrix);
      const i2 = e2.eyeSep / 2, n2 = i2 * e2.near / e2.focus, r2 = e2.near * Math.tan(Eo * e2.fov * 0.5) / e2.zoom;
      let s2, o2;
      _g.elements[12] = -i2, wg.elements[12] = i2, s2 = -r2 * e2.aspect + n2, o2 = r2 * e2.aspect + n2, Sg.elements[0] = 2 * e2.near / (o2 - s2), Sg.elements[8] = (o2 + s2) / (o2 - s2), this.cameraL.projectionMatrix.copy(Sg), s2 = -r2 * e2.aspect - n2, o2 = r2 * e2.aspect - n2, Sg.elements[0] = 2 * e2.near / (o2 - s2), Sg.elements[8] = (o2 + s2) / (o2 - s2), this.cameraR.projectionMatrix.copy(Sg);
    }
    this.cameraL.matrixWorld.copy(t6.matrixWorld).multiply(_g), this.cameraR.matrixWorld.copy(t6.matrixWorld).multiply(wg);
  }
};
var Tg = class {
  constructor(t6 = true) {
    this.autoStart = t6, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = false;
  }
  start() {
    this.startTime = Eg(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = true;
  }
  stop() {
    this.getElapsedTime(), this.running = false, this.autoStart = false;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let t6 = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const e2 = Eg();
      t6 = (e2 - this.oldTime) / 1e3, this.oldTime = e2, this.elapsedTime += t6;
    }
    return t6;
  }
};
function Eg() {
  return ("undefined" == typeof performance ? Date : performance).now();
}
var Ag = new pa();
var Cg = new da();
var Rg = new pa();
var Pg = new pa();
var Lg = class extends ml {
  constructor() {
    super(), this.type = "AudioListener", this.context = vg.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Tg();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(t6) {
    return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t6, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(t6) {
    return this.gain.gain.setTargetAtTime(t6, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(t6) {
    super.updateMatrixWorld(t6);
    const e2 = this.context.listener, i2 = this.up;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Ag, Cg, Rg), Pg.set(0, 0, -1).applyQuaternion(Cg), e2.positionX) {
      const t7 = this.context.currentTime + this.timeDelta;
      e2.positionX.linearRampToValueAtTime(Ag.x, t7), e2.positionY.linearRampToValueAtTime(Ag.y, t7), e2.positionZ.linearRampToValueAtTime(Ag.z, t7), e2.forwardX.linearRampToValueAtTime(Pg.x, t7), e2.forwardY.linearRampToValueAtTime(Pg.y, t7), e2.forwardZ.linearRampToValueAtTime(Pg.z, t7), e2.upX.linearRampToValueAtTime(i2.x, t7), e2.upY.linearRampToValueAtTime(i2.y, t7), e2.upZ.linearRampToValueAtTime(i2.z, t7);
    } else e2.setPosition(Ag.x, Ag.y, Ag.z), e2.setOrientation(Pg.x, Pg.y, Pg.z, i2.x, i2.y, i2.z);
  }
};
var Ig = class extends ml {
  constructor(t6) {
    super(), this.type = "Audio", this.listener = t6, this.context = t6.context, this.gain = this.context.createGain(), this.gain.connect(t6.getInput()), this.autoplay = false, this.buffer = null, this.detune = 0, this.loop = false, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = false, this.hasPlaybackControl = true, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = false, this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(t6) {
    return this.hasPlaybackControl = false, this.sourceType = "audioNode", this.source = t6, this.connect(), this;
  }
  setMediaElementSource(t6) {
    return this.hasPlaybackControl = false, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t6), this.connect(), this;
  }
  setMediaStreamSource(t6) {
    return this.hasPlaybackControl = false, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t6), this.connect(), this;
  }
  setBuffer(t6) {
    return this.buffer = t6, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  play(t6 = 0) {
    if (true === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
    if (false === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
    this._startedAt = this.context.currentTime + t6;
    const e2 = this.context.createBufferSource();
    return e2.buffer = this.buffer, e2.loop = this.loop, e2.loopStart = this.loopStart, e2.loopEnd = this.loopEnd, e2.onended = this.onEnded.bind(this), e2.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = true, this.source = e2, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  pause() {
    if (false !== this.hasPlaybackControl) return true === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, true === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = false), this;
    console.warn("THREE.Audio: this Audio has no playback control.");
  }
  stop() {
    if (false !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = false, this;
    console.warn("THREE.Audio: this Audio has no playback control.");
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let t6 = 1, e2 = this.filters.length; t6 < e2; t6++) this.filters[t6 - 1].connect(this.filters[t6]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return this._connected = true, this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let t6 = 1, e2 = this.filters.length; t6 < e2; t6++) this.filters[t6 - 1].disconnect(this.filters[t6]);
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else this.source.disconnect(this.getOutput());
    return this._connected = false, this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(t6) {
    return t6 || (t6 = []), true === this._connected ? (this.disconnect(), this.filters = t6.slice(), this.connect()) : this.filters = t6.slice(), this;
  }
  setDetune(t6) {
    if (this.detune = t6, void 0 !== this.source.detune) return true === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(t6) {
    return this.setFilters(t6 ? [t6] : []);
  }
  setPlaybackRate(t6) {
    if (false !== this.hasPlaybackControl) return this.playbackRate = t6, true === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
    console.warn("THREE.Audio: this Audio has no playback control.");
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = false;
  }
  getLoop() {
    return false === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), false) : this.loop;
  }
  setLoop(t6) {
    if (false !== this.hasPlaybackControl) return this.loop = t6, true === this.isPlaying && (this.source.loop = this.loop), this;
    console.warn("THREE.Audio: this Audio has no playback control.");
  }
  setLoopStart(t6) {
    return this.loopStart = t6, this;
  }
  setLoopEnd(t6) {
    return this.loopEnd = t6, this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(t6) {
    return this.gain.gain.setTargetAtTime(t6, this.context.currentTime, 0.01), this;
  }
};
var Dg = new pa();
var Og = new da();
var zg = new pa();
var Fg = new pa();
var Ng = class extends Ig {
  constructor(t6) {
    super(t6), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(t6) {
    return this.panner.refDistance = t6, this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(t6) {
    return this.panner.rolloffFactor = t6, this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(t6) {
    return this.panner.distanceModel = t6, this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(t6) {
    return this.panner.maxDistance = t6, this;
  }
  setDirectionalCone(t6, e2, i2) {
    return this.panner.coneInnerAngle = t6, this.panner.coneOuterAngle = e2, this.panner.coneOuterGain = i2, this;
  }
  updateMatrixWorld(t6) {
    if (super.updateMatrixWorld(t6), true === this.hasPlaybackControl && false === this.isPlaying) return;
    this.matrixWorld.decompose(Dg, Og, zg), Fg.set(0, 0, 1).applyQuaternion(Og);
    const e2 = this.panner;
    if (e2.positionX) {
      const t7 = this.context.currentTime + this.listener.timeDelta;
      e2.positionX.linearRampToValueAtTime(Dg.x, t7), e2.positionY.linearRampToValueAtTime(Dg.y, t7), e2.positionZ.linearRampToValueAtTime(Dg.z, t7), e2.orientationX.linearRampToValueAtTime(Fg.x, t7), e2.orientationY.linearRampToValueAtTime(Fg.y, t7), e2.orientationZ.linearRampToValueAtTime(Fg.z, t7);
    } else e2.setPosition(Dg.x, Dg.y, Dg.z), e2.setOrientation(Fg.x, Fg.y, Fg.z);
  }
};
var Bg = class {
  constructor(t6, e2 = 2048) {
    this.analyser = t6.context.createAnalyser(), this.analyser.fftSize = e2, this.data = new Uint8Array(this.analyser.frequencyBinCount), t6.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let t6 = 0;
    const e2 = this.getFrequencyData();
    for (let i2 = 0; i2 < e2.length; i2++) t6 += e2[i2];
    return t6 / e2.length;
  }
};
var kg = class {
  constructor(t6, e2, i2) {
    let n2, r2, s2;
    switch (this.binding = t6, this.valueSize = i2, e2) {
      case "quaternion":
        n2 = this._slerp, r2 = this._slerpAdditive, s2 = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * i2), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        n2 = this._select, r2 = this._select, s2 = this._setAdditiveIdentityOther, this.buffer = new Array(5 * i2);
        break;
      default:
        n2 = this._lerp, r2 = this._lerpAdditive, s2 = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * i2);
    }
    this._mixBufferRegion = n2, this._mixBufferRegionAdditive = r2, this._setIdentity = s2, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  accumulate(t6, e2) {
    const i2 = this.buffer, n2 = this.valueSize, r2 = t6 * n2 + n2;
    let s2 = this.cumulativeWeight;
    if (0 === s2) {
      for (let t7 = 0; t7 !== n2; ++t7) i2[r2 + t7] = i2[t7];
      s2 = e2;
    } else {
      s2 += e2;
      const t7 = e2 / s2;
      this._mixBufferRegion(i2, r2, 0, t7, n2);
    }
    this.cumulativeWeight = s2;
  }
  accumulateAdditive(t6) {
    const e2 = this.buffer, i2 = this.valueSize, n2 = i2 * this._addIndex;
    0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e2, n2, 0, t6, i2), this.cumulativeWeightAdditive += t6;
  }
  apply(t6) {
    const e2 = this.valueSize, i2 = this.buffer, n2 = t6 * e2 + e2, r2 = this.cumulativeWeight, s2 = this.cumulativeWeightAdditive, o2 = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r2 < 1) {
      const t7 = e2 * this._origIndex;
      this._mixBufferRegion(i2, n2, t7, 1 - r2, e2);
    }
    s2 > 0 && this._mixBufferRegionAdditive(i2, n2, this._addIndex * e2, 1, e2);
    for (let t7 = e2, r3 = e2 + e2; t7 !== r3; ++t7) if (i2[t7] !== i2[t7 + e2]) {
      o2.setValue(i2, n2);
      break;
    }
  }
  saveOriginalState() {
    const t6 = this.binding, e2 = this.buffer, i2 = this.valueSize, n2 = i2 * this._origIndex;
    t6.getValue(e2, n2);
    for (let t7 = i2, r2 = n2; t7 !== r2; ++t7) e2[t7] = e2[n2 + t7 % i2];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  restoreOriginalState() {
    const t6 = 3 * this.valueSize;
    this.binding.setValue(this.buffer, t6);
  }
  _setAdditiveIdentityNumeric() {
    const t6 = this._addIndex * this.valueSize, e2 = t6 + this.valueSize;
    for (let i2 = t6; i2 < e2; i2++) this.buffer[i2] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const t6 = this._origIndex * this.valueSize, e2 = this._addIndex * this.valueSize;
    for (let i2 = 0; i2 < this.valueSize; i2++) this.buffer[e2 + i2] = this.buffer[t6 + i2];
  }
  _select(t6, e2, i2, n2, r2) {
    if (n2 >= 0.5) for (let n3 = 0; n3 !== r2; ++n3) t6[e2 + n3] = t6[i2 + n3];
  }
  _slerp(t6, e2, i2, n2) {
    da.slerpFlat(t6, e2, t6, e2, t6, i2, n2);
  }
  _slerpAdditive(t6, e2, i2, n2, r2) {
    const s2 = this._workIndex * r2;
    da.multiplyQuaternionsFlat(t6, s2, t6, e2, t6, i2), da.slerpFlat(t6, e2, t6, e2, t6, s2, n2);
  }
  _lerp(t6, e2, i2, n2, r2) {
    const s2 = 1 - n2;
    for (let o2 = 0; o2 !== r2; ++o2) {
      const r3 = e2 + o2;
      t6[r3] = t6[r3] * s2 + t6[i2 + o2] * n2;
    }
  }
  _lerpAdditive(t6, e2, i2, n2, r2) {
    for (let s2 = 0; s2 !== r2; ++s2) {
      const r3 = e2 + s2;
      t6[r3] = t6[r3] + t6[i2 + s2] * n2;
    }
  }
};
var Ug = "\\[\\]\\.:\\/";
var Hg = new RegExp("[" + Ug + "]", "g");
var Vg = "[^" + Ug + "]";
var jg = "[^" + Ug.replace("\\.", "") + "]";
var Gg = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", Vg) + /(WCOD+)?/.source.replace("WCOD", jg) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Vg) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Vg) + "$");
var Wg = ["material", "materials", "bones"];
var qg = class _qg {
  constructor(t6, e2, i2) {
    this.path = e2, this.parsedPath = i2 || _qg.parseTrackName(e2), this.node = _qg.findNode(t6, this.parsedPath.nodeName) || t6, this.rootNode = t6, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(t6, e2, i2) {
    return t6 && t6.isAnimationObjectGroup ? new _qg.Composite(t6, e2, i2) : new _qg(t6, e2, i2);
  }
  static sanitizeNodeName(t6) {
    return t6.replace(/\s/g, "_").replace(Hg, "");
  }
  static parseTrackName(t6) {
    const e2 = Gg.exec(t6);
    if (null === e2) throw new Error("PropertyBinding: Cannot parse trackName: " + t6);
    const i2 = { nodeName: e2[2], objectName: e2[3], objectIndex: e2[4], propertyName: e2[5], propertyIndex: e2[6] }, n2 = i2.nodeName && i2.nodeName.lastIndexOf(".");
    if (void 0 !== n2 && -1 !== n2) {
      const t7 = i2.nodeName.substring(n2 + 1);
      -1 !== Wg.indexOf(t7) && (i2.nodeName = i2.nodeName.substring(0, n2), i2.objectName = t7);
    }
    if (null === i2.propertyName || 0 === i2.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t6);
    return i2;
  }
  static findNode(t6, e2) {
    if (void 0 === e2 || "" === e2 || "." === e2 || -1 === e2 || e2 === t6.name || e2 === t6.uuid) return t6;
    if (t6.skeleton) {
      const i2 = t6.skeleton.getBoneByName(e2);
      if (void 0 !== i2) return i2;
    }
    if (t6.children) {
      const i2 = function(t7) {
        for (let n3 = 0; n3 < t7.length; n3++) {
          const r2 = t7[n3];
          if (r2.name === e2 || r2.uuid === e2) return r2;
          const s2 = i2(r2.children);
          if (s2) return s2;
        }
        return null;
      }, n2 = i2(t6.children);
      if (n2) return n2;
    }
    return null;
  }
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  _getValue_direct(t6, e2) {
    t6[e2] = this.targetObject[this.propertyName];
  }
  _getValue_array(t6, e2) {
    const i2 = this.resolvedProperty;
    for (let n2 = 0, r2 = i2.length; n2 !== r2; ++n2) t6[e2++] = i2[n2];
  }
  _getValue_arrayElement(t6, e2) {
    t6[e2] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(t6, e2) {
    this.resolvedProperty.toArray(t6, e2);
  }
  _setValue_direct(t6, e2) {
    this.targetObject[this.propertyName] = t6[e2];
  }
  _setValue_direct_setNeedsUpdate(t6, e2) {
    this.targetObject[this.propertyName] = t6[e2], this.targetObject.needsUpdate = true;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(t6, e2) {
    this.targetObject[this.propertyName] = t6[e2], this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_array(t6, e2) {
    const i2 = this.resolvedProperty;
    for (let n2 = 0, r2 = i2.length; n2 !== r2; ++n2) i2[n2] = t6[e2++];
  }
  _setValue_array_setNeedsUpdate(t6, e2) {
    const i2 = this.resolvedProperty;
    for (let n2 = 0, r2 = i2.length; n2 !== r2; ++n2) i2[n2] = t6[e2++];
    this.targetObject.needsUpdate = true;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(t6, e2) {
    const i2 = this.resolvedProperty;
    for (let n2 = 0, r2 = i2.length; n2 !== r2; ++n2) i2[n2] = t6[e2++];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_arrayElement(t6, e2) {
    this.resolvedProperty[this.propertyIndex] = t6[e2];
  }
  _setValue_arrayElement_setNeedsUpdate(t6, e2) {
    this.resolvedProperty[this.propertyIndex] = t6[e2], this.targetObject.needsUpdate = true;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(t6, e2) {
    this.resolvedProperty[this.propertyIndex] = t6[e2], this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_fromArray(t6, e2) {
    this.resolvedProperty.fromArray(t6, e2);
  }
  _setValue_fromArray_setNeedsUpdate(t6, e2) {
    this.resolvedProperty.fromArray(t6, e2), this.targetObject.needsUpdate = true;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(t6, e2) {
    this.resolvedProperty.fromArray(t6, e2), this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _getValue_unbound(t6, e2) {
    this.bind(), this.getValue(t6, e2);
  }
  _setValue_unbound(t6, e2) {
    this.bind(), this.setValue(t6, e2);
  }
  bind() {
    let t6 = this.node;
    const e2 = this.parsedPath, i2 = e2.objectName, n2 = e2.propertyName;
    let r2 = e2.propertyIndex;
    if (t6 || (t6 = _qg.findNode(this.rootNode, e2.nodeName) || this.rootNode, this.node = t6), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t6) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
    if (i2) {
      let n3 = e2.objectIndex;
      switch (i2) {
        case "materials":
          if (!t6.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
          if (!t6.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
          t6 = t6.material.materials;
          break;
        case "bones":
          if (!t6.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
          t6 = t6.skeleton.bones;
          for (let e3 = 0; e3 < t6.length; e3++) if (t6[e3].name === n3) {
            n3 = e3;
            break;
          }
          break;
        default:
          if (void 0 === t6[i2]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
          t6 = t6[i2];
      }
      if (void 0 !== n3) {
        if (void 0 === t6[n3]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t6);
        t6 = t6[n3];
      }
    }
    const s2 = t6[n2];
    if (void 0 === s2) {
      const i3 = e2.nodeName;
      return void console.error("THREE.PropertyBinding: Trying to update property for track: " + i3 + "." + n2 + " but it wasn't found.", t6);
    }
    let o2 = this.Versioning.None;
    this.targetObject = t6, void 0 !== t6.needsUpdate ? o2 = this.Versioning.NeedsUpdate : void 0 !== t6.matrixWorldNeedsUpdate && (o2 = this.Versioning.MatrixWorldNeedsUpdate);
    let a2 = this.BindingType.Direct;
    if (void 0 !== r2) {
      if ("morphTargetInfluences" === n2) {
        if (!t6.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
        if (!t6.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
        void 0 !== t6.morphTargetDictionary[r2] && (r2 = t6.morphTargetDictionary[r2]);
      }
      a2 = this.BindingType.ArrayElement, this.resolvedProperty = s2, this.propertyIndex = r2;
    } else void 0 !== s2.fromArray && void 0 !== s2.toArray ? (a2 = this.BindingType.HasFromToArray, this.resolvedProperty = s2) : Array.isArray(s2) ? (a2 = this.BindingType.EntireArray, this.resolvedProperty = s2) : this.propertyName = n2;
    this.getValue = this.GetterByBindingType[a2], this.setValue = this.SetterByBindingTypeAndVersioning[a2][o2];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
};
qg.Composite = class {
  constructor(t6, e2, i2) {
    const n2 = i2 || qg.parseTrackName(e2);
    this._targetGroup = t6, this._bindings = t6.subscribe_(e2, n2);
  }
  getValue(t6, e2) {
    this.bind();
    const i2 = this._targetGroup.nCachedObjects_, n2 = this._bindings[i2];
    void 0 !== n2 && n2.getValue(t6, e2);
  }
  setValue(t6, e2) {
    const i2 = this._bindings;
    for (let n2 = this._targetGroup.nCachedObjects_, r2 = i2.length; n2 !== r2; ++n2) i2[n2].setValue(t6, e2);
  }
  bind() {
    const t6 = this._bindings;
    for (let e2 = this._targetGroup.nCachedObjects_, i2 = t6.length; e2 !== i2; ++e2) t6[e2].bind();
  }
  unbind() {
    const t6 = this._bindings;
    for (let e2 = this._targetGroup.nCachedObjects_, i2 = t6.length; e2 !== i2; ++e2) t6[e2].unbind();
  }
}, qg.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, qg.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, qg.prototype.GetterByBindingType = [qg.prototype._getValue_direct, qg.prototype._getValue_array, qg.prototype._getValue_arrayElement, qg.prototype._getValue_toArray], qg.prototype.SetterByBindingTypeAndVersioning = [[qg.prototype._setValue_direct, qg.prototype._setValue_direct_setNeedsUpdate, qg.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [qg.prototype._setValue_array, qg.prototype._setValue_array_setNeedsUpdate, qg.prototype._setValue_array_setMatrixWorldNeedsUpdate], [qg.prototype._setValue_arrayElement, qg.prototype._setValue_arrayElement_setNeedsUpdate, qg.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [qg.prototype._setValue_fromArray, qg.prototype._setValue_fromArray_setNeedsUpdate, qg.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
var Xg = class {
  constructor() {
    this.isAnimationObjectGroup = true, this.uuid = Co(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    const t6 = {};
    this._indicesByUUID = t6;
    for (let e3 = 0, i2 = arguments.length; e3 !== i2; ++e3) t6[arguments[e3].uuid] = e3;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    const e2 = this;
    this.stats = { objects: { get total() {
      return e2._objects.length;
    }, get inUse() {
      return this.total - e2.nCachedObjects_;
    } }, get bindingsPerObject() {
      return e2._bindings.length;
    } };
  }
  add() {
    const t6 = this._objects, e2 = this._indicesByUUID, i2 = this._paths, n2 = this._parsedPaths, r2 = this._bindings, s2 = r2.length;
    let o2, a2 = t6.length, l2 = this.nCachedObjects_;
    for (let c2 = 0, h2 = arguments.length; c2 !== h2; ++c2) {
      const h3 = arguments[c2], u2 = h3.uuid;
      let d2 = e2[u2];
      if (void 0 === d2) {
        d2 = a2++, e2[u2] = d2, t6.push(h3);
        for (let t7 = 0, e3 = s2; t7 !== e3; ++t7) r2[t7].push(new qg(h3, i2[t7], n2[t7]));
      } else if (d2 < l2) {
        o2 = t6[d2];
        const a3 = --l2, c3 = t6[a3];
        e2[c3.uuid] = d2, t6[d2] = c3, e2[u2] = a3, t6[a3] = h3;
        for (let t7 = 0, e3 = s2; t7 !== e3; ++t7) {
          const e4 = r2[t7], s3 = e4[a3];
          let o3 = e4[d2];
          e4[d2] = s3, void 0 === o3 && (o3 = new qg(h3, i2[t7], n2[t7])), e4[a3] = o3;
        }
      } else t6[d2] !== o2 && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = l2;
  }
  remove() {
    const t6 = this._objects, e2 = this._indicesByUUID, i2 = this._bindings, n2 = i2.length;
    let r2 = this.nCachedObjects_;
    for (let s2 = 0, o2 = arguments.length; s2 !== o2; ++s2) {
      const o3 = arguments[s2], a2 = o3.uuid, l2 = e2[a2];
      if (void 0 !== l2 && l2 >= r2) {
        const s3 = r2++, c2 = t6[s3];
        e2[c2.uuid] = l2, t6[l2] = c2, e2[a2] = s3, t6[s3] = o3;
        for (let t7 = 0, e3 = n2; t7 !== e3; ++t7) {
          const e4 = i2[t7], n3 = e4[s3], r3 = e4[l2];
          e4[l2] = n3, e4[s3] = r3;
        }
      }
    }
    this.nCachedObjects_ = r2;
  }
  uncache() {
    const t6 = this._objects, e2 = this._indicesByUUID, i2 = this._bindings, n2 = i2.length;
    let r2 = this.nCachedObjects_, s2 = t6.length;
    for (let o2 = 0, a2 = arguments.length; o2 !== a2; ++o2) {
      const a3 = arguments[o2].uuid, l2 = e2[a3];
      if (void 0 !== l2) if (delete e2[a3], l2 < r2) {
        const o3 = --r2, a4 = t6[o3], c2 = --s2, h2 = t6[c2];
        e2[a4.uuid] = l2, t6[l2] = a4, e2[h2.uuid] = o3, t6[o3] = h2, t6.pop();
        for (let t7 = 0, e3 = n2; t7 !== e3; ++t7) {
          const e4 = i2[t7], n3 = e4[o3], r3 = e4[c2];
          e4[l2] = n3, e4[o3] = r3, e4.pop();
        }
      } else {
        const r3 = --s2, o3 = t6[r3];
        r3 > 0 && (e2[o3.uuid] = l2), t6[l2] = o3, t6.pop();
        for (let t7 = 0, e3 = n2; t7 !== e3; ++t7) {
          const e4 = i2[t7];
          e4[l2] = e4[r3], e4.pop();
        }
      }
    }
    this.nCachedObjects_ = r2;
  }
  subscribe_(t6, e2) {
    const i2 = this._bindingsIndicesByPath;
    let n2 = i2[t6];
    const r2 = this._bindings;
    if (void 0 !== n2) return r2[n2];
    const s2 = this._paths, o2 = this._parsedPaths, a2 = this._objects, l2 = a2.length, c2 = this.nCachedObjects_, h2 = new Array(l2);
    n2 = r2.length, i2[t6] = n2, s2.push(t6), o2.push(e2), r2.push(h2);
    for (let i3 = c2, n3 = a2.length; i3 !== n3; ++i3) {
      const n4 = a2[i3];
      h2[i3] = new qg(n4, t6, e2);
    }
    return h2;
  }
  unsubscribe_(t6) {
    const e2 = this._bindingsIndicesByPath, i2 = e2[t6];
    if (void 0 !== i2) {
      const n2 = this._paths, r2 = this._parsedPaths, s2 = this._bindings, o2 = s2.length - 1, a2 = s2[o2];
      e2[t6[o2]] = i2, s2[i2] = a2, s2.pop(), r2[i2] = r2[o2], r2.pop(), n2[i2] = n2[o2], n2.pop();
    }
  }
};
var Yg = class {
  constructor(t6, e2, i2 = null, n2 = e2.blendMode) {
    this._mixer = t6, this._clip = e2, this._localRoot = i2, this.blendMode = n2;
    const r2 = e2.tracks, s2 = r2.length, o2 = new Array(s2), a2 = { endingStart: Ps, endingEnd: Ps };
    for (let t7 = 0; t7 !== s2; ++t7) {
      const e3 = r2[t7].createInterpolant(null);
      o2[t7] = e3, e3.settings = a2;
    }
    this._interpolantSettings = a2, this._interpolants = o2, this._propertyBindings = new Array(s2), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = Ts, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = false, this.enabled = true, this.clampWhenFinished = false, this.zeroSlopeAtStart = true, this.zeroSlopeAtEnd = true;
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = false, this.enabled = true, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(t6) {
    return this._startTime = t6, this;
  }
  setLoop(t6, e2) {
    return this.loop = t6, this.repetitions = e2, this;
  }
  setEffectiveWeight(t6) {
    return this.weight = t6, this._effectiveWeight = this.enabled ? t6 : 0, this.stopFading();
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(t6) {
    return this._scheduleFading(t6, 0, 1);
  }
  fadeOut(t6) {
    return this._scheduleFading(t6, 1, 0);
  }
  crossFadeFrom(t6, e2, i2) {
    if (t6.fadeOut(e2), this.fadeIn(e2), i2) {
      const i3 = this._clip.duration, n2 = t6._clip.duration, r2 = n2 / i3, s2 = i3 / n2;
      t6.warp(1, r2, e2), this.warp(s2, 1, e2);
    }
    return this;
  }
  crossFadeTo(t6, e2, i2) {
    return t6.crossFadeFrom(this, e2, i2);
  }
  stopFading() {
    const t6 = this._weightInterpolant;
    return null !== t6 && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t6)), this;
  }
  setEffectiveTimeScale(t6) {
    return this.timeScale = t6, this._effectiveTimeScale = this.paused ? 0 : t6, this.stopWarping();
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(t6) {
    return this.timeScale = this._clip.duration / t6, this.stopWarping();
  }
  syncWith(t6) {
    return this.time = t6.time, this.timeScale = t6.timeScale, this.stopWarping();
  }
  halt(t6) {
    return this.warp(this._effectiveTimeScale, 0, t6);
  }
  warp(t6, e2, i2) {
    const n2 = this._mixer, r2 = n2.time, s2 = this.timeScale;
    let o2 = this._timeScaleInterpolant;
    null === o2 && (o2 = n2._lendControlInterpolant(), this._timeScaleInterpolant = o2);
    const a2 = o2.parameterPositions, l2 = o2.sampleValues;
    return a2[0] = r2, a2[1] = r2 + i2, l2[0] = t6 / s2, l2[1] = e2 / s2, this;
  }
  stopWarping() {
    const t6 = this._timeScaleInterpolant;
    return null !== t6 && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t6)), this;
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(t6, e2, i2, n2) {
    if (!this.enabled) return void this._updateWeight(t6);
    const r2 = this._startTime;
    if (null !== r2) {
      const n3 = (t6 - r2) * i2;
      if (n3 < 0 || 0 === i2) return;
      this._startTime = null, e2 = i2 * n3;
    }
    e2 *= this._updateTimeScale(t6);
    const s2 = this._updateTime(e2), o2 = this._updateWeight(t6);
    if (o2 > 0) {
      const t7 = this._interpolants, e3 = this._propertyBindings;
      if (this.blendMode === Os) for (let i3 = 0, n3 = t7.length; i3 !== n3; ++i3) t7[i3].evaluate(s2), e3[i3].accumulateAdditive(o2);
      else for (let i3 = 0, r3 = t7.length; i3 !== r3; ++i3) t7[i3].evaluate(s2), e3[i3].accumulate(n2, o2);
    }
  }
  _updateWeight(t6) {
    let e2 = 0;
    if (this.enabled) {
      e2 = this.weight;
      const i2 = this._weightInterpolant;
      if (null !== i2) {
        const n2 = i2.evaluate(t6)[0];
        e2 *= n2, t6 > i2.parameterPositions[1] && (this.stopFading(), 0 === n2 && (this.enabled = false));
      }
    }
    return this._effectiveWeight = e2, e2;
  }
  _updateTimeScale(t6) {
    let e2 = 0;
    if (!this.paused) {
      e2 = this.timeScale;
      const i2 = this._timeScaleInterpolant;
      if (null !== i2) {
        e2 *= i2.evaluate(t6)[0], t6 > i2.parameterPositions[1] && (this.stopWarping(), 0 === e2 ? this.paused = true : this.timeScale = e2);
      }
    }
    return this._effectiveTimeScale = e2, e2;
  }
  _updateTime(t6) {
    const e2 = this._clip.duration, i2 = this.loop;
    let n2 = this.time + t6, r2 = this._loopCount;
    const s2 = i2 === Es;
    if (0 === t6) return -1 === r2 || !s2 || 1 & ~r2 ? n2 : e2 - n2;
    if (i2 === Ms) {
      -1 === r2 && (this._loopCount = 0, this._setEndings(true, true, false));
      t: {
        if (n2 >= e2) n2 = e2;
        else {
          if (!(n2 < 0)) {
            this.time = n2;
            break t;
          }
          n2 = 0;
        }
        this.clampWhenFinished ? this.paused = true : this.enabled = false, this.time = n2, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t6 < 0 ? -1 : 1 });
      }
    } else {
      if (-1 === r2 && (t6 >= 0 ? (r2 = 0, this._setEndings(true, 0 === this.repetitions, s2)) : this._setEndings(0 === this.repetitions, true, s2)), n2 >= e2 || n2 < 0) {
        const i3 = Math.floor(n2 / e2);
        n2 -= e2 * i3, r2 += Math.abs(i3);
        const o2 = this.repetitions - r2;
        if (o2 <= 0) this.clampWhenFinished ? this.paused = true : this.enabled = false, n2 = t6 > 0 ? e2 : 0, this.time = n2, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t6 > 0 ? 1 : -1 });
        else {
          if (1 === o2) {
            const e3 = t6 < 0;
            this._setEndings(e3, !e3, s2);
          } else this._setEndings(false, false, s2);
          this._loopCount = r2, this.time = n2, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: i3 });
        }
      } else this.time = n2;
      if (s2 && !(1 & ~r2)) return e2 - n2;
    }
    return n2;
  }
  _setEndings(t6, e2, i2) {
    const n2 = this._interpolantSettings;
    i2 ? (n2.endingStart = Ls, n2.endingEnd = Ls) : (n2.endingStart = t6 ? this.zeroSlopeAtStart ? Ls : Ps : Is, n2.endingEnd = e2 ? this.zeroSlopeAtEnd ? Ls : Ps : Is);
  }
  _scheduleFading(t6, e2, i2) {
    const n2 = this._mixer, r2 = n2.time;
    let s2 = this._weightInterpolant;
    null === s2 && (s2 = n2._lendControlInterpolant(), this._weightInterpolant = s2);
    const o2 = s2.parameterPositions, a2 = s2.sampleValues;
    return o2[0] = r2, a2[0] = e2, o2[1] = r2 + t6, a2[1] = i2, this;
  }
};
var Zg = new Float32Array(1);
var Jg = class extends So {
  constructor(t6) {
    super(), this._root = t6, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(t6, e2) {
    const i2 = t6._localRoot || this._root, n2 = t6._clip.tracks, r2 = n2.length, s2 = t6._propertyBindings, o2 = t6._interpolants, a2 = i2.uuid, l2 = this._bindingsByRootAndName;
    let c2 = l2[a2];
    void 0 === c2 && (c2 = {}, l2[a2] = c2);
    for (let t7 = 0; t7 !== r2; ++t7) {
      const r3 = n2[t7], l3 = r3.name;
      let h2 = c2[l3];
      if (void 0 !== h2) ++h2.referenceCount, s2[t7] = h2;
      else {
        if (h2 = s2[t7], void 0 !== h2) {
          null === h2._cacheIndex && (++h2.referenceCount, this._addInactiveBinding(h2, a2, l3));
          continue;
        }
        const n3 = e2 && e2._propertyBindings[t7].binding.parsedPath;
        h2 = new kg(qg.create(i2, l3, n3), r3.ValueTypeName, r3.getValueSize()), ++h2.referenceCount, this._addInactiveBinding(h2, a2, l3), s2[t7] = h2;
      }
      o2[t7].resultBuffer = h2.buffer;
    }
  }
  _activateAction(t6) {
    if (!this._isActiveAction(t6)) {
      if (null === t6._cacheIndex) {
        const e3 = (t6._localRoot || this._root).uuid, i2 = t6._clip.uuid, n2 = this._actionsByClip[i2];
        this._bindAction(t6, n2 && n2.knownActions[0]), this._addInactiveAction(t6, i2, e3);
      }
      const e2 = t6._propertyBindings;
      for (let t7 = 0, i2 = e2.length; t7 !== i2; ++t7) {
        const i3 = e2[t7];
        0 == i3.useCount++ && (this._lendBinding(i3), i3.saveOriginalState());
      }
      this._lendAction(t6);
    }
  }
  _deactivateAction(t6) {
    if (this._isActiveAction(t6)) {
      const e2 = t6._propertyBindings;
      for (let t7 = 0, i2 = e2.length; t7 !== i2; ++t7) {
        const i3 = e2[t7];
        0 == --i3.useCount && (i3.restoreOriginalState(), this._takeBackBinding(i3));
      }
      this._takeBackAction(t6);
    }
  }
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const t6 = this;
    this.stats = { actions: { get total() {
      return t6._actions.length;
    }, get inUse() {
      return t6._nActiveActions;
    } }, bindings: { get total() {
      return t6._bindings.length;
    }, get inUse() {
      return t6._nActiveBindings;
    } }, controlInterpolants: { get total() {
      return t6._controlInterpolants.length;
    }, get inUse() {
      return t6._nActiveControlInterpolants;
    } } };
  }
  _isActiveAction(t6) {
    const e2 = t6._cacheIndex;
    return null !== e2 && e2 < this._nActiveActions;
  }
  _addInactiveAction(t6, e2, i2) {
    const n2 = this._actions, r2 = this._actionsByClip;
    let s2 = r2[e2];
    if (void 0 === s2) s2 = { knownActions: [t6], actionByRoot: {} }, t6._byClipCacheIndex = 0, r2[e2] = s2;
    else {
      const e3 = s2.knownActions;
      t6._byClipCacheIndex = e3.length, e3.push(t6);
    }
    t6._cacheIndex = n2.length, n2.push(t6), s2.actionByRoot[i2] = t6;
  }
  _removeInactiveAction(t6) {
    const e2 = this._actions, i2 = e2[e2.length - 1], n2 = t6._cacheIndex;
    i2._cacheIndex = n2, e2[n2] = i2, e2.pop(), t6._cacheIndex = null;
    const r2 = t6._clip.uuid, s2 = this._actionsByClip, o2 = s2[r2], a2 = o2.knownActions, l2 = a2[a2.length - 1], c2 = t6._byClipCacheIndex;
    l2._byClipCacheIndex = c2, a2[c2] = l2, a2.pop(), t6._byClipCacheIndex = null;
    delete o2.actionByRoot[(t6._localRoot || this._root).uuid], 0 === a2.length && delete s2[r2], this._removeInactiveBindingsForAction(t6);
  }
  _removeInactiveBindingsForAction(t6) {
    const e2 = t6._propertyBindings;
    for (let t7 = 0, i2 = e2.length; t7 !== i2; ++t7) {
      const i3 = e2[t7];
      0 == --i3.referenceCount && this._removeInactiveBinding(i3);
    }
  }
  _lendAction(t6) {
    const e2 = this._actions, i2 = t6._cacheIndex, n2 = this._nActiveActions++, r2 = e2[n2];
    t6._cacheIndex = n2, e2[n2] = t6, r2._cacheIndex = i2, e2[i2] = r2;
  }
  _takeBackAction(t6) {
    const e2 = this._actions, i2 = t6._cacheIndex, n2 = --this._nActiveActions, r2 = e2[n2];
    t6._cacheIndex = n2, e2[n2] = t6, r2._cacheIndex = i2, e2[i2] = r2;
  }
  _addInactiveBinding(t6, e2, i2) {
    const n2 = this._bindingsByRootAndName, r2 = this._bindings;
    let s2 = n2[e2];
    void 0 === s2 && (s2 = {}, n2[e2] = s2), s2[i2] = t6, t6._cacheIndex = r2.length, r2.push(t6);
  }
  _removeInactiveBinding(t6) {
    const e2 = this._bindings, i2 = t6.binding, n2 = i2.rootNode.uuid, r2 = i2.path, s2 = this._bindingsByRootAndName, o2 = s2[n2], a2 = e2[e2.length - 1], l2 = t6._cacheIndex;
    a2._cacheIndex = l2, e2[l2] = a2, e2.pop(), delete o2[r2], 0 === Object.keys(o2).length && delete s2[n2];
  }
  _lendBinding(t6) {
    const e2 = this._bindings, i2 = t6._cacheIndex, n2 = this._nActiveBindings++, r2 = e2[n2];
    t6._cacheIndex = n2, e2[n2] = t6, r2._cacheIndex = i2, e2[i2] = r2;
  }
  _takeBackBinding(t6) {
    const e2 = this._bindings, i2 = t6._cacheIndex, n2 = --this._nActiveBindings, r2 = e2[n2];
    t6._cacheIndex = n2, e2[n2] = t6, r2._cacheIndex = i2, e2[i2] = r2;
  }
  _lendControlInterpolant() {
    const t6 = this._controlInterpolants, e2 = this._nActiveControlInterpolants++;
    let i2 = t6[e2];
    return void 0 === i2 && (i2 = new vm(new Float32Array(2), new Float32Array(2), 1, Zg), i2.__cacheIndex = e2, t6[e2] = i2), i2;
  }
  _takeBackControlInterpolant(t6) {
    const e2 = this._controlInterpolants, i2 = t6.__cacheIndex, n2 = --this._nActiveControlInterpolants, r2 = e2[n2];
    t6.__cacheIndex = n2, e2[n2] = t6, r2.__cacheIndex = i2, e2[i2] = r2;
  }
  clipAction(t6, e2, i2) {
    const n2 = e2 || this._root, r2 = n2.uuid;
    let s2 = "string" == typeof t6 ? Am.findByName(n2, t6) : t6;
    const o2 = null !== s2 ? s2.uuid : t6, a2 = this._actionsByClip[o2];
    let l2 = null;
    if (void 0 === i2 && (i2 = null !== s2 ? s2.blendMode : Ds), void 0 !== a2) {
      const t7 = a2.actionByRoot[r2];
      if (void 0 !== t7 && t7.blendMode === i2) return t7;
      l2 = a2.knownActions[0], null === s2 && (s2 = l2._clip);
    }
    if (null === s2) return null;
    const c2 = new Yg(this, s2, e2, i2);
    return this._bindAction(c2, l2), this._addInactiveAction(c2, o2, r2), c2;
  }
  existingAction(t6, e2) {
    const i2 = e2 || this._root, n2 = i2.uuid, r2 = "string" == typeof t6 ? Am.findByName(i2, t6) : t6, s2 = r2 ? r2.uuid : t6, o2 = this._actionsByClip[s2];
    return void 0 !== o2 && o2.actionByRoot[n2] || null;
  }
  stopAllAction() {
    const t6 = this._actions;
    for (let e2 = this._nActiveActions - 1; e2 >= 0; --e2) t6[e2].stop();
    return this;
  }
  update(t6) {
    t6 *= this.timeScale;
    const e2 = this._actions, i2 = this._nActiveActions, n2 = this.time += t6, r2 = Math.sign(t6), s2 = this._accuIndex ^= 1;
    for (let o3 = 0; o3 !== i2; ++o3) {
      e2[o3]._update(n2, t6, r2, s2);
    }
    const o2 = this._bindings, a2 = this._nActiveBindings;
    for (let t7 = 0; t7 !== a2; ++t7) o2[t7].apply(s2);
    return this;
  }
  setTime(t6) {
    this.time = 0;
    for (let t7 = 0; t7 < this._actions.length; t7++) this._actions[t7].time = 0;
    return this.update(t6);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(t6) {
    const e2 = this._actions, i2 = t6.uuid, n2 = this._actionsByClip, r2 = n2[i2];
    if (void 0 !== r2) {
      const t7 = r2.knownActions;
      for (let i3 = 0, n3 = t7.length; i3 !== n3; ++i3) {
        const n4 = t7[i3];
        this._deactivateAction(n4);
        const r3 = n4._cacheIndex, s2 = e2[e2.length - 1];
        n4._cacheIndex = null, n4._byClipCacheIndex = null, s2._cacheIndex = r3, e2[r3] = s2, e2.pop(), this._removeInactiveBindingsForAction(n4);
      }
      delete n2[i2];
    }
  }
  uncacheRoot(t6) {
    const e2 = t6.uuid, i2 = this._actionsByClip;
    for (const t7 in i2) {
      const n3 = i2[t7].actionByRoot[e2];
      void 0 !== n3 && (this._deactivateAction(n3), this._removeInactiveAction(n3));
    }
    const n2 = this._bindingsByRootAndName[e2];
    if (void 0 !== n2) for (const t7 in n2) {
      const e3 = n2[t7];
      e3.restoreOriginalState(), this._removeInactiveBinding(e3);
    }
  }
  uncacheAction(t6, e2) {
    const i2 = this.existingAction(t6, e2);
    null !== i2 && (this._deactivateAction(i2), this._removeInactiveAction(i2));
  }
};
var Kg = class _Kg {
  constructor(t6) {
    "string" == typeof t6 && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t6 = arguments[1]), this.value = t6;
  }
  clone() {
    return new _Kg(void 0 === this.value.clone ? this.value : this.value.clone());
  }
};
var $g = 0;
var Qg = class extends So {
  constructor() {
    super(), this.isUniformsGroup = true, Object.defineProperty(this, "id", { value: $g++ }), this.name = "", this.usage = ho, this.uniforms = [];
  }
  add(t6) {
    return this.uniforms.push(t6), this;
  }
  remove(t6) {
    const e2 = this.uniforms.indexOf(t6);
    return -1 !== e2 && this.uniforms.splice(e2, 1), this;
  }
  setName(t6) {
    return this.name = t6, this;
  }
  setUsage(t6) {
    return this.usage = t6, this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(t6) {
    this.name = t6.name, this.usage = t6.usage;
    const e2 = t6.uniforms;
    this.uniforms.length = 0;
    for (let t7 = 0, i2 = e2.length; t7 < i2; t7++) this.uniforms.push(e2[t7].clone());
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var tv = class extends wd {
  constructor(t6, e2, i2 = 1) {
    super(t6, e2), this.isInstancedInterleavedBuffer = true, this.meshPerAttribute = i2;
  }
  copy(t6) {
    return super.copy(t6), this.meshPerAttribute = t6.meshPerAttribute, this;
  }
  clone(t6) {
    const e2 = super.clone(t6);
    return e2.meshPerAttribute = this.meshPerAttribute, e2;
  }
  toJSON(t6) {
    const e2 = super.toJSON(t6);
    return e2.isInstancedInterleavedBuffer = true, e2.meshPerAttribute = this.meshPerAttribute, e2;
  }
};
var ev = class {
  constructor(t6, e2, i2, n2, r2) {
    this.isGLBufferAttribute = true, this.buffer = t6, this.type = e2, this.itemSize = i2, this.elementSize = n2, this.count = r2, this.version = 0;
  }
  set needsUpdate(t6) {
    true === t6 && this.version++;
  }
  setBuffer(t6) {
    return this.buffer = t6, this;
  }
  setType(t6, e2) {
    return this.type = t6, this.elementSize = e2, this;
  }
  setItemSize(t6) {
    return this.itemSize = t6, this;
  }
  setCount(t6) {
    return this.count = t6, this;
  }
};
var iv = class {
  constructor(t6, e2, i2 = 0, n2 = 1 / 0) {
    this.ray = new ja(t6, e2), this.near = i2, this.far = n2, this.camera = null, this.layers = new el(), this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} };
  }
  set(t6, e2) {
    this.ray.set(t6, e2);
  }
  setFromCamera(t6, e2) {
    e2.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e2.matrixWorld), this.ray.direction.set(t6.x, t6.y, 0.5).unproject(e2).sub(this.ray.origin).normalize(), this.camera = e2) : e2.isOrthographicCamera ? (this.ray.origin.set(t6.x, t6.y, (e2.near + e2.far) / (e2.near - e2.far)).unproject(e2), this.ray.direction.set(0, 0, -1).transformDirection(e2.matrixWorld), this.camera = e2) : console.error("THREE.Raycaster: Unsupported camera type: " + e2.type);
  }
  intersectObject(t6, e2 = true, i2 = []) {
    return rv(t6, this, i2, e2), i2.sort(nv), i2;
  }
  intersectObjects(t6, e2 = true, i2 = []) {
    for (let n2 = 0, r2 = t6.length; n2 < r2; n2++) rv(t6[n2], this, i2, e2);
    return i2.sort(nv), i2;
  }
};
function nv(t6, e2) {
  return t6.distance - e2.distance;
}
function rv(t6, e2, i2, n2) {
  if (t6.layers.test(e2.layers) && t6.raycast(e2, i2), true === n2) {
    const n3 = t6.children;
    for (let t7 = 0, r2 = n3.length; t7 < r2; t7++) rv(n3[t7], e2, i2, true);
  }
}
var sv = class {
  constructor(t6 = 1, e2 = 0, i2 = 0) {
    return this.radius = t6, this.phi = e2, this.theta = i2, this;
  }
  set(t6, e2, i2) {
    return this.radius = t6, this.phi = e2, this.theta = i2, this;
  }
  copy(t6) {
    return this.radius = t6.radius, this.phi = t6.phi, this.theta = t6.theta, this;
  }
  makeSafe() {
    const t6 = 1e-6;
    return this.phi = Math.max(t6, Math.min(Math.PI - t6, this.phi)), this;
  }
  setFromVector3(t6) {
    return this.setFromCartesianCoords(t6.x, t6.y, t6.z);
  }
  setFromCartesianCoords(t6, e2, i2) {
    return this.radius = Math.sqrt(t6 * t6 + e2 * e2 + i2 * i2), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t6, i2), this.phi = Math.acos(Ro(e2 / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var ov = class {
  constructor(t6 = 1, e2 = 0, i2 = 0) {
    return this.radius = t6, this.theta = e2, this.y = i2, this;
  }
  set(t6, e2, i2) {
    return this.radius = t6, this.theta = e2, this.y = i2, this;
  }
  copy(t6) {
    return this.radius = t6.radius, this.theta = t6.theta, this.y = t6.y, this;
  }
  setFromVector3(t6) {
    return this.setFromCartesianCoords(t6.x, t6.y, t6.z);
  }
  setFromCartesianCoords(t6, e2, i2) {
    return this.radius = Math.sqrt(t6 * t6 + i2 * i2), this.theta = Math.atan2(t6, i2), this.y = e2, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var av = new Fo();
var lv = class {
  constructor(t6 = new Fo(1 / 0, 1 / 0), e2 = new Fo(-1 / 0, -1 / 0)) {
    this.isBox2 = true, this.min = t6, this.max = e2;
  }
  set(t6, e2) {
    return this.min.copy(t6), this.max.copy(e2), this;
  }
  setFromPoints(t6) {
    this.makeEmpty();
    for (let e2 = 0, i2 = t6.length; e2 < i2; e2++) this.expandByPoint(t6[e2]);
    return this;
  }
  setFromCenterAndSize(t6, e2) {
    const i2 = av.copy(e2).multiplyScalar(0.5);
    return this.min.copy(t6).sub(i2), this.max.copy(t6).add(i2), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t6) {
    return this.min.copy(t6.min), this.max.copy(t6.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(t6) {
    return this.isEmpty() ? t6.set(0, 0) : t6.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(t6) {
    return this.isEmpty() ? t6.set(0, 0) : t6.subVectors(this.max, this.min);
  }
  expandByPoint(t6) {
    return this.min.min(t6), this.max.max(t6), this;
  }
  expandByVector(t6) {
    return this.min.sub(t6), this.max.add(t6), this;
  }
  expandByScalar(t6) {
    return this.min.addScalar(-t6), this.max.addScalar(t6), this;
  }
  containsPoint(t6) {
    return !(t6.x < this.min.x || t6.x > this.max.x || t6.y < this.min.y || t6.y > this.max.y);
  }
  containsBox(t6) {
    return this.min.x <= t6.min.x && t6.max.x <= this.max.x && this.min.y <= t6.min.y && t6.max.y <= this.max.y;
  }
  getParameter(t6, e2) {
    return e2.set((t6.x - this.min.x) / (this.max.x - this.min.x), (t6.y - this.min.y) / (this.max.y - this.min.y));
  }
  intersectsBox(t6) {
    return !(t6.max.x < this.min.x || t6.min.x > this.max.x || t6.max.y < this.min.y || t6.min.y > this.max.y);
  }
  clampPoint(t6, e2) {
    return e2.copy(t6).clamp(this.min, this.max);
  }
  distanceToPoint(t6) {
    return av.copy(t6).clamp(this.min, this.max).sub(t6).length();
  }
  intersect(t6) {
    return this.min.max(t6.min), this.max.min(t6.max), this;
  }
  union(t6) {
    return this.min.min(t6.min), this.max.max(t6.max), this;
  }
  translate(t6) {
    return this.min.add(t6), this.max.add(t6), this;
  }
  equals(t6) {
    return t6.min.equals(this.min) && t6.max.equals(this.max);
  }
};
var cv = new pa();
var hv = new pa();
var uv = class {
  constructor(t6 = new pa(), e2 = new pa()) {
    this.start = t6, this.end = e2;
  }
  set(t6, e2) {
    return this.start.copy(t6), this.end.copy(e2), this;
  }
  copy(t6) {
    return this.start.copy(t6.start), this.end.copy(t6.end), this;
  }
  getCenter(t6) {
    return t6.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(t6) {
    return t6.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(t6, e2) {
    return this.delta(e2).multiplyScalar(t6).add(this.start);
  }
  closestPointToPointParameter(t6, e2) {
    cv.subVectors(t6, this.start), hv.subVectors(this.end, this.start);
    const i2 = hv.dot(hv);
    let n2 = hv.dot(cv) / i2;
    return e2 && (n2 = Ro(n2, 0, 1)), n2;
  }
  closestPointToPoint(t6, e2, i2) {
    const n2 = this.closestPointToPointParameter(t6, e2);
    return this.delta(i2).multiplyScalar(n2).add(this.start);
  }
  applyMatrix4(t6) {
    return this.start.applyMatrix4(t6), this.end.applyMatrix4(t6), this;
  }
  equals(t6) {
    return t6.start.equals(this.start) && t6.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var dv = new pa();
var pv = class extends ml {
  constructor(t6, e2) {
    super(), this.light = t6, this.light.updateMatrixWorld(), this.matrix = t6.matrixWorld, this.matrixAutoUpdate = false, this.color = e2;
    const i2 = new Jl(), n2 = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
    for (let t7 = 0, e3 = 1, i3 = 32; t7 < i3; t7++, e3++) {
      const r3 = t7 / i3 * Math.PI * 2, s2 = e3 / i3 * Math.PI * 2;
      n2.push(Math.cos(r3), Math.sin(r3), 1, Math.cos(s2), Math.sin(s2), 1);
    }
    i2.setAttribute("position", new Hl(n2, 3));
    const r2 = new op({ fog: false, toneMapped: false });
    this.cone = new mp(i2, r2), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateMatrixWorld();
    const t6 = this.light.distance ? this.light.distance : 1e3, e2 = t6 * Math.tan(this.light.angle);
    this.cone.scale.set(e2, e2, t6), dv.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(dv), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
};
var fv = new pa();
var mv = new Ga();
var gv = new Ga();
var vv = class extends mp {
  constructor(t6) {
    const e2 = yv(t6), i2 = new Jl(), n2 = [], r2 = [], s2 = new $o(0, 0, 1), o2 = new $o(0, 1, 0);
    for (let t7 = 0; t7 < e2.length; t7++) {
      const i3 = e2[t7];
      i3.parent && i3.parent.isBone && (n2.push(0, 0, 0), n2.push(0, 0, 0), r2.push(s2.r, s2.g, s2.b), r2.push(o2.r, o2.g, o2.b));
    }
    i2.setAttribute("position", new Hl(n2, 3)), i2.setAttribute("color", new Hl(r2, 3));
    super(i2, new op({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true })), this.isSkeletonHelper = true, this.type = "SkeletonHelper", this.root = t6, this.bones = e2, this.matrix = t6.matrixWorld, this.matrixAutoUpdate = false;
  }
  updateMatrixWorld(t6) {
    const e2 = this.bones, i2 = this.geometry, n2 = i2.getAttribute("position");
    gv.copy(this.root.matrixWorld).invert();
    for (let t7 = 0, i3 = 0; t7 < e2.length; t7++) {
      const r2 = e2[t7];
      r2.parent && r2.parent.isBone && (mv.multiplyMatrices(gv, r2.matrixWorld), fv.setFromMatrixPosition(mv), n2.setXYZ(i3, fv.x, fv.y, fv.z), mv.multiplyMatrices(gv, r2.parent.matrixWorld), fv.setFromMatrixPosition(mv), n2.setXYZ(i3 + 1, fv.x, fv.y, fv.z), i3 += 2);
    }
    i2.getAttribute("position").needsUpdate = true, super.updateMatrixWorld(t6);
  }
};
function yv(t6) {
  const e2 = [];
  true === t6.isBone && e2.push(t6);
  for (let i2 = 0; i2 < t6.children.length; i2++) e2.push.apply(e2, yv(t6.children[i2]));
  return e2;
}
var xv = class extends fc {
  constructor(t6, e2, i2) {
    super(new Gf(e2, 4, 2), new Rl({ wireframe: true, fog: false, toneMapped: false })), this.light = t6, this.light.updateMatrixWorld(), this.color = i2, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = false, this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
};
var bv = new pa();
var wv = new $o();
var _v = new $o();
var Sv = class extends ml {
  constructor(t6, e2, i2) {
    super(), this.light = t6, this.light.updateMatrixWorld(), this.matrix = t6.matrixWorld, this.matrixAutoUpdate = false, this.color = i2;
    const n2 = new Hf(e2);
    n2.rotateY(0.5 * Math.PI), this.material = new Rl({ wireframe: true, fog: false, toneMapped: false }), void 0 === this.color && (this.material.vertexColors = true);
    const r2 = n2.getAttribute("position"), s2 = new Float32Array(3 * r2.count);
    n2.setAttribute("color", new Il(s2, 3)), this.add(new fc(n2, this.material)), this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const t6 = this.children[0];
    if (void 0 !== this.color) this.material.color.set(this.color);
    else {
      const e2 = t6.geometry.getAttribute("color");
      wv.copy(this.light.color), _v.copy(this.light.groundColor);
      for (let t7 = 0, i2 = e2.count; t7 < i2; t7++) {
        const n2 = t7 < i2 / 2 ? wv : _v;
        e2.setXYZ(t7, n2.r, n2.g, n2.b);
      }
      e2.needsUpdate = true;
    }
    t6.lookAt(bv.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
};
var Mv = class extends mp {
  constructor(t6 = 10, e2 = 10, i2 = 4473924, n2 = 8947848) {
    i2 = new $o(i2), n2 = new $o(n2);
    const r2 = e2 / 2, s2 = t6 / e2, o2 = t6 / 2, a2 = [], l2 = [];
    for (let t7 = 0, c3 = 0, h2 = -o2; t7 <= e2; t7++, h2 += s2) {
      a2.push(-o2, 0, h2, o2, 0, h2), a2.push(h2, 0, -o2, h2, 0, o2);
      const e3 = t7 === r2 ? i2 : n2;
      e3.toArray(l2, c3), c3 += 3, e3.toArray(l2, c3), c3 += 3, e3.toArray(l2, c3), c3 += 3, e3.toArray(l2, c3), c3 += 3;
    }
    const c2 = new Jl();
    c2.setAttribute("position", new Hl(a2, 3)), c2.setAttribute("color", new Hl(l2, 3));
    super(c2, new op({ vertexColors: true, toneMapped: false })), this.type = "GridHelper";
  }
};
var Tv = class extends mp {
  constructor(t6 = 10, e2 = 16, i2 = 8, n2 = 64, r2 = 4473924, s2 = 8947848) {
    r2 = new $o(r2), s2 = new $o(s2);
    const o2 = [], a2 = [];
    for (let i3 = 0; i3 <= e2; i3++) {
      const n3 = i3 / e2 * (2 * Math.PI), l3 = Math.sin(n3) * t6, c2 = Math.cos(n3) * t6;
      o2.push(0, 0, 0), o2.push(l3, 0, c2);
      const h2 = 1 & i3 ? r2 : s2;
      a2.push(h2.r, h2.g, h2.b), a2.push(h2.r, h2.g, h2.b);
    }
    for (let e3 = 0; e3 <= i2; e3++) {
      const l3 = 1 & e3 ? r2 : s2, c2 = t6 - t6 / i2 * e3;
      for (let t7 = 0; t7 < n2; t7++) {
        let e4 = t7 / n2 * (2 * Math.PI), i3 = Math.sin(e4) * c2, r3 = Math.cos(e4) * c2;
        o2.push(i3, 0, r3), a2.push(l3.r, l3.g, l3.b), e4 = (t7 + 1) / n2 * (2 * Math.PI), i3 = Math.sin(e4) * c2, r3 = Math.cos(e4) * c2, o2.push(i3, 0, r3), a2.push(l3.r, l3.g, l3.b);
      }
    }
    const l2 = new Jl();
    l2.setAttribute("position", new Hl(o2, 3)), l2.setAttribute("color", new Hl(a2, 3));
    super(l2, new op({ vertexColors: true, toneMapped: false })), this.type = "PolarGridHelper";
  }
};
var Ev = new pa();
var Av = new pa();
var Cv = new pa();
var Rv = class extends ml {
  constructor(t6, e2, i2) {
    super(), this.light = t6, this.light.updateMatrixWorld(), this.matrix = t6.matrixWorld, this.matrixAutoUpdate = false, this.color = i2, void 0 === e2 && (e2 = 1);
    let n2 = new Jl();
    n2.setAttribute("position", new Hl([-e2, e2, 0, e2, e2, 0, e2, -e2, 0, -e2, -e2, 0, -e2, e2, 0], 3));
    const r2 = new op({ fog: false, toneMapped: false });
    this.lightPlane = new dp(n2, r2), this.add(this.lightPlane), n2 = new Jl(), n2.setAttribute("position", new Hl([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new dp(n2, r2), this.add(this.targetLine), this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  update() {
    Ev.setFromMatrixPosition(this.light.matrixWorld), Av.setFromMatrixPosition(this.light.target.matrixWorld), Cv.subVectors(Av, Ev), this.lightPlane.lookAt(Av), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Av), this.targetLine.scale.z = Cv.length();
  }
};
var Pv = new pa();
var Lv = new wc();
var Iv = class extends mp {
  constructor(t6) {
    const e2 = new Jl(), i2 = new op({ color: 16777215, vertexColors: true, toneMapped: false }), n2 = [], r2 = [], s2 = {};
    function o2(t7, e3) {
      a2(t7), a2(e3);
    }
    function a2(t7) {
      n2.push(0, 0, 0), r2.push(0, 0, 0), void 0 === s2[t7] && (s2[t7] = []), s2[t7].push(n2.length / 3 - 1);
    }
    o2("n1", "n2"), o2("n2", "n4"), o2("n4", "n3"), o2("n3", "n1"), o2("f1", "f2"), o2("f2", "f4"), o2("f4", "f3"), o2("f3", "f1"), o2("n1", "f1"), o2("n2", "f2"), o2("n3", "f3"), o2("n4", "f4"), o2("p", "n1"), o2("p", "n2"), o2("p", "n3"), o2("p", "n4"), o2("u1", "u2"), o2("u2", "u3"), o2("u3", "u1"), o2("c", "t"), o2("p", "c"), o2("cn1", "cn2"), o2("cn3", "cn4"), o2("cf1", "cf2"), o2("cf3", "cf4"), e2.setAttribute("position", new Hl(n2, 3)), e2.setAttribute("color", new Hl(r2, 3)), super(e2, i2), this.type = "CameraHelper", this.camera = t6, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t6.matrixWorld, this.matrixAutoUpdate = false, this.pointMap = s2, this.update();
    const l2 = new $o(16755200), c2 = new $o(16711680), h2 = new $o(43775), u2 = new $o(16777215), d2 = new $o(3355443);
    this.setColors(l2, c2, h2, u2, d2);
  }
  setColors(t6, e2, i2, n2, r2) {
    const s2 = this.geometry.getAttribute("color");
    s2.setXYZ(0, t6.r, t6.g, t6.b), s2.setXYZ(1, t6.r, t6.g, t6.b), s2.setXYZ(2, t6.r, t6.g, t6.b), s2.setXYZ(3, t6.r, t6.g, t6.b), s2.setXYZ(4, t6.r, t6.g, t6.b), s2.setXYZ(5, t6.r, t6.g, t6.b), s2.setXYZ(6, t6.r, t6.g, t6.b), s2.setXYZ(7, t6.r, t6.g, t6.b), s2.setXYZ(8, t6.r, t6.g, t6.b), s2.setXYZ(9, t6.r, t6.g, t6.b), s2.setXYZ(10, t6.r, t6.g, t6.b), s2.setXYZ(11, t6.r, t6.g, t6.b), s2.setXYZ(12, t6.r, t6.g, t6.b), s2.setXYZ(13, t6.r, t6.g, t6.b), s2.setXYZ(14, t6.r, t6.g, t6.b), s2.setXYZ(15, t6.r, t6.g, t6.b), s2.setXYZ(16, t6.r, t6.g, t6.b), s2.setXYZ(17, t6.r, t6.g, t6.b), s2.setXYZ(18, t6.r, t6.g, t6.b), s2.setXYZ(19, t6.r, t6.g, t6.b), s2.setXYZ(20, t6.r, t6.g, t6.b), s2.setXYZ(21, t6.r, t6.g, t6.b), s2.setXYZ(22, t6.r, t6.g, t6.b), s2.setXYZ(23, t6.r, t6.g, t6.b), s2.setXYZ(24, e2.r, e2.g, e2.b), s2.setXYZ(25, e2.r, e2.g, e2.b), s2.setXYZ(26, e2.r, e2.g, e2.b), s2.setXYZ(27, e2.r, e2.g, e2.b), s2.setXYZ(28, e2.r, e2.g, e2.b), s2.setXYZ(29, e2.r, e2.g, e2.b), s2.setXYZ(30, e2.r, e2.g, e2.b), s2.setXYZ(31, e2.r, e2.g, e2.b), s2.setXYZ(32, i2.r, i2.g, i2.b), s2.setXYZ(33, i2.r, i2.g, i2.b), s2.setXYZ(34, i2.r, i2.g, i2.b), s2.setXYZ(35, i2.r, i2.g, i2.b), s2.setXYZ(36, i2.r, i2.g, i2.b), s2.setXYZ(37, i2.r, i2.g, i2.b), s2.setXYZ(38, n2.r, n2.g, n2.b), s2.setXYZ(39, n2.r, n2.g, n2.b), s2.setXYZ(40, r2.r, r2.g, r2.b), s2.setXYZ(41, r2.r, r2.g, r2.b), s2.setXYZ(42, r2.r, r2.g, r2.b), s2.setXYZ(43, r2.r, r2.g, r2.b), s2.setXYZ(44, r2.r, r2.g, r2.b), s2.setXYZ(45, r2.r, r2.g, r2.b), s2.setXYZ(46, r2.r, r2.g, r2.b), s2.setXYZ(47, r2.r, r2.g, r2.b), s2.setXYZ(48, r2.r, r2.g, r2.b), s2.setXYZ(49, r2.r, r2.g, r2.b), s2.needsUpdate = true;
  }
  update() {
    const t6 = this.geometry, e2 = this.pointMap;
    Lv.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Dv("c", e2, t6, Lv, 0, 0, -1), Dv("t", e2, t6, Lv, 0, 0, 1), Dv("n1", e2, t6, Lv, -1, -1, -1), Dv("n2", e2, t6, Lv, 1, -1, -1), Dv("n3", e2, t6, Lv, -1, 1, -1), Dv("n4", e2, t6, Lv, 1, 1, -1), Dv("f1", e2, t6, Lv, -1, -1, 1), Dv("f2", e2, t6, Lv, 1, -1, 1), Dv("f3", e2, t6, Lv, -1, 1, 1), Dv("f4", e2, t6, Lv, 1, 1, 1), Dv("u1", e2, t6, Lv, 0.7, 1.1, -1), Dv("u2", e2, t6, Lv, -0.7, 1.1, -1), Dv("u3", e2, t6, Lv, 0, 2, -1), Dv("cf1", e2, t6, Lv, -1, 0, 1), Dv("cf2", e2, t6, Lv, 1, 0, 1), Dv("cf3", e2, t6, Lv, 0, -1, 1), Dv("cf4", e2, t6, Lv, 0, 1, 1), Dv("cn1", e2, t6, Lv, -1, 0, -1), Dv("cn2", e2, t6, Lv, 1, 0, -1), Dv("cn3", e2, t6, Lv, 0, -1, -1), Dv("cn4", e2, t6, Lv, 0, 1, -1), t6.getAttribute("position").needsUpdate = true;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
};
function Dv(t6, e2, i2, n2, r2, s2, o2) {
  Pv.set(r2, s2, o2).unproject(n2);
  const a2 = e2[t6];
  if (void 0 !== a2) {
    const t7 = i2.getAttribute("position");
    for (let e3 = 0, i3 = a2.length; e3 < i3; e3++) t7.setXYZ(a2[e3], Pv.x, Pv.y, Pv.z);
  }
}
var Ov = new ga();
var zv = class extends mp {
  constructor(t6, e2 = 16776960) {
    const i2 = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), n2 = new Float32Array(24), r2 = new Jl();
    r2.setIndex(new Il(i2, 1)), r2.setAttribute("position", new Il(n2, 3)), super(r2, new op({ color: e2, toneMapped: false })), this.object = t6, this.type = "BoxHelper", this.matrixAutoUpdate = false, this.update();
  }
  update(t6) {
    if (void 0 !== t6 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && Ov.setFromObject(this.object), Ov.isEmpty()) return;
    const e2 = Ov.min, i2 = Ov.max, n2 = this.geometry.attributes.position, r2 = n2.array;
    r2[0] = i2.x, r2[1] = i2.y, r2[2] = i2.z, r2[3] = e2.x, r2[4] = i2.y, r2[5] = i2.z, r2[6] = e2.x, r2[7] = e2.y, r2[8] = i2.z, r2[9] = i2.x, r2[10] = e2.y, r2[11] = i2.z, r2[12] = i2.x, r2[13] = i2.y, r2[14] = e2.z, r2[15] = e2.x, r2[16] = i2.y, r2[17] = e2.z, r2[18] = e2.x, r2[19] = e2.y, r2[20] = e2.z, r2[21] = i2.x, r2[22] = e2.y, r2[23] = e2.z, n2.needsUpdate = true, this.geometry.computeBoundingSphere();
  }
  setFromObject(t6) {
    return this.object = t6, this.update(), this;
  }
  copy(t6, e2) {
    return super.copy(t6, e2), this.object = t6.object, this;
  }
};
var Fv = class extends mp {
  constructor(t6, e2 = 16776960) {
    const i2 = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), n2 = new Jl();
    n2.setIndex(new Il(i2, 1)), n2.setAttribute("position", new Hl([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(n2, new op({ color: e2, toneMapped: false })), this.box = t6, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(t6) {
    const e2 = this.box;
    e2.isEmpty() || (e2.getCenter(this.position), e2.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(t6));
  }
};
var Nv = class extends dp {
  constructor(t6, e2 = 1, i2 = 16776960) {
    const n2 = i2, r2 = new Jl();
    r2.setAttribute("position", new Hl([1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), r2.computeBoundingSphere(), super(r2, new op({ color: n2, toneMapped: false })), this.type = "PlaneHelper", this.plane = t6, this.size = e2;
    const s2 = new Jl();
    s2.setAttribute("position", new Hl([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), s2.computeBoundingSphere(), this.add(new fc(s2, new Rl({ color: n2, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false })));
  }
  updateMatrixWorld(t6) {
    this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(t6);
  }
};
var Bv = new pa();
var kv;
var Uv;
var Hv = class extends ml {
  constructor(t6 = new pa(0, 0, 1), e2 = new pa(0, 0, 0), i2 = 1, n2 = 16776960, r2 = 0.2 * i2, s2 = 0.2 * r2) {
    super(), this.type = "ArrowHelper", void 0 === kv && (kv = new Jl(), kv.setAttribute("position", new Hl([0, 0, 0, 0, 1, 0], 3)), Uv = new Qp(0, 0.5, 1, 5, 1), Uv.translate(0, -0.5, 0)), this.position.copy(e2), this.line = new dp(kv, new op({ color: n2, toneMapped: false })), this.line.matrixAutoUpdate = false, this.add(this.line), this.cone = new fc(Uv, new Rl({ color: n2, toneMapped: false })), this.cone.matrixAutoUpdate = false, this.add(this.cone), this.setDirection(t6), this.setLength(i2, r2, s2);
  }
  setDirection(t6) {
    if (t6.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (t6.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
      Bv.set(t6.z, 0, -t6.x).normalize();
      const e2 = Math.acos(t6.y);
      this.quaternion.setFromAxisAngle(Bv, e2);
    }
  }
  setLength(t6, e2 = 0.2 * t6, i2 = 0.2 * e2) {
    this.line.scale.set(1, Math.max(1e-4, t6 - e2), 1), this.line.updateMatrix(), this.cone.scale.set(i2, e2, i2), this.cone.position.y = t6, this.cone.updateMatrix();
  }
  setColor(t6) {
    this.line.material.color.set(t6), this.cone.material.color.set(t6);
  }
  copy(t6) {
    return super.copy(t6, false), this.line.copy(t6.line), this.cone.copy(t6.cone), this;
  }
};
var Vv = class extends mp {
  constructor(t6 = 1) {
    const e2 = [0, 0, 0, t6, 0, 0, 0, 0, 0, 0, t6, 0, 0, 0, 0, 0, 0, t6], i2 = new Jl();
    i2.setAttribute("position", new Hl(e2, 3)), i2.setAttribute("color", new Hl([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], 3));
    super(i2, new op({ vertexColors: true, toneMapped: false })), this.type = "AxesHelper";
  }
  setColors(t6, e2, i2) {
    const n2 = new $o(), r2 = this.geometry.attributes.color.array;
    return n2.set(t6), n2.toArray(r2, 0), n2.toArray(r2, 3), n2.set(e2), n2.toArray(r2, 6), n2.toArray(r2, 9), n2.set(i2), n2.toArray(r2, 12), n2.toArray(r2, 15), this.geometry.attributes.color.needsUpdate = true, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
};
var jv = class {
  constructor() {
    this.type = "ShapePath", this.color = new $o(), this.subPaths = [], this.currentPath = null;
  }
  moveTo(t6, e2) {
    return this.currentPath = new Zp(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(t6, e2), this;
  }
  lineTo(t6, e2) {
    return this.currentPath.lineTo(t6, e2), this;
  }
  quadraticCurveTo(t6, e2, i2, n2) {
    return this.currentPath.quadraticCurveTo(t6, e2, i2, n2), this;
  }
  bezierCurveTo(t6, e2, i2, n2, r2, s2) {
    return this.currentPath.bezierCurveTo(t6, e2, i2, n2, r2, s2), this;
  }
  splineThru(t6) {
    return this.currentPath.splineThru(t6), this;
  }
  toShapes(t6, e2) {
    function i2(t7) {
      const e3 = [];
      for (let i3 = 0, n3 = t7.length; i3 < n3; i3++) {
        const n4 = t7[i3], r3 = new cf();
        r3.curves = n4.curves, e3.push(r3);
      }
      return e3;
    }
    function n2(t7, e3) {
      const i3 = e3.length;
      let n3 = false;
      for (let r3 = i3 - 1, s3 = 0; s3 < i3; r3 = s3++) {
        let i4 = e3[r3], o3 = e3[s3], a3 = o3.x - i4.x, l3 = o3.y - i4.y;
        if (Math.abs(l3) > Number.EPSILON) {
          if (l3 < 0 && (i4 = e3[s3], a3 = -a3, o3 = e3[r3], l3 = -l3), t7.y < i4.y || t7.y > o3.y) continue;
          if (t7.y === i4.y) {
            if (t7.x === i4.x) return true;
          } else {
            const e4 = l3 * (t7.x - i4.x) - a3 * (t7.y - i4.y);
            if (0 === e4) return true;
            if (e4 < 0) continue;
            n3 = !n3;
          }
        } else {
          if (t7.y !== i4.y) continue;
          if (o3.x <= t7.x && t7.x <= i4.x || i4.x <= t7.x && t7.x <= o3.x) return true;
        }
      }
      return n3;
    }
    const r2 = zf.isClockWise, s2 = this.subPaths;
    if (0 === s2.length) return [];
    if (true === e2) return i2(s2);
    let o2, a2, l2;
    const c2 = [];
    if (1 === s2.length) return a2 = s2[0], l2 = new cf(), l2.curves = a2.curves, c2.push(l2), c2;
    let h2 = !r2(s2[0].getPoints());
    h2 = t6 ? !h2 : h2;
    const u2 = [], d2 = [];
    let p2, f2, m2 = [], g2 = 0;
    d2[g2] = void 0, m2[g2] = [];
    for (let e3 = 0, i3 = s2.length; e3 < i3; e3++) a2 = s2[e3], p2 = a2.getPoints(), o2 = r2(p2), o2 = t6 ? !o2 : o2, o2 ? (!h2 && d2[g2] && g2++, d2[g2] = { s: new cf(), p: p2 }, d2[g2].s.curves = a2.curves, h2 && g2++, m2[g2] = []) : m2[g2].push({ h: a2, p: p2[0] });
    if (!d2[0]) return i2(s2);
    if (d2.length > 1) {
      let t7 = false, e3 = 0;
      for (let t8 = 0, e4 = d2.length; t8 < e4; t8++) u2[t8] = [];
      for (let i3 = 0, r3 = d2.length; i3 < r3; i3++) {
        const r4 = m2[i3];
        for (let s3 = 0; s3 < r4.length; s3++) {
          const o3 = r4[s3];
          let a3 = true;
          for (let r5 = 0; r5 < d2.length; r5++) n2(o3.p, d2[r5].p) && (i3 !== r5 && e3++, a3 ? (a3 = false, u2[r5].push(o3)) : t7 = true);
          a3 && u2[i3].push(o3);
        }
      }
      e3 > 0 && false === t7 && (m2 = u2);
    }
    for (let t7 = 0, e3 = d2.length; t7 < e3; t7++) {
      l2 = d2[t7].s, c2.push(l2), f2 = m2[t7];
      for (let t8 = 0, e4 = f2.length; t8 < e4; t8++) l2.holes.push(f2[t8].h);
    }
    return c2;
  }
};
var Gv = Wv();
function Wv() {
  const t6 = new ArrayBuffer(4), e2 = new Float32Array(t6), i2 = new Uint32Array(t6), n2 = new Uint32Array(512), r2 = new Uint32Array(512);
  for (let t7 = 0; t7 < 256; ++t7) {
    const e3 = t7 - 127;
    e3 < -27 ? (n2[t7] = 0, n2[256 | t7] = 32768, r2[t7] = 24, r2[256 | t7] = 24) : e3 < -14 ? (n2[t7] = 1024 >> -e3 - 14, n2[256 | t7] = 1024 >> -e3 - 14 | 32768, r2[t7] = -e3 - 1, r2[256 | t7] = -e3 - 1) : e3 <= 15 ? (n2[t7] = e3 + 15 << 10, n2[256 | t7] = e3 + 15 << 10 | 32768, r2[t7] = 13, r2[256 | t7] = 13) : e3 < 128 ? (n2[t7] = 31744, n2[256 | t7] = 64512, r2[t7] = 24, r2[256 | t7] = 24) : (n2[t7] = 31744, n2[256 | t7] = 64512, r2[t7] = 13, r2[256 | t7] = 13);
  }
  const s2 = new Uint32Array(2048), o2 = new Uint32Array(64), a2 = new Uint32Array(64);
  for (let t7 = 1; t7 < 1024; ++t7) {
    let e3 = t7 << 13, i3 = 0;
    for (; !(8388608 & e3); ) e3 <<= 1, i3 -= 8388608;
    e3 &= -8388609, i3 += 947912704, s2[t7] = e3 | i3;
  }
  for (let t7 = 1024; t7 < 2048; ++t7) s2[t7] = 939524096 + (t7 - 1024 << 13);
  for (let t7 = 1; t7 < 31; ++t7) o2[t7] = t7 << 23;
  o2[31] = 1199570944, o2[32] = 2147483648;
  for (let t7 = 33; t7 < 63; ++t7) o2[t7] = 2147483648 + (t7 - 32 << 23);
  o2[63] = 3347054592;
  for (let t7 = 1; t7 < 64; ++t7) 32 !== t7 && (a2[t7] = 1024);
  return { floatView: e2, uint32View: i2, baseTable: n2, shiftTable: r2, mantissaTable: s2, exponentTable: o2, offsetTable: a2 };
}
var qv = Object.freeze({ __proto__: null, toHalfFloat: function(t6) {
  Math.abs(t6) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), t6 = Ro(t6, -65504, 65504), Gv.floatView[0] = t6;
  const e2 = Gv.uint32View[0], i2 = e2 >> 23 & 511;
  return Gv.baseTable[i2] + ((8388607 & e2) >> Gv.shiftTable[i2]);
}, fromHalfFloat: function(t6) {
  const e2 = t6 >> 10;
  return Gv.uint32View[0] = Gv.mantissaTable[Gv.offsetTable[e2] + (1023 & t6)] + Gv.exponentTable[e2], Gv.floatView[0];
} });
var Xv = class extends Jl {
  constructor() {
    console.error("THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js"), super();
  }
};
var Yv = class extends Jl {
  constructor() {
    console.error("THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js"), super();
  }
};
function Zv() {
  console.error("THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js");
}
function Jv() {
  console.error("THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js");
}
function Kv() {
  console.error("THREE.ImmediateRenderObject has been removed.");
}
var $v = class extends oa {
  constructor(t6, e2, i2) {
    console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.'), super(t6, e2, i2), this.samples = 4;
  }
};
var Qv = class extends aa {
  constructor(t6, e2, i2, n2) {
    console.warn("THREE.DataTexture2DArray has been renamed to DataArrayTexture."), super(t6, e2, i2, n2);
  }
};
var ty = class extends ca {
  constructor(t6, e2, i2, n2) {
    console.warn("THREE.DataTexture3D has been renamed to Data3DTexture."), super(t6, e2, i2, n2);
  }
};
"undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: cn } })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = cn);
var ey = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}";
var iy = 0;
var ny = 1;
var ry = 2;
var sy = 3;
var oy = 4;
var ay = 5;
var ly = 6;
var cy = 7;
var hy = 8;
var uy = 9;
var dy = 10;
var py = 11;
var fy = 12;
var my = 13;
var gy = 14;
var vy = 15;
var yy = 16;
var xy = 17;
var by = 18;
var wy = 19;
var _y = 20;
var Sy = 21;
var My = 22;
var Ty = 23;
var Ey = 24;
var Ay = 25;
var Cy = 26;
var Ry = 27;
var Py = 28;
var Ly = 29;
var Iy = 30;
var Dy = 31;
var Oy = 32;
var zy = "srgb";
var Fy = "srgb-linear";
var Ny = 0;
var By = 1;
var ky = 2;
var Uy = { FRAGMENT_HEAD: "FRAGMENT_HEAD", FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV", FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE", VERTEX_HEAD: "VERTEX_HEAD", VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT" };
var Hy = 0;
var Vy = 2;
var jy = Number(cn.replace(/\D+/g, ""));
var Gy = jy >= 152;
var Wy = /* @__PURE__ */ new Map([[Bs, Fy], [ks, zy]]);
var qy = /* @__PURE__ */ new Map([[Fy, Bs], [zy, ks]]);
function Xy(t6) {
  return null === t6 ? null : Gy ? t6.outputColorSpace : Wy.get(t6.outputEncoding);
}
function Yy(t6, e2) {
  null !== t6 && (Gy ? t6.colorSpace = e2 : t6.encoding = qy.get(e2));
}
function Zy(t6) {
  return jy < 154 ? t6.replace("colorspace_fragment", "encodings_fragment") : t6;
}
var Jy = [new Float32Array([0, 0]), new Float32Array([0, 1, 1]), new Float32Array([0, 1, 1, 2]), new Float32Array([0, 1, 2, 2, 3]), new Float32Array([0, 1, 2, 3, 4, 4, 5]), new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])];
var Ky = class extends bc {
  constructor(t6 = new sa()) {
    super({ name: "KawaseBlurMaterial", uniforms: { inputBuffer: new Kg(null), texelSize: new Kg(new sa()), scale: new Kg(1), kernel: new Kg(0) }, blending: Tn, toneMapped: false, depthWrite: false, depthTest: false, fragmentShader: "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;\n#include <colorspace_fragment>\n}", vertexShader: "uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}" }), this.fragmentShader = Zy(this.fragmentShader), this.setTexelSize(t6.x, t6.y), this.kernelSize = Vy;
  }
  set inputBuffer(t6) {
    this.uniforms.inputBuffer.value = t6;
  }
  setInputBuffer(t6) {
    this.inputBuffer = t6;
  }
  get kernelSequence() {
    return Jy[this.kernelSize];
  }
  get scale() {
    return this.uniforms.scale.value;
  }
  set scale(t6) {
    this.uniforms.scale.value = t6;
  }
  getScale() {
    return this.uniforms.scale.value;
  }
  setScale(t6) {
    this.uniforms.scale.value = t6;
  }
  getKernel() {
    return null;
  }
  get kernel() {
    return this.uniforms.kernel.value;
  }
  set kernel(t6) {
    this.uniforms.kernel.value = t6;
  }
  setKernel(t6) {
    this.kernel = t6;
  }
  setTexelSize(t6, e2) {
    this.uniforms.texelSize.value.set(t6, e2, 0.5 * t6, 0.5 * e2);
  }
  setSize(t6, e2) {
    const i2 = 1 / t6, n2 = 1 / e2;
    this.uniforms.texelSize.value.set(i2, n2, 0.5 * i2, 0.5 * n2);
  }
};
var $y = class extends bc {
  constructor() {
    super({ name: "CopyMaterial", uniforms: { inputBuffer: new Kg(null), opacity: new Kg(1) }, blending: Tn, toneMapped: false, depthWrite: false, depthTest: false, fragmentShader: "#include <common>\n#include <dithering_pars_fragment>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;\n#include <colorspace_fragment>\n#include <dithering_fragment>\n}", vertexShader: ey }), this.fragmentShader = Zy(this.fragmentShader);
  }
  set inputBuffer(t6) {
    this.uniforms.inputBuffer.value = t6;
  }
  setInputBuffer(t6) {
    this.uniforms.inputBuffer.value = t6;
  }
  getOpacity(t6) {
    return this.uniforms.opacity.value;
  }
  setOpacity(t6) {
    this.uniforms.opacity.value = t6;
  }
};
var Qy = class extends bc {
  constructor(t6 = null, e2) {
    super({ name: "DepthComparisonMaterial", defines: { DEPTH_PACKING: "0" }, uniforms: { depthBuffer: new Kg(null), cameraNear: new Kg(0.3), cameraFar: new Kg(1e3) }, blending: Tn, toneMapped: false, depthWrite: false, depthTest: false, fragmentShader: "#include <packing>\n#include <clipping_planes_pars_fragment>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform float cameraNear;uniform float cameraFar;centroid varying float vViewZ;centroid varying vec4 vProjTexCoord;void main(){\n#include <clipping_planes_fragment>\nvec2 projTexCoord=(vProjTexCoord.xy/vProjTexCoord.w)*0.5+0.5;projTexCoord=clamp(projTexCoord,0.002,0.998);\n#if DEPTH_PACKING == 3201\nfloat fragCoordZ=unpackRGBAToDepth(texture2D(depthBuffer,projTexCoord));\n#else\nfloat fragCoordZ=texture2D(depthBuffer,projTexCoord).r;\n#endif\n#ifdef PERSPECTIVE_CAMERA\nfloat viewZ=perspectiveDepthToViewZ(fragCoordZ,cameraNear,cameraFar);\n#else\nfloat viewZ=orthographicDepthToViewZ(fragCoordZ,cameraNear,cameraFar);\n#endif\nfloat depthTest=(-vViewZ>-viewZ)?1.0:0.0;gl_FragColor.rg=vec2(0.0,depthTest);}", vertexShader: "#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying float vViewZ;varying vec4 vProjTexCoord;void main(){\n#include <skinbase_vertex>\n#include <begin_vertex>\n#include <morphtarget_vertex>\n#include <skinning_vertex>\n#include <project_vertex>\nvViewZ=mvPosition.z;vProjTexCoord=gl_Position;\n#include <clipping_planes_vertex>\n}" }), this.depthBuffer = t6, this.depthPacking = Hs, this.copyCameraSettings(e2);
  }
  set depthBuffer(t6) {
    this.uniforms.depthBuffer.value = t6;
  }
  set depthPacking(t6) {
    this.defines.DEPTH_PACKING = t6.toFixed(0), this.needsUpdate = true;
  }
  setDepthBuffer(t6, e2 = Hs) {
    this.depthBuffer = t6, this.depthPacking = e2;
  }
  adoptCameraSettings(t6) {
    this.copyCameraSettings(t6);
  }
  copyCameraSettings(t6) {
    t6 && (this.uniforms.cameraNear.value = t6.near, this.uniforms.cameraFar.value = t6.far, t6 instanceof _c ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = true);
  }
};
var tx = class extends bc {
  constructor(t6, e2, i2, n2, r2 = false) {
    super({ name: "EffectMaterial", defines: { THREE_REVISION: cn.replace(/\D+/g, ""), DEPTH_PACKING: "0", ENCODE_OUTPUT: "1" }, uniforms: { inputBuffer: new Kg(null), depthBuffer: new Kg(null), resolution: new Kg(new Fo()), texelSize: new Kg(new Fo()), cameraNear: new Kg(0.3), cameraFar: new Kg(1e3), aspect: new Kg(1), time: new Kg(0) }, blending: Tn, toneMapped: false, depthWrite: false, depthTest: false, dithering: r2 }), t6 && this.setShaderParts(t6), e2 && this.setDefines(e2), i2 && this.setUniforms(i2), this.copyCameraSettings(n2);
  }
  set inputBuffer(t6) {
    this.uniforms.inputBuffer.value = t6;
  }
  setInputBuffer(t6) {
    this.uniforms.inputBuffer.value = t6;
  }
  get depthBuffer() {
    return this.uniforms.depthBuffer.value;
  }
  set depthBuffer(t6) {
    this.uniforms.depthBuffer.value = t6;
  }
  get depthPacking() {
    return Number(this.defines.DEPTH_PACKING);
  }
  set depthPacking(t6) {
    this.defines.DEPTH_PACKING = t6.toFixed(0), this.needsUpdate = true;
  }
  setDepthBuffer(t6, e2 = Us) {
    this.depthBuffer = t6, this.depthPacking = e2;
  }
  setShaderData(t6) {
    this.setShaderParts(t6.shaderParts), this.setDefines(t6.defines), this.setUniforms(t6.uniforms), this.setExtensions(t6.extensions);
  }
  setShaderParts(t6) {
    return this.fragmentShader = "#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;\n#if THREE_REVISION < 143\n#define luminance(v) linearToRelativeLuminance(v)\n#endif\n#if THREE_REVISION >= 137\nvec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;\n#ifdef ENCODE_OUTPUT\n#include <colorspace_fragment>\n#endif\n#include <dithering_fragment>\n}".replace(Uy.FRAGMENT_HEAD, t6.get(Uy.FRAGMENT_HEAD) || "").replace(Uy.FRAGMENT_MAIN_UV, t6.get(Uy.FRAGMENT_MAIN_UV) || "").replace(Uy.FRAGMENT_MAIN_IMAGE, t6.get(Uy.FRAGMENT_MAIN_IMAGE) || ""), this.vertexShader = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}".replace(Uy.VERTEX_HEAD, t6.get(Uy.VERTEX_HEAD) || "").replace(Uy.VERTEX_MAIN_SUPPORT, t6.get(Uy.VERTEX_MAIN_SUPPORT) || ""), this.fragmentShader = Zy(this.fragmentShader), this.needsUpdate = true, this;
  }
  setDefines(t6) {
    for (const e2 of t6.entries()) this.defines[e2[0]] = e2[1];
    return this.needsUpdate = true, this;
  }
  setUniforms(t6) {
    for (const e2 of t6.entries()) this.uniforms[e2[0]] = e2[1];
    return this;
  }
  setExtensions(t6) {
    this.extensions = {};
    for (const e2 of t6) this.extensions[e2] = true;
    return this;
  }
  get encodeOutput() {
    return void 0 !== this.defines.ENCODE_OUTPUT;
  }
  set encodeOutput(t6) {
    this.encodeOutput !== t6 && (t6 ? this.defines.ENCODE_OUTPUT = "1" : delete this.defines.ENCODE_OUTPUT, this.needsUpdate = true);
  }
  isOutputEncodingEnabled(t6) {
    return this.encodeOutput;
  }
  setOutputEncodingEnabled(t6) {
    this.encodeOutput = t6;
  }
  get time() {
    return this.uniforms.time.value;
  }
  set time(t6) {
    this.uniforms.time.value = t6;
  }
  setDeltaTime(t6) {
    this.uniforms.time.value += t6;
  }
  adoptCameraSettings(t6) {
    this.copyCameraSettings(t6);
  }
  copyCameraSettings(t6) {
    t6 && (this.uniforms.cameraNear.value = t6.near, this.uniforms.cameraFar.value = t6.far, t6 instanceof _c ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = true);
  }
  setSize(t6, e2) {
    const i2 = this.uniforms;
    i2.resolution.value.set(t6, e2), i2.texelSize.value.set(1 / t6, 1 / e2), i2.aspect.value = t6 / e2;
  }
  static get Section() {
    return Uy;
  }
};
var ex = class extends bc {
  constructor(t6 = new Fo()) {
    super({ name: "OutlineMaterial", uniforms: { inputBuffer: new Kg(null), texelSize: new Kg(new Fo()) }, blending: Tn, toneMapped: false, depthWrite: false, depthTest: false, fragmentShader: "uniform lowp sampler2D inputBuffer;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 c0=texture2D(inputBuffer,vUv0).rg;vec2 c1=texture2D(inputBuffer,vUv1).rg;vec2 c2=texture2D(inputBuffer,vUv2).rg;vec2 c3=texture2D(inputBuffer,vUv3).rg;float d0=(c0.x-c1.x)*0.5;float d1=(c2.x-c3.x)*0.5;float d=length(vec2(d0,d1));float a0=min(c0.y,c1.y);float a1=min(c2.y,c3.y);float visibilityFactor=min(a0,a1);gl_FragColor.rg=(1.0-visibilityFactor>0.001)?vec2(d,0.0):vec2(0.0,d);}", vertexShader: "uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=vec2(uv.x+texelSize.x,uv.y);vUv1=vec2(uv.x-texelSize.x,uv.y);vUv2=vec2(uv.x,uv.y+texelSize.y);vUv3=vec2(uv.x,uv.y-texelSize.y);gl_Position=vec4(position.xy,1.0,1.0);}" }), this.uniforms.texelSize.value.set(t6.x, t6.y), this.uniforms.maskTexture = this.uniforms.inputBuffer;
  }
  set inputBuffer(t6) {
    this.uniforms.inputBuffer.value = t6;
  }
  setInputBuffer(t6) {
    this.uniforms.inputBuffer.value = t6;
  }
  setTexelSize(t6, e2) {
    this.uniforms.texelSize.value.set(t6, e2);
  }
  setSize(t6, e2) {
    this.uniforms.texelSize.value.set(1 / t6, 1 / e2);
  }
};
var ix = new wc();
var nx = null;
var rx = class t5 {
  constructor(t6 = "Pass", e2 = new bd(), i2 = ix) {
    this.name = t6, this.renderer = null, this.scene = e2, this.camera = i2, this.screen = null, this.rtt = true, this.needsSwap = true, this.needsDepthTexture = false, this.enabled = true;
  }
  get renderToScreen() {
    return !this.rtt;
  }
  set renderToScreen(t6) {
    if (this.rtt === t6) {
      const e2 = this.fullscreenMaterial;
      null !== e2 && (e2.needsUpdate = true), this.rtt = !t6;
    }
  }
  set mainScene(t6) {
  }
  set mainCamera(t6) {
  }
  setRenderer(t6) {
    this.renderer = t6;
  }
  isEnabled() {
    return this.enabled;
  }
  setEnabled(t6) {
    this.enabled = t6;
  }
  get fullscreenMaterial() {
    return null !== this.screen ? this.screen.material : null;
  }
  set fullscreenMaterial(t6) {
    let e2 = this.screen;
    null !== e2 ? e2.material = t6 : (e2 = new fc((function() {
      if (null === nx) {
        const t7 = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]), e3 = new Float32Array([0, 0, 2, 0, 0, 2]);
        void 0 !== (nx = new Jl()).setAttribute ? (nx.setAttribute("position", new Il(t7, 3)), nx.setAttribute("uv", new Il(e3, 2))) : (nx.addAttribute("position", new Il(t7, 3)), nx.addAttribute("uv", new Il(e3, 2)));
      }
      return nx;
    })(), t6), e2.frustumCulled = false, null === this.scene && (this.scene = new bd()), this.scene.add(e2), this.screen = e2);
  }
  getFullscreenMaterial() {
    return this.fullscreenMaterial;
  }
  setFullscreenMaterial(t6) {
    this.fullscreenMaterial = t6;
  }
  getDepthTexture() {
    return null;
  }
  setDepthTexture(t6, e2 = Us) {
  }
  render(t6, e2, i2, n2, r2) {
    throw new Error("Render method not implemented!");
  }
  setSize(t6, e2) {
  }
  initialize(t6, e2, i2) {
  }
  dispose() {
    for (const e2 of Object.keys(this)) {
      const i2 = this[e2];
      (i2 instanceof oa || i2 instanceof Cl || i2 instanceof ra || i2 instanceof t5) && this[e2].dispose();
    }
  }
};
var sx = class extends rx {
  constructor(t6, e2 = true) {
    super("CopyPass"), this.fullscreenMaterial = new $y(), this.needsSwap = false, this.renderTarget = t6, void 0 === t6 && (this.renderTarget = new oa(1, 1, { minFilter: Mr, magFilter: Mr, stencilBuffer: false, depthBuffer: false }), this.renderTarget.texture.name = "CopyPass.Target"), this.autoResize = e2;
  }
  get resize() {
    return this.autoResize;
  }
  set resize(t6) {
    this.autoResize = t6;
  }
  get texture() {
    return this.renderTarget.texture;
  }
  getTexture() {
    return this.renderTarget.texture;
  }
  setAutoResizeEnabled(t6) {
    this.autoResize = t6;
  }
  render(t6, e2, i2, n2, r2) {
    this.fullscreenMaterial.inputBuffer = e2.texture, t6.setRenderTarget(this.renderToScreen ? null : this.renderTarget), t6.render(this.scene, this.camera);
  }
  setSize(t6, e2) {
    this.autoResize && this.renderTarget.setSize(t6, e2);
  }
  initialize(t6, e2, i2) {
    void 0 !== i2 && (this.renderTarget.texture.type = i2, i2 !== Rr ? this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1" : Xy(t6) === zy && Yy(this.renderTarget.texture, zy));
  }
};
var ox = class extends rx {
  constructor() {
    super("ClearMaskPass", null, null), this.needsSwap = false;
  }
  render(t6, e2, i2, n2, r2) {
    const s2 = t6.state.buffers.stencil;
    s2.setLocked(false), s2.setTest(false);
  }
};
var ax = new $o();
var lx = class extends rx {
  constructor(t6 = true, e2 = true, i2 = false) {
    super("ClearPass", null, null), this.needsSwap = false, this.color = t6, this.depth = e2, this.stencil = i2, this.overrideClearColor = null, this.overrideClearAlpha = -1;
  }
  setClearFlags(t6, e2, i2) {
    this.color = t6, this.depth = e2, this.stencil = i2;
  }
  getOverrideClearColor() {
    return this.overrideClearColor;
  }
  setOverrideClearColor(t6) {
    this.overrideClearColor = t6;
  }
  getOverrideClearAlpha() {
    return this.overrideClearAlpha;
  }
  setOverrideClearAlpha(t6) {
    this.overrideClearAlpha = t6;
  }
  render(t6, e2, i2, n2, r2) {
    const s2 = this.overrideClearColor, o2 = this.overrideClearAlpha, a2 = t6.getClearAlpha(), l2 = null !== s2, c2 = o2 >= 0;
    l2 ? (t6.getClearColor(ax), t6.setClearColor(s2, c2 ? o2 : a2)) : c2 && t6.setClearAlpha(o2), t6.setRenderTarget(this.renderToScreen ? null : e2), t6.clear(this.color, this.depth, this.stencil), l2 ? t6.setClearColor(ax, a2) : c2 && t6.setClearAlpha(a2);
  }
};
var cx = class extends rx {
  constructor(t6, e2, i2 = null) {
    super("RenderPass", t6, e2), this.needsSwap = false, this.clearPass = new lx(), this.overrideMaterialManager = null === i2 ? null : new _x(i2), this.ignoreBackground = false, this.skipShadowMapUpdate = false, this.selection = null;
  }
  set mainScene(t6) {
    this.scene = t6;
  }
  set mainCamera(t6) {
    this.camera = t6;
  }
  get renderToScreen() {
    return super.renderToScreen;
  }
  set renderToScreen(t6) {
    super.renderToScreen = t6, this.clearPass.renderToScreen = t6;
  }
  get overrideMaterial() {
    const t6 = this.overrideMaterialManager;
    return null !== t6 ? t6.material : null;
  }
  set overrideMaterial(t6) {
    const e2 = this.overrideMaterialManager;
    null !== t6 ? null !== e2 ? e2.setMaterial(t6) : this.overrideMaterialManager = new _x(t6) : null !== e2 && (e2.dispose(), this.overrideMaterialManager = null);
  }
  getOverrideMaterial() {
    return this.overrideMaterial;
  }
  setOverrideMaterial(t6) {
    this.overrideMaterial = t6;
  }
  get clear() {
    return this.clearPass.enabled;
  }
  set clear(t6) {
    this.clearPass.enabled = t6;
  }
  getSelection() {
    return this.selection;
  }
  setSelection(t6) {
    this.selection = t6;
  }
  isBackgroundDisabled() {
    return this.ignoreBackground;
  }
  setBackgroundDisabled(t6) {
    this.ignoreBackground = t6;
  }
  isShadowMapDisabled() {
    return this.skipShadowMapUpdate;
  }
  setShadowMapDisabled(t6) {
    this.skipShadowMapUpdate = t6;
  }
  getClearPass() {
    return this.clearPass;
  }
  render(t6, e2, i2, n2, r2) {
    const s2 = this.scene, o2 = this.camera, a2 = this.selection, l2 = o2.layers.mask, c2 = s2.background, h2 = t6.shadowMap.autoUpdate, u2 = this.renderToScreen ? null : e2;
    null !== a2 && o2.layers.set(a2.getLayer()), this.skipShadowMapUpdate && (t6.shadowMap.autoUpdate = false), (this.ignoreBackground || null !== this.clearPass.overrideClearColor) && (s2.background = null), this.clearPass.enabled && this.clearPass.render(t6, e2), t6.setRenderTarget(u2), null !== this.overrideMaterialManager ? this.overrideMaterialManager.render(t6, s2, o2) : t6.render(s2, o2), o2.layers.mask = l2, s2.background = c2, t6.shadowMap.autoUpdate = h2;
  }
};
var hx = class extends rx {
  constructor(t6, e2, { renderTarget: i2, resolutionScale: n2 = 1, width: r2 = Mx.AUTO_SIZE, height: s2 = Mx.AUTO_SIZE, resolutionX: o2 = r2, resolutionY: a2 = s2 } = {}) {
    super("DepthPass"), this.needsSwap = false, this.renderPass = new cx(t6, e2, new td({ depthPacking: Hs }));
    const l2 = this.renderPass;
    l2.skipShadowMapUpdate = true, l2.ignoreBackground = true;
    const c2 = l2.clearPass;
    c2.overrideClearColor = new $o(16777215), c2.overrideClearAlpha = 1, this.renderTarget = i2, void 0 === this.renderTarget && (this.renderTarget = new oa(1, 1, { minFilter: xr, magFilter: xr }), this.renderTarget.texture.name = "DepthPass.Target");
    const h2 = this.resolution = new Mx(this, o2, a2, n2);
    h2.addEventListener("change", ((t7) => this.setSize(h2.baseWidth, h2.baseHeight)));
  }
  set mainScene(t6) {
    this.renderPass.mainScene = t6;
  }
  set mainCamera(t6) {
    this.renderPass.mainCamera = t6;
  }
  get texture() {
    return this.renderTarget.texture;
  }
  getTexture() {
    return this.renderTarget.texture;
  }
  getResolution() {
    return this.resolution;
  }
  getResolutionScale() {
    return this.resolution.scale;
  }
  setResolutionScale(t6) {
    this.resolution.scale = t6;
  }
  render(t6, e2, i2, n2, r2) {
    const s2 = this.renderToScreen ? null : this.renderTarget;
    this.renderPass.render(t6, s2);
  }
  setSize(t6, e2) {
    const i2 = this.resolution;
    i2.setBaseSize(t6, e2), this.renderTarget.setSize(i2.width, i2.height);
  }
};
new Float32Array([255 / 256 / 256 ** 3, 255 / 256 / 65536, 255 / 256 / 256, 255 / 256]);
function ux(t6, e2, i2) {
  for (const n2 of e2) {
    const e3 = "$1" + t6 + n2.charAt(0).toUpperCase() + n2.slice(1), r2 = new RegExp("([^\\.])(\\b" + n2 + "\\b)", "g");
    for (const t7 of i2.entries()) null !== t7[1] && i2.set(t7[0], t7[1].replace(r2, e3));
  }
}
function dx(t6, e2, i2) {
  let n2 = e2.getFragmentShader(), r2 = e2.getVertexShader();
  const s2 = void 0 !== n2 && /mainImage/.test(n2), o2 = void 0 !== n2 && /mainUv/.test(n2);
  if (i2.attributes |= e2.getAttributes(), void 0 === n2) throw new Error(`Missing fragment shader (${e2.name})`);
  if (o2 && i2.attributes & ky) throw new Error(`Effects that transform UVs are incompatible with convolution effects (${e2.name})`);
  if (!s2 && !o2) throw new Error(`Could not find mainImage or mainUv function (${e2.name})`);
  {
    const a2 = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g, l2 = i2.shaderParts;
    let c2 = l2.get(Uy.FRAGMENT_HEAD) || "", h2 = l2.get(Uy.FRAGMENT_MAIN_UV) || "", u2 = l2.get(Uy.FRAGMENT_MAIN_IMAGE) || "", d2 = l2.get(Uy.VERTEX_HEAD) || "", p2 = l2.get(Uy.VERTEX_MAIN_SUPPORT) || "";
    const f2 = /* @__PURE__ */ new Set(), m2 = /* @__PURE__ */ new Set();
    if (o2 && (h2 += `	${t6}MainUv(UV);
`, i2.uvTransformation = true), null !== r2 && /mainSupport/.test(r2)) {
      const e3 = /mainSupport *\([\w\s]*?uv\s*?\)/.test(r2);
      p2 += `	${t6}MainSupport(`, p2 += e3 ? "vUv);\n" : ");\n";
      for (const t7 of r2.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g)) for (const e4 of t7[1].split(/\s*,\s*/)) i2.varyings.add(e4), f2.add(e4), m2.add(e4);
      for (const t7 of r2.matchAll(a2)) m2.add(t7[1]);
    }
    for (const t7 of n2.matchAll(a2)) m2.add(t7[1]);
    for (const t7 of e2.defines.keys()) m2.add(t7.replace(/\([\w\s,]*\)/g, ""));
    for (const t7 of e2.uniforms.keys()) m2.add(t7);
    m2.delete("while"), m2.delete("for"), m2.delete("if"), e2.uniforms.forEach(((e3, n3) => i2.uniforms.set(t6 + n3.charAt(0).toUpperCase() + n3.slice(1), e3))), e2.defines.forEach(((e3, n3) => i2.defines.set(t6 + n3.charAt(0).toUpperCase() + n3.slice(1), e3)));
    const g2 = /* @__PURE__ */ new Map([["fragment", n2], ["vertex", r2]]);
    ux(t6, m2, i2.defines), ux(t6, m2, g2), n2 = g2.get("fragment"), r2 = g2.get("vertex");
    const v2 = e2.blendMode;
    if (i2.blendModes.set(v2.blendFunction, v2), s2) {
      null !== e2.inputColorSpace && e2.inputColorSpace !== i2.colorSpace && (u2 += e2.inputColorSpace === zy ? "color0 = LinearTosRGB(color0);\n	" : "color0 = sRGBToLinear(color0);\n	"), "" !== e2.outputColorSpace ? i2.colorSpace = e2.outputColorSpace : null !== e2.inputColorSpace && (i2.colorSpace = e2.inputColorSpace);
      const r3 = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;
      u2 += `${t6}MainImage(color0, UV, `, i2.attributes & By && r3.test(n2) && (u2 += "depth, ", i2.readDepth = true), u2 += "color1);\n	";
      const s3 = t6 + "BlendOpacity";
      i2.uniforms.set(s3, v2.opacity), u2 += `color0 = blend${v2.blendFunction}(color0, color1, ${s3});

	`, c2 += `uniform float ${s3};

`;
    }
    if (c2 += n2 + "\n", null !== r2 && (d2 += r2 + "\n"), l2.set(Uy.FRAGMENT_HEAD, c2), l2.set(Uy.FRAGMENT_MAIN_UV, h2), l2.set(Uy.FRAGMENT_MAIN_IMAGE, u2), l2.set(Uy.VERTEX_HEAD, d2), l2.set(Uy.VERTEX_MAIN_SUPPORT, p2), null !== e2.extensions) for (const t7 of e2.extensions) i2.extensions.add(t7);
  }
}
var px = class extends rx {
  constructor(t6, ...e2) {
    super("EffectPass"), this.fullscreenMaterial = new tx(null, null, null, t6), this.listener = (t7) => this.handleEvent(t7), this.effects = [], this.setEffects(e2), this.skipRendering = false, this.minTime = 1, this.maxTime = Number.POSITIVE_INFINITY, this.timeScale = 1;
  }
  set mainScene(t6) {
    for (const e2 of this.effects) e2.mainScene = t6;
  }
  set mainCamera(t6) {
    this.fullscreenMaterial.copyCameraSettings(t6);
    for (const e2 of this.effects) e2.mainCamera = t6;
  }
  get encodeOutput() {
    return this.fullscreenMaterial.encodeOutput;
  }
  set encodeOutput(t6) {
    this.fullscreenMaterial.encodeOutput = t6;
  }
  get dithering() {
    return this.fullscreenMaterial.dithering;
  }
  set dithering(t6) {
    const e2 = this.fullscreenMaterial;
    e2.dithering = t6, e2.needsUpdate = true;
  }
  setEffects(t6) {
    for (const t7 of this.effects) t7.removeEventListener("change", this.listener);
    this.effects = t6.sort(((t7, e2) => e2.attributes - t7.attributes));
    for (const t7 of this.effects) t7.addEventListener("change", this.listener);
  }
  updateMaterial() {
    const t6 = new bx();
    let e2 = 0;
    for (const i3 of this.effects) if (i3.blendMode.blendFunction === uy) t6.attributes |= i3.getAttributes() & By;
    else {
      if (t6.attributes & i3.getAttributes() & ky) throw new Error(`Convolution effects cannot be merged (${i3.name})`);
      dx("e" + e2++, i3, t6);
    }
    let i2 = t6.shaderParts.get(Uy.FRAGMENT_HEAD), n2 = t6.shaderParts.get(Uy.FRAGMENT_MAIN_IMAGE), r2 = t6.shaderParts.get(Uy.FRAGMENT_MAIN_UV);
    const s2 = /\bblend\b/g;
    for (const e3 of t6.blendModes.values()) i2 += e3.getShaderCode().replace(s2, `blend${e3.blendFunction}`) + "\n";
    t6.attributes & By ? (t6.readDepth && (n2 = "float depth = readDepth(UV);\n\n	" + n2), this.needsDepthTexture = null === this.getDepthTexture()) : this.needsDepthTexture = false, t6.colorSpace === zy && (n2 += "color0 = sRGBToLinear(color0);\n	"), t6.uvTransformation ? (r2 = "vec2 transformedUv = vUv;\n" + r2, t6.defines.set("UV", "transformedUv")) : t6.defines.set("UV", "vUv"), t6.shaderParts.set(Uy.FRAGMENT_HEAD, i2), t6.shaderParts.set(Uy.FRAGMENT_MAIN_IMAGE, n2), t6.shaderParts.set(Uy.FRAGMENT_MAIN_UV, r2);
    for (const [e3, i3] of t6.shaderParts) null !== i3 && t6.shaderParts.set(e3, i3.trim().replace(/^#/, "\n#"));
    this.skipRendering = 0 === e2, this.needsSwap = !this.skipRendering, this.fullscreenMaterial.setShaderData(t6);
  }
  recompile() {
    this.updateMaterial();
  }
  getDepthTexture() {
    return this.fullscreenMaterial.depthBuffer;
  }
  setDepthTexture(t6, e2 = Us) {
    this.fullscreenMaterial.depthBuffer = t6, this.fullscreenMaterial.depthPacking = e2;
    for (const i2 of this.effects) i2.setDepthTexture(t6, e2);
  }
  render(t6, e2, i2, n2, r2) {
    for (const i3 of this.effects) i3.update(t6, e2, n2);
    if (!this.skipRendering || this.renderToScreen) {
      const r3 = this.fullscreenMaterial;
      r3.inputBuffer = e2.texture, r3.time += n2 * this.timeScale, t6.setRenderTarget(this.renderToScreen ? null : i2), t6.render(this.scene, this.camera);
    }
  }
  setSize(t6, e2) {
    this.fullscreenMaterial.setSize(t6, e2);
    for (const i2 of this.effects) i2.setSize(t6, e2);
  }
  initialize(t6, e2, i2) {
    this.renderer = t6;
    for (const n2 of this.effects) n2.initialize(t6, e2, i2);
    this.updateMaterial(), void 0 !== i2 && i2 !== Rr && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1");
  }
  dispose() {
    super.dispose();
    for (const t6 of this.effects) t6.removeEventListener("change", this.listener), t6.dispose();
  }
  handleEvent(t6) {
    if ("change" === t6.type) this.recompile();
  }
};
var fx = class extends rx {
  constructor({ kernelSize: t6 = Vy, resolutionScale: e2 = 0.5, width: i2 = Mx.AUTO_SIZE, height: n2 = Mx.AUTO_SIZE, resolutionX: r2 = i2, resolutionY: s2 = n2 } = {}) {
    super("KawaseBlurPass"), this.renderTargetA = new oa(1, 1, { depthBuffer: false }), this.renderTargetA.texture.name = "Blur.Target.A", this.renderTargetB = this.renderTargetA.clone(), this.renderTargetB.texture.name = "Blur.Target.B";
    const o2 = this.resolution = new Mx(this, r2, s2, e2);
    o2.addEventListener("change", ((t7) => this.setSize(o2.baseWidth, o2.baseHeight))), this._blurMaterial = new Ky(), this._blurMaterial.kernelSize = t6, this.copyMaterial = new $y();
  }
  getResolution() {
    return this.resolution;
  }
  get blurMaterial() {
    return this._blurMaterial;
  }
  set blurMaterial(t6) {
    this._blurMaterial = t6;
  }
  get dithering() {
    return this.copyMaterial.dithering;
  }
  set dithering(t6) {
    this.copyMaterial.dithering = t6;
  }
  get kernelSize() {
    return this.blurMaterial.kernelSize;
  }
  set kernelSize(t6) {
    this.blurMaterial.kernelSize = t6;
  }
  get width() {
    return this.resolution.width;
  }
  set width(t6) {
    this.resolution.preferredWidth = t6;
  }
  get height() {
    return this.resolution.height;
  }
  set height(t6) {
    this.resolution.preferredHeight = t6;
  }
  get scale() {
    return this.blurMaterial.scale;
  }
  set scale(t6) {
    this.blurMaterial.scale = t6;
  }
  getScale() {
    return this.blurMaterial.scale;
  }
  setScale(t6) {
    this.blurMaterial.scale = t6;
  }
  getKernelSize() {
    return this.kernelSize;
  }
  setKernelSize(t6) {
    this.kernelSize = t6;
  }
  getResolutionScale() {
    return this.resolution.scale;
  }
  setResolutionScale(t6) {
    this.resolution.scale = t6;
  }
  render(t6, e2, i2, n2, r2) {
    const s2 = this.scene, o2 = this.camera, a2 = this.renderTargetA, l2 = this.renderTargetB, c2 = this.blurMaterial, h2 = c2.kernelSequence;
    let u2 = e2;
    this.fullscreenMaterial = c2;
    for (let e3 = 0, i3 = h2.length; e3 < i3; ++e3) {
      const i4 = 1 & e3 ? l2 : a2;
      c2.kernel = h2[e3], c2.inputBuffer = u2.texture, t6.setRenderTarget(i4), t6.render(s2, o2), u2 = i4;
    }
    this.fullscreenMaterial = this.copyMaterial, this.copyMaterial.inputBuffer = u2.texture, t6.setRenderTarget(this.renderToScreen ? null : i2), t6.render(s2, o2);
  }
  setSize(t6, e2) {
    const i2 = this.resolution;
    i2.setBaseSize(t6, e2);
    const n2 = i2.width, r2 = i2.height;
    this.renderTargetA.setSize(n2, r2), this.renderTargetB.setSize(n2, r2), this.blurMaterial.setSize(t6, e2);
  }
  initialize(t6, e2, i2) {
    void 0 !== i2 && (this.renderTargetA.texture.type = i2, this.renderTargetB.texture.type = i2, i2 !== Rr ? (this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1", this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") : Xy(t6) === zy && (Yy(this.renderTargetA.texture, zy), Yy(this.renderTargetB.texture, zy)));
  }
  static get AUTO_SIZE() {
    return Mx.AUTO_SIZE;
  }
};
var mx = class extends rx {
  constructor(t6, e2) {
    super("MaskPass", t6, e2), this.needsSwap = false, this.clearPass = new lx(false, false, true), this.inverse = false;
  }
  set mainScene(t6) {
    this.scene = t6;
  }
  set mainCamera(t6) {
    this.camera = t6;
  }
  get inverted() {
    return this.inverse;
  }
  set inverted(t6) {
    this.inverse = t6;
  }
  get clear() {
    return this.clearPass.enabled;
  }
  set clear(t6) {
    this.clearPass.enabled = t6;
  }
  getClearPass() {
    return this.clearPass;
  }
  isInverted() {
    return this.inverted;
  }
  setInverted(t6) {
    this.inverted = t6;
  }
  render(t6, e2, i2, n2, r2) {
    const s2 = t6.getContext(), o2 = t6.state.buffers, a2 = this.scene, l2 = this.camera, c2 = this.clearPass, h2 = this.inverted ? 0 : 1, u2 = 1 - h2;
    o2.color.setMask(false), o2.depth.setMask(false), o2.color.setLocked(true), o2.depth.setLocked(true), o2.stencil.setTest(true), o2.stencil.setOp(s2.REPLACE, s2.REPLACE, s2.REPLACE), o2.stencil.setFunc(s2.ALWAYS, h2, 4294967295), o2.stencil.setClear(u2), o2.stencil.setLocked(true), this.clearPass.enabled && (this.renderToScreen ? c2.render(t6, null) : (c2.render(t6, e2), c2.render(t6, i2))), this.renderToScreen ? (t6.setRenderTarget(null), t6.render(a2, l2)) : (t6.setRenderTarget(e2), t6.render(a2, l2), t6.setRenderTarget(i2), t6.render(a2, l2)), o2.color.setLocked(false), o2.depth.setLocked(false), o2.stencil.setLocked(false), o2.stencil.setFunc(s2.EQUAL, 1, 4294967295), o2.stencil.setOp(s2.KEEP, s2.KEEP, s2.KEEP), o2.stencil.setLocked(true);
  }
};
var gx = class extends rx {
  constructor(t6, e2 = "inputBuffer") {
    super("ShaderPass"), this.fullscreenMaterial = t6, this.input = e2;
  }
  setInput(t6) {
    this.input = t6;
  }
  render(t6, e2, i2, n2, r2) {
    const s2 = this.fullscreenMaterial.uniforms;
    null !== e2 && void 0 !== s2 && void 0 !== s2[this.input] && (s2[this.input].value = e2.texture), t6.setRenderTarget(this.renderToScreen ? null : i2), t6.render(this.scene, this.camera);
  }
  initialize(t6, e2, i2) {
    void 0 !== i2 && i2 !== Rr && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1");
  }
};
var vx = 1e-3;
var yx = class {
  constructor() {
    this.startTime = performance.now(), this.previousTime = 0, this.currentTime = 0, this._delta = 0, this._elapsed = 0, this._fixedDelta = 1e3 / 60, this.timescale = 1, this.useFixedDelta = false, this._autoReset = false;
  }
  get autoReset() {
    return this._autoReset;
  }
  set autoReset(t6) {
    "undefined" != typeof document && void 0 !== document.hidden && (t6 ? document.addEventListener("visibilitychange", this) : document.removeEventListener("visibilitychange", this), this._autoReset = t6);
  }
  get delta() {
    return this._delta * vx;
  }
  get fixedDelta() {
    return this._fixedDelta * vx;
  }
  set fixedDelta(t6) {
    this._fixedDelta = 1e3 * t6;
  }
  get elapsed() {
    return this._elapsed * vx;
  }
  update(t6) {
    this.useFixedDelta ? this._delta = this.fixedDelta : (this.previousTime = this.currentTime, this.currentTime = (void 0 !== t6 ? t6 : performance.now()) - this.startTime, this._delta = this.currentTime - this.previousTime), this._delta *= this.timescale, this._elapsed += this._delta;
  }
  reset() {
    this._delta = 0, this._elapsed = 0, this.currentTime = performance.now() - this.startTime;
  }
  handleEvent(t6) {
    document.hidden || (this.currentTime = performance.now() - this.startTime);
  }
  dispose() {
    this.autoReset = false;
  }
};
var xx = class {
  constructor(t6 = null, { depthBuffer: e2 = true, stencilBuffer: i2 = false, multisampling: n2 = 0, frameBufferType: r2 } = {}) {
    this.renderer = null, this.inputBuffer = this.createBuffer(e2, i2, r2, n2), this.outputBuffer = this.inputBuffer.clone(), this.copyPass = new sx(), this.depthTexture = null, this.passes = [], this.timer = new yx(), this.autoRenderToScreen = true, this.setRenderer(t6);
  }
  get multisampling() {
    return this.inputBuffer.samples || 0;
  }
  set multisampling(t6) {
    const e2 = this.inputBuffer, i2 = this.multisampling;
    i2 > 0 && t6 > 0 ? (this.inputBuffer.samples = t6, this.outputBuffer.samples = t6, this.inputBuffer.dispose(), this.outputBuffer.dispose()) : i2 !== t6 && (this.inputBuffer.dispose(), this.outputBuffer.dispose(), this.inputBuffer = this.createBuffer(e2.depthBuffer, e2.stencilBuffer, e2.texture.type, t6), this.inputBuffer.depthTexture = this.depthTexture, this.outputBuffer = this.inputBuffer.clone());
  }
  getTimer() {
    return this.timer;
  }
  getRenderer() {
    return this.renderer;
  }
  setRenderer(t6) {
    if (this.renderer = t6, null !== t6) {
      const e2 = t6.getSize(new Fo()), i2 = t6.getContext().getContextAttributes().alpha, n2 = this.inputBuffer.texture.type;
      n2 === Rr && Xy(t6) === zy && (Yy(this.inputBuffer.texture, zy), Yy(this.outputBuffer.texture, zy), this.inputBuffer.dispose(), this.outputBuffer.dispose()), t6.autoClear = false, this.setSize(e2.width, e2.height);
      for (const e3 of this.passes) e3.initialize(t6, i2, n2);
    }
  }
  replaceRenderer(t6, e2 = true) {
    const i2 = this.renderer, n2 = i2.domElement.parentNode;
    return this.setRenderer(t6), e2 && null !== n2 && (n2.removeChild(i2.domElement), n2.appendChild(t6.domElement)), i2;
  }
  createDepthTexture() {
    const t6 = this.depthTexture = new dd();
    return this.inputBuffer.depthTexture = t6, this.inputBuffer.dispose(), this.inputBuffer.stencilBuffer ? (t6.format = qr, t6.type = kr) : t6.type = Or, t6;
  }
  deleteDepthTexture() {
    if (null !== this.depthTexture) {
      this.depthTexture.dispose(), this.depthTexture = null, this.inputBuffer.depthTexture = null, this.inputBuffer.dispose();
      for (const t6 of this.passes) t6.setDepthTexture(null);
    }
  }
  createBuffer(t6, e2, i2, n2) {
    const r2 = this.renderer, s2 = null === r2 ? new Fo() : r2.getDrawingBufferSize(new Fo()), o2 = { minFilter: Mr, magFilter: Mr, stencilBuffer: e2, depthBuffer: t6, type: i2 }, a2 = new oa(s2.width, s2.height, o2);
    return n2 > 0 && (a2.ignoreDepthForMultisampleCopy = false, a2.samples = n2), i2 === Rr && Xy(r2) === zy && Yy(a2.texture, zy), a2.texture.name = "EffectComposer.Buffer", a2.texture.generateMipmaps = false, a2;
  }
  setMainScene(t6) {
    for (const e2 of this.passes) e2.mainScene = t6;
  }
  setMainCamera(t6) {
    for (const e2 of this.passes) e2.mainCamera = t6;
  }
  addPass(t6, e2) {
    const i2 = this.passes, n2 = this.renderer, r2 = n2.getDrawingBufferSize(new Fo()), s2 = n2.getContext().getContextAttributes().alpha, o2 = this.inputBuffer.texture.type;
    if (t6.setRenderer(n2), t6.setSize(r2.width, r2.height), t6.initialize(n2, s2, o2), this.autoRenderToScreen && (i2.length > 0 && (i2[i2.length - 1].renderToScreen = false), t6.renderToScreen && (this.autoRenderToScreen = false)), void 0 !== e2 ? i2.splice(e2, 0, t6) : i2.push(t6), this.autoRenderToScreen && (i2[i2.length - 1].renderToScreen = true), t6.needsDepthTexture || null !== this.depthTexture) if (null === this.depthTexture) {
      const e3 = this.createDepthTexture();
      for (t6 of i2) t6.setDepthTexture(e3);
    } else t6.setDepthTexture(this.depthTexture);
  }
  removePass(t6) {
    const e2 = this.passes, i2 = e2.indexOf(t6);
    if (-1 !== i2 && e2.splice(i2, 1).length > 0) {
      if (null !== this.depthTexture) {
        const i3 = (t7, e3) => t7 || e3.needsDepthTexture;
        e2.reduce(i3, false) || (t6.getDepthTexture() === this.depthTexture && t6.setDepthTexture(null), this.deleteDepthTexture());
      }
      this.autoRenderToScreen && i2 === e2.length && (t6.renderToScreen = false, e2.length > 0 && (e2[e2.length - 1].renderToScreen = true));
    }
  }
  removeAllPasses() {
    const t6 = this.passes;
    this.deleteDepthTexture(), t6.length > 0 && (this.autoRenderToScreen && (t6[t6.length - 1].renderToScreen = false), this.passes = []);
  }
  render(t6) {
    const e2 = this.renderer, i2 = this.copyPass;
    let n2, r2, s2, o2 = this.inputBuffer, a2 = this.outputBuffer, l2 = false;
    void 0 === t6 && (this.timer.update(), t6 = this.timer.delta);
    for (const c2 of this.passes) c2.enabled && (c2.render(e2, o2, a2, t6, l2), c2.needsSwap && (l2 && (i2.renderToScreen = c2.renderToScreen, n2 = e2.getContext(), r2 = e2.state.buffers.stencil, r2.setFunc(n2.NOTEQUAL, 1, 4294967295), i2.render(e2, o2, a2, t6, l2), r2.setFunc(n2.EQUAL, 1, 4294967295)), s2 = o2, o2 = a2, a2 = s2), c2 instanceof mx ? l2 = true : c2 instanceof ox && (l2 = false));
  }
  setSize(t6, e2, i2) {
    const n2 = this.renderer, r2 = n2.getSize(new Fo());
    void 0 !== t6 && void 0 !== e2 || (t6 = r2.width, e2 = r2.height), r2.width === t6 && r2.height === e2 || n2.setSize(t6, e2, i2);
    const s2 = n2.getDrawingBufferSize(new Fo());
    this.inputBuffer.setSize(s2.width, s2.height), this.outputBuffer.setSize(s2.width, s2.height);
    for (const t7 of this.passes) t7.setSize(s2.width, s2.height);
  }
  reset() {
    const t6 = this.timer.autoReset;
    this.dispose(), this.autoRenderToScreen = true, this.timer.autoReset = t6;
  }
  dispose() {
    for (const t6 of this.passes) t6.dispose();
    this.passes = [], null !== this.inputBuffer && this.inputBuffer.dispose(), null !== this.outputBuffer && this.outputBuffer.dispose(), this.deleteDepthTexture(), this.copyPass.dispose(), this.timer.dispose();
  }
};
var bx = class {
  constructor() {
    this.shaderParts = /* @__PURE__ */ new Map([[Uy.FRAGMENT_HEAD, null], [Uy.FRAGMENT_MAIN_UV, null], [Uy.FRAGMENT_MAIN_IMAGE, null], [Uy.VERTEX_HEAD, null], [Uy.VERTEX_MAIN_SUPPORT, null]]), this.defines = /* @__PURE__ */ new Map(), this.uniforms = /* @__PURE__ */ new Map(), this.blendModes = /* @__PURE__ */ new Map(), this.extensions = /* @__PURE__ */ new Set(), this.attributes = Ny, this.varyings = /* @__PURE__ */ new Set(), this.uvTransformation = false, this.readDepth = false, this.colorSpace = Fy;
  }
};
var wx = false;
var _x = class {
  constructor(t6 = null) {
    this.originalMaterials = /* @__PURE__ */ new Map(), this.material = null, this.materials = null, this.materialsBackSide = null, this.materialsDoubleSide = null, this.materialsFlatShaded = null, this.materialsFlatShadedBackSide = null, this.materialsFlatShadedDoubleSide = null, this.setMaterial(t6), this.meshCount = 0, this.replaceMaterial = (t7) => {
      if (t7.isMesh) {
        let e2;
        if (t7.material.flatShading) switch (t7.material.side) {
          case _n:
            e2 = this.materialsFlatShadedDoubleSide;
            break;
          case wn:
            e2 = this.materialsFlatShadedBackSide;
            break;
          default:
            e2 = this.materialsFlatShaded;
        }
        else switch (t7.material.side) {
          case _n:
            e2 = this.materialsDoubleSide;
            break;
          case wn:
            e2 = this.materialsBackSide;
            break;
          default:
            e2 = this.materials;
        }
        this.originalMaterials.set(t7, t7.material), t7.isSkinnedMesh ? t7.material = e2[2] : t7.isInstancedMesh ? t7.material = e2[1] : t7.material = e2[0], ++this.meshCount;
      }
    };
  }
  cloneMaterial(t6) {
    if (!(t6 instanceof bc)) return t6.clone();
    const e2 = t6.uniforms, i2 = /* @__PURE__ */ new Map();
    for (const t7 in e2) {
      const n3 = e2[t7].value;
      n3.isRenderTargetTexture && (e2[t7].value = null, i2.set(t7, n3));
    }
    const n2 = t6.clone();
    for (const t7 of i2) e2[t7[0]].value = t7[1], n2.uniforms[t7[0]].value = t7[1];
    return n2;
  }
  setMaterial(t6) {
    if (this.disposeMaterials(), this.material = t6, null !== t6) {
      const e2 = this.materials = [this.cloneMaterial(t6), this.cloneMaterial(t6), this.cloneMaterial(t6)];
      for (const i2 of e2) i2.uniforms = Object.assign({}, t6.uniforms), i2.side = bn;
      e2[2].skinning = true, this.materialsBackSide = e2.map(((e3) => {
        const i2 = this.cloneMaterial(e3);
        return i2.uniforms = Object.assign({}, t6.uniforms), i2.side = wn, i2;
      })), this.materialsDoubleSide = e2.map(((e3) => {
        const i2 = this.cloneMaterial(e3);
        return i2.uniforms = Object.assign({}, t6.uniforms), i2.side = _n, i2;
      })), this.materialsFlatShaded = e2.map(((e3) => {
        const i2 = this.cloneMaterial(e3);
        return i2.uniforms = Object.assign({}, t6.uniforms), i2.flatShading = true, i2;
      })), this.materialsFlatShadedBackSide = e2.map(((e3) => {
        const i2 = this.cloneMaterial(e3);
        return i2.uniforms = Object.assign({}, t6.uniforms), i2.flatShading = true, i2.side = wn, i2;
      })), this.materialsFlatShadedDoubleSide = e2.map(((e3) => {
        const i2 = this.cloneMaterial(e3);
        return i2.uniforms = Object.assign({}, t6.uniforms), i2.flatShading = true, i2.side = _n, i2;
      }));
    }
  }
  render(t6, e2, i2) {
    const n2 = t6.shadowMap.enabled;
    if (t6.shadowMap.enabled = false, wx) {
      const n3 = this.originalMaterials;
      this.meshCount = 0, e2.traverse(this.replaceMaterial), t6.render(e2, i2);
      for (const t7 of n3) t7[0].material = t7[1];
      this.meshCount !== n3.size && n3.clear();
    } else {
      const n3 = e2.overrideMaterial;
      e2.overrideMaterial = this.material, t6.render(e2, i2), e2.overrideMaterial = n3;
    }
    t6.shadowMap.enabled = n2;
  }
  disposeMaterials() {
    if (null !== this.material) {
      const t6 = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);
      for (const e2 of t6) e2.dispose();
    }
  }
  dispose() {
    this.originalMaterials.clear(), this.disposeMaterials();
  }
  static get workaroundEnabled() {
    return wx;
  }
  static set workaroundEnabled(t6) {
    wx = t6;
  }
};
var Sx = -1;
var Mx = class extends So {
  constructor(t6, e2 = -1, i2 = -1, n2 = 1) {
    super(), this.resizable = t6, this.baseSize = new Fo(1, 1), this.preferredSize = new Fo(e2, i2), this.target = this.preferredSize, this.s = n2, this.effectiveSize = new Fo(), this.addEventListener("change", (() => this.updateEffectiveSize())), this.updateEffectiveSize();
  }
  updateEffectiveSize() {
    const t6 = this.baseSize, e2 = this.preferredSize, i2 = this.effectiveSize, n2 = this.scale;
    e2.width !== Sx ? i2.width = e2.width : e2.height !== Sx ? i2.width = Math.round(e2.height * (t6.width / Math.max(t6.height, 1))) : i2.width = Math.round(t6.width * n2), e2.height !== Sx ? i2.height = e2.height : e2.width !== Sx ? i2.height = Math.round(e2.width / Math.max(t6.width / Math.max(t6.height, 1), 1)) : i2.height = Math.round(t6.height * n2);
  }
  get width() {
    return this.effectiveSize.width;
  }
  set width(t6) {
    this.preferredWidth = t6;
  }
  get height() {
    return this.effectiveSize.height;
  }
  set height(t6) {
    this.preferredHeight = t6;
  }
  getWidth() {
    return this.width;
  }
  getHeight() {
    return this.height;
  }
  get scale() {
    return this.s;
  }
  set scale(t6) {
    this.s !== t6 && (this.s = t6, this.preferredSize.setScalar(Sx), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height));
  }
  getScale() {
    return this.scale;
  }
  setScale(t6) {
    this.scale = t6;
  }
  get baseWidth() {
    return this.baseSize.width;
  }
  set baseWidth(t6) {
    this.baseSize.width !== t6 && (this.baseSize.width = t6, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height));
  }
  getBaseWidth() {
    return this.baseWidth;
  }
  setBaseWidth(t6) {
    this.baseWidth = t6;
  }
  get baseHeight() {
    return this.baseSize.height;
  }
  set baseHeight(t6) {
    this.baseSize.height !== t6 && (this.baseSize.height = t6, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height));
  }
  getBaseHeight() {
    return this.baseHeight;
  }
  setBaseHeight(t6) {
    this.baseHeight = t6;
  }
  setBaseSize(t6, e2) {
    this.baseSize.width === t6 && this.baseSize.height === e2 || (this.baseSize.set(t6, e2), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height));
  }
  get preferredWidth() {
    return this.preferredSize.width;
  }
  set preferredWidth(t6) {
    this.preferredSize.width !== t6 && (this.preferredSize.width = t6, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height));
  }
  getPreferredWidth() {
    return this.preferredWidth;
  }
  setPreferredWidth(t6) {
    this.preferredWidth = t6;
  }
  get preferredHeight() {
    return this.preferredSize.height;
  }
  set preferredHeight(t6) {
    this.preferredSize.height !== t6 && (this.preferredSize.height = t6, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height));
  }
  getPreferredHeight() {
    return this.preferredHeight;
  }
  setPreferredHeight(t6) {
    this.preferredHeight = t6;
  }
  setPreferredSize(t6, e2) {
    this.preferredSize.width === t6 && this.preferredSize.height === e2 || (this.preferredSize.set(t6, e2), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height));
  }
  copy(t6) {
    this.s = t6.scale, this.baseSize.set(t6.baseWidth, t6.baseHeight), this.preferredSize.set(t6.preferredWidth, t6.preferredHeight), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height);
  }
  static get AUTO_SIZE() {
    return Sx;
  }
};
var Tx = class extends Set {
  constructor(t6, e2 = 10) {
    super(), this.l = e2, this.exclusive = false, void 0 !== t6 && this.set(t6);
  }
  get layer() {
    return this.l;
  }
  set layer(t6) {
    const e2 = this.l;
    for (const i2 of this) i2.layers.disable(e2), i2.layers.enable(t6);
    this.l = t6;
  }
  getLayer() {
    return this.layer;
  }
  setLayer(t6) {
    this.layer = t6;
  }
  isExclusive() {
    return this.exclusive;
  }
  setExclusive(t6) {
    this.exclusive = t6;
  }
  clear() {
    const t6 = this.layer;
    for (const e2 of this) e2.layers.disable(t6);
    return super.clear();
  }
  set(t6) {
    this.clear();
    for (const e2 of t6) this.add(e2);
    return this;
  }
  indexOf(t6) {
    return this.has(t6) ? 0 : -1;
  }
  add(t6) {
    return this.exclusive ? t6.layers.set(this.layer) : t6.layers.enable(this.layer), super.add(t6);
  }
  delete(t6) {
    return this.has(t6) && t6.layers.disable(this.layer), super.delete(t6);
  }
  toggle(t6) {
    let e2;
    return this.has(t6) ? (this.delete(t6), e2 = false) : (this.add(t6), e2 = true), e2;
  }
  setVisible(t6) {
    for (const e2 of this) t6 ? e2.layers.enable(0) : e2.layers.disable(0);
    return this;
  }
};
var Ex = /* @__PURE__ */ new Map([[iy, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}"], [ny, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}"], [ry, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}"], [sy, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}"], [oy, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}"], [ay, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}"], [ly, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}"], [cy, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}"], [hy, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}"], [uy, null], [dy, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}"], [py, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}"], [fy, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}"], [my, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}"], [gy, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}"], [vy, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}"], [yy, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}"], [xy, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}"], [by, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}"], [wy, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}"], [_y, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}"], [Sy, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}"], [My, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}"], [Ty, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}"], [Ey, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}"], [Ay, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}"], [Cy, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}"], [Ry, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}"], [Py, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}"], [Ly, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}"], [Iy, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}"], [Dy, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}"], [Oy, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}"]]);
var Ax = class extends So {
  constructor(t6, e2 = 1) {
    super(), this._blendFunction = t6, this.opacity = new Kg(e2);
  }
  getOpacity() {
    return this.opacity.value;
  }
  setOpacity(t6) {
    this.opacity.value = t6;
  }
  get blendFunction() {
    return this._blendFunction;
  }
  set blendFunction(t6) {
    this._blendFunction = t6, this.dispatchEvent({ type: "change" });
  }
  getBlendFunction() {
    return this.blendFunction;
  }
  setBlendFunction(t6) {
    this.blendFunction = t6;
  }
  getShaderCode() {
    return Ex.get(this.blendFunction);
  }
};
var Cx = class extends So {
  constructor(t6, e2, { attributes: i2 = Ny, blendFunction: n2 = Ty, defines: r2 = /* @__PURE__ */ new Map(), uniforms: s2 = /* @__PURE__ */ new Map(), extensions: o2 = null, vertexShader: a2 = null } = {}) {
    super(), this.name = t6, this.renderer = null, this.attributes = i2, this.fragmentShader = e2, this.vertexShader = a2, this.defines = r2, this.uniforms = s2, this.extensions = o2, this.blendMode = new Ax(n2), this.blendMode.addEventListener("change", ((t7) => this.setChanged())), this._inputColorSpace = Fy, this._outputColorSpace = "";
  }
  get inputColorSpace() {
    return this._inputColorSpace;
  }
  set inputColorSpace(t6) {
    this._inputColorSpace = t6, this.setChanged();
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(t6) {
    this._outputColorSpace = t6, this.setChanged();
  }
  set mainScene(t6) {
  }
  set mainCamera(t6) {
  }
  getName() {
    return this.name;
  }
  setRenderer(t6) {
    this.renderer = t6;
  }
  getDefines() {
    return this.defines;
  }
  getUniforms() {
    return this.uniforms;
  }
  getExtensions() {
    return this.extensions;
  }
  getBlendMode() {
    return this.blendMode;
  }
  getAttributes() {
    return this.attributes;
  }
  setAttributes(t6) {
    this.attributes = t6, this.setChanged();
  }
  getFragmentShader() {
    return this.fragmentShader;
  }
  setFragmentShader(t6) {
    this.fragmentShader = t6, this.setChanged();
  }
  getVertexShader() {
    return this.vertexShader;
  }
  setVertexShader(t6) {
    this.vertexShader = t6, this.setChanged();
  }
  setChanged() {
    this.dispatchEvent({ type: "change" });
  }
  setDepthTexture(t6, e2 = Us) {
  }
  update(t6, e2, i2) {
  }
  setSize(t6, e2) {
  }
  initialize(t6, e2, i2) {
  }
  dispose() {
    for (const t6 of Object.keys(this)) {
      const e2 = this[t6];
      (e2 instanceof oa || e2 instanceof Cl || e2 instanceof ra || e2 instanceof rx) && this[t6].dispose();
    }
  }
};
new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array([0, 0, 0]), new Float32Array([1, 0, 0]), new Float32Array([1, 1, 0]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([1, 0, 0]), new Float32Array([1, 0, 1]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 0, 1]), new Float32Array([1, 0, 1]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 1, 0]), new Float32Array([1, 1, 0]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 1, 0]), new Float32Array([0, 1, 1]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 0, 1]), new Float32Array([0, 1, 1]), new Float32Array([1, 1, 1]);
new Float32Array(2), new Float32Array(2), new Float32Array([0, -0.25, 0.25, -0.125, 0.125, -0.375, 0.375]), new Float32Array([0, 0]), new Float32Array([0.25, -0.25]), new Float32Array([-0.25, 0.25]), new Float32Array([0.125, -0.125]), new Float32Array([-0.125, 0.125]), new Uint8Array([0, 0]), new Uint8Array([3, 0]), new Uint8Array([0, 3]), new Uint8Array([3, 3]), new Uint8Array([1, 0]), new Uint8Array([4, 0]), new Uint8Array([1, 3]), new Uint8Array([4, 3]), new Uint8Array([0, 1]), new Uint8Array([3, 1]), new Uint8Array([0, 4]), new Uint8Array([3, 4]), new Uint8Array([1, 1]), new Uint8Array([4, 1]), new Uint8Array([1, 4]), new Uint8Array([4, 4]), new Uint8Array([0, 0]), new Uint8Array([1, 0]), new Uint8Array([0, 2]), new Uint8Array([1, 2]), new Uint8Array([2, 0]), new Uint8Array([3, 0]), new Uint8Array([2, 2]), new Uint8Array([3, 2]), new Uint8Array([0, 1]), new Uint8Array([1, 1]), new Uint8Array([0, 3]), new Uint8Array([1, 3]), new Uint8Array([2, 1]), new Uint8Array([3, 1]), new Uint8Array([2, 3]), new Uint8Array([3, 3]);
Px(0, 0, 0, 0), new Float32Array([0, 0, 0, 0]), Px(0, 0, 0, 1), new Float32Array([0, 0, 0, 1]), Px(0, 0, 1, 0), new Float32Array([0, 0, 1, 0]), Px(0, 0, 1, 1), new Float32Array([0, 0, 1, 1]), Px(0, 1, 0, 0), new Float32Array([0, 1, 0, 0]), Px(0, 1, 0, 1), new Float32Array([0, 1, 0, 1]), Px(0, 1, 1, 0), new Float32Array([0, 1, 1, 0]), Px(0, 1, 1, 1), new Float32Array([0, 1, 1, 1]), Px(1, 0, 0, 0), new Float32Array([1, 0, 0, 0]), Px(1, 0, 0, 1), new Float32Array([1, 0, 0, 1]), Px(1, 0, 1, 0), new Float32Array([1, 0, 1, 0]), Px(1, 0, 1, 1), new Float32Array([1, 0, 1, 1]), Px(1, 1, 0, 0), new Float32Array([1, 1, 0, 0]), Px(1, 1, 0, 1), new Float32Array([1, 1, 0, 1]), Px(1, 1, 1, 0), new Float32Array([1, 1, 1, 0]), Px(1, 1, 1, 1), new Float32Array([1, 1, 1, 1]);
function Rx(t6, e2, i2) {
  return t6 + (e2 - t6) * i2;
}
function Px(t6, e2, i2, n2) {
  const r2 = Rx(t6, e2, 0.75), s2 = Rx(i2, n2, 0.75);
  return Rx(r2, s2, 0.875);
}
var Lx = class extends Cx {
  constructor(t6, e2, { blendFunction: i2 = Py, patternTexture: n2 = null, patternScale: r2 = 1, edgeStrength: s2 = 1, pulseSpeed: o2 = 0, visibleEdgeColor: a2 = 16777215, hiddenEdgeColor: l2 = 2230538, kernelSize: c2 = Hy, blur: h2 = false, xRay: u2 = true, multisampling: d2 = 0, resolutionScale: p2 = 0.5, width: f2 = Mx.AUTO_SIZE, height: m2 = Mx.AUTO_SIZE, resolutionX: g2 = f2, resolutionY: v2 = m2 } = {}) {
    super("OutlineEffect", "uniform lowp sampler2D edgeTexture;uniform lowp sampler2D maskTexture;uniform vec3 visibleEdgeColor;uniform vec3 hiddenEdgeColor;uniform float pulse;uniform float edgeStrength;\n#ifdef USE_PATTERN\nuniform lowp sampler2D patternTexture;varying vec2 vUvPattern;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 edge=texture2D(edgeTexture,uv).rg;vec2 mask=texture2D(maskTexture,uv).rg;\n#ifndef X_RAY\nedge.y=0.0;\n#endif\nedge*=(edgeStrength*mask.x*pulse);vec3 color=edge.x*visibleEdgeColor+edge.y*hiddenEdgeColor;float visibilityFactor=0.0;\n#ifdef USE_PATTERN\nvec4 patternColor=texture2D(patternTexture,vUvPattern);\n#ifdef X_RAY\nfloat hiddenFactor=0.5;\n#else\nfloat hiddenFactor=0.0;\n#endif\nvisibilityFactor=(1.0-mask.y>0.0)?1.0:hiddenFactor;visibilityFactor*=(1.0-mask.x)*patternColor.a;color+=visibilityFactor*patternColor.rgb;\n#endif\nfloat alpha=max(max(edge.x,edge.y),visibilityFactor);\n#ifdef ALPHA\noutputColor=vec4(color,alpha);\n#else\noutputColor=vec4(color,max(alpha,inputColor.a));\n#endif\n}", { uniforms: /* @__PURE__ */ new Map([["maskTexture", new Kg(null)], ["edgeTexture", new Kg(null)], ["edgeStrength", new Kg(s2)], ["visibleEdgeColor", new Kg(new $o(a2))], ["hiddenEdgeColor", new Kg(new $o(l2))], ["pulse", new Kg(1)], ["patternScale", new Kg(r2)], ["patternTexture", new Kg(null)]]) }), this.blendMode.addEventListener("change", ((t7) => {
      this.blendMode.blendFunction === ny ? this.defines.set("ALPHA", "1") : this.defines.delete("ALPHA"), this.setChanged();
    })), this.blendMode.blendFunction = i2, this.patternTexture = n2, this.xRay = u2, this.scene = t6, this.camera = e2, this.renderTargetMask = new oa(1, 1), this.renderTargetMask.samples = d2, this.renderTargetMask.texture.name = "Outline.Mask", this.uniforms.get("maskTexture").value = this.renderTargetMask.texture, this.renderTargetOutline = new oa(1, 1, { depthBuffer: false }), this.renderTargetOutline.texture.name = "Outline.Edges", this.uniforms.get("edgeTexture").value = this.renderTargetOutline.texture, this.clearPass = new lx(), this.clearPass.overrideClearColor = new $o(0), this.clearPass.overrideClearAlpha = 1, this.depthPass = new hx(t6, e2), this.maskPass = new cx(t6, e2, new Qy(this.depthPass.texture, e2));
    const y2 = this.maskPass.clearPass;
    y2.overrideClearColor = new $o(16777215), y2.overrideClearAlpha = 1, this.blurPass = new fx({ resolutionScale: p2, resolutionX: g2, resolutionY: v2, kernelSize: c2 }), this.blurPass.enabled = h2;
    const x2 = this.blurPass.resolution;
    x2.addEventListener("change", ((t7) => this.setSize(x2.baseWidth, x2.baseHeight))), this.outlinePass = new gx(new ex());
    this.outlinePass.fullscreenMaterial.inputBuffer = this.renderTargetMask.texture, this.time = 0, this.forceUpdate = true, this.selection = new Tx(), this.selection.layer = 10, this.pulseSpeed = o2;
  }
  set mainScene(t6) {
    this.scene = t6, this.depthPass.mainScene = t6, this.maskPass.mainScene = t6;
  }
  set mainCamera(t6) {
    this.camera = t6, this.depthPass.mainCamera = t6, this.maskPass.mainCamera = t6, this.maskPass.overrideMaterial.copyCameraSettings(t6);
  }
  get resolution() {
    return this.blurPass.resolution;
  }
  getResolution() {
    return this.blurPass.getResolution();
  }
  get multisampling() {
    return this.renderTargetMask.samples;
  }
  set multisampling(t6) {
    this.renderTargetMask.samples = t6, this.renderTargetMask.dispose();
  }
  get patternScale() {
    return this.uniforms.get("patternScale").value;
  }
  set patternScale(t6) {
    this.uniforms.get("patternScale").value = t6;
  }
  get edgeStrength() {
    return this.uniforms.get("edgeStrength").value;
  }
  set edgeStrength(t6) {
    this.uniforms.get("edgeStrength").value = t6;
  }
  get visibleEdgeColor() {
    return this.uniforms.get("visibleEdgeColor").value;
  }
  set visibleEdgeColor(t6) {
    this.uniforms.get("visibleEdgeColor").value = t6;
  }
  get hiddenEdgeColor() {
    return this.uniforms.get("hiddenEdgeColor").value;
  }
  set hiddenEdgeColor(t6) {
    this.uniforms.get("hiddenEdgeColor").value = t6;
  }
  getBlurPass() {
    return this.blurPass;
  }
  getSelection() {
    return this.selection;
  }
  getPulseSpeed() {
    return this.pulseSpeed;
  }
  setPulseSpeed(t6) {
    this.pulseSpeed = t6;
  }
  get width() {
    return this.resolution.width;
  }
  set width(t6) {
    this.resolution.preferredWidth = t6;
  }
  get height() {
    return this.resolution.height;
  }
  set height(t6) {
    this.resolution.preferredHeight = t6;
  }
  get selectionLayer() {
    return this.selection.layer;
  }
  set selectionLayer(t6) {
    this.selection.layer = t6;
  }
  get dithering() {
    return this.blurPass.dithering;
  }
  set dithering(t6) {
    this.blurPass.dithering = t6;
  }
  get kernelSize() {
    return this.blurPass.kernelSize;
  }
  set kernelSize(t6) {
    this.blurPass.kernelSize = t6;
  }
  get blur() {
    return this.blurPass.enabled;
  }
  set blur(t6) {
    this.blurPass.enabled = t6;
  }
  get xRay() {
    return this.defines.has("X_RAY");
  }
  set xRay(t6) {
    this.xRay !== t6 && (t6 ? this.defines.set("X_RAY", "1") : this.defines.delete("X_RAY"), this.setChanged());
  }
  isXRayEnabled() {
    return this.xRay;
  }
  setXRayEnabled(t6) {
    this.xRay = t6;
  }
  get patternTexture() {
    return this.uniforms.get("patternTexture").value;
  }
  set patternTexture(t6) {
    null !== t6 ? (t6.wrapS = t6.wrapT = gr, this.defines.set("USE_PATTERN", "1"), this.setVertexShader("uniform float patternScale;varying vec2 vUvPattern;void mainSupport(const in vec2 uv){vUvPattern=uv*vec2(aspect,1.0)*patternScale;}")) : (this.defines.delete("USE_PATTERN"), this.setVertexShader(null)), this.uniforms.get("patternTexture").value = t6, this.setChanged();
  }
  setPatternTexture(t6) {
    this.patternTexture = t6;
  }
  getResolutionScale() {
    return this.resolution.scale;
  }
  setResolutionScale(t6) {
    this.resolution.scale = t6;
  }
  setSelection(t6) {
    return this.selection.set(t6), this;
  }
  clearSelection() {
    return this.selection.clear(), this;
  }
  selectObject(t6) {
    return this.selection.add(t6), this;
  }
  deselectObject(t6) {
    return this.selection.delete(t6), this;
  }
  update(t6, e2, i2) {
    const n2 = this.scene, r2 = this.camera, s2 = this.selection, o2 = this.uniforms.get("pulse"), a2 = n2.background, l2 = r2.layers.mask;
    (this.forceUpdate || s2.size > 0) && (n2.background = null, o2.value = 1, this.pulseSpeed > 0 && (o2.value = 0.375 * Math.cos(this.time * this.pulseSpeed * 10) + 0.625), this.time += i2, s2.setVisible(false), this.depthPass.render(t6), s2.setVisible(true), r2.layers.set(s2.layer), this.maskPass.render(t6, this.renderTargetMask), r2.layers.mask = l2, n2.background = a2, this.outlinePass.render(t6, null, this.renderTargetOutline), this.blurPass.enabled && this.blurPass.render(t6, this.renderTargetOutline, this.renderTargetOutline)), this.forceUpdate = s2.size > 0;
  }
  setSize(t6, e2) {
    this.blurPass.setSize(t6, e2), this.renderTargetMask.setSize(t6, e2);
    const i2 = this.resolution;
    i2.setBaseSize(t6, e2);
    const n2 = i2.width, r2 = i2.height;
    this.depthPass.setSize(n2, r2), this.renderTargetOutline.setSize(n2, r2), this.outlinePass.fullscreenMaterial.setSize(n2, r2);
  }
  initialize(t6, e2, i2) {
    this.blurPass.initialize(t6, e2, Rr), void 0 !== i2 && (this.depthPass.initialize(t6, e2, i2), this.maskPass.initialize(t6, e2, i2), this.outlinePass.initialize(t6, e2, i2));
  }
};
var Ix = (Math.PI, i(6571));
var Dx = i.n(Ix);
var Ox = new Pc();
var zx = new iv();
var Fx = new Fo();
var Nx = new pa();
var Bx = new pa();
var kx = new pa();
var Ux = new Ga();
var Hx = class extends So {
  constructor(t6, e2, i2) {
    super(), i2.style.touchAction = "none";
    let n2 = null, r2 = null;
    const s2 = [], o2 = this;
    function a2() {
      i2.addEventListener("pointermove", c2), i2.addEventListener("pointerdown", h2), i2.addEventListener("pointerup", u2), i2.addEventListener("pointerleave", u2);
    }
    function l2() {
      i2.removeEventListener("pointermove", c2), i2.removeEventListener("pointerdown", h2), i2.removeEventListener("pointerup", u2), i2.removeEventListener("pointerleave", u2), i2.style.cursor = "";
    }
    function c2(a3) {
      if (false !== o2.enabled) {
        if (d2(a3), zx.setFromCamera(Fx, e2), n2) return zx.ray.intersectPlane(Ox, Bx) && n2.position.copy(Bx.sub(Nx).applyMatrix4(Ux)), void o2.dispatchEvent({ type: "drag", object: n2 });
        if ("mouse" === a3.pointerType || "pen" === a3.pointerType) if (s2.length = 0, zx.setFromCamera(Fx, e2), zx.intersectObjects(t6, true, s2), s2.length > 0) {
          const t7 = s2[0].object;
          Ox.setFromNormalAndCoplanarPoint(e2.getWorldDirection(Ox.normal), kx.setFromMatrixPosition(t7.matrixWorld)), r2 !== t7 && null !== r2 && (o2.dispatchEvent({ type: "hoveroff", object: r2 }), i2.style.cursor = "auto", r2 = null), r2 !== t7 && (o2.dispatchEvent({ type: "hoveron", object: t7 }), i2.style.cursor = "pointer", r2 = t7);
        } else null !== r2 && (o2.dispatchEvent({ type: "hoveroff", object: r2 }), i2.style.cursor = "auto", r2 = null);
      }
    }
    function h2(r3) {
      false !== o2.enabled && (d2(r3), s2.length = 0, zx.setFromCamera(Fx, e2), zx.intersectObjects(t6, true, s2), s2.length > 0 && (n2 = true === o2.transformGroup ? t6[0] : s2[0].object, Ox.setFromNormalAndCoplanarPoint(e2.getWorldDirection(Ox.normal), kx.setFromMatrixPosition(n2.matrixWorld)), zx.ray.intersectPlane(Ox, Bx) && (Ux.copy(n2.parent.matrixWorld).invert(), Nx.copy(Bx).sub(kx.setFromMatrixPosition(n2.matrixWorld))), i2.style.cursor = "move", o2.dispatchEvent({ type: "dragstart", object: n2 })));
    }
    function u2() {
      false !== o2.enabled && (n2 && (o2.dispatchEvent({ type: "dragend", object: n2 }), n2 = null), i2.style.cursor = r2 ? "pointer" : "auto");
    }
    function d2(t7) {
      const e3 = i2.getBoundingClientRect();
      Fx.x = (t7.clientX - e3.left) / e3.width * 2 - 1, Fx.y = -(t7.clientY - e3.top) / e3.height * 2 + 1;
    }
    a2(), this.enabled = true, this.transformGroup = false, this.activate = a2, this.deactivate = l2, this.dispose = function() {
      l2();
    }, this.getObjects = function() {
      return t6;
    }, this.getRaycaster = function() {
      return zx;
    };
  }
};
var Vx = { type: "change" };
var jx = { type: "start" };
var Gx = { type: "end" };
var Wx = class extends So {
  constructor(t6, e2) {
    super(), void 0 === e2 && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'), e2 === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), this.object = t6, this.domElement = e2, this.domElement.style.touchAction = "none", this.enabled = true, this.target = new pa(), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = false, this.dampingFactor = 0.05, this.enableZoom = true, this.zoomSpeed = 1, this.enableRotate = true, this.rotateSpeed = 1, this.enablePan = true, this.panSpeed = 1, this.screenSpacePanning = true, this.keyPanSpeed = 7, this.autoRotate = false, this.autoRotateSpeed = 2, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: hn.ROTATE, MIDDLE: hn.DOLLY, RIGHT: hn.PAN }, this.touches = { ONE: un.ROTATE, TWO: un.DOLLY_PAN }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function() {
      return o2.phi;
    }, this.getAzimuthalAngle = function() {
      return o2.theta;
    }, this.getDistance = function() {
      return this.object.position.distanceTo(this.target);
    }, this.listenToKeyEvents = function(t7) {
      t7.addEventListener("keydown", j2), this._domElementKeyEvents = t7;
    }, this.saveState = function() {
      i2.target0.copy(i2.target), i2.position0.copy(i2.object.position), i2.zoom0 = i2.object.zoom;
    }, this.reset = function() {
      i2.target.copy(i2.target0), i2.object.position.copy(i2.position0), i2.object.zoom = i2.zoom0, i2.object.updateProjectionMatrix(), i2.dispatchEvent(Vx), i2.update(), r2 = n2.NONE;
    }, this.update = (function() {
      const e3 = new pa(), u3 = new da().setFromUnitVectors(t6.up, new pa(0, 1, 0)), d3 = u3.clone().invert(), p3 = new pa(), f3 = new da(), m3 = 2 * Math.PI;
      return function() {
        const t7 = i2.object.position;
        e3.copy(t7).sub(i2.target), e3.applyQuaternion(u3), o2.setFromVector3(e3), i2.autoRotate && r2 === n2.NONE && S2(2 * Math.PI / 60 / 60 * i2.autoRotateSpeed), i2.enableDamping ? (o2.theta += a2.theta * i2.dampingFactor, o2.phi += a2.phi * i2.dampingFactor) : (o2.theta += a2.theta, o2.phi += a2.phi);
        let g3 = i2.minAzimuthAngle, v3 = i2.maxAzimuthAngle;
        return isFinite(g3) && isFinite(v3) && (g3 < -Math.PI ? g3 += m3 : g3 > Math.PI && (g3 -= m3), v3 < -Math.PI ? v3 += m3 : v3 > Math.PI && (v3 -= m3), o2.theta = g3 <= v3 ? Math.max(g3, Math.min(v3, o2.theta)) : o2.theta > (g3 + v3) / 2 ? Math.max(g3, o2.theta) : Math.min(v3, o2.theta)), o2.phi = Math.max(i2.minPolarAngle, Math.min(i2.maxPolarAngle, o2.phi)), o2.makeSafe(), o2.radius *= l2, o2.radius = Math.max(i2.minDistance, Math.min(i2.maxDistance, o2.radius)), true === i2.enableDamping ? i2.target.addScaledVector(c2, i2.dampingFactor) : i2.target.add(c2), e3.setFromSpherical(o2), e3.applyQuaternion(d3), t7.copy(i2.target).add(e3), i2.object.lookAt(i2.target), true === i2.enableDamping ? (a2.theta *= 1 - i2.dampingFactor, a2.phi *= 1 - i2.dampingFactor, c2.multiplyScalar(1 - i2.dampingFactor)) : (a2.set(0, 0, 0), c2.set(0, 0, 0)), l2 = 1, !!(h2 || p3.distanceToSquared(i2.object.position) > s2 || 8 * (1 - f3.dot(i2.object.quaternion)) > s2) && (i2.dispatchEvent(Vx), p3.copy(i2.object.position), f3.copy(i2.object.quaternion), h2 = false, true);
      };
    })(), this.dispose = function() {
      i2.domElement.removeEventListener("contextmenu", G2), i2.domElement.removeEventListener("pointerdown", B2), i2.domElement.removeEventListener("pointercancel", H2), i2.domElement.removeEventListener("wheel", V2), i2.domElement.removeEventListener("pointermove", k2), i2.domElement.removeEventListener("pointerup", U2), null !== i2._domElementKeyEvents && i2._domElementKeyEvents.removeEventListener("keydown", j2);
    };
    const i2 = this, n2 = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 };
    let r2 = n2.NONE;
    const s2 = 1e-6, o2 = new sv(), a2 = new sv();
    let l2 = 1;
    const c2 = new pa();
    let h2 = false;
    const u2 = new Fo(), d2 = new Fo(), p2 = new Fo(), f2 = new Fo(), m2 = new Fo(), g2 = new Fo(), v2 = new Fo(), y2 = new Fo(), x2 = new Fo(), b2 = [], w2 = {};
    function _2() {
      return Math.pow(0.95, i2.zoomSpeed);
    }
    function S2(t7) {
      a2.theta -= t7;
    }
    function M2(t7) {
      a2.phi -= t7;
    }
    const T2 = (function() {
      const t7 = new pa();
      return function(e3, i3) {
        t7.setFromMatrixColumn(i3, 0), t7.multiplyScalar(-e3), c2.add(t7);
      };
    })(), E2 = (function() {
      const t7 = new pa();
      return function(e3, n3) {
        true === i2.screenSpacePanning ? t7.setFromMatrixColumn(n3, 1) : (t7.setFromMatrixColumn(n3, 0), t7.crossVectors(i2.object.up, t7)), t7.multiplyScalar(e3), c2.add(t7);
      };
    })(), A2 = (function() {
      const t7 = new pa();
      return function(e3, n3) {
        const r3 = i2.domElement;
        if (i2.object.isPerspectiveCamera) {
          const s3 = i2.object.position;
          t7.copy(s3).sub(i2.target);
          let o3 = t7.length();
          o3 *= Math.tan(i2.object.fov / 2 * Math.PI / 180), T2(2 * e3 * o3 / r3.clientHeight, i2.object.matrix), E2(2 * n3 * o3 / r3.clientHeight, i2.object.matrix);
        } else i2.object.isOrthographicCamera ? (T2(e3 * (i2.object.right - i2.object.left) / i2.object.zoom / r3.clientWidth, i2.object.matrix), E2(n3 * (i2.object.top - i2.object.bottom) / i2.object.zoom / r3.clientHeight, i2.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), i2.enablePan = false);
      };
    })();
    function C2(t7) {
      i2.object.isPerspectiveCamera ? l2 /= t7 : i2.object.isOrthographicCamera ? (i2.object.zoom = Math.max(i2.minZoom, Math.min(i2.maxZoom, i2.object.zoom * t7)), i2.object.updateProjectionMatrix(), h2 = true) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), i2.enableZoom = false);
    }
    function R2(t7) {
      i2.object.isPerspectiveCamera ? l2 *= t7 : i2.object.isOrthographicCamera ? (i2.object.zoom = Math.max(i2.minZoom, Math.min(i2.maxZoom, i2.object.zoom / t7)), i2.object.updateProjectionMatrix(), h2 = true) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), i2.enableZoom = false);
    }
    function P2(t7) {
      u2.set(t7.clientX, t7.clientY);
    }
    function L2(t7) {
      f2.set(t7.clientX, t7.clientY);
    }
    function I2() {
      if (1 === b2.length) u2.set(b2[0].pageX, b2[0].pageY);
      else {
        const t7 = 0.5 * (b2[0].pageX + b2[1].pageX), e3 = 0.5 * (b2[0].pageY + b2[1].pageY);
        u2.set(t7, e3);
      }
    }
    function D2() {
      if (1 === b2.length) f2.set(b2[0].pageX, b2[0].pageY);
      else {
        const t7 = 0.5 * (b2[0].pageX + b2[1].pageX), e3 = 0.5 * (b2[0].pageY + b2[1].pageY);
        f2.set(t7, e3);
      }
    }
    function O2() {
      const t7 = b2[0].pageX - b2[1].pageX, e3 = b2[0].pageY - b2[1].pageY, i3 = Math.sqrt(t7 * t7 + e3 * e3);
      v2.set(0, i3);
    }
    function z2(t7) {
      if (1 == b2.length) d2.set(t7.pageX, t7.pageY);
      else {
        const e4 = X2(t7), i3 = 0.5 * (t7.pageX + e4.x), n3 = 0.5 * (t7.pageY + e4.y);
        d2.set(i3, n3);
      }
      p2.subVectors(d2, u2).multiplyScalar(i2.rotateSpeed);
      const e3 = i2.domElement;
      S2(2 * Math.PI * p2.x / e3.clientHeight), M2(2 * Math.PI * p2.y / e3.clientHeight), u2.copy(d2);
    }
    function F2(t7) {
      if (1 === b2.length) m2.set(t7.pageX, t7.pageY);
      else {
        const e3 = X2(t7), i3 = 0.5 * (t7.pageX + e3.x), n3 = 0.5 * (t7.pageY + e3.y);
        m2.set(i3, n3);
      }
      g2.subVectors(m2, f2).multiplyScalar(i2.panSpeed), A2(g2.x, g2.y), f2.copy(m2);
    }
    function N2(t7) {
      const e3 = X2(t7), n3 = t7.pageX - e3.x, r3 = t7.pageY - e3.y, s3 = Math.sqrt(n3 * n3 + r3 * r3);
      y2.set(0, s3), x2.set(0, Math.pow(y2.y / v2.y, i2.zoomSpeed)), C2(x2.y), v2.copy(y2);
    }
    function B2(t7) {
      false !== i2.enabled && (0 === b2.length && (i2.domElement.setPointerCapture(t7.pointerId), i2.domElement.addEventListener("pointermove", k2), i2.domElement.addEventListener("pointerup", U2)), (function(t8) {
        b2.push(t8);
      })(t7), "touch" === t7.pointerType ? (function(t8) {
        switch (q2(t8), b2.length) {
          case 1:
            switch (i2.touches.ONE) {
              case un.ROTATE:
                if (false === i2.enableRotate) return;
                I2(), r2 = n2.TOUCH_ROTATE;
                break;
              case un.PAN:
                if (false === i2.enablePan) return;
                D2(), r2 = n2.TOUCH_PAN;
                break;
              default:
                r2 = n2.NONE;
            }
            break;
          case 2:
            switch (i2.touches.TWO) {
              case un.DOLLY_PAN:
                if (false === i2.enableZoom && false === i2.enablePan) return;
                i2.enableZoom && O2(), i2.enablePan && D2(), r2 = n2.TOUCH_DOLLY_PAN;
                break;
              case un.DOLLY_ROTATE:
                if (false === i2.enableZoom && false === i2.enableRotate) return;
                i2.enableZoom && O2(), i2.enableRotate && I2(), r2 = n2.TOUCH_DOLLY_ROTATE;
                break;
              default:
                r2 = n2.NONE;
            }
            break;
          default:
            r2 = n2.NONE;
        }
        r2 !== n2.NONE && i2.dispatchEvent(jx);
      })(t7) : (function(t8) {
        let e3;
        switch (t8.button) {
          case 0:
            e3 = i2.mouseButtons.LEFT;
            break;
          case 1:
            e3 = i2.mouseButtons.MIDDLE;
            break;
          case 2:
            e3 = i2.mouseButtons.RIGHT;
            break;
          default:
            e3 = -1;
        }
        switch (e3) {
          case hn.DOLLY:
            if (false === i2.enableZoom) return;
            !(function(t9) {
              v2.set(t9.clientX, t9.clientY);
            })(t8), r2 = n2.DOLLY;
            break;
          case hn.ROTATE:
            if (t8.ctrlKey || t8.metaKey || t8.shiftKey) {
              if (false === i2.enablePan) return;
              L2(t8), r2 = n2.PAN;
            } else {
              if (false === i2.enableRotate) return;
              P2(t8), r2 = n2.ROTATE;
            }
            break;
          case hn.PAN:
            if (t8.ctrlKey || t8.metaKey || t8.shiftKey) {
              if (false === i2.enableRotate) return;
              P2(t8), r2 = n2.ROTATE;
            } else {
              if (false === i2.enablePan) return;
              L2(t8), r2 = n2.PAN;
            }
            break;
          default:
            r2 = n2.NONE;
        }
        r2 !== n2.NONE && i2.dispatchEvent(jx);
      })(t7));
    }
    function k2(t7) {
      false !== i2.enabled && ("touch" === t7.pointerType ? (function(t8) {
        switch (q2(t8), r2) {
          case n2.TOUCH_ROTATE:
            if (false === i2.enableRotate) return;
            z2(t8), i2.update();
            break;
          case n2.TOUCH_PAN:
            if (false === i2.enablePan) return;
            F2(t8), i2.update();
            break;
          case n2.TOUCH_DOLLY_PAN:
            if (false === i2.enableZoom && false === i2.enablePan) return;
            !(function(t9) {
              i2.enableZoom && N2(t9), i2.enablePan && F2(t9);
            })(t8), i2.update();
            break;
          case n2.TOUCH_DOLLY_ROTATE:
            if (false === i2.enableZoom && false === i2.enableRotate) return;
            !(function(t9) {
              i2.enableZoom && N2(t9), i2.enableRotate && z2(t9);
            })(t8), i2.update();
            break;
          default:
            r2 = n2.NONE;
        }
      })(t7) : (function(t8) {
        switch (r2) {
          case n2.ROTATE:
            if (false === i2.enableRotate) return;
            !(function(t9) {
              d2.set(t9.clientX, t9.clientY), p2.subVectors(d2, u2).multiplyScalar(i2.rotateSpeed);
              const e3 = i2.domElement;
              S2(2 * Math.PI * p2.x / e3.clientHeight), M2(2 * Math.PI * p2.y / e3.clientHeight), u2.copy(d2), i2.update();
            })(t8);
            break;
          case n2.DOLLY:
            if (false === i2.enableZoom) return;
            !(function(t9) {
              y2.set(t9.clientX, t9.clientY), x2.subVectors(y2, v2), x2.y > 0 ? C2(_2()) : x2.y < 0 && R2(_2()), v2.copy(y2), i2.update();
            })(t8);
            break;
          case n2.PAN:
            if (false === i2.enablePan) return;
            !(function(t9) {
              m2.set(t9.clientX, t9.clientY), g2.subVectors(m2, f2).multiplyScalar(i2.panSpeed), A2(g2.x, g2.y), f2.copy(m2), i2.update();
            })(t8);
        }
      })(t7));
    }
    function U2(t7) {
      W2(t7), 0 === b2.length && (i2.domElement.releasePointerCapture(t7.pointerId), i2.domElement.removeEventListener("pointermove", k2), i2.domElement.removeEventListener("pointerup", U2)), i2.dispatchEvent(Gx), r2 = n2.NONE;
    }
    function H2(t7) {
      W2(t7);
    }
    function V2(t7) {
      false !== i2.enabled && false !== i2.enableZoom && r2 === n2.NONE && (t7.preventDefault(), i2.dispatchEvent(jx), (function(t8) {
        t8.deltaY < 0 ? R2(_2()) : t8.deltaY > 0 && C2(_2()), i2.update();
      })(t7), i2.dispatchEvent(Gx));
    }
    function j2(t7) {
      false !== i2.enabled && false !== i2.enablePan && (function(t8) {
        let e3 = false;
        switch (t8.code) {
          case i2.keys.UP:
            A2(0, i2.keyPanSpeed), e3 = true;
            break;
          case i2.keys.BOTTOM:
            A2(0, -i2.keyPanSpeed), e3 = true;
            break;
          case i2.keys.LEFT:
            A2(i2.keyPanSpeed, 0), e3 = true;
            break;
          case i2.keys.RIGHT:
            A2(-i2.keyPanSpeed, 0), e3 = true;
        }
        e3 && (t8.preventDefault(), i2.update());
      })(t7);
    }
    function G2(t7) {
      false !== i2.enabled && t7.preventDefault();
    }
    function W2(t7) {
      delete w2[t7.pointerId];
      for (let e3 = 0; e3 < b2.length; e3++) if (b2[e3].pointerId == t7.pointerId) return void b2.splice(e3, 1);
    }
    function q2(t7) {
      let e3 = w2[t7.pointerId];
      void 0 === e3 && (e3 = new Fo(), w2[t7.pointerId] = e3), e3.set(t7.pageX, t7.pageY);
    }
    function X2(t7) {
      const e3 = t7.pointerId === b2[0].pointerId ? b2[1] : b2[0];
      return w2[e3.pointerId];
    }
    i2.domElement.addEventListener("contextmenu", G2), i2.domElement.addEventListener("pointerdown", B2), i2.domElement.addEventListener("pointercancel", H2), i2.domElement.addEventListener("wheel", V2, { passive: false }), this.update();
  }
};
var qx = {};
var Xx = function(t6) {
  return URL.createObjectURL(new Blob([t6], { type: "text/javascript" }));
};
var Yx = function(t6) {
  return new Worker(t6);
};
try {
  URL.revokeObjectURL(Xx(""));
} catch (t6) {
  Xx = function(t7) {
    return "data:application/javascript;charset=UTF-8," + encodeURI(t7);
  }, Yx = function(t7) {
    return new Worker(t7, { type: "module" });
  };
}
var Zx = Uint8Array;
var Jx = Uint16Array;
var Kx = Uint32Array;
var $x = new Zx([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]);
var Qx = new Zx([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]);
var tb = new Zx([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var eb = function(t6, e2) {
  for (var i2 = new Jx(31), n2 = 0; n2 < 31; ++n2) i2[n2] = e2 += 1 << t6[n2 - 1];
  var r2 = new Kx(i2[30]);
  for (n2 = 1; n2 < 30; ++n2) for (var s2 = i2[n2]; s2 < i2[n2 + 1]; ++s2) r2[s2] = s2 - i2[n2] << 5 | n2;
  return [i2, r2];
};
var ib = eb($x, 2);
var nb = ib[0];
var rb = ib[1];
nb[28] = 258, rb[258] = 28;
for (sb = eb(Qx, 0), ob = sb[0], ab = sb[1], lb = new Jx(32768), cb = 0; cb < 32768; ++cb) {
  hb = (43690 & cb) >>> 1 | (21845 & cb) << 1;
  hb = (61680 & (hb = (52428 & hb) >>> 2 | (13107 & hb) << 2)) >>> 4 | (3855 & hb) << 4, lb[cb] = ((65280 & hb) >>> 8 | (255 & hb) << 8) >>> 1;
}
var hb;
var sb;
var ob;
var ab;
var lb;
var cb;
var ub = function(t6, e2, i2) {
  for (var n2 = t6.length, r2 = 0, s2 = new Jx(e2); r2 < n2; ++r2) ++s2[t6[r2] - 1];
  var o2, a2 = new Jx(e2);
  for (r2 = 0; r2 < e2; ++r2) a2[r2] = a2[r2 - 1] + s2[r2 - 1] << 1;
  if (i2) {
    o2 = new Jx(1 << e2);
    var l2 = 15 - e2;
    for (r2 = 0; r2 < n2; ++r2) if (t6[r2]) for (var c2 = r2 << 4 | t6[r2], h2 = e2 - t6[r2], u2 = a2[t6[r2] - 1]++ << h2, d2 = u2 | (1 << h2) - 1; u2 <= d2; ++u2) o2[lb[u2] >>> l2] = c2;
  } else for (o2 = new Jx(n2), r2 = 0; r2 < n2; ++r2) t6[r2] && (o2[r2] = lb[a2[t6[r2] - 1]++] >>> 15 - t6[r2]);
  return o2;
};
var db = new Zx(288);
for (cb = 0; cb < 144; ++cb) db[cb] = 8;
for (cb = 144; cb < 256; ++cb) db[cb] = 9;
for (cb = 256; cb < 280; ++cb) db[cb] = 7;
for (cb = 280; cb < 288; ++cb) db[cb] = 8;
var pb = new Zx(32);
for (cb = 0; cb < 32; ++cb) pb[cb] = 5;
var fb = ub(db, 9, 0);
var mb = ub(db, 9, 1);
var gb = ub(pb, 5, 0);
var vb = ub(pb, 5, 1);
var yb = function(t6) {
  for (var e2 = t6[0], i2 = 1; i2 < t6.length; ++i2) t6[i2] > e2 && (e2 = t6[i2]);
  return e2;
};
var xb = function(t6, e2, i2) {
  var n2 = e2 / 8 | 0;
  return (t6[n2] | t6[n2 + 1] << 8) >> (7 & e2) & i2;
};
var bb = function(t6, e2) {
  var i2 = e2 / 8 | 0;
  return (t6[i2] | t6[i2 + 1] << 8 | t6[i2 + 2] << 16) >> (7 & e2);
};
var wb = function(t6) {
  return (t6 / 8 | 0) + (7 & t6 && 1);
};
var _b = function(t6, e2, i2) {
  (null == e2 || e2 < 0) && (e2 = 0), (null == i2 || i2 > t6.length) && (i2 = t6.length);
  var n2 = new (t6 instanceof Jx ? Jx : t6 instanceof Kx ? Kx : Zx)(i2 - e2);
  return n2.set(t6.subarray(e2, i2)), n2;
};
var Sb = function(t6, e2, i2) {
  var n2 = t6.length;
  if (!n2 || i2 && !i2.l && n2 < 5) return e2 || new Zx(0);
  var r2 = !e2 || i2, s2 = !i2 || i2.i;
  i2 || (i2 = {}), e2 || (e2 = new Zx(3 * n2));
  var o2 = function(t7) {
    var i3 = e2.length;
    if (t7 > i3) {
      var n3 = new Zx(Math.max(2 * i3, t7));
      n3.set(e2), e2 = n3;
    }
  }, a2 = i2.f || 0, l2 = i2.p || 0, c2 = i2.b || 0, h2 = i2.l, u2 = i2.d, d2 = i2.m, p2 = i2.n, f2 = 8 * n2;
  do {
    if (!h2) {
      i2.f = a2 = xb(t6, l2, 1);
      var m2 = xb(t6, l2 + 1, 3);
      if (l2 += 3, !m2) {
        var g2 = t6[(A2 = wb(l2) + 4) - 4] | t6[A2 - 3] << 8, v2 = A2 + g2;
        if (v2 > n2) {
          if (s2) throw "unexpected EOF";
          break;
        }
        r2 && o2(c2 + g2), e2.set(t6.subarray(A2, v2), c2), i2.b = c2 += g2, i2.p = l2 = 8 * v2;
        continue;
      }
      if (1 == m2) h2 = mb, u2 = vb, d2 = 9, p2 = 5;
      else {
        if (2 != m2) throw "invalid block type";
        var y2 = xb(t6, l2, 31) + 257, x2 = xb(t6, l2 + 10, 15) + 4, b2 = y2 + xb(t6, l2 + 5, 31) + 1;
        l2 += 14;
        for (var w2 = new Zx(b2), _2 = new Zx(19), S2 = 0; S2 < x2; ++S2) _2[tb[S2]] = xb(t6, l2 + 3 * S2, 7);
        l2 += 3 * x2;
        var M2 = yb(_2), T2 = (1 << M2) - 1, E2 = ub(_2, M2, 1);
        for (S2 = 0; S2 < b2; ) {
          var A2, C2 = E2[xb(t6, l2, T2)];
          if (l2 += 15 & C2, (A2 = C2 >>> 4) < 16) w2[S2++] = A2;
          else {
            var R2 = 0, P2 = 0;
            for (16 == A2 ? (P2 = 3 + xb(t6, l2, 3), l2 += 2, R2 = w2[S2 - 1]) : 17 == A2 ? (P2 = 3 + xb(t6, l2, 7), l2 += 3) : 18 == A2 && (P2 = 11 + xb(t6, l2, 127), l2 += 7); P2--; ) w2[S2++] = R2;
          }
        }
        var L2 = w2.subarray(0, y2), I2 = w2.subarray(y2);
        d2 = yb(L2), p2 = yb(I2), h2 = ub(L2, d2, 1), u2 = ub(I2, p2, 1);
      }
      if (l2 > f2) {
        if (s2) throw "unexpected EOF";
        break;
      }
    }
    r2 && o2(c2 + 131072);
    for (var D2 = (1 << d2) - 1, O2 = (1 << p2) - 1, z2 = l2; ; z2 = l2) {
      var F2 = (R2 = h2[bb(t6, l2) & D2]) >>> 4;
      if ((l2 += 15 & R2) > f2) {
        if (s2) throw "unexpected EOF";
        break;
      }
      if (!R2) throw "invalid length/literal";
      if (F2 < 256) e2[c2++] = F2;
      else {
        if (256 == F2) {
          z2 = l2, h2 = null;
          break;
        }
        var N2 = F2 - 254;
        if (F2 > 264) {
          var B2 = $x[S2 = F2 - 257];
          N2 = xb(t6, l2, (1 << B2) - 1) + nb[S2], l2 += B2;
        }
        var k2 = u2[bb(t6, l2) & O2], U2 = k2 >>> 4;
        if (!k2) throw "invalid distance";
        l2 += 15 & k2;
        I2 = ob[U2];
        if (U2 > 3) {
          B2 = Qx[U2];
          I2 += bb(t6, l2) & (1 << B2) - 1, l2 += B2;
        }
        if (l2 > f2) {
          if (s2) throw "unexpected EOF";
          break;
        }
        r2 && o2(c2 + 131072);
        for (var H2 = c2 + N2; c2 < H2; c2 += 4) e2[c2] = e2[c2 - I2], e2[c2 + 1] = e2[c2 + 1 - I2], e2[c2 + 2] = e2[c2 + 2 - I2], e2[c2 + 3] = e2[c2 + 3 - I2];
        c2 = H2;
      }
    }
    i2.l = h2, i2.p = z2, i2.b = c2, h2 && (a2 = 1, i2.m = d2, i2.d = u2, i2.n = p2);
  } while (!a2);
  return c2 == e2.length ? e2 : _b(e2, 0, c2);
};
var Mb = function(t6, e2, i2) {
  i2 <<= 7 & e2;
  var n2 = e2 / 8 | 0;
  t6[n2] |= i2, t6[n2 + 1] |= i2 >>> 8;
};
var Tb = function(t6, e2, i2) {
  i2 <<= 7 & e2;
  var n2 = e2 / 8 | 0;
  t6[n2] |= i2, t6[n2 + 1] |= i2 >>> 8, t6[n2 + 2] |= i2 >>> 16;
};
var Eb = function(t6, e2) {
  for (var i2 = [], n2 = 0; n2 < t6.length; ++n2) t6[n2] && i2.push({ s: n2, f: t6[n2] });
  var r2 = i2.length, s2 = i2.slice();
  if (!r2) return [Db, 0];
  if (1 == r2) {
    var o2 = new Zx(i2[0].s + 1);
    return o2[i2[0].s] = 1, [o2, 1];
  }
  i2.sort((function(t7, e3) {
    return t7.f - e3.f;
  })), i2.push({ s: -1, f: 25001 });
  var a2 = i2[0], l2 = i2[1], c2 = 0, h2 = 1, u2 = 2;
  for (i2[0] = { s: -1, f: a2.f + l2.f, l: a2, r: l2 }; h2 != r2 - 1; ) a2 = i2[i2[c2].f < i2[u2].f ? c2++ : u2++], l2 = i2[c2 != h2 && i2[c2].f < i2[u2].f ? c2++ : u2++], i2[h2++] = { s: -1, f: a2.f + l2.f, l: a2, r: l2 };
  var d2 = s2[0].s;
  for (n2 = 1; n2 < r2; ++n2) s2[n2].s > d2 && (d2 = s2[n2].s);
  var p2 = new Jx(d2 + 1), f2 = Ab(i2[h2 - 1], p2, 0);
  if (f2 > e2) {
    n2 = 0;
    var m2 = 0, g2 = f2 - e2, v2 = 1 << g2;
    for (s2.sort((function(t7, e3) {
      return p2[e3.s] - p2[t7.s] || t7.f - e3.f;
    })); n2 < r2; ++n2) {
      var y2 = s2[n2].s;
      if (!(p2[y2] > e2)) break;
      m2 += v2 - (1 << f2 - p2[y2]), p2[y2] = e2;
    }
    for (m2 >>>= g2; m2 > 0; ) {
      var x2 = s2[n2].s;
      p2[x2] < e2 ? m2 -= 1 << e2 - p2[x2]++ - 1 : ++n2;
    }
    for (; n2 >= 0 && m2; --n2) {
      var b2 = s2[n2].s;
      p2[b2] == e2 && (--p2[b2], ++m2);
    }
    f2 = e2;
  }
  return [new Zx(p2), f2];
};
var Ab = function(t6, e2, i2) {
  return -1 == t6.s ? Math.max(Ab(t6.l, e2, i2 + 1), Ab(t6.r, e2, i2 + 1)) : e2[t6.s] = i2;
};
var Cb = function(t6) {
  for (var e2 = t6.length; e2 && !t6[--e2]; ) ;
  for (var i2 = new Jx(++e2), n2 = 0, r2 = t6[0], s2 = 1, o2 = function(t7) {
    i2[n2++] = t7;
  }, a2 = 1; a2 <= e2; ++a2) if (t6[a2] == r2 && a2 != e2) ++s2;
  else {
    if (!r2 && s2 > 2) {
      for (; s2 > 138; s2 -= 138) o2(32754);
      s2 > 2 && (o2(s2 > 10 ? s2 - 11 << 5 | 28690 : s2 - 3 << 5 | 12305), s2 = 0);
    } else if (s2 > 3) {
      for (o2(r2), --s2; s2 > 6; s2 -= 6) o2(8304);
      s2 > 2 && (o2(s2 - 3 << 5 | 8208), s2 = 0);
    }
    for (; s2--; ) o2(r2);
    s2 = 1, r2 = t6[a2];
  }
  return [i2.subarray(0, n2), e2];
};
var Rb = function(t6, e2) {
  for (var i2 = 0, n2 = 0; n2 < e2.length; ++n2) i2 += t6[n2] * e2[n2];
  return i2;
};
var Pb = function(t6, e2, i2) {
  var n2 = i2.length, r2 = wb(e2 + 2);
  t6[r2] = 255 & n2, t6[r2 + 1] = n2 >>> 8, t6[r2 + 2] = 255 ^ t6[r2], t6[r2 + 3] = 255 ^ t6[r2 + 1];
  for (var s2 = 0; s2 < n2; ++s2) t6[r2 + s2 + 4] = i2[s2];
  return 8 * (r2 + 4 + n2);
};
var Lb = function(t6, e2, i2, n2, r2, s2, o2, a2, l2, c2, h2) {
  Mb(e2, h2++, i2), ++r2[256];
  for (var u2 = Eb(r2, 15), d2 = u2[0], p2 = u2[1], f2 = Eb(s2, 15), m2 = f2[0], g2 = f2[1], v2 = Cb(d2), y2 = v2[0], x2 = v2[1], b2 = Cb(m2), w2 = b2[0], _2 = b2[1], S2 = new Jx(19), M2 = 0; M2 < y2.length; ++M2) S2[31 & y2[M2]]++;
  for (M2 = 0; M2 < w2.length; ++M2) S2[31 & w2[M2]]++;
  for (var T2 = Eb(S2, 7), E2 = T2[0], A2 = T2[1], C2 = 19; C2 > 4 && !E2[tb[C2 - 1]]; --C2) ;
  var R2, P2, L2, I2, D2 = c2 + 5 << 3, O2 = Rb(r2, db) + Rb(s2, pb) + o2, z2 = Rb(r2, d2) + Rb(s2, m2) + o2 + 14 + 3 * C2 + Rb(S2, E2) + (2 * S2[16] + 3 * S2[17] + 7 * S2[18]);
  if (D2 <= O2 && D2 <= z2) return Pb(e2, h2, t6.subarray(l2, l2 + c2));
  if (Mb(e2, h2, 1 + (z2 < O2)), h2 += 2, z2 < O2) {
    R2 = ub(d2, p2, 0), P2 = d2, L2 = ub(m2, g2, 0), I2 = m2;
    var F2 = ub(E2, A2, 0);
    Mb(e2, h2, x2 - 257), Mb(e2, h2 + 5, _2 - 1), Mb(e2, h2 + 10, C2 - 4), h2 += 14;
    for (M2 = 0; M2 < C2; ++M2) Mb(e2, h2 + 3 * M2, E2[tb[M2]]);
    h2 += 3 * C2;
    for (var N2 = [y2, w2], B2 = 0; B2 < 2; ++B2) {
      var k2 = N2[B2];
      for (M2 = 0; M2 < k2.length; ++M2) {
        var U2 = 31 & k2[M2];
        Mb(e2, h2, F2[U2]), h2 += E2[U2], U2 > 15 && (Mb(e2, h2, k2[M2] >>> 5 & 127), h2 += k2[M2] >>> 12);
      }
    }
  } else R2 = fb, P2 = db, L2 = gb, I2 = pb;
  for (M2 = 0; M2 < a2; ++M2) if (n2[M2] > 255) {
    U2 = n2[M2] >>> 18 & 31;
    Tb(e2, h2, R2[U2 + 257]), h2 += P2[U2 + 257], U2 > 7 && (Mb(e2, h2, n2[M2] >>> 23 & 31), h2 += $x[U2]);
    var H2 = 31 & n2[M2];
    Tb(e2, h2, L2[H2]), h2 += I2[H2], H2 > 3 && (Tb(e2, h2, n2[M2] >>> 5 & 8191), h2 += Qx[H2]);
  } else Tb(e2, h2, R2[n2[M2]]), h2 += P2[n2[M2]];
  return Tb(e2, h2, R2[256]), h2 + P2[256];
};
var Ib = new Kx([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
var Db = new Zx(0);
var Ob = function(t6, e2, i2, n2, r2, s2) {
  var o2 = t6.length, a2 = new Zx(n2 + o2 + 5 * (1 + Math.ceil(o2 / 7e3)) + r2), l2 = a2.subarray(n2, a2.length - r2), c2 = 0;
  if (!e2 || o2 < 8) for (var h2 = 0; h2 <= o2; h2 += 65535) {
    var u2 = h2 + 65535;
    u2 < o2 ? c2 = Pb(l2, c2, t6.subarray(h2, u2)) : (l2[h2] = s2, c2 = Pb(l2, c2, t6.subarray(h2, o2)));
  }
  else {
    for (var d2 = Ib[e2 - 1], p2 = d2 >>> 13, f2 = 8191 & d2, m2 = (1 << i2) - 1, g2 = new Jx(32768), v2 = new Jx(m2 + 1), y2 = Math.ceil(i2 / 3), x2 = 2 * y2, b2 = function(e3) {
      return (t6[e3] ^ t6[e3 + 1] << y2 ^ t6[e3 + 2] << x2) & m2;
    }, w2 = new Kx(25e3), _2 = new Jx(288), S2 = new Jx(32), M2 = 0, T2 = 0, E2 = (h2 = 0, 0), A2 = 0, C2 = 0; h2 < o2; ++h2) {
      var R2 = b2(h2), P2 = 32767 & h2, L2 = v2[R2];
      if (g2[P2] = L2, v2[R2] = P2, A2 <= h2) {
        var I2 = o2 - h2;
        if ((M2 > 7e3 || E2 > 24576) && I2 > 423) {
          c2 = Lb(t6, l2, 0, w2, _2, S2, T2, E2, C2, h2 - C2, c2), E2 = M2 = T2 = 0, C2 = h2;
          for (var D2 = 0; D2 < 286; ++D2) _2[D2] = 0;
          for (D2 = 0; D2 < 30; ++D2) S2[D2] = 0;
        }
        var O2 = 2, z2 = 0, F2 = f2, N2 = P2 - L2 & 32767;
        if (I2 > 2 && R2 == b2(h2 - N2)) for (var B2 = Math.min(p2, I2) - 1, k2 = Math.min(32767, h2), U2 = Math.min(258, I2); N2 <= k2 && --F2 && P2 != L2; ) {
          if (t6[h2 + O2] == t6[h2 + O2 - N2]) {
            for (var H2 = 0; H2 < U2 && t6[h2 + H2] == t6[h2 + H2 - N2]; ++H2) ;
            if (H2 > O2) {
              if (O2 = H2, z2 = N2, H2 > B2) break;
              var V2 = Math.min(N2, H2 - 2), j2 = 0;
              for (D2 = 0; D2 < V2; ++D2) {
                var G2 = h2 - N2 + D2 + 32768 & 32767, W2 = G2 - g2[G2] + 32768 & 32767;
                W2 > j2 && (j2 = W2, L2 = G2);
              }
            }
          }
          N2 += (P2 = L2) - (L2 = g2[P2]) + 32768 & 32767;
        }
        if (z2) {
          w2[E2++] = 268435456 | rb[O2] << 18 | ab[z2];
          var q2 = 31 & rb[O2], X2 = 31 & ab[z2];
          T2 += $x[q2] + Qx[X2], ++_2[257 + q2], ++S2[X2], A2 = h2 + O2, ++M2;
        } else w2[E2++] = t6[h2], ++_2[t6[h2]];
      }
    }
    c2 = Lb(t6, l2, s2, w2, _2, S2, T2, E2, C2, h2 - C2, c2), !s2 && 7 & c2 && (c2 = Pb(l2, c2 + 1, Db));
  }
  return _b(a2, 0, n2 + wb(c2) + r2);
};
var zb = (function() {
  for (var t6 = new Kx(256), e2 = 0; e2 < 256; ++e2) {
    for (var i2 = e2, n2 = 9; --n2; ) i2 = (1 & i2 && 3988292384) ^ i2 >>> 1;
    t6[e2] = i2;
  }
  return t6;
})();
var Fb = function() {
  var t6 = -1;
  return { p: function(e2) {
    for (var i2 = t6, n2 = 0; n2 < e2.length; ++n2) i2 = zb[255 & i2 ^ e2[n2]] ^ i2 >>> 8;
    t6 = i2;
  }, d: function() {
    return ~t6;
  } };
};
var Nb = function() {
  var t6 = 1, e2 = 0;
  return { p: function(i2) {
    for (var n2 = t6, r2 = e2, s2 = i2.length, o2 = 0; o2 != s2; ) {
      for (var a2 = Math.min(o2 + 2655, s2); o2 < a2; ++o2) r2 += n2 += i2[o2];
      n2 = (65535 & n2) + 15 * (n2 >> 16), r2 = (65535 & r2) + 15 * (r2 >> 16);
    }
    t6 = n2, e2 = r2;
  }, d: function() {
    return (255 & (t6 %= 65521)) << 24 | t6 >>> 8 << 16 | (255 & (e2 %= 65521)) << 8 | e2 >>> 8;
  } };
};
var Bb = function(t6, e2, i2, n2, r2) {
  return Ob(t6, null == e2.level ? 6 : e2.level, null == e2.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(t6.length)))) : 12 + e2.mem, i2, n2, !r2);
};
var kb = function(t6, e2) {
  var i2 = {};
  for (var n2 in t6) i2[n2] = t6[n2];
  for (var n2 in e2) i2[n2] = e2[n2];
  return i2;
};
var Ub = function(t6, e2, i2) {
  for (var n2 = t6(), r2 = t6.toString(), s2 = r2.slice(r2.indexOf("[") + 1, r2.lastIndexOf("]")).replace(/ /g, "").split(","), o2 = 0; o2 < n2.length; ++o2) {
    var a2 = n2[o2], l2 = s2[o2];
    if ("function" == typeof a2) {
      e2 += ";" + l2 + "=";
      var c2 = a2.toString();
      if (a2.prototype) if (-1 != c2.indexOf("[native code]")) {
        var h2 = c2.indexOf(" ", 8) + 1;
        e2 += c2.slice(h2, c2.indexOf("(", h2));
      } else for (var u2 in e2 += c2, a2.prototype) e2 += ";" + l2 + ".prototype." + u2 + "=" + a2.prototype[u2].toString();
      else e2 += c2;
    } else i2[l2] = a2;
  }
  return [e2, i2];
};
var Hb = [];
var Vb = function(t6, e2, i2, n2) {
  var r2;
  if (!Hb[i2]) {
    for (var s2 = "", o2 = {}, a2 = t6.length - 1, l2 = 0; l2 < a2; ++l2) s2 = (r2 = Ub(t6[l2], s2, o2))[0], o2 = r2[1];
    Hb[i2] = Ub(t6[a2], s2, o2);
  }
  var c2 = kb({}, Hb[i2][1]);
  return (function(t7, e3, i3, n3, r3) {
    var s3 = Yx(qx[e3] || (qx[e3] = Xx(t7)));
    return s3.onerror = function(t8) {
      return r3(t8.error, null);
    }, s3.onmessage = function(t8) {
      return r3(null, t8.data);
    }, s3.postMessage(i3, n3), s3;
  })(Hb[i2][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + e2.toString() + "}", i2, c2, (function(t7) {
    var e3 = [];
    for (var i3 in t7) (t7[i3] instanceof Zx || t7[i3] instanceof Jx || t7[i3] instanceof Kx) && e3.push((t7[i3] = new t7[i3].constructor(t7[i3])).buffer);
    return e3;
  })(c2), n2);
};
var jb = function() {
  return [Zx, Jx, Kx, $x, Qx, tb, nb, ob, mb, vb, lb, ub, yb, xb, bb, wb, _b, Sb, yw, Zb, Jb];
};
var Gb = function() {
  return [Zx, Jx, Kx, $x, Qx, tb, rb, ab, fb, db, gb, pb, lb, Ib, Db, ub, Mb, Tb, Eb, Ab, Cb, Rb, Pb, Lb, wb, _b, Ob, Bb, fw, Zb];
};
var Wb = function() {
  return [rw, aw, nw, Fb, zb];
};
var qb = function() {
  return [sw, ow];
};
var Xb = function() {
  return [lw, nw, Nb];
};
var Yb = function() {
  return [cw];
};
var Zb = function(t6) {
  return postMessage(t6, [t6.buffer]);
};
var Jb = function(t6) {
  return t6 && t6.size && new Zx(t6.size);
};
var Kb = function(t6, e2, i2, n2, r2, s2) {
  var o2 = Vb(i2, n2, r2, (function(t7, e3) {
    o2.terminate(), s2(t7, e3);
  }));
  return o2.postMessage([t6, e2], e2.consume ? [t6.buffer] : []), function() {
    o2.terminate();
  };
};
var $b = function(t6) {
  return t6.ondata = function(t7, e2) {
    return postMessage([t7, e2], [t7.buffer]);
  }, function(e2) {
    return t6.push(e2.data[0], e2.data[1]);
  };
};
var Qb = function(t6, e2, i2, n2, r2) {
  var s2, o2 = Vb(t6, n2, r2, (function(t7, i3) {
    t7 ? (o2.terminate(), e2.ondata.call(e2, t7)) : (i3[1] && o2.terminate(), e2.ondata.call(e2, t7, i3[0], i3[1]));
  }));
  o2.postMessage(i2), e2.push = function(t7, i3) {
    if (s2) throw "stream finished";
    if (!e2.ondata) throw "no stream handler";
    o2.postMessage([t7, s2 = i3], [t7.buffer]);
  }, e2.terminate = function() {
    o2.terminate();
  };
};
var tw = function(t6, e2) {
  return t6[e2] | t6[e2 + 1] << 8;
};
var ew = function(t6, e2) {
  return (t6[e2] | t6[e2 + 1] << 8 | t6[e2 + 2] << 16 | t6[e2 + 3] << 24) >>> 0;
};
var iw = function(t6, e2) {
  return ew(t6, e2) + 4294967296 * ew(t6, e2 + 4);
};
var nw = function(t6, e2, i2) {
  for (; i2; ++e2) t6[e2] = i2, i2 >>>= 8;
};
var rw = function(t6, e2) {
  var i2 = e2.filename;
  if (t6[0] = 31, t6[1] = 139, t6[2] = 8, t6[8] = e2.level < 2 ? 4 : 9 == e2.level ? 2 : 0, t6[9] = 3, 0 != e2.mtime && nw(t6, 4, Math.floor(new Date(e2.mtime || Date.now()) / 1e3)), i2) {
    t6[3] = 8;
    for (var n2 = 0; n2 <= i2.length; ++n2) t6[n2 + 10] = i2.charCodeAt(n2);
  }
};
var sw = function(t6) {
  if (31 != t6[0] || 139 != t6[1] || 8 != t6[2]) throw "invalid gzip data";
  var e2 = t6[3], i2 = 10;
  4 & e2 && (i2 += t6[10] | 2 + (t6[11] << 8));
  for (var n2 = (e2 >> 3 & 1) + (e2 >> 4 & 1); n2 > 0; n2 -= !t6[i2++]) ;
  return i2 + (2 & e2);
};
var ow = function(t6) {
  var e2 = t6.length;
  return (t6[e2 - 4] | t6[e2 - 3] << 8 | t6[e2 - 2] << 16 | t6[e2 - 1] << 24) >>> 0;
};
var aw = function(t6) {
  return 10 + (t6.filename && t6.filename.length + 1 || 0);
};
var lw = function(t6, e2) {
  var i2 = e2.level, n2 = 0 == i2 ? 0 : i2 < 6 ? 1 : 9 == i2 ? 3 : 2;
  t6[0] = 120, t6[1] = n2 << 6 | (n2 ? 32 - 2 * n2 : 1);
};
var cw = function(t6) {
  if (8 != (15 & t6[0]) || t6[0] >>> 4 > 7 || (t6[0] << 8 | t6[1]) % 31) throw "invalid zlib data";
  if (32 & t6[1]) throw "invalid zlib data: preset dictionaries not supported";
};
function hw(t6, e2) {
  return e2 || "function" != typeof t6 || (e2 = t6, t6 = {}), this.ondata = e2, t6;
}
var uw = (function() {
  function t6(t7, e2) {
    e2 || "function" != typeof t7 || (e2 = t7, t7 = {}), this.ondata = e2, this.o = t7 || {};
  }
  return t6.prototype.p = function(t7, e2) {
    this.ondata(Bb(t7, this.o, 0, 0, !e2), e2);
  }, t6.prototype.push = function(t7, e2) {
    if (this.d) throw "stream finished";
    if (!this.ondata) throw "no stream handler";
    this.d = e2, this.p(t7, e2 || false);
  }, t6;
})();
var dw = /* @__PURE__ */ (function() {
  return function(t6, e2) {
    Qb([Gb, function() {
      return [$b, uw];
    }], this, hw.call(this, t6, e2), (function(t7) {
      var e3 = new uw(t7.data);
      onmessage = $b(e3);
    }), 6);
  };
})();
function pw(t6, e2, i2) {
  if (i2 || (i2 = e2, e2 = {}), "function" != typeof i2) throw "no callback";
  return Kb(t6, e2, [Gb], (function(t7) {
    return Zb(fw(t7.data[0], t7.data[1]));
  }), 0, i2);
}
function fw(t6, e2) {
  return Bb(t6, e2 || {}, 0, 0);
}
var mw = (function() {
  function t6(t7) {
    this.s = {}, this.p = new Zx(0), this.ondata = t7;
  }
  return t6.prototype.e = function(t7) {
    if (this.d) throw "stream finished";
    if (!this.ondata) throw "no stream handler";
    var e2 = this.p.length, i2 = new Zx(e2 + t7.length);
    i2.set(this.p), i2.set(t7, e2), this.p = i2;
  }, t6.prototype.c = function(t7) {
    this.d = this.s.i = t7 || false;
    var e2 = this.s.b, i2 = Sb(this.p, this.o, this.s);
    this.ondata(_b(i2, e2, this.s.b), this.d), this.o = _b(i2, this.s.b - 32768), this.s.b = this.o.length, this.p = _b(this.p, this.s.p / 8 | 0), this.s.p &= 7;
  }, t6.prototype.push = function(t7, e2) {
    this.e(t7), this.c(e2);
  }, t6;
})();
var gw = /* @__PURE__ */ (function() {
  return function(t6) {
    this.ondata = t6, Qb([jb, function() {
      return [$b, mw];
    }], this, 0, (function() {
      var t7 = new mw();
      onmessage = $b(t7);
    }), 7);
  };
})();
function vw(t6, e2, i2) {
  if (i2 || (i2 = e2, e2 = {}), "function" != typeof i2) throw "no callback";
  return Kb(t6, e2, [jb], (function(t7) {
    return Zb(yw(t7.data[0], Jb(t7.data[1])));
  }), 1, i2);
}
function yw(t6, e2) {
  return Sb(t6, e2);
}
var xw = (function() {
  function t6(t7, e2) {
    this.c = Fb(), this.l = 0, this.v = 1, uw.call(this, t7, e2);
  }
  return t6.prototype.push = function(t7, e2) {
    uw.prototype.push.call(this, t7, e2);
  }, t6.prototype.p = function(t7, e2) {
    this.c.p(t7), this.l += t7.length;
    var i2 = Bb(t7, this.o, this.v && aw(this.o), e2 && 8, !e2);
    this.v && (rw(i2, this.o), this.v = 0), e2 && (nw(i2, i2.length - 8, this.c.d()), nw(i2, i2.length - 4, this.l)), this.ondata(i2, e2);
  }, t6;
})();
var bw = /* @__PURE__ */ (function() {
  return function(t6, e2) {
    Qb([Gb, Wb, function() {
      return [$b, uw, xw];
    }], this, hw.call(this, t6, e2), (function(t7) {
      var e3 = new xw(t7.data);
      onmessage = $b(e3);
    }), 8);
  };
})();
function ww(t6, e2, i2) {
  if (i2 || (i2 = e2, e2 = {}), "function" != typeof i2) throw "no callback";
  return Kb(t6, e2, [Gb, Wb, function() {
    return [_w];
  }], (function(t7) {
    return Zb(_w(t7.data[0], t7.data[1]));
  }), 2, i2);
}
function _w(t6, e2) {
  e2 || (e2 = {});
  var i2 = Fb(), n2 = t6.length;
  i2.p(t6);
  var r2 = Bb(t6, e2, aw(e2), 8), s2 = r2.length;
  return rw(r2, e2), nw(r2, s2 - 8, i2.d()), nw(r2, s2 - 4, n2), r2;
}
var Sw = (function() {
  function t6(t7) {
    this.v = 1, mw.call(this, t7);
  }
  return t6.prototype.push = function(t7, e2) {
    if (mw.prototype.e.call(this, t7), this.v) {
      var i2 = this.p.length > 3 ? sw(this.p) : 4;
      if (i2 >= this.p.length && !e2) return;
      this.p = this.p.subarray(i2), this.v = 0;
    }
    if (e2) {
      if (this.p.length < 8) throw "invalid gzip stream";
      this.p = this.p.subarray(0, -8);
    }
    mw.prototype.c.call(this, e2);
  }, t6;
})();
var Mw = /* @__PURE__ */ (function() {
  return function(t6) {
    this.ondata = t6, Qb([jb, qb, function() {
      return [$b, mw, Sw];
    }], this, 0, (function() {
      var t7 = new Sw();
      onmessage = $b(t7);
    }), 9);
  };
})();
function Tw(t6, e2, i2) {
  if (i2 || (i2 = e2, e2 = {}), "function" != typeof i2) throw "no callback";
  return Kb(t6, e2, [jb, qb, function() {
    return [Ew];
  }], (function(t7) {
    return Zb(Ew(t7.data[0]));
  }), 3, i2);
}
function Ew(t6, e2) {
  return Sb(t6.subarray(sw(t6), -8), e2 || new Zx(ow(t6)));
}
var Aw = (function() {
  function t6(t7, e2) {
    this.c = Nb(), this.v = 1, uw.call(this, t7, e2);
  }
  return t6.prototype.push = function(t7, e2) {
    uw.prototype.push.call(this, t7, e2);
  }, t6.prototype.p = function(t7, e2) {
    this.c.p(t7);
    var i2 = Bb(t7, this.o, this.v && 2, e2 && 4, !e2);
    this.v && (lw(i2, this.o), this.v = 0), e2 && nw(i2, i2.length - 4, this.c.d()), this.ondata(i2, e2);
  }, t6;
})();
var Cw = /* @__PURE__ */ (function() {
  return function(t6, e2) {
    Qb([Gb, Xb, function() {
      return [$b, uw, Aw];
    }], this, hw.call(this, t6, e2), (function(t7) {
      var e3 = new Aw(t7.data);
      onmessage = $b(e3);
    }), 10);
  };
})();
function Rw(t6, e2, i2) {
  if (i2 || (i2 = e2, e2 = {}), "function" != typeof i2) throw "no callback";
  return Kb(t6, e2, [Gb, Xb, function() {
    return [Pw];
  }], (function(t7) {
    return Zb(Pw(t7.data[0], t7.data[1]));
  }), 4, i2);
}
function Pw(t6, e2) {
  e2 || (e2 = {});
  var i2 = Nb();
  i2.p(t6);
  var n2 = Bb(t6, e2, 2, 4);
  return lw(n2, e2), nw(n2, n2.length - 4, i2.d()), n2;
}
var Lw = (function() {
  function t6(t7) {
    this.v = 1, mw.call(this, t7);
  }
  return t6.prototype.push = function(t7, e2) {
    if (mw.prototype.e.call(this, t7), this.v) {
      if (this.p.length < 2 && !e2) return;
      this.p = this.p.subarray(2), this.v = 0;
    }
    if (e2) {
      if (this.p.length < 4) throw "invalid zlib stream";
      this.p = this.p.subarray(0, -4);
    }
    mw.prototype.c.call(this, e2);
  }, t6;
})();
var Iw = /* @__PURE__ */ (function() {
  return function(t6) {
    this.ondata = t6, Qb([jb, Yb, function() {
      return [$b, mw, Lw];
    }], this, 0, (function() {
      var t7 = new Lw();
      onmessage = $b(t7);
    }), 11);
  };
})();
function Dw(t6, e2, i2) {
  if (i2 || (i2 = e2, e2 = {}), "function" != typeof i2) throw "no callback";
  return Kb(t6, e2, [jb, Yb, function() {
    return [Ow];
  }], (function(t7) {
    return Zb(Ow(t7.data[0], Jb(t7.data[1])));
  }), 5, i2);
}
function Ow(t6, e2) {
  return Sb((cw(t6), t6.subarray(2, -4)), e2);
}
var zw = (function() {
  function t6(t7) {
    this.G = Sw, this.I = mw, this.Z = Lw, this.ondata = t7;
  }
  return t6.prototype.push = function(t7, e2) {
    if (!this.ondata) throw "no stream handler";
    if (this.s) this.s.push(t7, e2);
    else {
      if (this.p && this.p.length) {
        var i2 = new Zx(this.p.length + t7.length);
        i2.set(this.p), i2.set(t7, this.p.length);
      } else this.p = t7;
      if (this.p.length > 2) {
        var n2 = this, r2 = function() {
          n2.ondata.apply(n2, arguments);
        };
        this.s = 31 == this.p[0] && 139 == this.p[1] && 8 == this.p[2] ? new this.G(r2) : 8 != (15 & this.p[0]) || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(r2) : new this.Z(r2), this.s.push(this.p, e2), this.p = null;
      }
    }
  }, t6;
})();
var Fw = (function() {
  function t6(t7) {
    this.G = Mw, this.I = gw, this.Z = Iw, this.ondata = t7;
  }
  return t6.prototype.push = function(t7, e2) {
    zw.prototype.push.call(this, t7, e2);
  }, t6;
})();
function Nw(t6, e2, i2) {
  if (i2 || (i2 = e2, e2 = {}), "function" != typeof i2) throw "no callback";
  return 31 == t6[0] && 139 == t6[1] && 8 == t6[2] ? Tw(t6, e2, i2) : 8 != (15 & t6[0]) || t6[0] >> 4 > 7 || (t6[0] << 8 | t6[1]) % 31 ? vw(t6, e2, i2) : Dw(t6, e2, i2);
}
function Bw(t6, e2) {
  return 31 == t6[0] && 139 == t6[1] && 8 == t6[2] ? Ew(t6, e2) : 8 != (15 & t6[0]) || t6[0] >> 4 > 7 || (t6[0] << 8 | t6[1]) % 31 ? yw(t6, e2) : Ow(t6, e2);
}
var kw = function(t6, e2, i2, n2) {
  for (var r2 in t6) {
    var s2 = t6[r2], o2 = e2 + r2;
    s2 instanceof Zx ? i2[o2] = [s2, n2] : Array.isArray(s2) ? i2[o2] = [s2[0], kb(n2, s2[1])] : kw(s2, o2 + "/", i2, n2);
  }
};
var Uw = "undefined" != typeof TextEncoder && new TextEncoder();
var Hw = "undefined" != typeof TextDecoder && new TextDecoder();
var Vw = 0;
try {
  Hw.decode(Db, { stream: true }), Vw = 1;
} catch (t6) {
}
var jw = function(t6) {
  for (var e2 = "", i2 = 0; ; ) {
    var n2 = t6[i2++], r2 = (n2 > 127) + (n2 > 223) + (n2 > 239);
    if (i2 + r2 > t6.length) return [e2, _b(t6, i2 - 1)];
    r2 ? 3 == r2 ? (n2 = ((15 & n2) << 18 | (63 & t6[i2++]) << 12 | (63 & t6[i2++]) << 6 | 63 & t6[i2++]) - 65536, e2 += String.fromCharCode(55296 | n2 >> 10, 56320 | 1023 & n2)) : e2 += 1 & r2 ? String.fromCharCode((31 & n2) << 6 | 63 & t6[i2++]) : String.fromCharCode((15 & n2) << 12 | (63 & t6[i2++]) << 6 | 63 & t6[i2++]) : e2 += String.fromCharCode(n2);
  }
};
var Gw = (function() {
  function t6(t7) {
    this.ondata = t7, Vw ? this.t = new TextDecoder() : this.p = Db;
  }
  return t6.prototype.push = function(t7, e2) {
    if (!this.ondata) throw "no callback";
    if (e2 = !!e2, this.t) {
      if (this.ondata(this.t.decode(t7, { stream: true }), e2), e2) {
        if (this.t.decode().length) throw "invalid utf-8 data";
        this.t = null;
      }
    } else {
      if (!this.p) throw "stream finished";
      var i2 = new Zx(this.p.length + t7.length);
      i2.set(this.p), i2.set(t7, this.p.length);
      var n2 = jw(i2), r2 = n2[0], s2 = n2[1];
      if (e2) {
        if (s2.length) throw "invalid utf-8 data";
        this.p = null;
      } else this.p = s2;
      this.ondata(r2, e2);
    }
  }, t6;
})();
var Ww = (function() {
  function t6(t7) {
    this.ondata = t7;
  }
  return t6.prototype.push = function(t7, e2) {
    if (!this.ondata) throw "no callback";
    if (this.d) throw "stream finished";
    this.ondata(qw(t7), this.d = e2 || false);
  }, t6;
})();
function qw(t6, e2) {
  if (e2) {
    for (var i2 = new Zx(t6.length), n2 = 0; n2 < t6.length; ++n2) i2[n2] = t6.charCodeAt(n2);
    return i2;
  }
  if (Uw) return Uw.encode(t6);
  var r2 = t6.length, s2 = new Zx(t6.length + (t6.length >> 1)), o2 = 0, a2 = function(t7) {
    s2[o2++] = t7;
  };
  for (n2 = 0; n2 < r2; ++n2) {
    if (o2 + 5 > s2.length) {
      var l2 = new Zx(o2 + 8 + (r2 - n2 << 1));
      l2.set(s2), s2 = l2;
    }
    var c2 = t6.charCodeAt(n2);
    c2 < 128 || e2 ? a2(c2) : c2 < 2048 ? (a2(192 | c2 >> 6), a2(128 | 63 & c2)) : c2 > 55295 && c2 < 57344 ? (a2(240 | (c2 = 65536 + (1047552 & c2) | 1023 & t6.charCodeAt(++n2)) >> 18), a2(128 | c2 >> 12 & 63), a2(128 | c2 >> 6 & 63), a2(128 | 63 & c2)) : (a2(224 | c2 >> 12), a2(128 | c2 >> 6 & 63), a2(128 | 63 & c2));
  }
  return _b(s2, 0, o2);
}
function Xw(t6, e2) {
  if (e2) {
    for (var i2 = "", n2 = 0; n2 < t6.length; n2 += 16384) i2 += String.fromCharCode.apply(null, t6.subarray(n2, n2 + 16384));
    return i2;
  }
  if (Hw) return Hw.decode(t6);
  var r2 = jw(t6), s2 = r2[0];
  if (r2[1].length) throw "invalid utf-8 data";
  return s2;
}
var Yw = function(t6) {
  return 1 == t6 ? 3 : t6 < 6 ? 2 : 9 == t6 ? 1 : 0;
};
var Zw = function(t6, e2) {
  return e2 + 30 + tw(t6, e2 + 26) + tw(t6, e2 + 28);
};
var Jw = function(t6, e2, i2) {
  var n2 = tw(t6, e2 + 28), r2 = Xw(t6.subarray(e2 + 46, e2 + 46 + n2), !(2048 & tw(t6, e2 + 8))), s2 = e2 + 46 + n2, o2 = ew(t6, e2 + 20), a2 = i2 && 4294967295 == o2 ? Kw(t6, s2) : [o2, ew(t6, e2 + 24), ew(t6, e2 + 42)], l2 = a2[0], c2 = a2[1], h2 = a2[2];
  return [tw(t6, e2 + 10), l2, c2, r2, s2 + tw(t6, e2 + 30) + tw(t6, e2 + 32), h2];
};
var Kw = function(t6, e2) {
  for (; 1 != tw(t6, e2); e2 += 4 + tw(t6, e2 + 2)) ;
  return [iw(t6, e2 + 12), iw(t6, e2 + 4), iw(t6, e2 + 20)];
};
var $w = function(t6) {
  var e2 = 0;
  if (t6) for (var i2 in t6) {
    var n2 = t6[i2].length;
    if (n2 > 65535) throw "extra field too long";
    e2 += n2 + 4;
  }
  return e2;
};
var Qw = function(t6, e2, i2, n2, r2, s2, o2, a2) {
  var l2 = n2.length, c2 = i2.extra, h2 = a2 && a2.length, u2 = $w(c2);
  nw(t6, e2, null != o2 ? 33639248 : 67324752), e2 += 4, null != o2 && (t6[e2++] = 20, t6[e2++] = i2.os), t6[e2] = 20, e2 += 2, t6[e2++] = i2.flag << 1 | (null == s2 && 8), t6[e2++] = r2 && 8, t6[e2++] = 255 & i2.compression, t6[e2++] = i2.compression >> 8;
  var d2 = new Date(null == i2.mtime ? Date.now() : i2.mtime), p2 = d2.getFullYear() - 1980;
  if (p2 < 0 || p2 > 119) throw "date not in range 1980-2099";
  if (nw(t6, e2, p2 << 25 | d2.getMonth() + 1 << 21 | d2.getDate() << 16 | d2.getHours() << 11 | d2.getMinutes() << 5 | d2.getSeconds() >>> 1), e2 += 4, null != s2 && (nw(t6, e2, i2.crc), nw(t6, e2 + 4, s2), nw(t6, e2 + 8, i2.size)), nw(t6, e2 + 12, l2), nw(t6, e2 + 14, u2), e2 += 16, null != o2 && (nw(t6, e2, h2), nw(t6, e2 + 6, i2.attrs), nw(t6, e2 + 10, o2), e2 += 14), t6.set(n2, e2), e2 += l2, u2) for (var f2 in c2) {
    var m2 = c2[f2], g2 = m2.length;
    nw(t6, e2, +f2), nw(t6, e2 + 2, g2), t6.set(m2, e2 + 4), e2 += 4 + g2;
  }
  return h2 && (t6.set(a2, e2), e2 += h2), e2;
};
var t_ = function(t6, e2, i2, n2, r2) {
  nw(t6, e2, 101010256), nw(t6, e2 + 8, i2), nw(t6, e2 + 10, i2), nw(t6, e2 + 12, n2), nw(t6, e2 + 16, r2);
};
var e_ = (function() {
  function t6(t7) {
    this.filename = t7, this.c = Fb(), this.size = 0, this.compression = 0;
  }
  return t6.prototype.process = function(t7, e2) {
    this.ondata(null, t7, e2);
  }, t6.prototype.push = function(t7, e2) {
    if (!this.ondata) throw "no callback - add to ZIP archive before pushing";
    this.c.p(t7), this.size += t7.length, e2 && (this.crc = this.c.d()), this.process(t7, e2 || false);
  }, t6;
})();
var i_ = (function() {
  function t6(t7, e2) {
    var i2 = this;
    e2 || (e2 = {}), e_.call(this, t7), this.d = new uw(e2, (function(t8, e3) {
      i2.ondata(null, t8, e3);
    })), this.compression = 8, this.flag = Yw(e2.level);
  }
  return t6.prototype.process = function(t7, e2) {
    try {
      this.d.push(t7, e2);
    } catch (t8) {
      this.ondata(t8, null, e2);
    }
  }, t6.prototype.push = function(t7, e2) {
    e_.prototype.push.call(this, t7, e2);
  }, t6;
})();
var n_ = (function() {
  function t6(t7, e2) {
    var i2 = this;
    e2 || (e2 = {}), e_.call(this, t7), this.d = new dw(e2, (function(t8, e3, n2) {
      i2.ondata(t8, e3, n2);
    })), this.compression = 8, this.flag = Yw(e2.level), this.terminate = this.d.terminate;
  }
  return t6.prototype.process = function(t7, e2) {
    this.d.push(t7, e2);
  }, t6.prototype.push = function(t7, e2) {
    e_.prototype.push.call(this, t7, e2);
  }, t6;
})();
var r_ = (function() {
  function t6(t7) {
    this.ondata = t7, this.u = [], this.d = 1;
  }
  return t6.prototype.add = function(t7) {
    var e2 = this;
    if (2 & this.d) throw "stream finished";
    var i2 = qw(t7.filename), n2 = i2.length, r2 = t7.comment, s2 = r2 && qw(r2), o2 = n2 != t7.filename.length || s2 && r2.length != s2.length, a2 = n2 + $w(t7.extra) + 30;
    if (n2 > 65535) throw "filename too long";
    var l2 = new Zx(a2);
    Qw(l2, 0, t7, i2, o2);
    var c2 = [l2], h2 = function() {
      for (var t8 = 0, i3 = c2; t8 < i3.length; t8++) {
        var n3 = i3[t8];
        e2.ondata(null, n3, false);
      }
      c2 = [];
    }, u2 = this.d;
    this.d = 0;
    var d2 = this.u.length, p2 = kb(t7, { f: i2, u: o2, o: s2, t: function() {
      t7.terminate && t7.terminate();
    }, r: function() {
      if (h2(), u2) {
        var t8 = e2.u[d2 + 1];
        t8 ? t8.r() : e2.d = 1;
      }
      u2 = 1;
    } }), f2 = 0;
    t7.ondata = function(i3, n3, r3) {
      if (i3) e2.ondata(i3, n3, r3), e2.terminate();
      else if (f2 += n3.length, c2.push(n3), r3) {
        var s3 = new Zx(16);
        nw(s3, 0, 134695760), nw(s3, 4, t7.crc), nw(s3, 8, f2), nw(s3, 12, t7.size), c2.push(s3), p2.c = f2, p2.b = a2 + f2 + 16, p2.crc = t7.crc, p2.size = t7.size, u2 && p2.r(), u2 = 1;
      } else u2 && h2();
    }, this.u.push(p2);
  }, t6.prototype.end = function() {
    var t7 = this;
    if (2 & this.d) {
      if (1 & this.d) throw "stream finishing";
      throw "stream finished";
    }
    this.d ? this.e() : this.u.push({ r: function() {
      1 & t7.d && (t7.u.splice(-1, 1), t7.e());
    }, t: function() {
    } }), this.d = 3;
  }, t6.prototype.e = function() {
    for (var t7 = 0, e2 = 0, i2 = 0, n2 = 0, r2 = this.u; n2 < r2.length; n2++) {
      i2 += 46 + (l2 = r2[n2]).f.length + $w(l2.extra) + (l2.o ? l2.o.length : 0);
    }
    for (var s2 = new Zx(i2 + 22), o2 = 0, a2 = this.u; o2 < a2.length; o2++) {
      var l2 = a2[o2];
      Qw(s2, t7, l2, l2.f, l2.u, l2.c, e2, l2.o), t7 += 46 + l2.f.length + $w(l2.extra) + (l2.o ? l2.o.length : 0), e2 += l2.b;
    }
    t_(s2, t7, this.u.length, i2, e2), this.ondata(null, s2, true), this.d = 2;
  }, t6.prototype.terminate = function() {
    for (var t7 = 0, e2 = this.u; t7 < e2.length; t7++) {
      e2[t7].t();
    }
    this.d = 2;
  }, t6;
})();
function s_(t6, e2, i2) {
  if (i2 || (i2 = e2, e2 = {}), "function" != typeof i2) throw "no callback";
  var n2 = {};
  kw(t6, "", n2, e2);
  var r2 = Object.keys(n2), s2 = r2.length, o2 = 0, a2 = 0, l2 = s2, c2 = new Array(s2), h2 = [], u2 = function() {
    for (var t7 = 0; t7 < h2.length; ++t7) h2[t7]();
  }, d2 = function() {
    var t7 = new Zx(a2 + 22), e3 = o2, n3 = a2 - o2;
    a2 = 0;
    for (var r3 = 0; r3 < l2; ++r3) {
      var s3 = c2[r3];
      try {
        var h3 = s3.c.length;
        Qw(t7, a2, s3, s3.f, s3.u, h3);
        var u3 = 30 + s3.f.length + $w(s3.extra), d3 = a2 + u3;
        t7.set(s3.c, d3), Qw(t7, o2, s3, s3.f, s3.u, h3, a2, s3.m), o2 += 16 + u3 + (s3.m ? s3.m.length : 0), a2 = d3 + h3;
      } catch (t8) {
        return i2(t8, null);
      }
    }
    t_(t7, o2, c2.length, n3, e3), i2(null, t7);
  };
  s2 || d2();
  for (var p2 = function(t7) {
    var e3 = r2[t7], l3 = n2[e3], p3 = l3[0], f3 = l3[1], m2 = Fb(), g2 = p3.length;
    m2.p(p3);
    var v2 = qw(e3), y2 = v2.length, x2 = f3.comment, b2 = x2 && qw(x2), w2 = b2 && b2.length, _2 = $w(f3.extra), S2 = 0 == f3.level ? 0 : 8, M2 = function(n3, r3) {
      if (n3) u2(), i2(n3, null);
      else {
        var l4 = r3.length;
        c2[t7] = kb(f3, { size: g2, crc: m2.d(), c: r3, f: v2, m: b2, u: y2 != e3.length || b2 && x2.length != w2, compression: S2 }), o2 += 30 + y2 + _2 + l4, a2 += 76 + 2 * (y2 + _2) + (w2 || 0) + l4, --s2 || d2();
      }
    };
    if (y2 > 65535 && M2("filename too long", null), S2) if (g2 < 16e4) try {
      M2(null, fw(p3, f3));
    } catch (t8) {
      M2(t8, null);
    }
    else h2.push(pw(p3, f3, M2));
    else M2(null, p3);
  }, f2 = 0; f2 < l2; ++f2) p2(f2);
  return u2;
}
function o_(t6, e2) {
  e2 || (e2 = {});
  var i2 = {}, n2 = [];
  kw(t6, "", i2, e2);
  var r2 = 0, s2 = 0;
  for (var o2 in i2) {
    var a2 = i2[o2], l2 = a2[0], c2 = a2[1], h2 = 0 == c2.level ? 0 : 8, u2 = (S2 = qw(o2)).length, d2 = c2.comment, p2 = d2 && qw(d2), f2 = p2 && p2.length, m2 = $w(c2.extra);
    if (u2 > 65535) throw "filename too long";
    var g2 = h2 ? fw(l2, c2) : l2, v2 = g2.length, y2 = Fb();
    y2.p(l2), n2.push(kb(c2, { size: l2.length, crc: y2.d(), c: g2, f: S2, m: p2, u: u2 != o2.length || p2 && d2.length != f2, o: r2, compression: h2 })), r2 += 30 + u2 + m2 + v2, s2 += 76 + 2 * (u2 + m2) + (f2 || 0) + v2;
  }
  for (var x2 = new Zx(s2 + 22), b2 = r2, w2 = s2 - r2, _2 = 0; _2 < n2.length; ++_2) {
    var S2 = n2[_2];
    Qw(x2, S2.o, S2, S2.f, S2.u, S2.c.length);
    var M2 = 30 + S2.f.length + $w(S2.extra);
    x2.set(S2.c, S2.o + M2), Qw(x2, r2, S2, S2.f, S2.u, S2.c.length, S2.o, S2.m), r2 += 16 + M2 + (S2.m ? S2.m.length : 0);
  }
  return t_(x2, r2, n2.length, w2, b2), x2;
}
var a_ = (function() {
  function t6() {
  }
  return t6.prototype.push = function(t7, e2) {
    this.ondata(null, t7, e2);
  }, t6.compression = 0, t6;
})();
var l_ = (function() {
  function t6() {
    var t7 = this;
    this.i = new mw((function(e2, i2) {
      t7.ondata(null, e2, i2);
    }));
  }
  return t6.prototype.push = function(t7, e2) {
    try {
      this.i.push(t7, e2);
    } catch (i2) {
      this.ondata(i2, t7, e2);
    }
  }, t6.compression = 8, t6;
})();
var c_ = (function() {
  function t6(t7, e2) {
    var i2 = this;
    e2 < 32e4 ? this.i = new mw((function(t8, e3) {
      i2.ondata(null, t8, e3);
    })) : (this.i = new gw((function(t8, e3, n2) {
      i2.ondata(t8, e3, n2);
    })), this.terminate = this.i.terminate);
  }
  return t6.prototype.push = function(t7, e2) {
    this.i.terminate && (t7 = _b(t7, 0)), this.i.push(t7, e2);
  }, t6.compression = 8, t6;
})();
var h_ = (function() {
  function t6(t7) {
    this.onfile = t7, this.k = [], this.o = { 0: a_ }, this.p = Db;
  }
  return t6.prototype.push = function(t7, e2) {
    var i2 = this;
    if (!this.onfile) throw "no callback";
    if (!this.p) throw "stream finished";
    if (this.c > 0) {
      var n2 = Math.min(this.c, t7.length), r2 = t7.subarray(0, n2);
      if (this.c -= n2, this.d ? this.d.push(r2, !this.c) : this.k[0].push(r2), (t7 = t7.subarray(n2)).length) return this.push(t7, e2);
    } else {
      var s2 = 0, o2 = 0, a2 = void 0, l2 = void 0;
      this.p.length ? t7.length ? ((l2 = new Zx(this.p.length + t7.length)).set(this.p), l2.set(t7, this.p.length)) : l2 = this.p : l2 = t7;
      for (var c2 = l2.length, h2 = this.c, u2 = h2 && this.d, d2 = function() {
        var t8, e3 = ew(l2, o2);
        if (67324752 == e3) {
          s2 = 1, a2 = o2, p2.d = null, p2.c = 0;
          var n3 = tw(l2, o2 + 6), r3 = tw(l2, o2 + 8), u3 = 2048 & n3, d3 = 8 & n3, f3 = tw(l2, o2 + 26), m2 = tw(l2, o2 + 28);
          if (c2 > o2 + 30 + f3 + m2) {
            var g2 = [];
            p2.k.unshift(g2), s2 = 2;
            var v2, y2 = ew(l2, o2 + 18), x2 = ew(l2, o2 + 22), b2 = Xw(l2.subarray(o2 + 30, o2 += 30 + f3), !u3);
            4294967295 == y2 ? (t8 = d3 ? [-2] : Kw(l2, o2), y2 = t8[0], x2 = t8[1]) : d3 && (y2 = -1), o2 += m2, p2.c = y2;
            var w2 = { name: b2, compression: r3, start: function() {
              if (!w2.ondata) throw "no callback";
              if (y2) {
                var t9 = i2.o[r3];
                if (!t9) throw "unknown compression type " + r3;
                (v2 = y2 < 0 ? new t9(b2) : new t9(b2, y2, x2)).ondata = function(t10, e5, i3) {
                  w2.ondata(t10, e5, i3);
                };
                for (var e4 = 0, n4 = g2; e4 < n4.length; e4++) {
                  var s3 = n4[e4];
                  v2.push(s3, false);
                }
                i2.k[0] == g2 && i2.c ? i2.d = v2 : v2.push(Db, true);
              } else w2.ondata(null, Db, true);
            }, terminate: function() {
              v2 && v2.terminate && v2.terminate();
            } };
            y2 >= 0 && (w2.size = y2, w2.originalSize = x2), p2.onfile(w2);
          }
          return "break";
        }
        if (h2) {
          if (134695760 == e3) return a2 = o2 += 12 + (-2 == h2 && 8), s2 = 3, p2.c = 0, "break";
          if (33639248 == e3) return a2 = o2 -= 4, s2 = 3, p2.c = 0, "break";
        }
      }, p2 = this; o2 < c2 - 4; ++o2) {
        if ("break" === d2()) break;
      }
      if (this.p = Db, h2 < 0) {
        var f2 = s2 ? l2.subarray(0, a2 - 12 - (-2 == h2 && 8) - (134695760 == ew(l2, a2 - 16) && 4)) : l2.subarray(0, o2);
        u2 ? u2.push(f2, !!s2) : this.k[+(2 == s2)].push(f2);
      }
      if (2 & s2) return this.push(l2.subarray(o2), e2);
      this.p = l2.subarray(o2);
    }
    if (e2) {
      if (this.c) throw "invalid zip file";
      this.p = null;
    }
  }, t6.prototype.register = function(t7) {
    this.o[t7.compression] = t7;
  }, t6;
})();
function u_(t6, e2) {
  if ("function" != typeof e2) throw "no callback";
  for (var i2 = [], n2 = function() {
    for (var t7 = 0; t7 < i2.length; ++t7) i2[t7]();
  }, r2 = {}, s2 = t6.length - 22; 101010256 != ew(t6, s2); --s2) if (!s2 || t6.length - s2 > 65558) return void e2("invalid zip file", null);
  var o2 = tw(t6, s2 + 8);
  o2 || e2(null, {});
  var a2 = o2, l2 = ew(t6, s2 + 16), c2 = 4294967295 == l2;
  if (c2) {
    if (s2 = ew(t6, s2 - 12), 101075792 != ew(t6, s2)) return void e2("invalid zip file", null);
    a2 = o2 = ew(t6, s2 + 32), l2 = ew(t6, s2 + 48);
  }
  for (var h2 = function(s3) {
    var a3 = Jw(t6, l2, c2), h3 = a3[0], u3 = a3[1], d2 = a3[2], p2 = a3[3], f2 = a3[4], m2 = a3[5], g2 = Zw(t6, m2);
    l2 = f2;
    var v2 = function(t7, i3) {
      t7 ? (n2(), e2(t7, null)) : (r2[p2] = i3, --o2 || e2(null, r2));
    };
    if (h3) if (8 == h3) {
      var y2 = t6.subarray(g2, g2 + u3);
      if (u3 < 32e4) try {
        v2(null, yw(y2, new Zx(d2)));
      } catch (t7) {
        v2(t7, null);
      }
      else i2.push(vw(y2, { size: d2 }, v2));
    } else v2("unknown compression type " + h3, null);
    else v2(null, _b(t6, g2, g2 + u3));
  }, u2 = 0; u2 < a2; ++u2) h2();
  return n2;
}
function d_(t6) {
  for (var e2 = {}, i2 = t6.length - 22; 101010256 != ew(t6, i2); --i2) if (!i2 || t6.length - i2 > 65558) throw "invalid zip file";
  var n2 = tw(t6, i2 + 8);
  if (!n2) return {};
  var r2 = ew(t6, i2 + 16), s2 = 4294967295 == r2;
  if (s2) {
    if (i2 = ew(t6, i2 - 12), 101075792 != ew(t6, i2)) throw "invalid zip file";
    n2 = ew(t6, i2 + 32), r2 = ew(t6, i2 + 48);
  }
  for (var o2 = 0; o2 < n2; ++o2) {
    var a2 = Jw(t6, r2, s2), l2 = a2[0], c2 = a2[1], h2 = a2[2], u2 = a2[3], d2 = a2[4], p2 = a2[5], f2 = Zw(t6, p2);
    if (r2 = d2, l2) {
      if (8 != l2) throw "unknown compression type " + l2;
      e2[u2] = yw(t6.subarray(f2, f2 + c2), new Zx(h2));
    } else e2[u2] = _b(t6, f2, f2 + c2);
  }
  return e2;
}
function p_(t6, e2, i2) {
  const n2 = i2.length - t6 - 1;
  if (e2 >= i2[n2]) return n2 - 1;
  if (e2 <= i2[t6]) return t6;
  let r2 = t6, s2 = n2, o2 = Math.floor((r2 + s2) / 2);
  for (; e2 < i2[o2] || e2 >= i2[o2 + 1]; ) e2 < i2[o2] ? s2 = o2 : r2 = o2, o2 = Math.floor((r2 + s2) / 2);
  return o2;
}
function f_(t6, e2, i2, n2) {
  const r2 = [], s2 = [], o2 = [];
  r2[0] = 1;
  for (let a2 = 1; a2 <= i2; ++a2) {
    s2[a2] = e2 - n2[t6 + 1 - a2], o2[a2] = n2[t6 + a2] - e2;
    let i3 = 0;
    for (let t7 = 0; t7 < a2; ++t7) {
      const e3 = o2[t7 + 1], n3 = s2[a2 - t7], l2 = r2[t7] / (e3 + n3);
      r2[t7] = i3 + e3 * l2, i3 = n3 * l2;
    }
    r2[a2] = i3;
  }
  return r2;
}
function m_(t6, e2) {
  let i2 = 1;
  for (let e3 = 2; e3 <= t6; ++e3) i2 *= e3;
  let n2 = 1;
  for (let t7 = 2; t7 <= e2; ++t7) n2 *= t7;
  for (let i3 = 2; i3 <= t6 - e2; ++i3) n2 *= i3;
  return i2 / n2;
}
function g_(t6, e2, i2, n2, r2) {
  const s2 = (function(t7, e3, i3, n3, r3) {
    const s3 = r3 < t7 ? r3 : t7, o2 = [], a2 = p_(t7, n3, e3), l2 = (function(t8, e4, i4, n4, r4) {
      const s4 = [];
      for (let t9 = 0; t9 <= i4; ++t9) s4[t9] = 0;
      const o3 = [];
      for (let t9 = 0; t9 <= n4; ++t9) o3[t9] = s4.slice(0);
      const a3 = [];
      for (let t9 = 0; t9 <= i4; ++t9) a3[t9] = s4.slice(0);
      a3[0][0] = 1;
      const l3 = s4.slice(0), c3 = s4.slice(0);
      for (let n5 = 1; n5 <= i4; ++n5) {
        l3[n5] = e4 - r4[t8 + 1 - n5], c3[n5] = r4[t8 + n5] - e4;
        let i5 = 0;
        for (let t9 = 0; t9 < n5; ++t9) {
          const e5 = c3[t9 + 1], r5 = l3[n5 - t9];
          a3[n5][t9] = e5 + r5;
          const s5 = a3[t9][n5 - 1] / a3[n5][t9];
          a3[t9][n5] = i5 + e5 * s5, i5 = r5 * s5;
        }
        a3[n5][n5] = i5;
      }
      for (let t9 = 0; t9 <= i4; ++t9) o3[0][t9] = a3[t9][i4];
      for (let t9 = 0; t9 <= i4; ++t9) {
        let e5 = 0, r5 = 1;
        const l4 = [];
        for (let t10 = 0; t10 <= i4; ++t10) l4[t10] = s4.slice(0);
        l4[0][0] = 1;
        for (let s5 = 1; s5 <= n4; ++s5) {
          let n5 = 0;
          const c4 = t9 - s5, h3 = i4 - s5;
          t9 >= s5 && (l4[r5][0] = l4[e5][0] / a3[h3 + 1][c4], n5 = l4[r5][0] * a3[c4][h3]);
          const u2 = t9 - 1 <= h3 ? s5 - 1 : i4 - t9;
          for (let t10 = c4 >= -1 ? 1 : -c4; t10 <= u2; ++t10) l4[r5][t10] = (l4[e5][t10] - l4[e5][t10 - 1]) / a3[h3 + 1][c4 + t10], n5 += l4[r5][t10] * a3[c4 + t10][h3];
          t9 <= h3 && (l4[r5][s5] = -l4[e5][s5 - 1] / a3[h3 + 1][t9], n5 += l4[r5][s5] * a3[t9][h3]), o3[s5][t9] = n5;
          const d2 = e5;
          e5 = r5, r5 = d2;
        }
      }
      let h2 = i4;
      for (let t9 = 1; t9 <= n4; ++t9) {
        for (let e5 = 0; e5 <= i4; ++e5) o3[t9][e5] *= h2;
        h2 *= i4 - t9;
      }
      return o3;
    })(a2, n3, t7, s3, e3), c2 = [];
    for (let t8 = 0; t8 < i3.length; ++t8) {
      const e4 = i3[t8].clone(), n4 = e4.w;
      e4.x *= n4, e4.y *= n4, e4.z *= n4, c2[t8] = e4;
    }
    for (let e4 = 0; e4 <= s3; ++e4) {
      const i4 = c2[a2 - t7].clone().multiplyScalar(l2[e4][0]);
      for (let n4 = 1; n4 <= t7; ++n4) i4.add(c2[a2 - t7 + n4].clone().multiplyScalar(l2[e4][n4]));
      o2[e4] = i4;
    }
    for (let t8 = s3 + 1; t8 <= r3 + 1; ++t8) o2[t8] = new sa(0, 0, 0);
    return o2;
  })(t6, e2, i2, n2, r2);
  return (function(t7) {
    const e3 = t7.length, i3 = [], n3 = [];
    for (let r4 = 0; r4 < e3; ++r4) {
      const e4 = t7[r4];
      i3[r4] = new pa(e4.x, e4.y, e4.z), n3[r4] = e4.w;
    }
    const r3 = [];
    for (let t8 = 0; t8 < e3; ++t8) {
      const e4 = i3[t8].clone();
      for (let i4 = 1; i4 <= t8; ++i4) e4.sub(r3[t8 - i4].clone().multiplyScalar(m_(t8, i4) * n3[i4]));
      r3[t8] = e4.divideScalar(n3[0]);
    }
    return r3;
  })(s2);
}
var v_ = class extends Cp {
  constructor(t6, e2, i2, n2, r2) {
    super(), this.degree = t6, this.knots = e2, this.controlPoints = [], this.startKnot = n2 || 0, this.endKnot = r2 || this.knots.length - 1;
    for (let t7 = 0; t7 < i2.length; ++t7) {
      const e3 = i2[t7];
      this.controlPoints[t7] = new sa(e3.x, e3.y, e3.z, e3.w);
    }
  }
  getPoint(t6, e2 = new pa()) {
    const i2 = e2, n2 = this.knots[this.startKnot] + t6 * (this.knots[this.endKnot] - this.knots[this.startKnot]), r2 = (function(t7, e3, i3, n3) {
      const r3 = p_(t7, n3, e3), s2 = f_(r3, n3, t7, e3), o2 = new sa(0, 0, 0, 0);
      for (let e4 = 0; e4 <= t7; ++e4) {
        const n4 = i3[r3 - t7 + e4], a2 = s2[e4], l2 = n4.w * a2;
        o2.x += n4.x * l2, o2.y += n4.y * l2, o2.z += n4.z * l2, o2.w += n4.w * a2;
      }
      return o2;
    })(this.degree, this.knots, this.controlPoints, n2);
    return 1 !== r2.w && r2.divideScalar(r2.w), i2.set(r2.x, r2.y, r2.z);
  }
  getTangent(t6, e2 = new pa()) {
    const i2 = e2, n2 = this.knots[0] + t6 * (this.knots[this.knots.length - 1] - this.knots[0]), r2 = g_(this.degree, this.knots, this.controlPoints, n2, 1);
    return i2.copy(r2[1]).normalize(), i2;
  }
};
var y_;
var x_;
var b_;
var w_ = class extends Im {
  constructor(t6) {
    super(t6);
  }
  load(t6, e2, i2, n2) {
    const r2 = this, s2 = "" === r2.path ? lg.extractUrlBase(t6) : r2.path, o2 = new zm(this.manager);
    o2.setPath(r2.path), o2.setResponseType("arraybuffer"), o2.setRequestHeader(r2.requestHeader), o2.setWithCredentials(r2.withCredentials), o2.load(t6, (function(i3) {
      try {
        e2(r2.parse(i3, s2));
      } catch (e3) {
        n2 ? n2(e3) : console.error(e3), r2.manager.itemError(t6);
      }
    }), i2, n2);
  }
  parse(t6, e2) {
    if ((function(t7) {
      const e3 = "Kaydara FBX Binary  \0";
      return t7.byteLength >= e3.length && e3 === B_(t7, 0, e3.length);
    })(t6)) y_ = new E_().parse(t6);
    else {
      const e3 = B_(t6);
      if (!(function(t7) {
        const e4 = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
        let i3 = 0;
        function n2(e5) {
          const n3 = t7[e5 - 1];
          return t7 = t7.slice(i3 + e5), i3++, n3;
        }
        for (let t8 = 0; t8 < e4.length; ++t8) {
          if (n2(1) === e4[t8]) return false;
        }
        return true;
      })(e3)) throw new Error("THREE.FBXLoader: Unknown format.");
      if (R_(e3) < 7e3) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + R_(e3));
      y_ = new T_().parse(e3);
    }
    const i2 = new Hm(this.manager).setPath(this.resourcePath || e2).setCrossOrigin(this.crossOrigin);
    return new __(i2, this.manager).parse(y_);
  }
};
var __ = class {
  constructor(t6, e2) {
    this.textureLoader = t6, this.manager = e2;
  }
  parse() {
    x_ = this.parseConnections();
    const t6 = this.parseImages(), e2 = this.parseTextures(t6), i2 = this.parseMaterials(e2), n2 = this.parseDeformers(), r2 = new S_().parse(n2);
    return this.parseScene(n2, r2, i2), b_;
  }
  parseConnections() {
    const t6 = /* @__PURE__ */ new Map();
    if ("Connections" in y_) {
      y_.Connections.connections.forEach((function(e2) {
        const i2 = e2[0], n2 = e2[1], r2 = e2[2];
        t6.has(i2) || t6.set(i2, { parents: [], children: [] });
        const s2 = { ID: n2, relationship: r2 };
        t6.get(i2).parents.push(s2), t6.has(n2) || t6.set(n2, { parents: [], children: [] });
        const o2 = { ID: i2, relationship: r2 };
        t6.get(n2).children.push(o2);
      }));
    }
    return t6;
  }
  parseImages() {
    const t6 = {}, e2 = {};
    if ("Video" in y_.Objects) {
      const i2 = y_.Objects.Video;
      for (const n2 in i2) {
        const r2 = i2[n2];
        if (t6[parseInt(n2)] = r2.RelativeFilename || r2.Filename, "Content" in r2) {
          const t7 = r2.Content instanceof ArrayBuffer && r2.Content.byteLength > 0, s2 = "string" == typeof r2.Content && "" !== r2.Content;
          if (t7 || s2) {
            const t8 = this.parseImage(i2[n2]);
            e2[r2.RelativeFilename || r2.Filename] = t8;
          }
        }
      }
    }
    for (const i2 in t6) {
      const n2 = t6[i2];
      void 0 !== e2[n2] ? t6[i2] = e2[n2] : t6[i2] = t6[i2].split("\\").pop();
    }
    return t6;
  }
  parseImage(t6) {
    const e2 = t6.Content, i2 = t6.RelativeFilename || t6.Filename, n2 = i2.slice(i2.lastIndexOf(".") + 1).toLowerCase();
    let r2;
    switch (n2) {
      case "bmp":
        r2 = "image/bmp";
        break;
      case "jpg":
      case "jpeg":
        r2 = "image/jpeg";
        break;
      case "png":
        r2 = "image/png";
        break;
      case "tif":
        r2 = "image/tiff";
        break;
      case "tga":
        null === this.manager.getHandler(".tga") && console.warn("FBXLoader: TGA loader not found, skipping ", i2), r2 = "image/tga";
        break;
      default:
        return void console.warn('FBXLoader: Image type "' + n2 + '" is not supported.');
    }
    if ("string" == typeof e2) return "data:" + r2 + ";base64," + e2;
    {
      const t7 = new Uint8Array(e2);
      return window.URL.createObjectURL(new Blob([t7], { type: r2 }));
    }
  }
  parseTextures(t6) {
    const e2 = /* @__PURE__ */ new Map();
    if ("Texture" in y_.Objects) {
      const i2 = y_.Objects.Texture;
      for (const n2 in i2) {
        const r2 = this.parseTexture(i2[n2], t6);
        e2.set(parseInt(n2), r2);
      }
    }
    return e2;
  }
  parseTexture(t6, e2) {
    const i2 = this.loadTexture(t6, e2);
    i2.ID = t6.id, i2.name = t6.attrName;
    const n2 = t6.WrapModeU, r2 = t6.WrapModeV, s2 = void 0 !== n2 ? n2.value : 0, o2 = void 0 !== r2 ? r2.value : 0;
    if (i2.wrapS = 0 === s2 ? gr : vr, i2.wrapT = 0 === o2 ? gr : vr, "Scaling" in t6) {
      const e3 = t6.Scaling.value;
      i2.repeat.x = e3[0], i2.repeat.y = e3[1];
    }
    if ("Translation" in t6) {
      const e3 = t6.Translation.value;
      i2.offset.x = e3[0], i2.offset.y = e3[1];
    }
    return i2;
  }
  loadTexture(t6, e2) {
    let i2;
    const n2 = this.textureLoader.path, r2 = x_.get(t6.id).children;
    let s2;
    void 0 !== r2 && r2.length > 0 && void 0 !== e2[r2[0].ID] && (i2 = e2[r2[0].ID], 0 !== i2.indexOf("blob:") && 0 !== i2.indexOf("data:") || this.textureLoader.setPath(void 0));
    const o2 = t6.FileName.slice(-3).toLowerCase();
    if ("tga" === o2) {
      const e3 = this.manager.getHandler(".tga");
      null === e3 ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", t6.RelativeFilename), s2 = new ra()) : (e3.setPath(this.textureLoader.path), s2 = e3.load(i2));
    } else "psd" === o2 ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", t6.RelativeFilename), s2 = new ra()) : s2 = this.textureLoader.load(i2);
    return this.textureLoader.setPath(n2), s2;
  }
  parseMaterials(t6) {
    const e2 = /* @__PURE__ */ new Map();
    if ("Material" in y_.Objects) {
      const i2 = y_.Objects.Material;
      for (const n2 in i2) {
        const r2 = this.parseMaterial(i2[n2], t6);
        null !== r2 && e2.set(parseInt(n2), r2);
      }
    }
    return e2;
  }
  parseMaterial(t6, e2) {
    const i2 = t6.id, n2 = t6.attrName;
    let r2 = t6.ShadingModel;
    if ("object" == typeof r2 && (r2 = r2.value), !x_.has(i2)) return null;
    const s2 = this.parseParameters(t6, e2, i2);
    let o2;
    switch (r2.toLowerCase()) {
      case "phong":
        o2 = new im();
        break;
      case "lambert":
        o2 = new sm();
        break;
      default:
        console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', r2), o2 = new im();
    }
    return o2.setValues(s2), o2.name = n2, o2;
  }
  parseParameters(t6, e2, i2) {
    const n2 = {};
    t6.BumpFactor && (n2.bumpScale = t6.BumpFactor.value), t6.Diffuse ? n2.color = new $o().fromArray(t6.Diffuse.value) : !t6.DiffuseColor || "Color" !== t6.DiffuseColor.type && "ColorRGB" !== t6.DiffuseColor.type || (n2.color = new $o().fromArray(t6.DiffuseColor.value)), t6.DisplacementFactor && (n2.displacementScale = t6.DisplacementFactor.value), t6.Emissive ? n2.emissive = new $o().fromArray(t6.Emissive.value) : !t6.EmissiveColor || "Color" !== t6.EmissiveColor.type && "ColorRGB" !== t6.EmissiveColor.type || (n2.emissive = new $o().fromArray(t6.EmissiveColor.value)), t6.EmissiveFactor && (n2.emissiveIntensity = parseFloat(t6.EmissiveFactor.value)), t6.Opacity && (n2.opacity = parseFloat(t6.Opacity.value)), n2.opacity < 1 && (n2.transparent = true), t6.ReflectionFactor && (n2.reflectivity = t6.ReflectionFactor.value), t6.Shininess && (n2.shininess = t6.Shininess.value), t6.Specular ? n2.specular = new $o().fromArray(t6.Specular.value) : t6.SpecularColor && "Color" === t6.SpecularColor.type && (n2.specular = new $o().fromArray(t6.SpecularColor.value));
    const r2 = this;
    return x_.get(i2).children.forEach((function(t7) {
      const i3 = t7.relationship;
      switch (i3) {
        case "Bump":
          n2.bumpMap = r2.getTexture(e2, t7.ID);
          break;
        case "Maya|TEX_ao_map":
          n2.aoMap = r2.getTexture(e2, t7.ID);
          break;
        case "DiffuseColor":
        case "Maya|TEX_color_map":
          n2.map = r2.getTexture(e2, t7.ID), void 0 !== n2.map && (n2.map.encoding = ks);
          break;
        case "DisplacementColor":
          n2.displacementMap = r2.getTexture(e2, t7.ID);
          break;
        case "EmissiveColor":
          n2.emissiveMap = r2.getTexture(e2, t7.ID), void 0 !== n2.emissiveMap && (n2.emissiveMap.encoding = ks);
          break;
        case "NormalMap":
        case "Maya|TEX_normal_map":
          n2.normalMap = r2.getTexture(e2, t7.ID);
          break;
        case "ReflectionColor":
          n2.envMap = r2.getTexture(e2, t7.ID), void 0 !== n2.envMap && (n2.envMap.mapping = pr, n2.envMap.encoding = ks);
          break;
        case "SpecularColor":
          n2.specularMap = r2.getTexture(e2, t7.ID), void 0 !== n2.specularMap && (n2.specularMap.encoding = ks);
          break;
        case "TransparentColor":
        case "TransparencyFactor":
          n2.alphaMap = r2.getTexture(e2, t7.ID), n2.transparent = true;
          break;
        default:
          console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", i3);
      }
    })), n2;
  }
  getTexture(t6, e2) {
    return "LayeredTexture" in y_.Objects && e2 in y_.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), e2 = x_.get(e2).children[0].ID), t6.get(e2);
  }
  parseDeformers() {
    const t6 = {}, e2 = {};
    if ("Deformer" in y_.Objects) {
      const i2 = y_.Objects.Deformer;
      for (const n2 in i2) {
        const r2 = i2[n2], s2 = x_.get(parseInt(n2));
        if ("Skin" === r2.attrType) {
          const e3 = this.parseSkeleton(s2, i2);
          e3.ID = n2, s2.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), e3.geometryID = s2.parents[0].ID, t6[n2] = e3;
        } else if ("BlendShape" === r2.attrType) {
          const t7 = { id: n2 };
          t7.rawTargets = this.parseMorphTargets(s2, i2), t7.id = n2, s2.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), e2[n2] = t7;
        }
      }
    }
    return { skeletons: t6, morphTargets: e2 };
  }
  parseSkeleton(t6, e2) {
    const i2 = [];
    return t6.children.forEach((function(t7) {
      const n2 = e2[t7.ID];
      if ("Cluster" !== n2.attrType) return;
      const r2 = { ID: t7.ID, indices: [], weights: [], transformLink: new Ga().fromArray(n2.TransformLink.a) };
      "Indexes" in n2 && (r2.indices = n2.Indexes.a, r2.weights = n2.Weights.a), i2.push(r2);
    })), { rawBones: i2, bones: [] };
  }
  parseMorphTargets(t6, e2) {
    const i2 = [];
    for (let n2 = 0; n2 < t6.children.length; n2++) {
      const r2 = t6.children[n2], s2 = e2[r2.ID], o2 = { name: s2.attrName, initialWeight: s2.DeformPercent, id: s2.id, fullWeights: s2.FullWeights.a };
      if ("BlendShapeChannel" !== s2.attrType) return;
      o2.geoID = x_.get(parseInt(r2.ID)).children.filter((function(t7) {
        return void 0 === t7.relationship;
      }))[0].ID, i2.push(o2);
    }
    return i2;
  }
  parseScene(t6, e2, i2) {
    b_ = new cd();
    const n2 = this.parseModels(t6.skeletons, e2, i2), r2 = y_.Objects.Model, s2 = this;
    n2.forEach((function(t7) {
      const e3 = r2[t7.ID];
      s2.setLookAtProperties(t7, e3);
      x_.get(t7.ID).parents.forEach((function(e4) {
        const i3 = n2.get(e4.ID);
        void 0 !== i3 && i3.add(t7);
      })), null === t7.parent && b_.add(t7);
    })), this.bindSkeleton(t6.skeletons, e2, n2), this.createAmbientLight(), b_.traverse((function(t7) {
      if (t7.userData.transformData) {
        t7.parent && (t7.userData.transformData.parentMatrix = t7.parent.matrix, t7.userData.transformData.parentMatrixWorld = t7.parent.matrixWorld);
        const e3 = z_(t7.userData.transformData);
        t7.applyMatrix4(e3), t7.updateWorldMatrix();
      }
    }));
    const o2 = new M_().parse();
    1 === b_.children.length && b_.children[0].isGroup && (b_.children[0].animations = o2, b_ = b_.children[0]), b_.animations = o2;
  }
  parseModels(t6, e2, i2) {
    const n2 = /* @__PURE__ */ new Map(), r2 = y_.Objects.Model;
    for (const s2 in r2) {
      const o2 = parseInt(s2), a2 = r2[s2], l2 = x_.get(o2);
      let c2 = this.buildSkeleton(l2, t6, o2, a2.attrName);
      if (!c2) {
        switch (a2.attrType) {
          case "Camera":
            c2 = this.createCamera(l2);
            break;
          case "Light":
            c2 = this.createLight(l2);
            break;
          case "Mesh":
            c2 = this.createMesh(l2, e2, i2);
            break;
          case "NurbsCurve":
            c2 = this.createCurve(l2, e2);
            break;
          case "LimbNode":
          case "Root":
            c2 = new Zd();
            break;
          default:
            c2 = new cd();
        }
        c2.name = a2.attrName ? qg.sanitizeNodeName(a2.attrName) : "", c2.ID = o2;
      }
      this.getTransformData(c2, a2), n2.set(o2, c2);
    }
    return n2;
  }
  buildSkeleton(t6, e2, i2, n2) {
    let r2 = null;
    return t6.parents.forEach((function(t7) {
      for (const s2 in e2) {
        const o2 = e2[s2];
        o2.rawBones.forEach((function(e3, s3) {
          if (e3.ID === t7.ID) {
            const t8 = r2;
            r2 = new Zd(), r2.matrixWorld.copy(e3.transformLink), r2.name = n2 ? qg.sanitizeNodeName(n2) : "", r2.ID = i2, o2.bones[s3] = r2, null !== t8 && r2.add(t8);
          }
        }));
      }
    })), r2;
  }
  createCamera(t6) {
    let e2, i2;
    if (t6.children.forEach((function(t7) {
      const e3 = y_.Objects.NodeAttribute[t7.ID];
      void 0 !== e3 && (i2 = e3);
    })), void 0 === i2) e2 = new ml();
    else {
      let t7 = 0;
      void 0 !== i2.CameraProjectionType && 1 === i2.CameraProjectionType.value && (t7 = 1);
      let n2 = 1;
      void 0 !== i2.NearPlane && (n2 = i2.NearPlane.value / 1e3);
      let r2 = 1e3;
      void 0 !== i2.FarPlane && (r2 = i2.FarPlane.value / 1e3);
      let s2 = window.innerWidth, o2 = window.innerHeight;
      void 0 !== i2.AspectWidth && void 0 !== i2.AspectHeight && (s2 = i2.AspectWidth.value, o2 = i2.AspectHeight.value);
      const a2 = s2 / o2;
      let l2 = 45;
      void 0 !== i2.FieldOfView && (l2 = i2.FieldOfView.value);
      const c2 = i2.FocalLength ? i2.FocalLength.value : null;
      switch (t7) {
        case 0:
          e2 = new _c(l2, a2, n2, r2), null !== c2 && e2.setFocalLength(c2);
          break;
        case 1:
          e2 = new qc(-s2 / 2, s2 / 2, o2 / 2, -o2 / 2, n2, r2);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown camera type " + t7 + "."), e2 = new ml();
      }
    }
    return e2;
  }
  createLight(t6) {
    let e2, i2;
    if (t6.children.forEach((function(t7) {
      const e3 = y_.Objects.NodeAttribute[t7.ID];
      void 0 !== e3 && (i2 = e3);
    })), void 0 === i2) e2 = new ml();
    else {
      let t7;
      t7 = void 0 === i2.LightType ? 0 : i2.LightType.value;
      let n2 = 16777215;
      void 0 !== i2.Color && (n2 = new $o().fromArray(i2.Color.value));
      let r2 = void 0 === i2.Intensity ? 1 : i2.Intensity.value / 100;
      void 0 !== i2.CastLightOnObject && 0 === i2.CastLightOnObject.value && (r2 = 0);
      let s2 = 0;
      void 0 !== i2.FarAttenuationEnd && (s2 = void 0 !== i2.EnableFarAttenuation && 0 === i2.EnableFarAttenuation.value ? 0 : i2.FarAttenuationEnd.value);
      const o2 = 1;
      switch (t7) {
        case 0:
          e2 = new tg(n2, r2, s2, o2);
          break;
        case 1:
          e2 = new ig(n2, r2);
          break;
        case 2:
          let t8 = Math.PI / 3;
          void 0 !== i2.InnerAngle && (t8 = zo.degToRad(i2.InnerAngle.value));
          let a2 = 0;
          void 0 !== i2.OuterAngle && (a2 = zo.degToRad(i2.OuterAngle.value), a2 = Math.max(a2, 1)), e2 = new Zm(n2, r2, s2, t8, a2, o2);
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown light type " + i2.LightType.value + ", defaulting to a PointLight."), e2 = new tg(n2, r2);
      }
      void 0 !== i2.CastShadows && 1 === i2.CastShadows.value && (e2.castShadow = true);
    }
    return e2;
  }
  createMesh(t6, e2, i2) {
    let n2, r2 = null, s2 = null;
    const o2 = [];
    return t6.children.forEach((function(t7) {
      e2.has(t7.ID) && (r2 = e2.get(t7.ID)), i2.has(t7.ID) && o2.push(i2.get(t7.ID));
    })), o2.length > 1 ? s2 = o2 : o2.length > 0 ? s2 = o2[0] : (s2 = new im({ color: 13421772 }), o2.push(s2)), "color" in r2.attributes && o2.forEach((function(t7) {
      t7.vertexColors = true;
    })), r2.FBX_Deformer ? (n2 = new Yd(r2, s2), n2.normalizeSkinWeights()) : n2 = new fc(r2, s2), n2;
  }
  createCurve(t6, e2) {
    const i2 = t6.children.reduce((function(t7, i3) {
      return e2.has(i3.ID) && (t7 = e2.get(i3.ID)), t7;
    }), null), n2 = new op({ color: 3342591, linewidth: 1 });
    return new dp(i2, n2);
  }
  getTransformData(t6, e2) {
    const i2 = {};
    "InheritType" in e2 && (i2.inheritType = parseInt(e2.InheritType.value)), i2.eulerOrder = "RotationOrder" in e2 ? F_(e2.RotationOrder.value) : "ZYX", "Lcl_Translation" in e2 && (i2.translation = e2.Lcl_Translation.value), "PreRotation" in e2 && (i2.preRotation = e2.PreRotation.value), "Lcl_Rotation" in e2 && (i2.rotation = e2.Lcl_Rotation.value), "PostRotation" in e2 && (i2.postRotation = e2.PostRotation.value), "Lcl_Scaling" in e2 && (i2.scale = e2.Lcl_Scaling.value), "ScalingOffset" in e2 && (i2.scalingOffset = e2.ScalingOffset.value), "ScalingPivot" in e2 && (i2.scalingPivot = e2.ScalingPivot.value), "RotationOffset" in e2 && (i2.rotationOffset = e2.RotationOffset.value), "RotationPivot" in e2 && (i2.rotationPivot = e2.RotationPivot.value), t6.userData.transformData = i2;
  }
  setLookAtProperties(t6, e2) {
    if ("LookAtProperty" in e2) {
      x_.get(t6.ID).children.forEach((function(e3) {
        if ("LookAtProperty" === e3.relationship) {
          const i2 = y_.Objects.Model[e3.ID];
          if ("Lcl_Translation" in i2) {
            const e4 = i2.Lcl_Translation.value;
            void 0 !== t6.target ? (t6.target.position.fromArray(e4), b_.add(t6.target)) : t6.lookAt(new pa().fromArray(e4));
          }
        }
      }));
    }
  }
  bindSkeleton(t6, e2, i2) {
    const n2 = this.parsePoseNodes();
    for (const r2 in t6) {
      const s2 = t6[r2];
      x_.get(parseInt(s2.ID)).parents.forEach((function(t7) {
        if (e2.has(t7.ID)) {
          const e3 = t7.ID;
          x_.get(e3).parents.forEach((function(t8) {
            if (i2.has(t8.ID)) {
              i2.get(t8.ID).bind(new Qd(s2.bones), n2[t8.ID]);
            }
          }));
        }
      }));
    }
  }
  parsePoseNodes() {
    const t6 = {};
    if ("Pose" in y_.Objects) {
      const e2 = y_.Objects.Pose;
      for (const i2 in e2) if ("BindPose" === e2[i2].attrType && e2[i2].NbPoseNodes > 0) {
        const n2 = e2[i2].PoseNode;
        Array.isArray(n2) ? n2.forEach((function(e3) {
          t6[e3.Node] = new Ga().fromArray(e3.Matrix.a);
        })) : t6[n2.Node] = new Ga().fromArray(n2.Matrix.a);
      }
    }
    return t6;
  }
  createAmbientLight() {
    if ("GlobalSettings" in y_ && "AmbientColor" in y_.GlobalSettings) {
      const t6 = y_.GlobalSettings.AmbientColor.value, e2 = t6[0], i2 = t6[1], n2 = t6[2];
      if (0 !== e2 || 0 !== i2 || 0 !== n2) {
        const t7 = new $o(e2, i2, n2);
        b_.add(new ng(t7, 1));
      }
    }
  }
};
var S_ = class {
  parse(t6) {
    const e2 = /* @__PURE__ */ new Map();
    if ("Geometry" in y_.Objects) {
      const i2 = y_.Objects.Geometry;
      for (const n2 in i2) {
        const r2 = x_.get(parseInt(n2)), s2 = this.parseGeometry(r2, i2[n2], t6);
        e2.set(parseInt(n2), s2);
      }
    }
    return e2;
  }
  parseGeometry(t6, e2, i2) {
    switch (e2.attrType) {
      case "Mesh":
        return this.parseMeshGeometry(t6, e2, i2);
      case "NurbsCurve":
        return this.parseNurbsGeometry(e2);
    }
  }
  parseMeshGeometry(t6, e2, i2) {
    const n2 = i2.skeletons, r2 = [], s2 = t6.parents.map((function(t7) {
      return y_.Objects.Model[t7.ID];
    }));
    if (0 === s2.length) return;
    const o2 = t6.children.reduce((function(t7, e3) {
      return void 0 !== n2[e3.ID] && (t7 = n2[e3.ID]), t7;
    }), null);
    t6.children.forEach((function(t7) {
      void 0 !== i2.morphTargets[t7.ID] && r2.push(i2.morphTargets[t7.ID]);
    }));
    const a2 = s2[0], l2 = {};
    "RotationOrder" in a2 && (l2.eulerOrder = F_(a2.RotationOrder.value)), "InheritType" in a2 && (l2.inheritType = parseInt(a2.InheritType.value)), "GeometricTranslation" in a2 && (l2.translation = a2.GeometricTranslation.value), "GeometricRotation" in a2 && (l2.rotation = a2.GeometricRotation.value), "GeometricScaling" in a2 && (l2.scale = a2.GeometricScaling.value);
    const c2 = z_(l2);
    return this.genGeometry(e2, o2, r2, c2);
  }
  genGeometry(t6, e2, i2, n2) {
    const r2 = new Jl();
    t6.attrName && (r2.name = t6.attrName);
    const s2 = this.parseGeoNode(t6, e2), o2 = this.genBuffers(s2), a2 = new Hl(o2.vertex, 3);
    if (a2.applyMatrix4(n2), r2.setAttribute("position", a2), o2.colors.length > 0 && r2.setAttribute("color", new Hl(o2.colors, 3)), e2 && (r2.setAttribute("skinIndex", new Nl(o2.weightsIndices, 4)), r2.setAttribute("skinWeight", new Hl(o2.vertexWeights, 4)), r2.FBX_Deformer = e2), o2.normal.length > 0) {
      const t7 = new No().getNormalMatrix(n2), e3 = new Hl(o2.normal, 3);
      e3.applyNormalMatrix(t7), r2.setAttribute("normal", e3);
    }
    if (o2.uvs.forEach((function(t7, e3) {
      let i3 = "uv" + (e3 + 1).toString();
      0 === e3 && (i3 = "uv"), r2.setAttribute(i3, new Hl(o2.uvs[e3], 2));
    })), s2.material && "AllSame" !== s2.material.mappingType) {
      let t7 = o2.materialIndex[0], e3 = 0;
      if (o2.materialIndex.forEach((function(i3, n3) {
        i3 !== t7 && (r2.addGroup(e3, n3 - e3, t7), t7 = i3, e3 = n3);
      })), r2.groups.length > 0) {
        const e4 = r2.groups[r2.groups.length - 1], i3 = e4.start + e4.count;
        i3 !== o2.materialIndex.length && r2.addGroup(i3, o2.materialIndex.length - i3, t7);
      }
      0 === r2.groups.length && r2.addGroup(0, o2.materialIndex.length, o2.materialIndex[0]);
    }
    return this.addMorphTargets(r2, t6, i2, n2), r2;
  }
  parseGeoNode(t6, e2) {
    const i2 = {};
    if (i2.vertexPositions = void 0 !== t6.Vertices ? t6.Vertices.a : [], i2.vertexIndices = void 0 !== t6.PolygonVertexIndex ? t6.PolygonVertexIndex.a : [], t6.LayerElementColor && (i2.color = this.parseVertexColors(t6.LayerElementColor[0])), t6.LayerElementMaterial && (i2.material = this.parseMaterialIndices(t6.LayerElementMaterial[0])), t6.LayerElementNormal && (i2.normal = this.parseNormals(t6.LayerElementNormal[0])), t6.LayerElementUV) {
      i2.uv = [];
      let e3 = 0;
      for (; t6.LayerElementUV[e3]; ) t6.LayerElementUV[e3].UV && i2.uv.push(this.parseUVs(t6.LayerElementUV[e3])), e3++;
    }
    return i2.weightTable = {}, null !== e2 && (i2.skeleton = e2, e2.rawBones.forEach((function(t7, e3) {
      t7.indices.forEach((function(n2, r2) {
        void 0 === i2.weightTable[n2] && (i2.weightTable[n2] = []), i2.weightTable[n2].push({ id: e3, weight: t7.weights[r2] });
      }));
    }))), i2;
  }
  genBuffers(t6) {
    const e2 = { vertex: [], normal: [], colors: [], uvs: [], materialIndex: [], vertexWeights: [], weightsIndices: [] };
    let i2 = 0, n2 = 0, r2 = false, s2 = [], o2 = [], a2 = [], l2 = [], c2 = [], h2 = [];
    const u2 = this;
    return t6.vertexIndices.forEach((function(d2, p2) {
      let f2, m2 = false;
      d2 < 0 && (d2 = ~d2, m2 = true);
      let g2 = [], v2 = [];
      if (s2.push(3 * d2, 3 * d2 + 1, 3 * d2 + 2), t6.color) {
        const e3 = I_(p2, i2, d2, t6.color);
        a2.push(e3[0], e3[1], e3[2]);
      }
      if (t6.skeleton) {
        if (void 0 !== t6.weightTable[d2] && t6.weightTable[d2].forEach((function(t7) {
          v2.push(t7.weight), g2.push(t7.id);
        })), v2.length > 4) {
          r2 || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), r2 = true);
          const t7 = [0, 0, 0, 0], e3 = [0, 0, 0, 0];
          v2.forEach((function(i3, n3) {
            let r3 = i3, s3 = g2[n3];
            e3.forEach((function(e4, i4, n4) {
              if (r3 > e4) {
                n4[i4] = r3, r3 = e4;
                const o3 = t7[i4];
                t7[i4] = s3, s3 = o3;
              }
            }));
          })), g2 = t7, v2 = e3;
        }
        for (; v2.length < 4; ) v2.push(0), g2.push(0);
        for (let t7 = 0; t7 < 4; ++t7) c2.push(v2[t7]), h2.push(g2[t7]);
      }
      if (t6.normal) {
        const e3 = I_(p2, i2, d2, t6.normal);
        o2.push(e3[0], e3[1], e3[2]);
      }
      t6.material && "AllSame" !== t6.material.mappingType && (f2 = I_(p2, i2, d2, t6.material)[0]), t6.uv && t6.uv.forEach((function(t7, e3) {
        const n3 = I_(p2, i2, d2, t7);
        void 0 === l2[e3] && (l2[e3] = []), l2[e3].push(n3[0]), l2[e3].push(n3[1]);
      })), n2++, m2 && (u2.genFace(e2, t6, s2, f2, o2, a2, l2, c2, h2, n2), i2++, n2 = 0, s2 = [], o2 = [], a2 = [], l2 = [], c2 = [], h2 = []);
    })), e2;
  }
  genFace(t6, e2, i2, n2, r2, s2, o2, a2, l2, c2) {
    for (let h2 = 2; h2 < c2; h2++) t6.vertex.push(e2.vertexPositions[i2[0]]), t6.vertex.push(e2.vertexPositions[i2[1]]), t6.vertex.push(e2.vertexPositions[i2[2]]), t6.vertex.push(e2.vertexPositions[i2[3 * (h2 - 1)]]), t6.vertex.push(e2.vertexPositions[i2[3 * (h2 - 1) + 1]]), t6.vertex.push(e2.vertexPositions[i2[3 * (h2 - 1) + 2]]), t6.vertex.push(e2.vertexPositions[i2[3 * h2]]), t6.vertex.push(e2.vertexPositions[i2[3 * h2 + 1]]), t6.vertex.push(e2.vertexPositions[i2[3 * h2 + 2]]), e2.skeleton && (t6.vertexWeights.push(a2[0]), t6.vertexWeights.push(a2[1]), t6.vertexWeights.push(a2[2]), t6.vertexWeights.push(a2[3]), t6.vertexWeights.push(a2[4 * (h2 - 1)]), t6.vertexWeights.push(a2[4 * (h2 - 1) + 1]), t6.vertexWeights.push(a2[4 * (h2 - 1) + 2]), t6.vertexWeights.push(a2[4 * (h2 - 1) + 3]), t6.vertexWeights.push(a2[4 * h2]), t6.vertexWeights.push(a2[4 * h2 + 1]), t6.vertexWeights.push(a2[4 * h2 + 2]), t6.vertexWeights.push(a2[4 * h2 + 3]), t6.weightsIndices.push(l2[0]), t6.weightsIndices.push(l2[1]), t6.weightsIndices.push(l2[2]), t6.weightsIndices.push(l2[3]), t6.weightsIndices.push(l2[4 * (h2 - 1)]), t6.weightsIndices.push(l2[4 * (h2 - 1) + 1]), t6.weightsIndices.push(l2[4 * (h2 - 1) + 2]), t6.weightsIndices.push(l2[4 * (h2 - 1) + 3]), t6.weightsIndices.push(l2[4 * h2]), t6.weightsIndices.push(l2[4 * h2 + 1]), t6.weightsIndices.push(l2[4 * h2 + 2]), t6.weightsIndices.push(l2[4 * h2 + 3])), e2.color && (t6.colors.push(s2[0]), t6.colors.push(s2[1]), t6.colors.push(s2[2]), t6.colors.push(s2[3 * (h2 - 1)]), t6.colors.push(s2[3 * (h2 - 1) + 1]), t6.colors.push(s2[3 * (h2 - 1) + 2]), t6.colors.push(s2[3 * h2]), t6.colors.push(s2[3 * h2 + 1]), t6.colors.push(s2[3 * h2 + 2])), e2.material && "AllSame" !== e2.material.mappingType && (t6.materialIndex.push(n2), t6.materialIndex.push(n2), t6.materialIndex.push(n2)), e2.normal && (t6.normal.push(r2[0]), t6.normal.push(r2[1]), t6.normal.push(r2[2]), t6.normal.push(r2[3 * (h2 - 1)]), t6.normal.push(r2[3 * (h2 - 1) + 1]), t6.normal.push(r2[3 * (h2 - 1) + 2]), t6.normal.push(r2[3 * h2]), t6.normal.push(r2[3 * h2 + 1]), t6.normal.push(r2[3 * h2 + 2])), e2.uv && e2.uv.forEach((function(e3, i3) {
      void 0 === t6.uvs[i3] && (t6.uvs[i3] = []), t6.uvs[i3].push(o2[i3][0]), t6.uvs[i3].push(o2[i3][1]), t6.uvs[i3].push(o2[i3][2 * (h2 - 1)]), t6.uvs[i3].push(o2[i3][2 * (h2 - 1) + 1]), t6.uvs[i3].push(o2[i3][2 * h2]), t6.uvs[i3].push(o2[i3][2 * h2 + 1]);
    }));
  }
  addMorphTargets(t6, e2, i2, n2) {
    if (0 === i2.length) return;
    t6.morphTargetsRelative = true, t6.morphAttributes.position = [];
    const r2 = this;
    i2.forEach((function(i3) {
      i3.rawTargets.forEach((function(i4) {
        const s2 = y_.Objects.Geometry[i4.geoID];
        void 0 !== s2 && r2.genMorphGeometry(t6, e2, s2, n2, i4.name);
      }));
    }));
  }
  genMorphGeometry(t6, e2, i2, n2, r2) {
    const s2 = void 0 !== e2.PolygonVertexIndex ? e2.PolygonVertexIndex.a : [], o2 = void 0 !== i2.Vertices ? i2.Vertices.a : [], a2 = void 0 !== i2.Indexes ? i2.Indexes.a : [], l2 = 3 * t6.attributes.position.count, c2 = new Float32Array(l2);
    for (let t7 = 0; t7 < a2.length; t7++) {
      const e3 = 3 * a2[t7];
      c2[e3] = o2[3 * t7], c2[e3 + 1] = o2[3 * t7 + 1], c2[e3 + 2] = o2[3 * t7 + 2];
    }
    const h2 = { vertexIndices: s2, vertexPositions: c2 }, u2 = this.genBuffers(h2), d2 = new Hl(u2.vertex, 3);
    d2.name = r2 || i2.attrName, d2.applyMatrix4(n2), t6.morphAttributes.position.push(d2);
  }
  parseNormals(t6) {
    const e2 = t6.MappingInformationType, i2 = t6.ReferenceInformationType, n2 = t6.Normals.a;
    let r2 = [];
    return "IndexToDirect" === i2 && ("NormalIndex" in t6 ? r2 = t6.NormalIndex.a : "NormalsIndex" in t6 && (r2 = t6.NormalsIndex.a)), { dataSize: 3, buffer: n2, indices: r2, mappingType: e2, referenceType: i2 };
  }
  parseUVs(t6) {
    const e2 = t6.MappingInformationType, i2 = t6.ReferenceInformationType, n2 = t6.UV.a;
    let r2 = [];
    return "IndexToDirect" === i2 && (r2 = t6.UVIndex.a), { dataSize: 2, buffer: n2, indices: r2, mappingType: e2, referenceType: i2 };
  }
  parseVertexColors(t6) {
    const e2 = t6.MappingInformationType, i2 = t6.ReferenceInformationType, n2 = t6.Colors.a;
    let r2 = [];
    return "IndexToDirect" === i2 && (r2 = t6.ColorIndex.a), { dataSize: 4, buffer: n2, indices: r2, mappingType: e2, referenceType: i2 };
  }
  parseMaterialIndices(t6) {
    const e2 = t6.MappingInformationType, i2 = t6.ReferenceInformationType;
    if ("NoMappingInformation" === e2) return { dataSize: 1, buffer: [0], indices: [0], mappingType: "AllSame", referenceType: i2 };
    const n2 = t6.Materials.a, r2 = [];
    for (let t7 = 0; t7 < n2.length; ++t7) r2.push(t7);
    return { dataSize: 1, buffer: n2, indices: r2, mappingType: e2, referenceType: i2 };
  }
  parseNurbsGeometry(t6) {
    if (void 0 === v_) return console.error("THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."), new Jl();
    const e2 = parseInt(t6.Order);
    if (isNaN(e2)) return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", t6.Order, t6.id), new Jl();
    const i2 = e2 - 1, n2 = t6.KnotVector.a, r2 = [], s2 = t6.Points.a;
    for (let t7 = 0, e3 = s2.length; t7 < e3; t7 += 4) r2.push(new sa().fromArray(s2, t7));
    let o2, a2;
    if ("Closed" === t6.Form) r2.push(r2[0]);
    else if ("Periodic" === t6.Form) {
      o2 = i2, a2 = n2.length - 1 - o2;
      for (let t7 = 0; t7 < i2; ++t7) r2.push(r2[t7]);
    }
    const l2 = new v_(i2, n2, r2, o2, a2).getPoints(12 * r2.length);
    return new Jl().setFromPoints(l2);
  }
};
var M_ = class {
  parse() {
    const t6 = [], e2 = this.parseClips();
    if (void 0 !== e2) for (const i2 in e2) {
      const n2 = e2[i2], r2 = this.addClip(n2);
      t6.push(r2);
    }
    return t6;
  }
  parseClips() {
    if (void 0 === y_.Objects.AnimationCurve) return;
    const t6 = this.parseAnimationCurveNodes();
    this.parseAnimationCurves(t6);
    const e2 = this.parseAnimationLayers(t6);
    return this.parseAnimStacks(e2);
  }
  parseAnimationCurveNodes() {
    const t6 = y_.Objects.AnimationCurveNode, e2 = /* @__PURE__ */ new Map();
    for (const i2 in t6) {
      const n2 = t6[i2];
      if (null !== n2.attrName.match(/S|R|T|DeformPercent/)) {
        const t7 = { id: n2.id, attr: n2.attrName, curves: {} };
        e2.set(t7.id, t7);
      }
    }
    return e2;
  }
  parseAnimationCurves(t6) {
    const e2 = y_.Objects.AnimationCurve;
    for (const i2 in e2) {
      const n2 = { id: e2[i2].id, times: e2[i2].KeyTime.a.map(P_), values: e2[i2].KeyValueFloat.a }, r2 = x_.get(n2.id);
      if (void 0 !== r2) {
        const e3 = r2.parents[0].ID, i3 = r2.parents[0].relationship;
        i3.match(/X/) ? t6.get(e3).curves.x = n2 : i3.match(/Y/) ? t6.get(e3).curves.y = n2 : i3.match(/Z/) ? t6.get(e3).curves.z = n2 : i3.match(/d|DeformPercent/) && t6.has(e3) && (t6.get(e3).curves.morph = n2);
      }
    }
  }
  parseAnimationLayers(t6) {
    const e2 = y_.Objects.AnimationLayer, i2 = /* @__PURE__ */ new Map();
    for (const n2 in e2) {
      const e3 = [], r2 = x_.get(parseInt(n2));
      if (void 0 !== r2) {
        r2.children.forEach((function(i3, n3) {
          if (t6.has(i3.ID)) {
            const r3 = t6.get(i3.ID);
            if (void 0 !== r3.curves.x || void 0 !== r3.curves.y || void 0 !== r3.curves.z) {
              if (void 0 === e3[n3]) {
                const t7 = x_.get(i3.ID).parents.filter((function(t8) {
                  return void 0 !== t8.relationship;
                }))[0].ID;
                if (void 0 !== t7) {
                  const r4 = y_.Objects.Model[t7.toString()];
                  if (void 0 === r4) return void console.warn("THREE.FBXLoader: Encountered a unused curve.", i3);
                  const s2 = { modelName: r4.attrName ? qg.sanitizeNodeName(r4.attrName) : "", ID: r4.id, initialPosition: [0, 0, 0], initialRotation: [0, 0, 0], initialScale: [1, 1, 1] };
                  b_.traverse((function(t8) {
                    t8.ID === r4.id && (s2.transform = t8.matrix, t8.userData.transformData && (s2.eulerOrder = t8.userData.transformData.eulerOrder));
                  })), s2.transform || (s2.transform = new Ga()), "PreRotation" in r4 && (s2.preRotation = r4.PreRotation.value), "PostRotation" in r4 && (s2.postRotation = r4.PostRotation.value), e3[n3] = s2;
                }
              }
              e3[n3] && (e3[n3][r3.attr] = r3);
            } else if (void 0 !== r3.curves.morph) {
              if (void 0 === e3[n3]) {
                const t7 = x_.get(i3.ID).parents.filter((function(t8) {
                  return void 0 !== t8.relationship;
                }))[0].ID, r4 = x_.get(t7).parents[0].ID, s2 = x_.get(r4).parents[0].ID, o2 = x_.get(s2).parents[0].ID, a2 = y_.Objects.Model[o2], l2 = { modelName: a2.attrName ? qg.sanitizeNodeName(a2.attrName) : "", morphName: y_.Objects.Deformer[t7].attrName };
                e3[n3] = l2;
              }
              e3[n3][r3.attr] = r3;
            }
          }
        })), i2.set(parseInt(n2), e3);
      }
    }
    return i2;
  }
  parseAnimStacks(t6) {
    const e2 = y_.Objects.AnimationStack, i2 = {};
    for (const n2 in e2) {
      const r2 = x_.get(parseInt(n2)).children;
      r2.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
      const s2 = t6.get(r2[0].ID);
      i2[n2] = { name: e2[n2].attrName, layer: s2 };
    }
    return i2;
  }
  addClip(t6) {
    let e2 = [];
    const i2 = this;
    return t6.layer.forEach((function(t7) {
      e2 = e2.concat(i2.generateTracks(t7));
    })), new Am(t6.name, -1, e2);
  }
  generateTracks(t6) {
    const e2 = [];
    let i2 = new pa(), n2 = new da(), r2 = new pa();
    if (t6.transform && t6.transform.decompose(i2, n2, r2), i2 = i2.toArray(), n2 = new tl().setFromQuaternion(n2, t6.eulerOrder).toArray(), r2 = r2.toArray(), void 0 !== t6.T && Object.keys(t6.T.curves).length > 0) {
      const n3 = this.generateVectorTrack(t6.modelName, t6.T.curves, i2, "position");
      void 0 !== n3 && e2.push(n3);
    }
    if (void 0 !== t6.R && Object.keys(t6.R.curves).length > 0) {
      const i3 = this.generateRotationTrack(t6.modelName, t6.R.curves, n2, t6.preRotation, t6.postRotation, t6.eulerOrder);
      void 0 !== i3 && e2.push(i3);
    }
    if (void 0 !== t6.S && Object.keys(t6.S.curves).length > 0) {
      const i3 = this.generateVectorTrack(t6.modelName, t6.S.curves, r2, "scale");
      void 0 !== i3 && e2.push(i3);
    }
    if (void 0 !== t6.DeformPercent) {
      const i3 = this.generateMorphTrack(t6);
      void 0 !== i3 && e2.push(i3);
    }
    return e2;
  }
  generateVectorTrack(t6, e2, i2, n2) {
    const r2 = this.getTimesForAllAxes(e2), s2 = this.getKeyframeTrackValues(r2, e2, i2);
    return new Em(t6 + "." + n2, r2, s2);
  }
  generateRotationTrack(t6, e2, i2, n2, r2, s2) {
    void 0 !== e2.x && (this.interpolateRotations(e2.x), e2.x.values = e2.x.values.map(zo.degToRad)), void 0 !== e2.y && (this.interpolateRotations(e2.y), e2.y.values = e2.y.values.map(zo.degToRad)), void 0 !== e2.z && (this.interpolateRotations(e2.z), e2.z.values = e2.z.values.map(zo.degToRad));
    const o2 = this.getTimesForAllAxes(e2), a2 = this.getKeyframeTrackValues(o2, e2, i2);
    void 0 !== n2 && ((n2 = n2.map(zo.degToRad)).push(s2), n2 = new tl().fromArray(n2), n2 = new da().setFromEuler(n2)), void 0 !== r2 && ((r2 = r2.map(zo.degToRad)).push(s2), r2 = new tl().fromArray(r2), r2 = new da().setFromEuler(r2).invert());
    const l2 = new da(), c2 = new tl(), h2 = [];
    for (let t7 = 0; t7 < a2.length; t7 += 3) c2.set(a2[t7], a2[t7 + 1], a2[t7 + 2], s2), l2.setFromEuler(c2), void 0 !== n2 && l2.premultiply(n2), void 0 !== r2 && l2.multiply(r2), l2.toArray(h2, t7 / 3 * 4);
    return new Mm(t6 + ".quaternion", o2, h2);
  }
  generateMorphTrack(t6) {
    const e2 = t6.DeformPercent.curves.morph, i2 = e2.values.map((function(t7) {
      return t7 / 100;
    })), n2 = b_.getObjectByName(t6.modelName).morphTargetDictionary[t6.morphName];
    return new _m(t6.modelName + ".morphTargetInfluences[" + n2 + "]", e2.times, i2);
  }
  getTimesForAllAxes(t6) {
    let e2 = [];
    if (void 0 !== t6.x && (e2 = e2.concat(t6.x.times)), void 0 !== t6.y && (e2 = e2.concat(t6.y.times)), void 0 !== t6.z && (e2 = e2.concat(t6.z.times)), e2 = e2.sort((function(t7, e3) {
      return t7 - e3;
    })), e2.length > 1) {
      let t7 = 1, i2 = e2[0];
      for (let n2 = 1; n2 < e2.length; n2++) {
        const r2 = e2[n2];
        r2 !== i2 && (e2[t7] = r2, i2 = r2, t7++);
      }
      e2 = e2.slice(0, t7);
    }
    return e2;
  }
  getKeyframeTrackValues(t6, e2, i2) {
    const n2 = i2, r2 = [];
    let s2 = -1, o2 = -1, a2 = -1;
    return t6.forEach((function(t7) {
      if (e2.x && (s2 = e2.x.times.indexOf(t7)), e2.y && (o2 = e2.y.times.indexOf(t7)), e2.z && (a2 = e2.z.times.indexOf(t7)), -1 !== s2) {
        const t8 = e2.x.values[s2];
        r2.push(t8), n2[0] = t8;
      } else r2.push(n2[0]);
      if (-1 !== o2) {
        const t8 = e2.y.values[o2];
        r2.push(t8), n2[1] = t8;
      } else r2.push(n2[1]);
      if (-1 !== a2) {
        const t8 = e2.z.values[a2];
        r2.push(t8), n2[2] = t8;
      } else r2.push(n2[2]);
    })), r2;
  }
  interpolateRotations(t6) {
    for (let e2 = 1; e2 < t6.values.length; e2++) {
      const i2 = t6.values[e2 - 1], n2 = t6.values[e2] - i2, r2 = Math.abs(n2);
      if (r2 >= 180) {
        const s2 = r2 / 180, o2 = n2 / s2;
        let a2 = i2 + o2;
        const l2 = t6.times[e2 - 1], c2 = (t6.times[e2] - l2) / s2;
        let h2 = l2 + c2;
        const u2 = [], d2 = [];
        for (; h2 < t6.times[e2]; ) u2.push(h2), h2 += c2, d2.push(a2), a2 += o2;
        t6.times = k_(t6.times, e2, u2), t6.values = k_(t6.values, e2, d2);
      }
    }
  }
};
var T_ = class {
  getPrevNode() {
    return this.nodeStack[this.currentIndent - 2];
  }
  getCurrentNode() {
    return this.nodeStack[this.currentIndent - 1];
  }
  getCurrentProp() {
    return this.currentProp;
  }
  pushStack(t6) {
    this.nodeStack.push(t6), this.currentIndent += 1;
  }
  popStack() {
    this.nodeStack.pop(), this.currentIndent -= 1;
  }
  setCurrentProp(t6, e2) {
    this.currentProp = t6, this.currentPropName = e2;
  }
  parse(t6) {
    this.currentIndent = 0, this.allNodes = new C_(), this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
    const e2 = this, i2 = t6.split(/[\r\n]+/);
    return i2.forEach((function(t7, n2) {
      const r2 = t7.match(/^[\s\t]*;/), s2 = t7.match(/^[\s\t]*$/);
      if (r2 || s2) return;
      const o2 = t7.match("^\\t{" + e2.currentIndent + "}(\\w+):(.*){", ""), a2 = t7.match("^\\t{" + e2.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"), l2 = t7.match("^\\t{" + (e2.currentIndent - 1) + "}}");
      o2 ? e2.parseNodeBegin(t7, o2) : a2 ? e2.parseNodeProperty(t7, a2, i2[++n2]) : l2 ? e2.popStack() : t7.match(/^[^\s\t}]/) && e2.parseNodePropertyContinued(t7);
    })), this.allNodes;
  }
  parseNodeBegin(t6, e2) {
    const i2 = e2[1].trim().replace(/^"/, "").replace(/"$/, ""), n2 = e2[2].split(",").map((function(t7) {
      return t7.trim().replace(/^"/, "").replace(/"$/, "");
    })), r2 = { name: i2 }, s2 = this.parseNodeAttr(n2), o2 = this.getCurrentNode();
    0 === this.currentIndent ? this.allNodes.add(i2, r2) : i2 in o2 ? ("PoseNode" === i2 ? o2.PoseNode.push(r2) : void 0 !== o2[i2].id && (o2[i2] = {}, o2[i2][o2[i2].id] = o2[i2]), "" !== s2.id && (o2[i2][s2.id] = r2)) : "number" == typeof s2.id ? (o2[i2] = {}, o2[i2][s2.id] = r2) : "Properties70" !== i2 && (o2[i2] = "PoseNode" === i2 ? [r2] : r2), "number" == typeof s2.id && (r2.id = s2.id), "" !== s2.name && (r2.attrName = s2.name), "" !== s2.type && (r2.attrType = s2.type), this.pushStack(r2);
  }
  parseNodeAttr(t6) {
    let e2 = t6[0];
    "" !== t6[0] && (e2 = parseInt(t6[0]), isNaN(e2) && (e2 = t6[0]));
    let i2 = "", n2 = "";
    return t6.length > 1 && (i2 = t6[1].replace(/^(\w+)::/, ""), n2 = t6[2]), { id: e2, name: i2, type: n2 };
  }
  parseNodeProperty(t6, e2, i2) {
    let n2 = e2[1].replace(/^"/, "").replace(/"$/, "").trim(), r2 = e2[2].replace(/^"/, "").replace(/"$/, "").trim();
    "Content" === n2 && "," === r2 && (r2 = i2.replace(/"/g, "").replace(/,$/, "").trim());
    const s2 = this.getCurrentNode();
    if ("Properties70" !== s2.name) {
      if ("C" === n2) {
        const t7 = r2.split(",").slice(1), e3 = parseInt(t7[0]), i3 = parseInt(t7[1]);
        let o2 = r2.split(",").slice(3);
        o2 = o2.map((function(t8) {
          return t8.trim().replace(/^"/, "");
        })), n2 = "connections", r2 = [e3, i3], (function(t8, e4) {
          for (let i4 = 0, n3 = t8.length, r3 = e4.length; i4 < r3; i4++, n3++) t8[n3] = e4[i4];
        })(r2, o2), void 0 === s2[n2] && (s2[n2] = []);
      }
      "Node" === n2 && (s2.id = r2), n2 in s2 && Array.isArray(s2[n2]) ? s2[n2].push(r2) : "a" !== n2 ? s2[n2] = r2 : s2.a = r2, this.setCurrentProp(s2, n2), "a" === n2 && "," !== r2.slice(-1) && (s2.a = N_(r2));
    } else this.parseNodeSpecialProperty(t6, n2, r2);
  }
  parseNodePropertyContinued(t6) {
    const e2 = this.getCurrentNode();
    e2.a += t6, "," !== t6.slice(-1) && (e2.a = N_(e2.a));
  }
  parseNodeSpecialProperty(t6, e2, i2) {
    const n2 = i2.split('",').map((function(t7) {
      return t7.trim().replace(/^\"/, "").replace(/\s/, "_");
    })), r2 = n2[0], s2 = n2[1], o2 = n2[2], a2 = n2[3];
    let l2 = n2[4];
    switch (s2) {
      case "int":
      case "enum":
      case "bool":
      case "ULongLong":
      case "double":
      case "Number":
      case "FieldOfView":
        l2 = parseFloat(l2);
        break;
      case "Color":
      case "ColorRGB":
      case "Vector3D":
      case "Lcl_Translation":
      case "Lcl_Rotation":
      case "Lcl_Scaling":
        l2 = N_(l2);
    }
    this.getPrevNode()[r2] = { type: s2, type2: o2, flag: a2, value: l2 }, this.setCurrentProp(this.getPrevNode(), r2);
  }
};
var E_ = class {
  parse(t6) {
    const e2 = new A_(t6);
    e2.skip(23);
    const i2 = e2.getUint32();
    if (i2 < 6400) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + i2);
    const n2 = new C_();
    for (; !this.endOfContent(e2); ) {
      const t7 = this.parseNode(e2, i2);
      null !== t7 && n2.add(t7.name, t7);
    }
    return n2;
  }
  endOfContent(t6) {
    return t6.size() % 16 == 0 ? (t6.getOffset() + 160 + 16 & -16) >= t6.size() : t6.getOffset() + 160 + 16 >= t6.size();
  }
  parseNode(t6, e2) {
    const i2 = {}, n2 = e2 >= 7500 ? t6.getUint64() : t6.getUint32(), r2 = e2 >= 7500 ? t6.getUint64() : t6.getUint32();
    e2 >= 7500 ? t6.getUint64() : t6.getUint32();
    const s2 = t6.getUint8(), o2 = t6.getString(s2);
    if (0 === n2) return null;
    const a2 = [];
    for (let e3 = 0; e3 < r2; e3++) a2.push(this.parseProperty(t6));
    const l2 = a2.length > 0 ? a2[0] : "", c2 = a2.length > 1 ? a2[1] : "", h2 = a2.length > 2 ? a2[2] : "";
    for (i2.singleProperty = 1 === r2 && t6.getOffset() === n2; n2 > t6.getOffset(); ) {
      const n3 = this.parseNode(t6, e2);
      null !== n3 && this.parseSubNode(o2, i2, n3);
    }
    return i2.propertyList = a2, "number" == typeof l2 && (i2.id = l2), "" !== c2 && (i2.attrName = c2), "" !== h2 && (i2.attrType = h2), "" !== o2 && (i2.name = o2), i2;
  }
  parseSubNode(t6, e2, i2) {
    if (true === i2.singleProperty) {
      const t7 = i2.propertyList[0];
      Array.isArray(t7) ? (e2[i2.name] = i2, i2.a = t7) : e2[i2.name] = t7;
    } else if ("Connections" === t6 && "C" === i2.name) {
      const t7 = [];
      i2.propertyList.forEach((function(e3, i3) {
        0 !== i3 && t7.push(e3);
      })), void 0 === e2.connections && (e2.connections = []), e2.connections.push(t7);
    } else if ("Properties70" === i2.name) {
      Object.keys(i2).forEach((function(t7) {
        e2[t7] = i2[t7];
      }));
    } else if ("Properties70" === t6 && "P" === i2.name) {
      let t7 = i2.propertyList[0], n2 = i2.propertyList[1];
      const r2 = i2.propertyList[2], s2 = i2.propertyList[3];
      let o2;
      0 === t7.indexOf("Lcl ") && (t7 = t7.replace("Lcl ", "Lcl_")), 0 === n2.indexOf("Lcl ") && (n2 = n2.replace("Lcl ", "Lcl_")), o2 = "Color" === n2 || "ColorRGB" === n2 || "Vector" === n2 || "Vector3D" === n2 || 0 === n2.indexOf("Lcl_") ? [i2.propertyList[4], i2.propertyList[5], i2.propertyList[6]] : i2.propertyList[4], e2[t7] = { type: n2, type2: r2, flag: s2, value: o2 };
    } else void 0 === e2[i2.name] ? "number" == typeof i2.id ? (e2[i2.name] = {}, e2[i2.name][i2.id] = i2) : e2[i2.name] = i2 : "PoseNode" === i2.name ? (Array.isArray(e2[i2.name]) || (e2[i2.name] = [e2[i2.name]]), e2[i2.name].push(i2)) : void 0 === e2[i2.name][i2.id] && (e2[i2.name][i2.id] = i2);
  }
  parseProperty(t6) {
    const e2 = t6.getString(1);
    let i2;
    switch (e2) {
      case "C":
        return t6.getBoolean();
      case "D":
        return t6.getFloat64();
      case "F":
        return t6.getFloat32();
      case "I":
        return t6.getInt32();
      case "L":
        return t6.getInt64();
      case "R":
        return i2 = t6.getUint32(), t6.getArrayBuffer(i2);
      case "S":
        return i2 = t6.getUint32(), t6.getString(i2);
      case "Y":
        return t6.getInt16();
      case "b":
      case "c":
      case "d":
      case "f":
      case "i":
      case "l":
        const n2 = t6.getUint32(), r2 = t6.getUint32(), s2 = t6.getUint32();
        if (0 === r2) switch (e2) {
          case "b":
          case "c":
            return t6.getBooleanArray(n2);
          case "d":
            return t6.getFloat64Array(n2);
          case "f":
            return t6.getFloat32Array(n2);
          case "i":
            return t6.getInt32Array(n2);
          case "l":
            return t6.getInt64Array(n2);
        }
        void 0 === o && console.error("THREE.FBXLoader: External library fflate.min.js required.");
        const a2 = Ow(new Uint8Array(t6.getArrayBuffer(s2))), l2 = new A_(a2.buffer);
        switch (e2) {
          case "b":
          case "c":
            return l2.getBooleanArray(n2);
          case "d":
            return l2.getFloat64Array(n2);
          case "f":
            return l2.getFloat32Array(n2);
          case "i":
            return l2.getInt32Array(n2);
          case "l":
            return l2.getInt64Array(n2);
        }
        break;
      default:
        throw new Error("THREE.FBXLoader: Unknown property type " + e2);
    }
  }
};
var A_ = class {
  constructor(t6, e2) {
    this.dv = new DataView(t6), this.offset = 0, this.littleEndian = void 0 === e2 || e2;
  }
  getOffset() {
    return this.offset;
  }
  size() {
    return this.dv.buffer.byteLength;
  }
  skip(t6) {
    this.offset += t6;
  }
  getBoolean() {
    return !(1 & ~this.getUint8());
  }
  getBooleanArray(t6) {
    const e2 = [];
    for (let i2 = 0; i2 < t6; i2++) e2.push(this.getBoolean());
    return e2;
  }
  getUint8() {
    const t6 = this.dv.getUint8(this.offset);
    return this.offset += 1, t6;
  }
  getInt16() {
    const t6 = this.dv.getInt16(this.offset, this.littleEndian);
    return this.offset += 2, t6;
  }
  getInt32() {
    const t6 = this.dv.getInt32(this.offset, this.littleEndian);
    return this.offset += 4, t6;
  }
  getInt32Array(t6) {
    const e2 = [];
    for (let i2 = 0; i2 < t6; i2++) e2.push(this.getInt32());
    return e2;
  }
  getUint32() {
    const t6 = this.dv.getUint32(this.offset, this.littleEndian);
    return this.offset += 4, t6;
  }
  getInt64() {
    let t6, e2;
    return this.littleEndian ? (t6 = this.getUint32(), e2 = this.getUint32()) : (e2 = this.getUint32(), t6 = this.getUint32()), 2147483648 & e2 ? (e2 = 4294967295 & ~e2, t6 = 4294967295 & ~t6, 4294967295 === t6 && (e2 = e2 + 1 & 4294967295), t6 = t6 + 1 & 4294967295, -(4294967296 * e2 + t6)) : 4294967296 * e2 + t6;
  }
  getInt64Array(t6) {
    const e2 = [];
    for (let i2 = 0; i2 < t6; i2++) e2.push(this.getInt64());
    return e2;
  }
  getUint64() {
    let t6, e2;
    return this.littleEndian ? (t6 = this.getUint32(), e2 = this.getUint32()) : (e2 = this.getUint32(), t6 = this.getUint32()), 4294967296 * e2 + t6;
  }
  getFloat32() {
    const t6 = this.dv.getFloat32(this.offset, this.littleEndian);
    return this.offset += 4, t6;
  }
  getFloat32Array(t6) {
    const e2 = [];
    for (let i2 = 0; i2 < t6; i2++) e2.push(this.getFloat32());
    return e2;
  }
  getFloat64() {
    const t6 = this.dv.getFloat64(this.offset, this.littleEndian);
    return this.offset += 8, t6;
  }
  getFloat64Array(t6) {
    const e2 = [];
    for (let i2 = 0; i2 < t6; i2++) e2.push(this.getFloat64());
    return e2;
  }
  getArrayBuffer(t6) {
    const e2 = this.dv.buffer.slice(this.offset, this.offset + t6);
    return this.offset += t6, e2;
  }
  getString(t6) {
    let e2 = [];
    for (let i3 = 0; i3 < t6; i3++) e2[i3] = this.getUint8();
    const i2 = e2.indexOf(0);
    return i2 >= 0 && (e2 = e2.slice(0, i2)), lg.decodeText(new Uint8Array(e2));
  }
};
var C_ = class {
  add(t6, e2) {
    this[t6] = e2;
  }
};
function R_(t6) {
  const e2 = t6.match(/FBXVersion: (\d+)/);
  if (e2) {
    return parseInt(e2[1]);
  }
  throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
}
function P_(t6) {
  return t6 / 46186158e3;
}
var L_ = [];
function I_(t6, e2, i2, n2) {
  let r2;
  switch (n2.mappingType) {
    case "ByPolygonVertex":
      r2 = t6;
      break;
    case "ByPolygon":
      r2 = e2;
      break;
    case "ByVertice":
      r2 = i2;
      break;
    case "AllSame":
      r2 = n2.indices[0];
      break;
    default:
      console.warn("THREE.FBXLoader: unknown attribute mapping type " + n2.mappingType);
  }
  "IndexToDirect" === n2.referenceType && (r2 = n2.indices[r2]);
  const s2 = r2 * n2.dataSize, o2 = s2 + n2.dataSize;
  return (function(t7, e3, i3, n3) {
    for (let r3 = i3, s3 = 0; r3 < n3; r3++, s3++) t7[s3] = e3[r3];
    return t7;
  })(L_, n2.buffer, s2, o2);
}
var D_ = new tl();
var O_ = new pa();
function z_(t6) {
  const e2 = new Ga(), i2 = new Ga(), n2 = new Ga(), r2 = new Ga(), s2 = new Ga(), o2 = new Ga(), a2 = new Ga(), l2 = new Ga(), c2 = new Ga(), h2 = new Ga(), u2 = new Ga(), d2 = new Ga(), p2 = t6.inheritType ? t6.inheritType : 0;
  if (t6.translation && e2.setPosition(O_.fromArray(t6.translation)), t6.preRotation) {
    const e3 = t6.preRotation.map(zo.degToRad);
    e3.push(t6.eulerOrder), i2.makeRotationFromEuler(D_.fromArray(e3));
  }
  if (t6.rotation) {
    const e3 = t6.rotation.map(zo.degToRad);
    e3.push(t6.eulerOrder), n2.makeRotationFromEuler(D_.fromArray(e3));
  }
  if (t6.postRotation) {
    const e3 = t6.postRotation.map(zo.degToRad);
    e3.push(t6.eulerOrder), r2.makeRotationFromEuler(D_.fromArray(e3)), r2.invert();
  }
  t6.scale && s2.scale(O_.fromArray(t6.scale)), t6.scalingOffset && a2.setPosition(O_.fromArray(t6.scalingOffset)), t6.scalingPivot && o2.setPosition(O_.fromArray(t6.scalingPivot)), t6.rotationOffset && l2.setPosition(O_.fromArray(t6.rotationOffset)), t6.rotationPivot && c2.setPosition(O_.fromArray(t6.rotationPivot)), t6.parentMatrixWorld && (u2.copy(t6.parentMatrix), h2.copy(t6.parentMatrixWorld));
  const f2 = i2.clone().multiply(n2).multiply(r2), m2 = new Ga();
  m2.extractRotation(h2);
  const g2 = new Ga();
  g2.copyPosition(h2);
  const v2 = g2.clone().invert().multiply(h2), y2 = m2.clone().invert().multiply(v2), x2 = s2, b2 = new Ga();
  if (0 === p2) b2.copy(m2).multiply(f2).multiply(y2).multiply(x2);
  else if (1 === p2) b2.copy(m2).multiply(y2).multiply(f2).multiply(x2);
  else {
    const t7 = new Ga().scale(new pa().setFromMatrixScale(u2)).clone().invert(), e3 = y2.clone().multiply(t7);
    b2.copy(m2).multiply(f2).multiply(e3).multiply(x2);
  }
  const w2 = c2.clone().invert(), _2 = o2.clone().invert();
  let S2 = e2.clone().multiply(l2).multiply(c2).multiply(i2).multiply(n2).multiply(r2).multiply(w2).multiply(a2).multiply(o2).multiply(s2).multiply(_2);
  const M2 = new Ga().copyPosition(S2), T2 = h2.clone().multiply(M2);
  return d2.copyPosition(T2), S2 = d2.clone().multiply(b2), S2.premultiply(h2.invert()), S2;
}
function F_(t6) {
  const e2 = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"];
  return 6 === (t6 = t6 || 0) ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), e2[0]) : e2[t6];
}
function N_(t6) {
  return t6.split(",").map((function(t7) {
    return parseFloat(t7);
  }));
}
function B_(t6, e2, i2) {
  return void 0 === e2 && (e2 = 0), void 0 === i2 && (i2 = t6.byteLength), lg.decodeText(new Uint8Array(t6, e2, i2));
}
function k_(t6, e2, i2) {
  return t6.slice(0, e2).concat(i2).concat(t6.slice(e2));
}
var U_ = class extends Im {
  constructor(t6) {
    super(t6), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function(t7) {
      return new q_(t7);
    })), this.register((function(t7) {
      return new Q_(t7);
    })), this.register((function(t7) {
      return new tS(t7);
    })), this.register((function(t7) {
      return new Y_(t7);
    })), this.register((function(t7) {
      return new Z_(t7);
    })), this.register((function(t7) {
      return new J_(t7);
    })), this.register((function(t7) {
      return new K_(t7);
    })), this.register((function(t7) {
      return new W_(t7);
    })), this.register((function(t7) {
      return new $_(t7);
    })), this.register((function(t7) {
      return new X_(t7);
    })), this.register((function(t7) {
      return new j_(t7);
    })), this.register((function(t7) {
      return new eS(t7);
    }));
  }
  load(t6, e2, i2, n2) {
    const r2 = this;
    let s2;
    s2 = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : lg.extractUrlBase(t6), this.manager.itemStart(t6);
    const o2 = function(e3) {
      n2 ? n2(e3) : console.error(e3), r2.manager.itemError(t6), r2.manager.itemEnd(t6);
    }, a2 = new zm(this.manager);
    a2.setPath(this.path), a2.setResponseType("arraybuffer"), a2.setRequestHeader(this.requestHeader), a2.setWithCredentials(this.withCredentials), a2.load(t6, (function(i3) {
      try {
        r2.parse(i3, s2, (function(i4) {
          e2(i4), r2.manager.itemEnd(t6);
        }), o2);
      } catch (t7) {
        o2(t7);
      }
    }), i2, o2);
  }
  setDRACOLoader(t6) {
    return this.dracoLoader = t6, this;
  }
  setDDSLoader() {
    throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
  }
  setKTX2Loader(t6) {
    return this.ktx2Loader = t6, this;
  }
  setMeshoptDecoder(t6) {
    return this.meshoptDecoder = t6, this;
  }
  register(t6) {
    return -1 === this.pluginCallbacks.indexOf(t6) && this.pluginCallbacks.push(t6), this;
  }
  unregister(t6) {
    return -1 !== this.pluginCallbacks.indexOf(t6) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t6), 1), this;
  }
  parse(t6, e2, i2, n2) {
    let r2;
    const s2 = {}, o2 = {};
    if ("string" == typeof t6) r2 = t6;
    else {
      if (lg.decodeText(new Uint8Array(t6, 0, 4)) === iS) {
        try {
          s2[V_.KHR_BINARY_GLTF] = new sS(t6);
        } catch (t7) {
          return void (n2 && n2(t7));
        }
        r2 = s2[V_.KHR_BINARY_GLTF].content;
      } else r2 = lg.decodeText(new Uint8Array(t6));
    }
    const a2 = JSON.parse(r2);
    if (void 0 === a2.asset || a2.asset.version[0] < 2) return void (n2 && n2(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
    const l2 = new BS(a2, { path: e2 || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder });
    l2.fileLoader.setRequestHeader(this.requestHeader);
    for (let t7 = 0; t7 < this.pluginCallbacks.length; t7++) {
      const e3 = this.pluginCallbacks[t7](l2);
      o2[e3.name] = e3, s2[e3.name] = true;
    }
    if (a2.extensionsUsed) for (let t7 = 0; t7 < a2.extensionsUsed.length; ++t7) {
      const e3 = a2.extensionsUsed[t7], i3 = a2.extensionsRequired || [];
      switch (e3) {
        case V_.KHR_MATERIALS_UNLIT:
          s2[e3] = new G_();
          break;
        case V_.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
          s2[e3] = new cS();
          break;
        case V_.KHR_DRACO_MESH_COMPRESSION:
          s2[e3] = new oS(a2, this.dracoLoader);
          break;
        case V_.KHR_TEXTURE_TRANSFORM:
          s2[e3] = new aS();
          break;
        case V_.KHR_MESH_QUANTIZATION:
          s2[e3] = new hS();
          break;
        default:
          i3.indexOf(e3) >= 0 && void 0 === o2[e3] && console.warn('THREE.GLTFLoader: Unknown extension "' + e3 + '".');
      }
    }
    l2.setExtensions(s2), l2.setPlugins(o2), l2.parse(i2, n2);
  }
  parseAsync(t6, e2) {
    const i2 = this;
    return new Promise((function(n2, r2) {
      i2.parse(t6, e2, n2, r2);
    }));
  }
};
function H_() {
  let t6 = {};
  return { get: function(e2) {
    return t6[e2];
  }, add: function(e2, i2) {
    t6[e2] = i2;
  }, remove: function(e2) {
    delete t6[e2];
  }, removeAll: function() {
    t6 = {};
  } };
}
var V_ = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_IOR: "KHR_materials_ior", KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness", KHR_MATERIALS_SHEEN: "KHR_materials_sheen", KHR_MATERIALS_SPECULAR: "KHR_materials_specular", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_MATERIALS_VOLUME: "KHR_materials_volume", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression" };
var j_ = class {
  constructor(t6) {
    this.parser = t6, this.name = V_.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const t6 = this.parser, e2 = this.parser.json.nodes || [];
    for (let i2 = 0, n2 = e2.length; i2 < n2; i2++) {
      const n3 = e2[i2];
      n3.extensions && n3.extensions[this.name] && void 0 !== n3.extensions[this.name].light && t6._addNodeRef(this.cache, n3.extensions[this.name].light);
    }
  }
  _loadLight(t6) {
    const e2 = this.parser, i2 = "light:" + t6;
    let n2 = e2.cache.get(i2);
    if (n2) return n2;
    const r2 = e2.json, s2 = ((r2.extensions && r2.extensions[this.name] || {}).lights || [])[t6];
    let o2;
    const a2 = new $o(16777215);
    void 0 !== s2.color && a2.fromArray(s2.color);
    const l2 = void 0 !== s2.range ? s2.range : 0;
    switch (s2.type) {
      case "directional":
        o2 = new ig(a2), o2.target.position.set(0, 0, -1), o2.add(o2.target);
        break;
      case "point":
        o2 = new tg(a2), o2.distance = l2;
        break;
      case "spot":
        o2 = new Zm(a2), o2.distance = l2, s2.spot = s2.spot || {}, s2.spot.innerConeAngle = void 0 !== s2.spot.innerConeAngle ? s2.spot.innerConeAngle : 0, s2.spot.outerConeAngle = void 0 !== s2.spot.outerConeAngle ? s2.spot.outerConeAngle : Math.PI / 4, o2.angle = s2.spot.outerConeAngle, o2.penumbra = 1 - s2.spot.innerConeAngle / s2.spot.outerConeAngle, o2.target.position.set(0, 0, -1), o2.add(o2.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + s2.type);
    }
    return o2.position.set(0, 0, 0), o2.decay = 2, void 0 !== s2.intensity && (o2.intensity = s2.intensity), o2.name = e2.createUniqueName(s2.name || "light_" + t6), n2 = Promise.resolve(o2), e2.cache.add(i2, n2), n2;
  }
  createNodeAttachment(t6) {
    const e2 = this, i2 = this.parser, n2 = i2.json.nodes[t6], r2 = (n2.extensions && n2.extensions[this.name] || {}).light;
    return void 0 === r2 ? null : this._loadLight(r2).then((function(t7) {
      return i2._getNodeRef(e2.cache, r2, t7);
    }));
  }
};
var G_ = class {
  constructor() {
    this.name = V_.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return Rl;
  }
  extendParams(t6, e2, i2) {
    const n2 = [];
    t6.color = new $o(1, 1, 1), t6.opacity = 1;
    const r2 = e2.pbrMetallicRoughness;
    if (r2) {
      if (Array.isArray(r2.baseColorFactor)) {
        const e3 = r2.baseColorFactor;
        t6.color.fromArray(e3), t6.opacity = e3[3];
      }
      void 0 !== r2.baseColorTexture && n2.push(i2.assignTexture(t6, "map", r2.baseColorTexture, ks));
    }
    return Promise.all(n2);
  }
};
var W_ = class {
  constructor(t6) {
    this.parser = t6, this.name = V_.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(t6, e2) {
    const i2 = this.parser.json.materials[t6];
    if (!i2.extensions || !i2.extensions[this.name]) return Promise.resolve();
    const n2 = i2.extensions[this.name].emissiveStrength;
    return void 0 !== n2 && (e2.emissiveIntensity = n2), Promise.resolve();
  }
};
var q_ = class {
  constructor(t6) {
    this.parser = t6, this.name = V_.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(t6) {
    const e2 = this.parser.json.materials[t6];
    return e2.extensions && e2.extensions[this.name] ? em : null;
  }
  extendMaterialParams(t6, e2) {
    const i2 = this.parser, n2 = i2.json.materials[t6];
    if (!n2.extensions || !n2.extensions[this.name]) return Promise.resolve();
    const r2 = [], s2 = n2.extensions[this.name];
    if (void 0 !== s2.clearcoatFactor && (e2.clearcoat = s2.clearcoatFactor), void 0 !== s2.clearcoatTexture && r2.push(i2.assignTexture(e2, "clearcoatMap", s2.clearcoatTexture)), void 0 !== s2.clearcoatRoughnessFactor && (e2.clearcoatRoughness = s2.clearcoatRoughnessFactor), void 0 !== s2.clearcoatRoughnessTexture && r2.push(i2.assignTexture(e2, "clearcoatRoughnessMap", s2.clearcoatRoughnessTexture)), void 0 !== s2.clearcoatNormalTexture && (r2.push(i2.assignTexture(e2, "clearcoatNormalMap", s2.clearcoatNormalTexture)), void 0 !== s2.clearcoatNormalTexture.scale)) {
      const t7 = s2.clearcoatNormalTexture.scale;
      e2.clearcoatNormalScale = new Fo(t7, t7);
    }
    return Promise.all(r2);
  }
};
var X_ = class {
  constructor(t6) {
    this.parser = t6, this.name = V_.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(t6) {
    const e2 = this.parser.json.materials[t6];
    return e2.extensions && e2.extensions[this.name] ? em : null;
  }
  extendMaterialParams(t6, e2) {
    const i2 = this.parser, n2 = i2.json.materials[t6];
    if (!n2.extensions || !n2.extensions[this.name]) return Promise.resolve();
    const r2 = [], s2 = n2.extensions[this.name];
    return void 0 !== s2.iridescenceFactor && (e2.iridescence = s2.iridescenceFactor), void 0 !== s2.iridescenceTexture && r2.push(i2.assignTexture(e2, "iridescenceMap", s2.iridescenceTexture)), void 0 !== s2.iridescenceIor && (e2.iridescenceIOR = s2.iridescenceIor), void 0 === e2.iridescenceThicknessRange && (e2.iridescenceThicknessRange = [100, 400]), void 0 !== s2.iridescenceThicknessMinimum && (e2.iridescenceThicknessRange[0] = s2.iridescenceThicknessMinimum), void 0 !== s2.iridescenceThicknessMaximum && (e2.iridescenceThicknessRange[1] = s2.iridescenceThicknessMaximum), void 0 !== s2.iridescenceThicknessTexture && r2.push(i2.assignTexture(e2, "iridescenceThicknessMap", s2.iridescenceThicknessTexture)), Promise.all(r2);
  }
};
var Y_ = class {
  constructor(t6) {
    this.parser = t6, this.name = V_.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(t6) {
    const e2 = this.parser.json.materials[t6];
    return e2.extensions && e2.extensions[this.name] ? em : null;
  }
  extendMaterialParams(t6, e2) {
    const i2 = this.parser, n2 = i2.json.materials[t6];
    if (!n2.extensions || !n2.extensions[this.name]) return Promise.resolve();
    const r2 = [];
    e2.sheenColor = new $o(0, 0, 0), e2.sheenRoughness = 0, e2.sheen = 1;
    const s2 = n2.extensions[this.name];
    return void 0 !== s2.sheenColorFactor && e2.sheenColor.fromArray(s2.sheenColorFactor), void 0 !== s2.sheenRoughnessFactor && (e2.sheenRoughness = s2.sheenRoughnessFactor), void 0 !== s2.sheenColorTexture && r2.push(i2.assignTexture(e2, "sheenColorMap", s2.sheenColorTexture, ks)), void 0 !== s2.sheenRoughnessTexture && r2.push(i2.assignTexture(e2, "sheenRoughnessMap", s2.sheenRoughnessTexture)), Promise.all(r2);
  }
};
var Z_ = class {
  constructor(t6) {
    this.parser = t6, this.name = V_.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(t6) {
    const e2 = this.parser.json.materials[t6];
    return e2.extensions && e2.extensions[this.name] ? em : null;
  }
  extendMaterialParams(t6, e2) {
    const i2 = this.parser, n2 = i2.json.materials[t6];
    if (!n2.extensions || !n2.extensions[this.name]) return Promise.resolve();
    const r2 = [], s2 = n2.extensions[this.name];
    return void 0 !== s2.transmissionFactor && (e2.transmission = s2.transmissionFactor), void 0 !== s2.transmissionTexture && r2.push(i2.assignTexture(e2, "transmissionMap", s2.transmissionTexture)), Promise.all(r2);
  }
};
var J_ = class {
  constructor(t6) {
    this.parser = t6, this.name = V_.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(t6) {
    const e2 = this.parser.json.materials[t6];
    return e2.extensions && e2.extensions[this.name] ? em : null;
  }
  extendMaterialParams(t6, e2) {
    const i2 = this.parser, n2 = i2.json.materials[t6];
    if (!n2.extensions || !n2.extensions[this.name]) return Promise.resolve();
    const r2 = [], s2 = n2.extensions[this.name];
    e2.thickness = void 0 !== s2.thicknessFactor ? s2.thicknessFactor : 0, void 0 !== s2.thicknessTexture && r2.push(i2.assignTexture(e2, "thicknessMap", s2.thicknessTexture)), e2.attenuationDistance = s2.attenuationDistance || 0;
    const o2 = s2.attenuationColor || [1, 1, 1];
    return e2.attenuationColor = new $o(o2[0], o2[1], o2[2]), Promise.all(r2);
  }
};
var K_ = class {
  constructor(t6) {
    this.parser = t6, this.name = V_.KHR_MATERIALS_IOR;
  }
  getMaterialType(t6) {
    const e2 = this.parser.json.materials[t6];
    return e2.extensions && e2.extensions[this.name] ? em : null;
  }
  extendMaterialParams(t6, e2) {
    const i2 = this.parser.json.materials[t6];
    if (!i2.extensions || !i2.extensions[this.name]) return Promise.resolve();
    const n2 = i2.extensions[this.name];
    return e2.ior = void 0 !== n2.ior ? n2.ior : 1.5, Promise.resolve();
  }
};
var $_ = class {
  constructor(t6) {
    this.parser = t6, this.name = V_.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(t6) {
    const e2 = this.parser.json.materials[t6];
    return e2.extensions && e2.extensions[this.name] ? em : null;
  }
  extendMaterialParams(t6, e2) {
    const i2 = this.parser, n2 = i2.json.materials[t6];
    if (!n2.extensions || !n2.extensions[this.name]) return Promise.resolve();
    const r2 = [], s2 = n2.extensions[this.name];
    e2.specularIntensity = void 0 !== s2.specularFactor ? s2.specularFactor : 1, void 0 !== s2.specularTexture && r2.push(i2.assignTexture(e2, "specularIntensityMap", s2.specularTexture));
    const o2 = s2.specularColorFactor || [1, 1, 1];
    return e2.specularColor = new $o(o2[0], o2[1], o2[2]), void 0 !== s2.specularColorTexture && r2.push(i2.assignTexture(e2, "specularColorMap", s2.specularColorTexture, ks)), Promise.all(r2);
  }
};
var Q_ = class {
  constructor(t6) {
    this.parser = t6, this.name = V_.KHR_TEXTURE_BASISU;
  }
  loadTexture(t6) {
    const e2 = this.parser, i2 = e2.json, n2 = i2.textures[t6];
    if (!n2.extensions || !n2.extensions[this.name]) return null;
    const r2 = n2.extensions[this.name], s2 = e2.options.ktx2Loader;
    if (!s2) {
      if (i2.extensionsRequired && i2.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return e2.loadTextureImage(t6, r2.source, s2);
  }
};
var tS = class {
  constructor(t6) {
    this.parser = t6, this.name = V_.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(t6) {
    const e2 = this.name, i2 = this.parser, n2 = i2.json, r2 = n2.textures[t6];
    if (!r2.extensions || !r2.extensions[e2]) return null;
    const s2 = r2.extensions[e2], o2 = n2.images[s2.source];
    let a2 = i2.textureLoader;
    if (o2.uri) {
      const t7 = i2.options.manager.getHandler(o2.uri);
      null !== t7 && (a2 = t7);
    }
    return this.detectSupport().then((function(r3) {
      if (r3) return i2.loadTextureImage(t6, s2.source, a2);
      if (n2.extensionsRequired && n2.extensionsRequired.indexOf(e2) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return i2.loadTexture(t6);
    }));
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise((function(t6) {
      const e2 = new Image();
      e2.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", e2.onload = e2.onerror = function() {
        t6(1 === e2.height);
      };
    }))), this.isSupported;
  }
};
var eS = class {
  constructor(t6) {
    this.name = V_.EXT_MESHOPT_COMPRESSION, this.parser = t6;
  }
  loadBufferView(t6) {
    const e2 = this.parser.json, i2 = e2.bufferViews[t6];
    if (i2.extensions && i2.extensions[this.name]) {
      const t7 = i2.extensions[this.name], n2 = this.parser.getDependency("buffer", t7.buffer), r2 = this.parser.options.meshoptDecoder;
      if (!r2 || !r2.supported) {
        if (e2.extensionsRequired && e2.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return Promise.all([n2, r2.ready]).then((function(e3) {
        const i3 = t7.byteOffset || 0, n3 = t7.byteLength || 0, s2 = t7.count, o2 = t7.byteStride, a2 = new ArrayBuffer(s2 * o2), l2 = new Uint8Array(e3[0], i3, n3);
        return r2.decodeGltfBuffer(new Uint8Array(a2), s2, o2, l2, t7.mode, t7.filter), a2;
      }));
    }
    return null;
  }
};
var iS = "glTF";
var nS = 1313821514;
var rS = 5130562;
var sS = class {
  constructor(t6) {
    this.name = V_.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const e2 = new DataView(t6, 0, 12);
    if (this.header = { magic: lg.decodeText(new Uint8Array(t6.slice(0, 4))), version: e2.getUint32(4, true), length: e2.getUint32(8, true) }, this.header.magic !== iS) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const i2 = this.header.length - 12, n2 = new DataView(t6, 12);
    let r2 = 0;
    for (; r2 < i2; ) {
      const e3 = n2.getUint32(r2, true);
      r2 += 4;
      const i3 = n2.getUint32(r2, true);
      if (r2 += 4, i3 === nS) {
        const i4 = new Uint8Array(t6, 12 + r2, e3);
        this.content = lg.decodeText(i4);
      } else if (i3 === rS) {
        const i4 = 12 + r2;
        this.body = t6.slice(i4, i4 + e3);
      }
      r2 += e3;
    }
    if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
};
var oS = class {
  constructor(t6, e2) {
    if (!e2) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = V_.KHR_DRACO_MESH_COMPRESSION, this.json = t6, this.dracoLoader = e2, this.dracoLoader.preload();
  }
  decodePrimitive(t6, e2) {
    const i2 = this.json, n2 = this.dracoLoader, r2 = t6.extensions[this.name].bufferView, s2 = t6.extensions[this.name].attributes, o2 = {}, a2 = {}, l2 = {};
    for (const t7 in s2) {
      const e3 = TS[t7] || t7.toLowerCase();
      o2[e3] = s2[t7];
    }
    for (const e3 in t6.attributes) {
      const n3 = TS[e3] || e3.toLowerCase();
      if (void 0 !== s2[e3]) {
        const r3 = i2.accessors[t6.attributes[e3]], s3 = wS[r3.componentType];
        l2[n3] = s3, a2[n3] = true === r3.normalized;
      }
    }
    return e2.getDependency("bufferView", r2).then((function(t7) {
      return new Promise((function(e3) {
        n2.decodeDracoFile(t7, (function(t8) {
          for (const e4 in t8.attributes) {
            const i3 = t8.attributes[e4], n3 = a2[e4];
            void 0 !== n3 && (i3.normalized = n3);
          }
          e3(t8);
        }), o2, l2);
      }));
    }));
  }
};
var aS = class {
  constructor() {
    this.name = V_.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(t6, e2) {
    return void 0 !== e2.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), void 0 === e2.offset && void 0 === e2.rotation && void 0 === e2.scale || (t6 = t6.clone(), void 0 !== e2.offset && t6.offset.fromArray(e2.offset), void 0 !== e2.rotation && (t6.rotation = e2.rotation), void 0 !== e2.scale && t6.repeat.fromArray(e2.scale), t6.needsUpdate = true), t6;
  }
};
var lS = class extends tm {
  constructor(t6) {
    super(), this.isGLTFSpecularGlossinessMaterial = true;
    const e2 = ["#ifdef USE_SPECULARMAP", "	uniform sampler2D specularMap;", "#endif"].join("\n"), i2 = ["#ifdef USE_GLOSSINESSMAP", "	uniform sampler2D glossinessMap;", "#endif"].join("\n"), n2 = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "	vec4 texelSpecular = texture2D( specularMap, vUv );", "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "	specularFactor *= texelSpecular.rgb;", "#endif"].join("\n"), r2 = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );", "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "	glossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"), s2 = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"), o2 = { specular: { value: new $o().setHex(16777215) }, glossiness: { value: 1 }, specularMap: { value: null }, glossinessMap: { value: null } };
    this._extraUniforms = o2, this.onBeforeCompile = function(t7) {
      for (const e3 in o2) t7.uniforms[e3] = o2[e3];
      t7.fragmentShader = t7.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", e2).replace("#include <metalnessmap_pars_fragment>", i2).replace("#include <roughnessmap_fragment>", n2).replace("#include <metalnessmap_fragment>", r2).replace("#include <lights_physical_fragment>", s2);
    }, Object.defineProperties(this, { specular: { get: function() {
      return o2.specular.value;
    }, set: function(t7) {
      o2.specular.value = t7;
    } }, specularMap: { get: function() {
      return o2.specularMap.value;
    }, set: function(t7) {
      o2.specularMap.value = t7, t7 ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP;
    } }, glossiness: { get: function() {
      return o2.glossiness.value;
    }, set: function(t7) {
      o2.glossiness.value = t7;
    } }, glossinessMap: { get: function() {
      return o2.glossinessMap.value;
    }, set: function(t7) {
      o2.glossinessMap.value = t7, t7 ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV);
    } } }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(t6);
  }
  copy(t6) {
    return super.copy(t6), this.specularMap = t6.specularMap, this.specular.copy(t6.specular), this.glossinessMap = t6.glossinessMap, this.glossiness = t6.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this;
  }
};
var cS = class {
  constructor() {
    this.name = V_.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity"];
  }
  getMaterialType() {
    return lS;
  }
  extendParams(t6, e2, i2) {
    const n2 = e2.extensions[this.name];
    t6.color = new $o(1, 1, 1), t6.opacity = 1;
    const r2 = [];
    if (Array.isArray(n2.diffuseFactor)) {
      const e3 = n2.diffuseFactor;
      t6.color.fromArray(e3), t6.opacity = e3[3];
    }
    if (void 0 !== n2.diffuseTexture && r2.push(i2.assignTexture(t6, "map", n2.diffuseTexture, ks)), t6.emissive = new $o(0, 0, 0), t6.glossiness = void 0 !== n2.glossinessFactor ? n2.glossinessFactor : 1, t6.specular = new $o(1, 1, 1), Array.isArray(n2.specularFactor) && t6.specular.fromArray(n2.specularFactor), void 0 !== n2.specularGlossinessTexture) {
      const e3 = n2.specularGlossinessTexture;
      r2.push(i2.assignTexture(t6, "glossinessMap", e3)), r2.push(i2.assignTexture(t6, "specularMap", e3, ks));
    }
    return Promise.all(r2);
  }
  createMaterial(t6) {
    const e2 = new lS(t6);
    return e2.fog = true, e2.color = t6.color, e2.map = void 0 === t6.map ? null : t6.map, e2.lightMap = null, e2.lightMapIntensity = 1, e2.aoMap = void 0 === t6.aoMap ? null : t6.aoMap, e2.aoMapIntensity = 1, e2.emissive = t6.emissive, e2.emissiveIntensity = void 0 === t6.emissiveIntensity ? 1 : t6.emissiveIntensity, e2.emissiveMap = void 0 === t6.emissiveMap ? null : t6.emissiveMap, e2.bumpMap = void 0 === t6.bumpMap ? null : t6.bumpMap, e2.bumpScale = 1, e2.normalMap = void 0 === t6.normalMap ? null : t6.normalMap, e2.normalMapType = Vs, t6.normalScale && (e2.normalScale = t6.normalScale), e2.displacementMap = null, e2.displacementScale = 1, e2.displacementBias = 0, e2.specularMap = void 0 === t6.specularMap ? null : t6.specularMap, e2.specular = t6.specular, e2.glossinessMap = void 0 === t6.glossinessMap ? null : t6.glossinessMap, e2.glossiness = t6.glossiness, e2.alphaMap = null, e2.envMap = void 0 === t6.envMap ? null : t6.envMap, e2.envMapIntensity = 1, e2;
  }
};
var hS = class {
  constructor() {
    this.name = V_.KHR_MESH_QUANTIZATION;
  }
};
var uS = class extends mm {
  constructor(t6, e2, i2, n2) {
    super(t6, e2, i2, n2);
  }
  copySampleValue_(t6) {
    const e2 = this.resultBuffer, i2 = this.sampleValues, n2 = this.valueSize, r2 = t6 * n2 * 3 + n2;
    for (let t7 = 0; t7 !== n2; t7++) e2[t7] = i2[r2 + t7];
    return e2;
  }
  interpolate_(t6, e2, i2, n2) {
    const r2 = this.resultBuffer, s2 = this.sampleValues, o2 = this.valueSize, a2 = 2 * o2, l2 = 3 * o2, c2 = n2 - e2, h2 = (i2 - e2) / c2, u2 = h2 * h2, d2 = u2 * h2, p2 = t6 * l2, f2 = p2 - l2, m2 = -2 * d2 + 3 * u2, g2 = d2 - u2, v2 = 1 - m2, y2 = g2 - u2 + h2;
    for (let t7 = 0; t7 !== o2; t7++) {
      const e3 = s2[f2 + t7 + o2], i3 = s2[f2 + t7 + a2] * c2, n3 = s2[p2 + t7 + o2], l3 = s2[p2 + t7] * c2;
      r2[t7] = v2 * e3 + y2 * i3 + m2 * n3 + g2 * l3;
    }
    return r2;
  }
};
var dS = new da();
var pS = class extends uS {
  interpolate_(t6, e2, i2, n2) {
    const r2 = super.interpolate_(t6, e2, i2, n2);
    return dS.fromArray(r2).normalize().toArray(r2), r2;
  }
};
var fS = 0;
var mS = 1;
var gS = 2;
var vS = 3;
var yS = 4;
var xS = 5;
var bS = 6;
var wS = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array };
var _S = { 9728: xr, 9729: Mr, 9984: br, 9985: Tr, 9986: _r, 9987: Ar };
var SS = { 33071: vr, 33648: yr, 10497: gr };
var MS = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 };
var TS = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv2", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" };
var ES = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" };
var AS = { CUBICSPLINE: void 0, LINEAR: Cs, STEP: As };
var CS = "OPAQUE";
var RS = "MASK";
var PS = "BLEND";
function LS(t6) {
  return void 0 === t6.DefaultMaterial && (t6.DefaultMaterial = new tm({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: false, depthTest: true, side: bn })), t6.DefaultMaterial;
}
function IS(t6, e2, i2) {
  for (const n2 in i2.extensions) void 0 === t6[n2] && (e2.userData.gltfExtensions = e2.userData.gltfExtensions || {}, e2.userData.gltfExtensions[n2] = i2.extensions[n2]);
}
function DS(t6, e2) {
  void 0 !== e2.extras && ("object" == typeof e2.extras ? Object.assign(t6.userData, e2.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e2.extras));
}
function OS(t6, e2) {
  if (t6.updateMorphTargets(), void 0 !== e2.weights) for (let i2 = 0, n2 = e2.weights.length; i2 < n2; i2++) t6.morphTargetInfluences[i2] = e2.weights[i2];
  if (e2.extras && Array.isArray(e2.extras.targetNames)) {
    const i2 = e2.extras.targetNames;
    if (t6.morphTargetInfluences.length === i2.length) {
      t6.morphTargetDictionary = {};
      for (let e3 = 0, n2 = i2.length; e3 < n2; e3++) t6.morphTargetDictionary[i2[e3]] = e3;
    } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function zS(t6) {
  const e2 = t6.extensions && t6.extensions[V_.KHR_DRACO_MESH_COMPRESSION];
  let i2;
  return i2 = e2 ? "draco:" + e2.bufferView + ":" + e2.indices + ":" + FS(e2.attributes) : t6.indices + ":" + FS(t6.attributes) + ":" + t6.mode, i2;
}
function FS(t6) {
  let e2 = "";
  const i2 = Object.keys(t6).sort();
  for (let n2 = 0, r2 = i2.length; n2 < r2; n2++) e2 += i2[n2] + ":" + t6[i2[n2]] + ";";
  return e2;
}
function NS(t6) {
  switch (t6) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
var BS = class {
  constructor(t6 = {}, e2 = {}) {
    this.json = t6, this.extensions = {}, this.plugins = {}, this.options = e2, this.cache = new H_(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    const i2 = true === /^((?!chrome|android).)*safari/i.test(navigator.userAgent), n2 = navigator.userAgent.indexOf("Firefox") > -1, r2 = n2 ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
    "undefined" == typeof createImageBitmap || i2 || n2 && r2 < 98 ? this.textureLoader = new Hm(this.options.manager) : this.textureLoader = new mg(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new zm(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(true);
  }
  setExtensions(t6) {
    this.extensions = t6;
  }
  setPlugins(t6) {
    this.plugins = t6;
  }
  parse(t6, e2) {
    const i2 = this, n2 = this.json, r2 = this.extensions;
    this.cache.removeAll(), this._invokeAll((function(t7) {
      return t7._markDefs && t7._markDefs();
    })), Promise.all(this._invokeAll((function(t7) {
      return t7.beforeRoot && t7.beforeRoot();
    }))).then((function() {
      return Promise.all([i2.getDependencies("scene"), i2.getDependencies("animation"), i2.getDependencies("camera")]);
    })).then((function(e3) {
      const s2 = { scene: e3[0][n2.scene || 0], scenes: e3[0], animations: e3[1], cameras: e3[2], asset: n2.asset, parser: i2, userData: {} };
      IS(r2, s2, n2), DS(s2, n2), Promise.all(i2._invokeAll((function(t7) {
        return t7.afterRoot && t7.afterRoot(s2);
      }))).then((function() {
        t6(s2);
      }));
    })).catch(e2);
  }
  _markDefs() {
    const t6 = this.json.nodes || [], e2 = this.json.skins || [], i2 = this.json.meshes || [];
    for (let i3 = 0, n2 = e2.length; i3 < n2; i3++) {
      const n3 = e2[i3].joints;
      for (let e3 = 0, i4 = n3.length; e3 < i4; e3++) t6[n3[e3]].isBone = true;
    }
    for (let e3 = 0, n2 = t6.length; e3 < n2; e3++) {
      const n3 = t6[e3];
      void 0 !== n3.mesh && (this._addNodeRef(this.meshCache, n3.mesh), void 0 !== n3.skin && (i2[n3.mesh].isSkinnedMesh = true)), void 0 !== n3.camera && this._addNodeRef(this.cameraCache, n3.camera);
    }
  }
  _addNodeRef(t6, e2) {
    void 0 !== e2 && (void 0 === t6.refs[e2] && (t6.refs[e2] = t6.uses[e2] = 0), t6.refs[e2]++);
  }
  _getNodeRef(t6, e2, i2) {
    if (t6.refs[e2] <= 1) return i2;
    const n2 = i2.clone(), r2 = (t7, e3) => {
      const i3 = this.associations.get(t7);
      null != i3 && this.associations.set(e3, i3);
      for (const [i4, n3] of t7.children.entries()) r2(n3, e3.children[i4]);
    };
    return r2(i2, n2), n2.name += "_instance_" + t6.uses[e2]++, n2;
  }
  _invokeOne(t6) {
    const e2 = Object.values(this.plugins);
    e2.push(this);
    for (let i2 = 0; i2 < e2.length; i2++) {
      const n2 = t6(e2[i2]);
      if (n2) return n2;
    }
    return null;
  }
  _invokeAll(t6) {
    const e2 = Object.values(this.plugins);
    e2.unshift(this);
    const i2 = [];
    for (let n2 = 0; n2 < e2.length; n2++) {
      const r2 = t6(e2[n2]);
      r2 && i2.push(r2);
    }
    return i2;
  }
  getDependency(t6, e2) {
    const i2 = t6 + ":" + e2;
    let n2 = this.cache.get(i2);
    if (!n2) {
      switch (t6) {
        case "scene":
          n2 = this.loadScene(e2);
          break;
        case "node":
          n2 = this.loadNode(e2);
          break;
        case "mesh":
          n2 = this._invokeOne((function(t7) {
            return t7.loadMesh && t7.loadMesh(e2);
          }));
          break;
        case "accessor":
          n2 = this.loadAccessor(e2);
          break;
        case "bufferView":
          n2 = this._invokeOne((function(t7) {
            return t7.loadBufferView && t7.loadBufferView(e2);
          }));
          break;
        case "buffer":
          n2 = this.loadBuffer(e2);
          break;
        case "material":
          n2 = this._invokeOne((function(t7) {
            return t7.loadMaterial && t7.loadMaterial(e2);
          }));
          break;
        case "texture":
          n2 = this._invokeOne((function(t7) {
            return t7.loadTexture && t7.loadTexture(e2);
          }));
          break;
        case "skin":
          n2 = this.loadSkin(e2);
          break;
        case "animation":
          n2 = this._invokeOne((function(t7) {
            return t7.loadAnimation && t7.loadAnimation(e2);
          }));
          break;
        case "camera":
          n2 = this.loadCamera(e2);
          break;
        default:
          throw new Error("Unknown type: " + t6);
      }
      this.cache.add(i2, n2);
    }
    return n2;
  }
  getDependencies(t6) {
    let e2 = this.cache.get(t6);
    if (!e2) {
      const i2 = this, n2 = this.json[t6 + ("mesh" === t6 ? "es" : "s")] || [];
      e2 = Promise.all(n2.map((function(e3, n3) {
        return i2.getDependency(t6, n3);
      }))), this.cache.add(t6, e2);
    }
    return e2;
  }
  loadBuffer(t6) {
    const e2 = this.json.buffers[t6], i2 = this.fileLoader;
    if (e2.type && "arraybuffer" !== e2.type) throw new Error("THREE.GLTFLoader: " + e2.type + " buffer type is not supported.");
    if (void 0 === e2.uri && 0 === t6) return Promise.resolve(this.extensions[V_.KHR_BINARY_GLTF].body);
    const n2 = this.options;
    return new Promise((function(t7, r2) {
      i2.load(lg.resolveURL(e2.uri, n2.path), t7, void 0, (function() {
        r2(new Error('THREE.GLTFLoader: Failed to load buffer "' + e2.uri + '".'));
      }));
    }));
  }
  loadBufferView(t6) {
    const e2 = this.json.bufferViews[t6];
    return this.getDependency("buffer", e2.buffer).then((function(t7) {
      const i2 = e2.byteLength || 0, n2 = e2.byteOffset || 0;
      return t7.slice(n2, n2 + i2);
    }));
  }
  loadAccessor(t6) {
    const e2 = this, i2 = this.json, n2 = this.json.accessors[t6];
    if (void 0 === n2.bufferView && void 0 === n2.sparse) return Promise.resolve(null);
    const r2 = [];
    return void 0 !== n2.bufferView ? r2.push(this.getDependency("bufferView", n2.bufferView)) : r2.push(null), void 0 !== n2.sparse && (r2.push(this.getDependency("bufferView", n2.sparse.indices.bufferView)), r2.push(this.getDependency("bufferView", n2.sparse.values.bufferView))), Promise.all(r2).then((function(t7) {
      const r3 = t7[0], s2 = MS[n2.type], o2 = wS[n2.componentType], a2 = o2.BYTES_PER_ELEMENT, l2 = a2 * s2, c2 = n2.byteOffset || 0, h2 = void 0 !== n2.bufferView ? i2.bufferViews[n2.bufferView].byteStride : void 0, u2 = true === n2.normalized;
      let d2, p2;
      if (h2 && h2 !== l2) {
        const t8 = Math.floor(c2 / h2), i3 = "InterleavedBuffer:" + n2.bufferView + ":" + n2.componentType + ":" + t8 + ":" + n2.count;
        let l3 = e2.cache.get(i3);
        l3 || (d2 = new o2(r3, t8 * h2, n2.count * h2 / a2), l3 = new wd(d2, h2 / a2), e2.cache.add(i3, l3)), p2 = new Sd(l3, s2, c2 % h2 / a2, u2);
      } else d2 = null === r3 ? new o2(n2.count * s2) : new o2(r3, c2, n2.count * s2), p2 = new Il(d2, s2, u2);
      if (void 0 !== n2.sparse) {
        const e3 = MS.SCALAR, i3 = wS[n2.sparse.indices.componentType], a3 = n2.sparse.indices.byteOffset || 0, l3 = n2.sparse.values.byteOffset || 0, c3 = new i3(t7[1], a3, n2.sparse.count * e3), h3 = new o2(t7[2], l3, n2.sparse.count * s2);
        null !== r3 && (p2 = new Il(p2.array.slice(), p2.itemSize, p2.normalized));
        for (let t8 = 0, e4 = c3.length; t8 < e4; t8++) {
          const e5 = c3[t8];
          if (p2.setX(e5, h3[t8 * s2]), s2 >= 2 && p2.setY(e5, h3[t8 * s2 + 1]), s2 >= 3 && p2.setZ(e5, h3[t8 * s2 + 2]), s2 >= 4 && p2.setW(e5, h3[t8 * s2 + 3]), s2 >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return p2;
    }));
  }
  loadTexture(t6) {
    const e2 = this.json, i2 = this.options, n2 = e2.textures[t6].source, r2 = e2.images[n2];
    let s2 = this.textureLoader;
    if (r2.uri) {
      const t7 = i2.manager.getHandler(r2.uri);
      null !== t7 && (s2 = t7);
    }
    return this.loadTextureImage(t6, n2, s2);
  }
  loadTextureImage(t6, e2, i2) {
    const n2 = this, r2 = this.json, s2 = r2.textures[t6], o2 = r2.images[e2], a2 = (o2.uri || o2.bufferView) + ":" + s2.sampler;
    if (this.textureCache[a2]) return this.textureCache[a2];
    const l2 = this.loadImageSource(e2, i2).then((function(e3) {
      e3.flipY = false, s2.name && (e3.name = s2.name);
      const i3 = (r2.samplers || {})[s2.sampler] || {};
      return e3.magFilter = _S[i3.magFilter] || Mr, e3.minFilter = _S[i3.minFilter] || Ar, e3.wrapS = SS[i3.wrapS] || gr, e3.wrapT = SS[i3.wrapT] || gr, n2.associations.set(e3, { textures: t6 }), e3;
    })).catch((function() {
      return null;
    }));
    return this.textureCache[a2] = l2, l2;
  }
  loadImageSource(t6, e2) {
    const i2 = this, n2 = this.json, r2 = this.options;
    if (void 0 !== this.sourceCache[t6]) return this.sourceCache[t6].then(((t7) => t7.clone()));
    const s2 = n2.images[t6], o2 = self.URL || self.webkitURL;
    let a2 = s2.uri || "", l2 = false;
    if (void 0 !== s2.bufferView) a2 = i2.getDependency("bufferView", s2.bufferView).then((function(t7) {
      l2 = true;
      const e3 = new Blob([t7], { type: s2.mimeType });
      return a2 = o2.createObjectURL(e3), a2;
    }));
    else if (void 0 === s2.uri) throw new Error("THREE.GLTFLoader: Image " + t6 + " is missing URI and bufferView");
    const c2 = Promise.resolve(a2).then((function(t7) {
      return new Promise((function(i3, n3) {
        let s3 = i3;
        true === e2.isImageBitmapLoader && (s3 = function(t8) {
          const e3 = new ra(t8);
          e3.needsUpdate = true, i3(e3);
        }), e2.load(lg.resolveURL(t7, r2.path), s3, void 0, n3);
      }));
    })).then((function(t7) {
      var e3;
      return true === l2 && o2.revokeObjectURL(a2), t7.userData.mimeType = s2.mimeType || ((e3 = s2.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === e3.search(/^data\:image\/jpeg/) ? "image/jpeg" : e3.search(/\.webp($|\?)/i) > 0 || 0 === e3.search(/^data\:image\/webp/) ? "image/webp" : "image/png"), t7;
    })).catch((function(t7) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", a2), t7;
    }));
    return this.sourceCache[t6] = c2, c2;
  }
  assignTexture(t6, e2, i2, n2) {
    const r2 = this;
    return this.getDependency("texture", i2.index).then((function(s2) {
      if (void 0 === i2.texCoord || 0 == i2.texCoord || "aoMap" === e2 && 1 == i2.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + i2.texCoord + " for texture " + e2 + " not yet supported."), r2.extensions[V_.KHR_TEXTURE_TRANSFORM]) {
        const t7 = void 0 !== i2.extensions ? i2.extensions[V_.KHR_TEXTURE_TRANSFORM] : void 0;
        if (t7) {
          const e3 = r2.associations.get(s2);
          s2 = r2.extensions[V_.KHR_TEXTURE_TRANSFORM].extendTexture(s2, t7), r2.associations.set(s2, e3);
        }
      }
      return void 0 !== n2 && (s2.encoding = n2), t6[e2] = s2, s2;
    }));
  }
  assignFinalMaterial(t6) {
    const e2 = t6.geometry;
    let i2 = t6.material;
    const n2 = void 0 === e2.attributes.tangent, r2 = void 0 !== e2.attributes.color, s2 = void 0 === e2.attributes.normal;
    if (t6.isPoints) {
      const t7 = "PointsMaterial:" + i2.uuid;
      let e3 = this.cache.get(t7);
      e3 || (e3 = new vp(), Cl.prototype.copy.call(e3, i2), e3.color.copy(i2.color), e3.map = i2.map, e3.sizeAttenuation = false, this.cache.add(t7, e3)), i2 = e3;
    } else if (t6.isLine) {
      const t7 = "LineBasicMaterial:" + i2.uuid;
      let e3 = this.cache.get(t7);
      e3 || (e3 = new op(), Cl.prototype.copy.call(e3, i2), e3.color.copy(i2.color), this.cache.add(t7, e3)), i2 = e3;
    }
    if (n2 || r2 || s2) {
      let t7 = "ClonedMaterial:" + i2.uuid + ":";
      i2.isGLTFSpecularGlossinessMaterial && (t7 += "specular-glossiness:"), n2 && (t7 += "derivative-tangents:"), r2 && (t7 += "vertex-colors:"), s2 && (t7 += "flat-shading:");
      let e3 = this.cache.get(t7);
      e3 || (e3 = i2.clone(), r2 && (e3.vertexColors = true), s2 && (e3.flatShading = true), n2 && (e3.normalScale && (e3.normalScale.y *= -1), e3.clearcoatNormalScale && (e3.clearcoatNormalScale.y *= -1)), this.cache.add(t7, e3), this.associations.set(e3, this.associations.get(i2))), i2 = e3;
    }
    i2.aoMap && void 0 === e2.attributes.uv2 && void 0 !== e2.attributes.uv && e2.setAttribute("uv2", e2.attributes.uv), t6.material = i2;
  }
  getMaterialType() {
    return tm;
  }
  loadMaterial(t6) {
    const e2 = this, i2 = this.json, n2 = this.extensions, r2 = i2.materials[t6];
    let s2;
    const o2 = {}, a2 = r2.extensions || {}, l2 = [];
    if (a2[V_.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
      const t7 = n2[V_.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
      s2 = t7.getMaterialType(), l2.push(t7.extendParams(o2, r2, e2));
    } else if (a2[V_.KHR_MATERIALS_UNLIT]) {
      const t7 = n2[V_.KHR_MATERIALS_UNLIT];
      s2 = t7.getMaterialType(), l2.push(t7.extendParams(o2, r2, e2));
    } else {
      const i3 = r2.pbrMetallicRoughness || {};
      if (o2.color = new $o(1, 1, 1), o2.opacity = 1, Array.isArray(i3.baseColorFactor)) {
        const t7 = i3.baseColorFactor;
        o2.color.fromArray(t7), o2.opacity = t7[3];
      }
      void 0 !== i3.baseColorTexture && l2.push(e2.assignTexture(o2, "map", i3.baseColorTexture, ks)), o2.metalness = void 0 !== i3.metallicFactor ? i3.metallicFactor : 1, o2.roughness = void 0 !== i3.roughnessFactor ? i3.roughnessFactor : 1, void 0 !== i3.metallicRoughnessTexture && (l2.push(e2.assignTexture(o2, "metalnessMap", i3.metallicRoughnessTexture)), l2.push(e2.assignTexture(o2, "roughnessMap", i3.metallicRoughnessTexture))), s2 = this._invokeOne((function(e3) {
        return e3.getMaterialType && e3.getMaterialType(t6);
      })), l2.push(Promise.all(this._invokeAll((function(e3) {
        return e3.extendMaterialParams && e3.extendMaterialParams(t6, o2);
      }))));
    }
    true === r2.doubleSided && (o2.side = _n);
    const c2 = r2.alphaMode || CS;
    if (c2 === PS ? (o2.transparent = true, o2.depthWrite = false) : (o2.transparent = false, c2 === RS && (o2.alphaTest = void 0 !== r2.alphaCutoff ? r2.alphaCutoff : 0.5)), void 0 !== r2.normalTexture && s2 !== Rl && (l2.push(e2.assignTexture(o2, "normalMap", r2.normalTexture)), o2.normalScale = new Fo(1, 1), void 0 !== r2.normalTexture.scale)) {
      const t7 = r2.normalTexture.scale;
      o2.normalScale.set(t7, t7);
    }
    return void 0 !== r2.occlusionTexture && s2 !== Rl && (l2.push(e2.assignTexture(o2, "aoMap", r2.occlusionTexture)), void 0 !== r2.occlusionTexture.strength && (o2.aoMapIntensity = r2.occlusionTexture.strength)), void 0 !== r2.emissiveFactor && s2 !== Rl && (o2.emissive = new $o().fromArray(r2.emissiveFactor)), void 0 !== r2.emissiveTexture && s2 !== Rl && l2.push(e2.assignTexture(o2, "emissiveMap", r2.emissiveTexture, ks)), Promise.all(l2).then((function() {
      let i3;
      return i3 = s2 === lS ? n2[V_.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(o2) : new s2(o2), r2.name && (i3.name = r2.name), DS(i3, r2), e2.associations.set(i3, { materials: t6 }), r2.extensions && IS(n2, i3, r2), i3;
    }));
  }
  createUniqueName(t6) {
    const e2 = qg.sanitizeNodeName(t6 || "");
    let i2 = e2;
    for (let t7 = 1; this.nodeNamesUsed[i2]; ++t7) i2 = e2 + "_" + t7;
    return this.nodeNamesUsed[i2] = true, i2;
  }
  loadGeometries(t6) {
    const e2 = this, i2 = this.extensions, n2 = this.primitiveCache;
    function r2(t7) {
      return i2[V_.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t7, e2).then((function(i3) {
        return US(i3, t7, e2);
      }));
    }
    const s2 = [];
    for (let i3 = 0, o2 = t6.length; i3 < o2; i3++) {
      const o3 = t6[i3], a2 = zS(o3), l2 = n2[a2];
      if (l2) s2.push(l2.promise);
      else {
        let t7;
        t7 = o3.extensions && o3.extensions[V_.KHR_DRACO_MESH_COMPRESSION] ? r2(o3) : US(new Jl(), o3, e2), n2[a2] = { primitive: o3, promise: t7 }, s2.push(t7);
      }
    }
    return Promise.all(s2);
  }
  loadMesh(t6) {
    const e2 = this, i2 = this.json, n2 = this.extensions, r2 = i2.meshes[t6], s2 = r2.primitives, o2 = [];
    for (let t7 = 0, e3 = s2.length; t7 < e3; t7++) {
      const e4 = void 0 === s2[t7].material ? LS(this.cache) : this.getDependency("material", s2[t7].material);
      o2.push(e4);
    }
    return o2.push(e2.loadGeometries(s2)), Promise.all(o2).then((function(i3) {
      const o3 = i3.slice(0, i3.length - 1), a2 = i3[i3.length - 1], l2 = [];
      for (let i4 = 0, c3 = a2.length; i4 < c3; i4++) {
        const c4 = a2[i4], h2 = s2[i4];
        let u2;
        const d2 = o3[i4];
        if (h2.mode === yS || h2.mode === xS || h2.mode === bS || void 0 === h2.mode) u2 = true === r2.isSkinnedMesh ? new Yd(c4, d2) : new fc(c4, d2), true !== u2.isSkinnedMesh || u2.geometry.attributes.skinWeight.normalized || u2.normalizeSkinWeights(), h2.mode === xS ? u2.geometry = HS(u2.geometry, Fs) : h2.mode === bS && (u2.geometry = HS(u2.geometry, Ns));
        else if (h2.mode === mS) u2 = new mp(c4, d2);
        else if (h2.mode === vS) u2 = new dp(c4, d2);
        else if (h2.mode === gS) u2 = new gp(c4, d2);
        else {
          if (h2.mode !== fS) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + h2.mode);
          u2 = new _p(c4, d2);
        }
        Object.keys(u2.geometry.morphAttributes).length > 0 && OS(u2, r2), u2.name = e2.createUniqueName(r2.name || "mesh_" + t6), DS(u2, r2), h2.extensions && IS(n2, u2, h2), e2.assignFinalMaterial(u2), l2.push(u2);
      }
      for (let i4 = 0, n3 = l2.length; i4 < n3; i4++) e2.associations.set(l2[i4], { meshes: t6, primitives: i4 });
      if (1 === l2.length) return l2[0];
      const c2 = new cd();
      e2.associations.set(c2, { meshes: t6 });
      for (let t7 = 0, e3 = l2.length; t7 < e3; t7++) c2.add(l2[t7]);
      return c2;
    }));
  }
  loadCamera(t6) {
    let e2;
    const i2 = this.json.cameras[t6], n2 = i2[i2.type];
    if (n2) return "perspective" === i2.type ? e2 = new _c(zo.radToDeg(n2.yfov), n2.aspectRatio || 1, n2.znear || 1, n2.zfar || 2e6) : "orthographic" === i2.type && (e2 = new qc(-n2.xmag, n2.xmag, n2.ymag, -n2.ymag, n2.znear, n2.zfar)), i2.name && (e2.name = this.createUniqueName(i2.name)), DS(e2, i2), Promise.resolve(e2);
    console.warn("THREE.GLTFLoader: Missing camera parameters.");
  }
  loadSkin(t6) {
    const e2 = this.json.skins[t6], i2 = { joints: e2.joints };
    return void 0 === e2.inverseBindMatrices ? Promise.resolve(i2) : this.getDependency("accessor", e2.inverseBindMatrices).then((function(t7) {
      return i2.inverseBindMatrices = t7, i2;
    }));
  }
  loadAnimation(t6) {
    const e2 = this.json.animations[t6], i2 = [], n2 = [], r2 = [], s2 = [], o2 = [];
    for (let t7 = 0, a2 = e2.channels.length; t7 < a2; t7++) {
      const a3 = e2.channels[t7], l2 = e2.samplers[a3.sampler], c2 = a3.target, h2 = void 0 !== c2.node ? c2.node : c2.id, u2 = void 0 !== e2.parameters ? e2.parameters[l2.input] : l2.input, d2 = void 0 !== e2.parameters ? e2.parameters[l2.output] : l2.output;
      i2.push(this.getDependency("node", h2)), n2.push(this.getDependency("accessor", u2)), r2.push(this.getDependency("accessor", d2)), s2.push(l2), o2.push(c2);
    }
    return Promise.all([Promise.all(i2), Promise.all(n2), Promise.all(r2), Promise.all(s2), Promise.all(o2)]).then((function(i3) {
      const n3 = i3[0], r3 = i3[1], s3 = i3[2], o3 = i3[3], a2 = i3[4], l2 = [];
      for (let t7 = 0, e3 = n3.length; t7 < e3; t7++) {
        const e4 = n3[t7], i4 = r3[t7], c3 = s3[t7], h2 = o3[t7], u2 = a2[t7];
        if (void 0 === e4) continue;
        let d2;
        switch (e4.updateMatrix(), ES[u2.path]) {
          case ES.weights:
            d2 = _m;
            break;
          case ES.rotation:
            d2 = Mm;
            break;
          default:
            d2 = Em;
        }
        const p2 = e4.name ? e4.name : e4.uuid, f2 = void 0 !== h2.interpolation ? AS[h2.interpolation] : Cs, m2 = [];
        ES[u2.path] === ES.weights ? e4.traverse((function(t8) {
          t8.morphTargetInfluences && m2.push(t8.name ? t8.name : t8.uuid);
        })) : m2.push(p2);
        let g2 = c3.array;
        if (c3.normalized) {
          const t8 = NS(g2.constructor), e5 = new Float32Array(g2.length);
          for (let i5 = 0, n4 = g2.length; i5 < n4; i5++) e5[i5] = g2[i5] * t8;
          g2 = e5;
        }
        for (let t8 = 0, e5 = m2.length; t8 < e5; t8++) {
          const e6 = new d2(m2[t8] + "." + ES[u2.path], i4.array, g2, f2);
          "CUBICSPLINE" === h2.interpolation && (e6.createInterpolant = function(t9) {
            return new (this instanceof Mm ? pS : uS)(this.times, this.values, this.getValueSize() / 3, t9);
          }, e6.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true), l2.push(e6);
        }
      }
      const c2 = e2.name ? e2.name : "animation_" + t6;
      return new Am(c2, void 0, l2);
    }));
  }
  createNodeMesh(t6) {
    const e2 = this.json, i2 = this, n2 = e2.nodes[t6];
    return void 0 === n2.mesh ? null : i2.getDependency("mesh", n2.mesh).then((function(t7) {
      const e3 = i2._getNodeRef(i2.meshCache, n2.mesh, t7);
      return void 0 !== n2.weights && e3.traverse((function(t8) {
        if (t8.isMesh) for (let e4 = 0, i3 = n2.weights.length; e4 < i3; e4++) t8.morphTargetInfluences[e4] = n2.weights[e4];
      })), e3;
    }));
  }
  loadNode(t6) {
    const e2 = this.json, i2 = this.extensions, n2 = this, r2 = e2.nodes[t6], s2 = r2.name ? n2.createUniqueName(r2.name) : "";
    return (function() {
      const e3 = [], i3 = n2._invokeOne((function(e4) {
        return e4.createNodeMesh && e4.createNodeMesh(t6);
      }));
      return i3 && e3.push(i3), void 0 !== r2.camera && e3.push(n2.getDependency("camera", r2.camera).then((function(t7) {
        return n2._getNodeRef(n2.cameraCache, r2.camera, t7);
      }))), n2._invokeAll((function(e4) {
        return e4.createNodeAttachment && e4.createNodeAttachment(t6);
      })).forEach((function(t7) {
        e3.push(t7);
      })), Promise.all(e3);
    })().then((function(e3) {
      let o2;
      if (o2 = true === r2.isBone ? new Zd() : e3.length > 1 ? new cd() : 1 === e3.length ? e3[0] : new ml(), o2 !== e3[0]) for (let t7 = 0, i3 = e3.length; t7 < i3; t7++) o2.add(e3[t7]);
      if (r2.name && (o2.userData.name = r2.name, o2.name = s2), DS(o2, r2), r2.extensions && IS(i2, o2, r2), void 0 !== r2.matrix) {
        const t7 = new Ga();
        t7.fromArray(r2.matrix), o2.applyMatrix4(t7);
      } else void 0 !== r2.translation && o2.position.fromArray(r2.translation), void 0 !== r2.rotation && o2.quaternion.fromArray(r2.rotation), void 0 !== r2.scale && o2.scale.fromArray(r2.scale);
      return n2.associations.has(o2) || n2.associations.set(o2, {}), n2.associations.get(o2).nodes = t6, o2;
    }));
  }
  loadScene(t6) {
    const e2 = this.json, i2 = this.extensions, n2 = this.json.scenes[t6], r2 = this, s2 = new cd();
    n2.name && (s2.name = r2.createUniqueName(n2.name)), DS(s2, n2), n2.extensions && IS(i2, s2, n2);
    const o2 = n2.nodes || [], a2 = [];
    for (let t7 = 0, i3 = o2.length; t7 < i3; t7++) a2.push(kS(o2[t7], s2, e2, r2));
    return Promise.all(a2).then((function() {
      return r2.associations = ((t7) => {
        const e3 = /* @__PURE__ */ new Map();
        for (const [t8, i3] of r2.associations) (t8 instanceof Cl || t8 instanceof ra) && e3.set(t8, i3);
        return t7.traverse(((t8) => {
          const i3 = r2.associations.get(t8);
          null != i3 && e3.set(t8, i3);
        })), e3;
      })(s2), s2;
    }));
  }
};
function kS(t6, e2, i2, n2) {
  const r2 = i2.nodes[t6];
  return n2.getDependency("node", t6).then((function(t7) {
    if (void 0 === r2.skin) return t7;
    let e3;
    return n2.getDependency("skin", r2.skin).then((function(t8) {
      e3 = t8;
      const i3 = [];
      for (let t9 = 0, r3 = e3.joints.length; t9 < r3; t9++) i3.push(n2.getDependency("node", e3.joints[t9]));
      return Promise.all(i3);
    })).then((function(i3) {
      return t7.traverse((function(t8) {
        if (!t8.isMesh) return;
        const n3 = [], r3 = [];
        for (let t9 = 0, s2 = i3.length; t9 < s2; t9++) {
          const s3 = i3[t9];
          if (s3) {
            n3.push(s3);
            const i4 = new Ga();
            void 0 !== e3.inverseBindMatrices && i4.fromArray(e3.inverseBindMatrices.array, 16 * t9), r3.push(i4);
          } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e3.joints[t9]);
        }
        t8.bind(new Qd(n3, r3), t8.matrixWorld);
      })), t7;
    }));
  })).then((function(t7) {
    e2.add(t7);
    const s2 = [];
    if (r2.children) {
      const e3 = r2.children;
      for (let r3 = 0, o2 = e3.length; r3 < o2; r3++) {
        const o3 = e3[r3];
        s2.push(kS(o3, t7, i2, n2));
      }
    }
    return Promise.all(s2);
  }));
}
function US(t6, e2, i2) {
  const n2 = e2.attributes, r2 = [];
  function s2(e3, n3) {
    return i2.getDependency("accessor", e3).then((function(e4) {
      t6.setAttribute(n3, e4);
    }));
  }
  for (const e3 in n2) {
    const i3 = TS[e3] || e3.toLowerCase();
    i3 in t6.attributes || r2.push(s2(n2[e3], i3));
  }
  if (void 0 !== e2.indices && !t6.index) {
    const n3 = i2.getDependency("accessor", e2.indices).then((function(e3) {
      t6.setIndex(e3);
    }));
    r2.push(n3);
  }
  return DS(t6, e2), (function(t7, e3, i3) {
    const n3 = e3.attributes, r3 = new ga();
    if (void 0 === n3.POSITION) return;
    {
      const t8 = i3.json.accessors[n3.POSITION], e4 = t8.min, s4 = t8.max;
      if (void 0 === e4 || void 0 === s4) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      if (r3.set(new pa(e4[0], e4[1], e4[2]), new pa(s4[0], s4[1], s4[2])), t8.normalized) {
        const e5 = NS(wS[t8.componentType]);
        r3.min.multiplyScalar(e5), r3.max.multiplyScalar(e5);
      }
    }
    const s3 = e3.targets;
    if (void 0 !== s3) {
      const t8 = new pa(), e4 = new pa();
      for (let n4 = 0, r4 = s3.length; n4 < r4; n4++) {
        const r5 = s3[n4];
        if (void 0 !== r5.POSITION) {
          const n5 = i3.json.accessors[r5.POSITION], s4 = n5.min, o3 = n5.max;
          if (void 0 !== s4 && void 0 !== o3) {
            if (e4.setX(Math.max(Math.abs(s4[0]), Math.abs(o3[0]))), e4.setY(Math.max(Math.abs(s4[1]), Math.abs(o3[1]))), e4.setZ(Math.max(Math.abs(s4[2]), Math.abs(o3[2]))), n5.normalized) {
              const t9 = NS(wS[n5.componentType]);
              e4.multiplyScalar(t9);
            }
            t8.max(e4);
          } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        }
      }
      r3.expandByVector(t8);
    }
    t7.boundingBox = r3;
    const o2 = new za();
    r3.getCenter(o2.center), o2.radius = r3.min.distanceTo(r3.max) / 2, t7.boundingSphere = o2;
  })(t6, e2, i2), Promise.all(r2).then((function() {
    return void 0 !== e2.targets ? (function(t7, e3, i3) {
      let n3 = false, r3 = false, s3 = false;
      for (let t8 = 0, i4 = e3.length; t8 < i4; t8++) {
        const i5 = e3[t8];
        if (void 0 !== i5.POSITION && (n3 = true), void 0 !== i5.NORMAL && (r3 = true), void 0 !== i5.COLOR_0 && (s3 = true), n3 && r3 && s3) break;
      }
      if (!n3 && !r3 && !s3) return Promise.resolve(t7);
      const o2 = [], a2 = [], l2 = [];
      for (let c2 = 0, h2 = e3.length; c2 < h2; c2++) {
        const h3 = e3[c2];
        if (n3) {
          const e4 = void 0 !== h3.POSITION ? i3.getDependency("accessor", h3.POSITION) : t7.attributes.position;
          o2.push(e4);
        }
        if (r3) {
          const e4 = void 0 !== h3.NORMAL ? i3.getDependency("accessor", h3.NORMAL) : t7.attributes.normal;
          a2.push(e4);
        }
        if (s3) {
          const e4 = void 0 !== h3.COLOR_0 ? i3.getDependency("accessor", h3.COLOR_0) : t7.attributes.color;
          l2.push(e4);
        }
      }
      return Promise.all([Promise.all(o2), Promise.all(a2), Promise.all(l2)]).then((function(e4) {
        const i4 = e4[0], o3 = e4[1], a3 = e4[2];
        return n3 && (t7.morphAttributes.position = i4), r3 && (t7.morphAttributes.normal = o3), s3 && (t7.morphAttributes.color = a3), t7.morphTargetsRelative = true, t7;
      }));
    })(t6, e2.targets, i2) : t6;
  }));
}
function HS(t6, e2) {
  let i2 = t6.getIndex();
  if (null === i2) {
    const e3 = [], n3 = t6.getAttribute("position");
    if (void 0 === n3) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), t6;
    for (let t7 = 0; t7 < n3.count; t7++) e3.push(t7);
    t6.setIndex(e3), i2 = t6.getIndex();
  }
  const n2 = i2.count - 2, r2 = [];
  if (e2 === Ns) for (let t7 = 1; t7 <= n2; t7++) r2.push(i2.getX(0)), r2.push(i2.getX(t7)), r2.push(i2.getX(t7 + 1));
  else for (let t7 = 0; t7 < n2; t7++) t7 % 2 == 0 ? (r2.push(i2.getX(t7)), r2.push(i2.getX(t7 + 1)), r2.push(i2.getX(t7 + 2))) : (r2.push(i2.getX(t7 + 2)), r2.push(i2.getX(t7 + 1)), r2.push(i2.getX(t7)));
  r2.length / 3 !== n2 && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
  const s2 = t6.clone();
  return s2.setIndex(r2), s2;
}
var VS = class _VS {
  constructor(t6 = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {
    this.elements = void 0, this.elements = t6;
  }
  identity() {
    const t6 = this.elements;
    t6[0] = 1, t6[1] = 0, t6[2] = 0, t6[3] = 0, t6[4] = 1, t6[5] = 0, t6[6] = 0, t6[7] = 0, t6[8] = 1;
  }
  setZero() {
    const t6 = this.elements;
    t6[0] = 0, t6[1] = 0, t6[2] = 0, t6[3] = 0, t6[4] = 0, t6[5] = 0, t6[6] = 0, t6[7] = 0, t6[8] = 0;
  }
  setTrace(t6) {
    const e2 = this.elements;
    e2[0] = t6.x, e2[4] = t6.y, e2[8] = t6.z;
  }
  getTrace(t6 = new GS()) {
    const e2 = this.elements;
    return t6.x = e2[0], t6.y = e2[4], t6.z = e2[8], t6;
  }
  vmult(t6, e2 = new GS()) {
    const i2 = this.elements, n2 = t6.x, r2 = t6.y, s2 = t6.z;
    return e2.x = i2[0] * n2 + i2[1] * r2 + i2[2] * s2, e2.y = i2[3] * n2 + i2[4] * r2 + i2[5] * s2, e2.z = i2[6] * n2 + i2[7] * r2 + i2[8] * s2, e2;
  }
  smult(t6) {
    for (let e2 = 0; e2 < this.elements.length; e2++) this.elements[e2] *= t6;
  }
  mmult(t6, e2 = new _VS()) {
    const i2 = this.elements, n2 = t6.elements, r2 = e2.elements, s2 = i2[0], o2 = i2[1], a2 = i2[2], l2 = i2[3], c2 = i2[4], h2 = i2[5], u2 = i2[6], d2 = i2[7], p2 = i2[8], f2 = n2[0], m2 = n2[1], g2 = n2[2], v2 = n2[3], y2 = n2[4], x2 = n2[5], b2 = n2[6], w2 = n2[7], _2 = n2[8];
    return r2[0] = s2 * f2 + o2 * v2 + a2 * b2, r2[1] = s2 * m2 + o2 * y2 + a2 * w2, r2[2] = s2 * g2 + o2 * x2 + a2 * _2, r2[3] = l2 * f2 + c2 * v2 + h2 * b2, r2[4] = l2 * m2 + c2 * y2 + h2 * w2, r2[5] = l2 * g2 + c2 * x2 + h2 * _2, r2[6] = u2 * f2 + d2 * v2 + p2 * b2, r2[7] = u2 * m2 + d2 * y2 + p2 * w2, r2[8] = u2 * g2 + d2 * x2 + p2 * _2, e2;
  }
  scale(t6, e2 = new _VS()) {
    const i2 = this.elements, n2 = e2.elements;
    for (let e3 = 0; 3 !== e3; e3++) n2[3 * e3 + 0] = t6.x * i2[3 * e3 + 0], n2[3 * e3 + 1] = t6.y * i2[3 * e3 + 1], n2[3 * e3 + 2] = t6.z * i2[3 * e3 + 2];
    return e2;
  }
  solve(t6, e2 = new GS()) {
    const i2 = [];
    let n2, r2;
    for (n2 = 0; n2 < 12; n2++) i2.push(0);
    for (n2 = 0; n2 < 3; n2++) for (r2 = 0; r2 < 3; r2++) i2[n2 + 4 * r2] = this.elements[n2 + 3 * r2];
    i2[3] = t6.x, i2[7] = t6.y, i2[11] = t6.z;
    let s2 = 3;
    const o2 = s2;
    let a2;
    let l2;
    do {
      if (n2 = o2 - s2, 0 === i2[n2 + 4 * n2]) {
        for (r2 = n2 + 1; r2 < o2; r2++) if (0 !== i2[n2 + 4 * r2]) {
          a2 = 4;
          do {
            l2 = 4 - a2, i2[l2 + 4 * n2] += i2[l2 + 4 * r2];
          } while (--a2);
          break;
        }
      }
      if (0 !== i2[n2 + 4 * n2]) for (r2 = n2 + 1; r2 < o2; r2++) {
        const t7 = i2[n2 + 4 * r2] / i2[n2 + 4 * n2];
        a2 = 4;
        do {
          l2 = 4 - a2, i2[l2 + 4 * r2] = l2 <= n2 ? 0 : i2[l2 + 4 * r2] - i2[l2 + 4 * n2] * t7;
        } while (--a2);
      }
    } while (--s2);
    if (e2.z = i2[11] / i2[10], e2.y = (i2[7] - i2[6] * e2.z) / i2[5], e2.x = (i2[3] - i2[2] * e2.z - i2[1] * e2.y) / i2[0], isNaN(e2.x) || isNaN(e2.y) || isNaN(e2.z) || e2.x === 1 / 0 || e2.y === 1 / 0 || e2.z === 1 / 0) throw "Could not solve equation! Got x=[" + e2.toString() + "], b=[" + t6.toString() + "], A=[" + this.toString() + "]";
    return e2;
  }
  e(t6, e2, i2) {
    if (void 0 === i2) return this.elements[e2 + 3 * t6];
    this.elements[e2 + 3 * t6] = i2;
  }
  copy(t6) {
    for (let e2 = 0; e2 < t6.elements.length; e2++) this.elements[e2] = t6.elements[e2];
    return this;
  }
  toString() {
    let t6 = "";
    for (let e2 = 0; e2 < 9; e2++) t6 += this.elements[e2] + ",";
    return t6;
  }
  reverse(t6 = new _VS()) {
    const e2 = jS;
    let i2, n2;
    for (i2 = 0; i2 < 3; i2++) for (n2 = 0; n2 < 3; n2++) e2[i2 + 6 * n2] = this.elements[i2 + 3 * n2];
    e2[3] = 1, e2[9] = 0, e2[15] = 0, e2[4] = 0, e2[10] = 1, e2[16] = 0, e2[5] = 0, e2[11] = 0, e2[17] = 1;
    let r2 = 3;
    const s2 = r2;
    let o2;
    let a2;
    do {
      if (i2 = s2 - r2, 0 === e2[i2 + 6 * i2]) {
        for (n2 = i2 + 1; n2 < s2; n2++) if (0 !== e2[i2 + 6 * n2]) {
          o2 = 6;
          do {
            a2 = 6 - o2, e2[a2 + 6 * i2] += e2[a2 + 6 * n2];
          } while (--o2);
          break;
        }
      }
      if (0 !== e2[i2 + 6 * i2]) for (n2 = i2 + 1; n2 < s2; n2++) {
        const t7 = e2[i2 + 6 * n2] / e2[i2 + 6 * i2];
        o2 = 6;
        do {
          a2 = 6 - o2, e2[a2 + 6 * n2] = a2 <= i2 ? 0 : e2[a2 + 6 * n2] - e2[a2 + 6 * i2] * t7;
        } while (--o2);
      }
    } while (--r2);
    i2 = 2;
    do {
      n2 = i2 - 1;
      do {
        const t7 = e2[i2 + 6 * n2] / e2[i2 + 6 * i2];
        o2 = 6;
        do {
          a2 = 6 - o2, e2[a2 + 6 * n2] = e2[a2 + 6 * n2] - e2[a2 + 6 * i2] * t7;
        } while (--o2);
      } while (n2--);
    } while (--i2);
    i2 = 2;
    do {
      const t7 = 1 / e2[i2 + 6 * i2];
      o2 = 6;
      do {
        a2 = 6 - o2, e2[a2 + 6 * i2] = e2[a2 + 6 * i2] * t7;
      } while (--o2);
    } while (i2--);
    i2 = 2;
    do {
      n2 = 2;
      do {
        if (a2 = e2[3 + n2 + 6 * i2], isNaN(a2) || a2 === 1 / 0) throw "Could not reverse! A=[" + this.toString() + "]";
        t6.e(i2, n2, a2);
      } while (n2--);
    } while (i2--);
    return t6;
  }
  setRotationFromQuaternion(t6) {
    const e2 = t6.x, i2 = t6.y, n2 = t6.z, r2 = t6.w, s2 = e2 + e2, o2 = i2 + i2, a2 = n2 + n2, l2 = e2 * s2, c2 = e2 * o2, h2 = e2 * a2, u2 = i2 * o2, d2 = i2 * a2, p2 = n2 * a2, f2 = r2 * s2, m2 = r2 * o2, g2 = r2 * a2, v2 = this.elements;
    return v2[0] = 1 - (u2 + p2), v2[1] = c2 - g2, v2[2] = h2 + m2, v2[3] = c2 + g2, v2[4] = 1 - (l2 + p2), v2[5] = d2 - f2, v2[6] = h2 - m2, v2[7] = d2 + f2, v2[8] = 1 - (l2 + u2), this;
  }
  transpose(t6 = new _VS()) {
    const e2 = this.elements, i2 = t6.elements;
    let n2;
    return i2[0] = e2[0], i2[4] = e2[4], i2[8] = e2[8], n2 = e2[1], i2[1] = e2[3], i2[3] = n2, n2 = e2[2], i2[2] = e2[6], i2[6] = n2, n2 = e2[5], i2[5] = e2[7], i2[7] = n2, t6;
  }
};
var jS = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
var GS = class _GS {
  constructor(t6 = 0, e2 = 0, i2 = 0) {
    this.x = void 0, this.y = void 0, this.z = void 0, this.x = t6, this.y = e2, this.z = i2;
  }
  cross(t6, e2 = new _GS()) {
    const i2 = t6.x, n2 = t6.y, r2 = t6.z, s2 = this.x, o2 = this.y, a2 = this.z;
    return e2.x = o2 * r2 - a2 * n2, e2.y = a2 * i2 - s2 * r2, e2.z = s2 * n2 - o2 * i2, e2;
  }
  set(t6, e2, i2) {
    return this.x = t6, this.y = e2, this.z = i2, this;
  }
  setZero() {
    this.x = this.y = this.z = 0;
  }
  vadd(t6, e2) {
    if (!e2) return new _GS(this.x + t6.x, this.y + t6.y, this.z + t6.z);
    e2.x = t6.x + this.x, e2.y = t6.y + this.y, e2.z = t6.z + this.z;
  }
  vsub(t6, e2) {
    if (!e2) return new _GS(this.x - t6.x, this.y - t6.y, this.z - t6.z);
    e2.x = this.x - t6.x, e2.y = this.y - t6.y, e2.z = this.z - t6.z;
  }
  crossmat() {
    return new VS([0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0]);
  }
  normalize() {
    const t6 = this.x, e2 = this.y, i2 = this.z, n2 = Math.sqrt(t6 * t6 + e2 * e2 + i2 * i2);
    if (n2 > 0) {
      const t7 = 1 / n2;
      this.x *= t7, this.y *= t7, this.z *= t7;
    } else this.x = 0, this.y = 0, this.z = 0;
    return n2;
  }
  unit(t6 = new _GS()) {
    const e2 = this.x, i2 = this.y, n2 = this.z;
    let r2 = Math.sqrt(e2 * e2 + i2 * i2 + n2 * n2);
    return r2 > 0 ? (r2 = 1 / r2, t6.x = e2 * r2, t6.y = i2 * r2, t6.z = n2 * r2) : (t6.x = 1, t6.y = 0, t6.z = 0), t6;
  }
  length() {
    const t6 = this.x, e2 = this.y, i2 = this.z;
    return Math.sqrt(t6 * t6 + e2 * e2 + i2 * i2);
  }
  lengthSquared() {
    return this.dot(this);
  }
  distanceTo(t6) {
    const e2 = this.x, i2 = this.y, n2 = this.z, r2 = t6.x, s2 = t6.y, o2 = t6.z;
    return Math.sqrt((r2 - e2) * (r2 - e2) + (s2 - i2) * (s2 - i2) + (o2 - n2) * (o2 - n2));
  }
  distanceSquared(t6) {
    const e2 = this.x, i2 = this.y, n2 = this.z, r2 = t6.x, s2 = t6.y, o2 = t6.z;
    return (r2 - e2) * (r2 - e2) + (s2 - i2) * (s2 - i2) + (o2 - n2) * (o2 - n2);
  }
  scale(t6, e2 = new _GS()) {
    const i2 = this.x, n2 = this.y, r2 = this.z;
    return e2.x = t6 * i2, e2.y = t6 * n2, e2.z = t6 * r2, e2;
  }
  vmul(t6, e2 = new _GS()) {
    return e2.x = t6.x * this.x, e2.y = t6.y * this.y, e2.z = t6.z * this.z, e2;
  }
  addScaledVector(t6, e2, i2 = new _GS()) {
    return i2.x = this.x + t6 * e2.x, i2.y = this.y + t6 * e2.y, i2.z = this.z + t6 * e2.z, i2;
  }
  dot(t6) {
    return this.x * t6.x + this.y * t6.y + this.z * t6.z;
  }
  isZero() {
    return 0 === this.x && 0 === this.y && 0 === this.z;
  }
  negate(t6 = new _GS()) {
    return t6.x = -this.x, t6.y = -this.y, t6.z = -this.z, t6;
  }
  tangents(t6, e2) {
    const i2 = this.length();
    if (i2 > 0) {
      const n2 = WS, r2 = 1 / i2;
      n2.set(this.x * r2, this.y * r2, this.z * r2);
      const s2 = qS;
      Math.abs(n2.x) < 0.9 ? (s2.set(1, 0, 0), n2.cross(s2, t6)) : (s2.set(0, 1, 0), n2.cross(s2, t6)), n2.cross(t6, e2);
    } else t6.set(1, 0, 0), e2.set(0, 1, 0);
  }
  toString() {
    return this.x + "," + this.y + "," + this.z;
  }
  toArray() {
    return [this.x, this.y, this.z];
  }
  copy(t6) {
    return this.x = t6.x, this.y = t6.y, this.z = t6.z, this;
  }
  lerp(t6, e2, i2) {
    const n2 = this.x, r2 = this.y, s2 = this.z;
    i2.x = n2 + (t6.x - n2) * e2, i2.y = r2 + (t6.y - r2) * e2, i2.z = s2 + (t6.z - s2) * e2;
  }
  almostEquals(t6, e2 = 1e-6) {
    return !(Math.abs(this.x - t6.x) > e2 || Math.abs(this.y - t6.y) > e2 || Math.abs(this.z - t6.z) > e2);
  }
  almostZero(t6 = 1e-6) {
    return !(Math.abs(this.x) > t6 || Math.abs(this.y) > t6 || Math.abs(this.z) > t6);
  }
  isAntiparallelTo(t6, e2) {
    return this.negate(XS), XS.almostEquals(t6, e2);
  }
  clone() {
    return new _GS(this.x, this.y, this.z);
  }
};
GS.ZERO = void 0, GS.UNIT_X = void 0, GS.UNIT_Y = void 0, GS.UNIT_Z = void 0, GS.ZERO = new GS(0, 0, 0), GS.UNIT_X = new GS(1, 0, 0), GS.UNIT_Y = new GS(0, 1, 0), GS.UNIT_Z = new GS(0, 0, 1);
var WS = new GS();
var qS = new GS();
var XS = new GS();
var YS = class _YS {
  constructor(t6 = {}) {
    this.lowerBound = void 0, this.upperBound = void 0, this.lowerBound = new GS(), this.upperBound = new GS(), t6.lowerBound && this.lowerBound.copy(t6.lowerBound), t6.upperBound && this.upperBound.copy(t6.upperBound);
  }
  setFromPoints(t6, e2, i2, n2) {
    const r2 = this.lowerBound, s2 = this.upperBound, o2 = i2;
    r2.copy(t6[0]), o2 && o2.vmult(r2, r2), s2.copy(r2);
    for (let e3 = 1; e3 < t6.length; e3++) {
      let i3 = t6[e3];
      o2 && (o2.vmult(i3, ZS), i3 = ZS), i3.x > s2.x && (s2.x = i3.x), i3.x < r2.x && (r2.x = i3.x), i3.y > s2.y && (s2.y = i3.y), i3.y < r2.y && (r2.y = i3.y), i3.z > s2.z && (s2.z = i3.z), i3.z < r2.z && (r2.z = i3.z);
    }
    return e2 && (e2.vadd(r2, r2), e2.vadd(s2, s2)), n2 && (r2.x -= n2, r2.y -= n2, r2.z -= n2, s2.x += n2, s2.y += n2, s2.z += n2), this;
  }
  copy(t6) {
    return this.lowerBound.copy(t6.lowerBound), this.upperBound.copy(t6.upperBound), this;
  }
  clone() {
    return new _YS().copy(this);
  }
  extend(t6) {
    this.lowerBound.x = Math.min(this.lowerBound.x, t6.lowerBound.x), this.upperBound.x = Math.max(this.upperBound.x, t6.upperBound.x), this.lowerBound.y = Math.min(this.lowerBound.y, t6.lowerBound.y), this.upperBound.y = Math.max(this.upperBound.y, t6.upperBound.y), this.lowerBound.z = Math.min(this.lowerBound.z, t6.lowerBound.z), this.upperBound.z = Math.max(this.upperBound.z, t6.upperBound.z);
  }
  overlaps(t6) {
    const e2 = this.lowerBound, i2 = this.upperBound, n2 = t6.lowerBound, r2 = t6.upperBound, s2 = n2.x <= i2.x && i2.x <= r2.x || e2.x <= r2.x && r2.x <= i2.x, o2 = n2.y <= i2.y && i2.y <= r2.y || e2.y <= r2.y && r2.y <= i2.y, a2 = n2.z <= i2.z && i2.z <= r2.z || e2.z <= r2.z && r2.z <= i2.z;
    return s2 && o2 && a2;
  }
  volume() {
    const t6 = this.lowerBound, e2 = this.upperBound;
    return (e2.x - t6.x) * (e2.y - t6.y) * (e2.z - t6.z);
  }
  contains(t6) {
    const e2 = this.lowerBound, i2 = this.upperBound, n2 = t6.lowerBound, r2 = t6.upperBound;
    return e2.x <= n2.x && i2.x >= r2.x && e2.y <= n2.y && i2.y >= r2.y && e2.z <= n2.z && i2.z >= r2.z;
  }
  getCorners(t6, e2, i2, n2, r2, s2, o2, a2) {
    const l2 = this.lowerBound, c2 = this.upperBound;
    t6.copy(l2), e2.set(c2.x, l2.y, l2.z), i2.set(c2.x, c2.y, l2.z), n2.set(l2.x, c2.y, c2.z), r2.set(c2.x, l2.y, c2.z), s2.set(l2.x, c2.y, l2.z), o2.set(l2.x, l2.y, c2.z), a2.copy(c2);
  }
  toLocalFrame(t6, e2) {
    const i2 = JS, n2 = i2[0], r2 = i2[1], s2 = i2[2], o2 = i2[3], a2 = i2[4], l2 = i2[5], c2 = i2[6], h2 = i2[7];
    this.getCorners(n2, r2, s2, o2, a2, l2, c2, h2);
    for (let e3 = 0; 8 !== e3; e3++) {
      const n3 = i2[e3];
      t6.pointToLocal(n3, n3);
    }
    return e2.setFromPoints(i2);
  }
  toWorldFrame(t6, e2) {
    const i2 = JS, n2 = i2[0], r2 = i2[1], s2 = i2[2], o2 = i2[3], a2 = i2[4], l2 = i2[5], c2 = i2[6], h2 = i2[7];
    this.getCorners(n2, r2, s2, o2, a2, l2, c2, h2);
    for (let e3 = 0; 8 !== e3; e3++) {
      const n3 = i2[e3];
      t6.pointToWorld(n3, n3);
    }
    return e2.setFromPoints(i2);
  }
  overlapsRay(t6) {
    const { direction: e2, from: i2 } = t6, n2 = 1 / e2.x, r2 = 1 / e2.y, s2 = 1 / e2.z, o2 = (this.lowerBound.x - i2.x) * n2, a2 = (this.upperBound.x - i2.x) * n2, l2 = (this.lowerBound.y - i2.y) * r2, c2 = (this.upperBound.y - i2.y) * r2, h2 = (this.lowerBound.z - i2.z) * s2, u2 = (this.upperBound.z - i2.z) * s2, d2 = Math.max(Math.max(Math.min(o2, a2), Math.min(l2, c2)), Math.min(h2, u2)), p2 = Math.min(Math.min(Math.max(o2, a2), Math.max(l2, c2)), Math.max(h2, u2));
    return !(p2 < 0) && !(d2 > p2);
  }
};
var ZS = new GS();
var JS = [new GS(), new GS(), new GS(), new GS(), new GS(), new GS(), new GS(), new GS()];
var KS = class {
  constructor() {
    this.matrix = void 0, this.matrix = [];
  }
  get(t6, e2) {
    let { index: i2 } = t6, { index: n2 } = e2;
    if (n2 > i2) {
      const t7 = n2;
      n2 = i2, i2 = t7;
    }
    return this.matrix[(i2 * (i2 + 1) >> 1) + n2 - 1];
  }
  set(t6, e2, i2) {
    let { index: n2 } = t6, { index: r2 } = e2;
    if (r2 > n2) {
      const t7 = r2;
      r2 = n2, n2 = t7;
    }
    this.matrix[(n2 * (n2 + 1) >> 1) + r2 - 1] = i2 ? 1 : 0;
  }
  reset() {
    for (let t6 = 0, e2 = this.matrix.length; t6 !== e2; t6++) this.matrix[t6] = 0;
  }
  setNumObjects(t6) {
    this.matrix.length = t6 * (t6 - 1) >> 1;
  }
};
var $S = class {
  constructor() {
    this._listeners = void 0;
  }
  addEventListener(t6, e2) {
    void 0 === this._listeners && (this._listeners = {});
    const i2 = this._listeners;
    return void 0 === i2[t6] && (i2[t6] = []), i2[t6].includes(e2) || i2[t6].push(e2), this;
  }
  hasEventListener(t6, e2) {
    if (void 0 === this._listeners) return false;
    const i2 = this._listeners;
    return !(void 0 === i2[t6] || !i2[t6].includes(e2));
  }
  hasAnyEventListener(t6) {
    if (void 0 === this._listeners) return false;
    return void 0 !== this._listeners[t6];
  }
  removeEventListener(t6, e2) {
    if (void 0 === this._listeners) return this;
    const i2 = this._listeners;
    if (void 0 === i2[t6]) return this;
    const n2 = i2[t6].indexOf(e2);
    return -1 !== n2 && i2[t6].splice(n2, 1), this;
  }
  dispatchEvent(t6) {
    if (void 0 === this._listeners) return this;
    const e2 = this._listeners[t6.type];
    if (void 0 !== e2) {
      t6.target = this;
      for (let i2 = 0, n2 = e2.length; i2 < n2; i2++) e2[i2].call(this, t6);
    }
    return this;
  }
};
var QS = class _QS {
  constructor(t6 = 0, e2 = 0, i2 = 0, n2 = 1) {
    this.x = void 0, this.y = void 0, this.z = void 0, this.w = void 0, this.x = t6, this.y = e2, this.z = i2, this.w = n2;
  }
  set(t6, e2, i2, n2) {
    return this.x = t6, this.y = e2, this.z = i2, this.w = n2, this;
  }
  toString() {
    return this.x + "," + this.y + "," + this.z + "," + this.w;
  }
  toArray() {
    return [this.x, this.y, this.z, this.w];
  }
  setFromAxisAngle(t6, e2) {
    const i2 = Math.sin(0.5 * e2);
    return this.x = t6.x * i2, this.y = t6.y * i2, this.z = t6.z * i2, this.w = Math.cos(0.5 * e2), this;
  }
  toAxisAngle(t6 = new GS()) {
    this.normalize();
    const e2 = 2 * Math.acos(this.w), i2 = Math.sqrt(1 - this.w * this.w);
    return i2 < 1e-3 ? (t6.x = this.x, t6.y = this.y, t6.z = this.z) : (t6.x = this.x / i2, t6.y = this.y / i2, t6.z = this.z / i2), [t6, e2];
  }
  setFromVectors(t6, e2) {
    if (t6.isAntiparallelTo(e2)) {
      const e3 = tM, i2 = eM;
      t6.tangents(e3, i2), this.setFromAxisAngle(e3, Math.PI);
    } else {
      const i2 = t6.cross(e2);
      this.x = i2.x, this.y = i2.y, this.z = i2.z, this.w = Math.sqrt(t6.length() ** 2 * e2.length() ** 2) + t6.dot(e2), this.normalize();
    }
    return this;
  }
  mult(t6, e2 = new _QS()) {
    const i2 = this.x, n2 = this.y, r2 = this.z, s2 = this.w, o2 = t6.x, a2 = t6.y, l2 = t6.z, c2 = t6.w;
    return e2.x = i2 * c2 + s2 * o2 + n2 * l2 - r2 * a2, e2.y = n2 * c2 + s2 * a2 + r2 * o2 - i2 * l2, e2.z = r2 * c2 + s2 * l2 + i2 * a2 - n2 * o2, e2.w = s2 * c2 - i2 * o2 - n2 * a2 - r2 * l2, e2;
  }
  inverse(t6 = new _QS()) {
    const e2 = this.x, i2 = this.y, n2 = this.z, r2 = this.w;
    this.conjugate(t6);
    const s2 = 1 / (e2 * e2 + i2 * i2 + n2 * n2 + r2 * r2);
    return t6.x *= s2, t6.y *= s2, t6.z *= s2, t6.w *= s2, t6;
  }
  conjugate(t6 = new _QS()) {
    return t6.x = -this.x, t6.y = -this.y, t6.z = -this.z, t6.w = this.w, t6;
  }
  normalize() {
    let t6 = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    return 0 === t6 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (t6 = 1 / t6, this.x *= t6, this.y *= t6, this.z *= t6, this.w *= t6), this;
  }
  normalizeFast() {
    const t6 = (3 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2;
    return 0 === t6 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (this.x *= t6, this.y *= t6, this.z *= t6, this.w *= t6), this;
  }
  vmult(t6, e2 = new GS()) {
    const i2 = t6.x, n2 = t6.y, r2 = t6.z, s2 = this.x, o2 = this.y, a2 = this.z, l2 = this.w, c2 = l2 * i2 + o2 * r2 - a2 * n2, h2 = l2 * n2 + a2 * i2 - s2 * r2, u2 = l2 * r2 + s2 * n2 - o2 * i2, d2 = -s2 * i2 - o2 * n2 - a2 * r2;
    return e2.x = c2 * l2 + d2 * -s2 + h2 * -a2 - u2 * -o2, e2.y = h2 * l2 + d2 * -o2 + u2 * -s2 - c2 * -a2, e2.z = u2 * l2 + d2 * -a2 + c2 * -o2 - h2 * -s2, e2;
  }
  copy(t6) {
    return this.x = t6.x, this.y = t6.y, this.z = t6.z, this.w = t6.w, this;
  }
  toEuler(t6, e2 = "YZX") {
    let i2, n2, r2;
    const s2 = this.x, o2 = this.y, a2 = this.z, l2 = this.w;
    if ("YZX" !== e2) throw new Error("Euler order " + e2 + " not supported yet.");
    {
      const t7 = s2 * o2 + a2 * l2;
      if (t7 > 0.499 && (i2 = 2 * Math.atan2(s2, l2), n2 = Math.PI / 2, r2 = 0), t7 < -0.499 && (i2 = -2 * Math.atan2(s2, l2), n2 = -Math.PI / 2, r2 = 0), void 0 === i2) {
        const e3 = s2 * s2, c2 = o2 * o2, h2 = a2 * a2;
        i2 = Math.atan2(2 * o2 * l2 - 2 * s2 * a2, 1 - 2 * c2 - 2 * h2), n2 = Math.asin(2 * t7), r2 = Math.atan2(2 * s2 * l2 - 2 * o2 * a2, 1 - 2 * e3 - 2 * h2);
      }
    }
    t6.y = i2, t6.z = n2, t6.x = r2;
  }
  setFromEuler(t6, e2, i2, n2 = "XYZ") {
    const r2 = Math.cos(t6 / 2), s2 = Math.cos(e2 / 2), o2 = Math.cos(i2 / 2), a2 = Math.sin(t6 / 2), l2 = Math.sin(e2 / 2), c2 = Math.sin(i2 / 2);
    return "XYZ" === n2 ? (this.x = a2 * s2 * o2 + r2 * l2 * c2, this.y = r2 * l2 * o2 - a2 * s2 * c2, this.z = r2 * s2 * c2 + a2 * l2 * o2, this.w = r2 * s2 * o2 - a2 * l2 * c2) : "YXZ" === n2 ? (this.x = a2 * s2 * o2 + r2 * l2 * c2, this.y = r2 * l2 * o2 - a2 * s2 * c2, this.z = r2 * s2 * c2 - a2 * l2 * o2, this.w = r2 * s2 * o2 + a2 * l2 * c2) : "ZXY" === n2 ? (this.x = a2 * s2 * o2 - r2 * l2 * c2, this.y = r2 * l2 * o2 + a2 * s2 * c2, this.z = r2 * s2 * c2 + a2 * l2 * o2, this.w = r2 * s2 * o2 - a2 * l2 * c2) : "ZYX" === n2 ? (this.x = a2 * s2 * o2 - r2 * l2 * c2, this.y = r2 * l2 * o2 + a2 * s2 * c2, this.z = r2 * s2 * c2 - a2 * l2 * o2, this.w = r2 * s2 * o2 + a2 * l2 * c2) : "YZX" === n2 ? (this.x = a2 * s2 * o2 + r2 * l2 * c2, this.y = r2 * l2 * o2 + a2 * s2 * c2, this.z = r2 * s2 * c2 - a2 * l2 * o2, this.w = r2 * s2 * o2 - a2 * l2 * c2) : "XZY" === n2 && (this.x = a2 * s2 * o2 - r2 * l2 * c2, this.y = r2 * l2 * o2 - a2 * s2 * c2, this.z = r2 * s2 * c2 + a2 * l2 * o2, this.w = r2 * s2 * o2 + a2 * l2 * c2), this;
  }
  clone() {
    return new _QS(this.x, this.y, this.z, this.w);
  }
  slerp(t6, e2, i2 = new _QS()) {
    const n2 = this.x, r2 = this.y, s2 = this.z, o2 = this.w;
    let a2, l2, c2, h2, u2, d2 = t6.x, p2 = t6.y, f2 = t6.z, m2 = t6.w;
    return l2 = n2 * d2 + r2 * p2 + s2 * f2 + o2 * m2, l2 < 0 && (l2 = -l2, d2 = -d2, p2 = -p2, f2 = -f2, m2 = -m2), 1 - l2 > 1e-6 ? (a2 = Math.acos(l2), c2 = Math.sin(a2), h2 = Math.sin((1 - e2) * a2) / c2, u2 = Math.sin(e2 * a2) / c2) : (h2 = 1 - e2, u2 = e2), i2.x = h2 * n2 + u2 * d2, i2.y = h2 * r2 + u2 * p2, i2.z = h2 * s2 + u2 * f2, i2.w = h2 * o2 + u2 * m2, i2;
  }
  integrate(t6, e2, i2, n2 = new _QS()) {
    const r2 = t6.x * i2.x, s2 = t6.y * i2.y, o2 = t6.z * i2.z, a2 = this.x, l2 = this.y, c2 = this.z, h2 = this.w, u2 = 0.5 * e2;
    return n2.x += u2 * (r2 * h2 + s2 * c2 - o2 * l2), n2.y += u2 * (s2 * h2 + o2 * a2 - r2 * c2), n2.z += u2 * (o2 * h2 + r2 * l2 - s2 * a2), n2.w += u2 * (-r2 * a2 - s2 * l2 - o2 * c2), n2;
  }
};
var tM = new GS();
var eM = new GS();
var iM = class _iM {
  constructor(t6 = {}) {
    this.id = void 0, this.type = void 0, this.boundingSphereRadius = void 0, this.collisionResponse = void 0, this.collisionFilterGroup = void 0, this.collisionFilterMask = void 0, this.material = void 0, this.body = void 0, this.id = _iM.idCounter++, this.type = t6.type || 0, this.boundingSphereRadius = 0, this.collisionResponse = !t6.collisionResponse || t6.collisionResponse, this.collisionFilterGroup = void 0 !== t6.collisionFilterGroup ? t6.collisionFilterGroup : 1, this.collisionFilterMask = void 0 !== t6.collisionFilterMask ? t6.collisionFilterMask : -1, this.material = t6.material ? t6.material : null, this.body = null;
  }
  updateBoundingSphereRadius() {
    throw "computeBoundingSphereRadius() not implemented for shape type " + this.type;
  }
  volume() {
    throw "volume() not implemented for shape type " + this.type;
  }
  calculateLocalInertia(t6, e2) {
    throw "calculateLocalInertia() not implemented for shape type " + this.type;
  }
  calculateWorldAABB(t6, e2, i2, n2) {
    throw "calculateWorldAABB() not implemented for shape type " + this.type;
  }
};
iM.idCounter = 0, iM.types = { SPHERE: 1, PLANE: 2, BOX: 4, COMPOUND: 8, CONVEXPOLYHEDRON: 16, HEIGHTFIELD: 32, PARTICLE: 64, CYLINDER: 128, TRIMESH: 256 };
var nM = class _nM {
  constructor(t6 = {}) {
    this.position = void 0, this.quaternion = void 0, this.position = new GS(), this.quaternion = new QS(), t6.position && this.position.copy(t6.position), t6.quaternion && this.quaternion.copy(t6.quaternion);
  }
  pointToLocal(t6, e2) {
    return _nM.pointToLocalFrame(this.position, this.quaternion, t6, e2);
  }
  pointToWorld(t6, e2) {
    return _nM.pointToWorldFrame(this.position, this.quaternion, t6, e2);
  }
  vectorToWorldFrame(t6, e2 = new GS()) {
    return this.quaternion.vmult(t6, e2), e2;
  }
  static pointToLocalFrame(t6, e2, i2, n2 = new GS()) {
    return i2.vsub(t6, n2), e2.conjugate(rM), rM.vmult(n2, n2), n2;
  }
  static pointToWorldFrame(t6, e2, i2, n2 = new GS()) {
    return e2.vmult(i2, n2), n2.vadd(t6, n2), n2;
  }
  static vectorToWorldFrame(t6, e2, i2 = new GS()) {
    return t6.vmult(e2, i2), i2;
  }
  static vectorToLocalFrame(t6, e2, i2, n2 = new GS()) {
    return e2.w *= -1, e2.vmult(i2, n2), e2.w *= -1, n2;
  }
};
var rM = new QS();
var sM = class _sM extends iM {
  constructor(t6 = {}) {
    const { vertices: e2 = [], faces: i2 = [], normals: n2 = [], axes: r2, boundingSphereRadius: s2 } = t6;
    super({ type: iM.types.CONVEXPOLYHEDRON }), this.vertices = void 0, this.faces = void 0, this.faceNormals = void 0, this.worldVertices = void 0, this.worldVerticesNeedsUpdate = void 0, this.worldFaceNormals = void 0, this.worldFaceNormalsNeedsUpdate = void 0, this.uniqueAxes = void 0, this.uniqueEdges = void 0, this.vertices = e2, this.faces = i2, this.faceNormals = n2, 0 === this.faceNormals.length && this.computeNormals(), s2 ? this.boundingSphereRadius = s2 : this.updateBoundingSphereRadius(), this.worldVertices = [], this.worldVerticesNeedsUpdate = true, this.worldFaceNormals = [], this.worldFaceNormalsNeedsUpdate = true, this.uniqueAxes = r2 ? r2.slice() : null, this.uniqueEdges = [], this.computeEdges();
  }
  computeEdges() {
    const t6 = this.faces, e2 = this.vertices, i2 = this.uniqueEdges;
    i2.length = 0;
    const n2 = new GS();
    for (let r2 = 0; r2 !== t6.length; r2++) {
      const s2 = t6[r2], o2 = s2.length;
      for (let t7 = 0; t7 !== o2; t7++) {
        const r3 = (t7 + 1) % o2;
        e2[s2[t7]].vsub(e2[s2[r3]], n2), n2.normalize();
        let a2 = false;
        for (let t8 = 0; t8 !== i2.length; t8++) if (i2[t8].almostEquals(n2) || i2[t8].almostEquals(n2)) {
          a2 = true;
          break;
        }
        a2 || i2.push(n2.clone());
      }
    }
  }
  computeNormals() {
    this.faceNormals.length = this.faces.length;
    for (let t6 = 0; t6 < this.faces.length; t6++) {
      for (let e3 = 0; e3 < this.faces[t6].length; e3++) if (!this.vertices[this.faces[t6][e3]]) throw new Error("Vertex " + this.faces[t6][e3] + " not found!");
      const e2 = this.faceNormals[t6] || new GS();
      this.getFaceNormal(t6, e2), e2.negate(e2), this.faceNormals[t6] = e2;
      const i2 = this.vertices[this.faces[t6][0]];
      if (e2.dot(i2) < 0) {
        console.error(".faceNormals[" + t6 + "] = Vec3(" + e2.toString() + ") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.");
        for (let e3 = 0; e3 < this.faces[t6].length; e3++) console.warn(".vertices[" + this.faces[t6][e3] + "] = Vec3(" + this.vertices[this.faces[t6][e3]].toString() + ")");
      }
    }
  }
  getFaceNormal(t6, e2) {
    const i2 = this.faces[t6], n2 = this.vertices[i2[0]], r2 = this.vertices[i2[1]], s2 = this.vertices[i2[2]];
    _sM.computeNormal(n2, r2, s2, e2);
  }
  static computeNormal(t6, e2, i2, n2) {
    const r2 = new GS(), s2 = new GS();
    e2.vsub(t6, s2), i2.vsub(e2, r2), r2.cross(s2, n2), n2.isZero() || n2.normalize();
  }
  clipAgainstHull(t6, e2, i2, n2, r2, s2, o2, a2, l2) {
    const c2 = new GS();
    let h2 = -1, u2 = -Number.MAX_VALUE;
    for (let t7 = 0; t7 < i2.faces.length; t7++) {
      c2.copy(i2.faceNormals[t7]), r2.vmult(c2, c2);
      const e3 = c2.dot(s2);
      e3 > u2 && (u2 = e3, h2 = t7);
    }
    const d2 = [];
    for (let t7 = 0; t7 < i2.faces[h2].length; t7++) {
      const e3 = i2.vertices[i2.faces[h2][t7]], s3 = new GS();
      s3.copy(e3), r2.vmult(s3, s3), n2.vadd(s3, s3), d2.push(s3);
    }
    h2 >= 0 && this.clipFaceAgainstHull(s2, t6, e2, d2, o2, a2, l2);
  }
  findSeparatingAxis(t6, e2, i2, n2, r2, s2, o2, a2) {
    const l2 = new GS(), c2 = new GS(), h2 = new GS(), u2 = new GS(), d2 = new GS(), p2 = new GS();
    let f2 = Number.MAX_VALUE;
    const m2 = this;
    if (m2.uniqueAxes) for (let o3 = 0; o3 !== m2.uniqueAxes.length; o3++) {
      i2.vmult(m2.uniqueAxes[o3], l2);
      const a3 = m2.testSepAxis(l2, t6, e2, i2, n2, r2);
      if (false === a3) return false;
      a3 < f2 && (f2 = a3, s2.copy(l2));
    }
    else {
      const a3 = o2 ? o2.length : m2.faces.length;
      for (let c3 = 0; c3 < a3; c3++) {
        const a4 = o2 ? o2[c3] : c3;
        l2.copy(m2.faceNormals[a4]), i2.vmult(l2, l2);
        const h3 = m2.testSepAxis(l2, t6, e2, i2, n2, r2);
        if (false === h3) return false;
        h3 < f2 && (f2 = h3, s2.copy(l2));
      }
    }
    if (t6.uniqueAxes) for (let o3 = 0; o3 !== t6.uniqueAxes.length; o3++) {
      r2.vmult(t6.uniqueAxes[o3], c2);
      const a3 = m2.testSepAxis(c2, t6, e2, i2, n2, r2);
      if (false === a3) return false;
      a3 < f2 && (f2 = a3, s2.copy(c2));
    }
    else {
      const o3 = a2 ? a2.length : t6.faces.length;
      for (let l3 = 0; l3 < o3; l3++) {
        const o4 = a2 ? a2[l3] : l3;
        c2.copy(t6.faceNormals[o4]), r2.vmult(c2, c2);
        const h3 = m2.testSepAxis(c2, t6, e2, i2, n2, r2);
        if (false === h3) return false;
        h3 < f2 && (f2 = h3, s2.copy(c2));
      }
    }
    for (let o3 = 0; o3 !== m2.uniqueEdges.length; o3++) {
      i2.vmult(m2.uniqueEdges[o3], u2);
      for (let o4 = 0; o4 !== t6.uniqueEdges.length; o4++) if (r2.vmult(t6.uniqueEdges[o4], d2), u2.cross(d2, p2), !p2.almostZero()) {
        p2.normalize();
        const o5 = m2.testSepAxis(p2, t6, e2, i2, n2, r2);
        if (false === o5) return false;
        o5 < f2 && (f2 = o5, s2.copy(p2));
      }
    }
    return n2.vsub(e2, h2), h2.dot(s2) > 0 && s2.negate(s2), true;
  }
  testSepAxis(t6, e2, i2, n2, r2, s2) {
    _sM.project(this, t6, i2, n2, oM), _sM.project(e2, t6, r2, s2, aM);
    const o2 = oM[0], a2 = oM[1], l2 = aM[0], c2 = aM[1];
    if (o2 < c2 || l2 < a2) return false;
    const h2 = o2 - c2, u2 = l2 - a2;
    return h2 < u2 ? h2 : u2;
  }
  calculateLocalInertia(t6, e2) {
    const i2 = new GS(), n2 = new GS();
    this.computeLocalAABB(n2, i2);
    const r2 = i2.x - n2.x, s2 = i2.y - n2.y, o2 = i2.z - n2.z;
    e2.x = 1 / 12 * t6 * (2 * s2 * 2 * s2 + 2 * o2 * 2 * o2), e2.y = 1 / 12 * t6 * (2 * r2 * 2 * r2 + 2 * o2 * 2 * o2), e2.z = 1 / 12 * t6 * (2 * s2 * 2 * s2 + 2 * r2 * 2 * r2);
  }
  getPlaneConstantOfFace(t6) {
    const e2 = this.faces[t6], i2 = this.faceNormals[t6], n2 = this.vertices[e2[0]];
    return -i2.dot(n2);
  }
  clipFaceAgainstHull(t6, e2, i2, n2, r2, s2, o2) {
    const a2 = new GS(), l2 = new GS(), c2 = new GS(), h2 = new GS(), u2 = new GS(), d2 = new GS(), p2 = new GS(), f2 = new GS(), m2 = this, g2 = n2, v2 = [];
    let y2 = -1, x2 = Number.MAX_VALUE;
    for (let e3 = 0; e3 < m2.faces.length; e3++) {
      a2.copy(m2.faceNormals[e3]), i2.vmult(a2, a2);
      const n3 = a2.dot(t6);
      n3 < x2 && (x2 = n3, y2 = e3);
    }
    if (y2 < 0) return;
    const b2 = m2.faces[y2];
    b2.connectedFaces = [];
    for (let t7 = 0; t7 < m2.faces.length; t7++) for (let e3 = 0; e3 < m2.faces[t7].length; e3++) -1 !== b2.indexOf(m2.faces[t7][e3]) && t7 !== y2 && -1 === b2.connectedFaces.indexOf(t7) && b2.connectedFaces.push(t7);
    const w2 = b2.length;
    for (let t7 = 0; t7 < w2; t7++) {
      const n3 = m2.vertices[b2[t7]], r3 = m2.vertices[b2[(t7 + 1) % w2]];
      n3.vsub(r3, l2), c2.copy(l2), i2.vmult(c2, c2), e2.vadd(c2, c2), h2.copy(this.faceNormals[y2]), i2.vmult(h2, h2), e2.vadd(h2, h2), c2.cross(h2, u2), u2.negate(u2), d2.copy(n3), i2.vmult(d2, d2), e2.vadd(d2, d2);
      const s3 = b2.connectedFaces[t7];
      p2.copy(this.faceNormals[s3]);
      const o3 = this.getPlaneConstantOfFace(s3);
      f2.copy(p2), i2.vmult(f2, f2);
      const a3 = o3 - f2.dot(e2);
      for (this.clipFaceAgainstPlane(g2, v2, f2, a3); g2.length; ) g2.shift();
      for (; v2.length; ) g2.push(v2.shift());
    }
    p2.copy(this.faceNormals[y2]);
    const _2 = this.getPlaneConstantOfFace(y2);
    f2.copy(p2), i2.vmult(f2, f2);
    const S2 = _2 - f2.dot(e2);
    for (let t7 = 0; t7 < g2.length; t7++) {
      let e3 = f2.dot(g2[t7]) + S2;
      if (e3 <= r2 && (console.log("clamped: depth=" + e3 + " to minDist=" + r2), e3 = r2), e3 <= s2) {
        const i3 = g2[t7];
        if (e3 <= 1e-6) {
          const t8 = { point: i3, normal: f2, depth: e3 };
          o2.push(t8);
        }
      }
    }
  }
  clipFaceAgainstPlane(t6, e2, i2, n2) {
    let r2, s2;
    const o2 = t6.length;
    if (o2 < 2) return e2;
    let a2 = t6[t6.length - 1], l2 = t6[0];
    r2 = i2.dot(a2) + n2;
    for (let c2 = 0; c2 < o2; c2++) {
      if (l2 = t6[c2], s2 = i2.dot(l2) + n2, r2 < 0) if (s2 < 0) {
        const t7 = new GS();
        t7.copy(l2), e2.push(t7);
      } else {
        const t7 = new GS();
        a2.lerp(l2, r2 / (r2 - s2), t7), e2.push(t7);
      }
      else if (s2 < 0) {
        const t7 = new GS();
        a2.lerp(l2, r2 / (r2 - s2), t7), e2.push(t7), e2.push(l2);
      }
      a2 = l2, r2 = s2;
    }
    return e2;
  }
  computeWorldVertices(t6, e2) {
    for (; this.worldVertices.length < this.vertices.length; ) this.worldVertices.push(new GS());
    const i2 = this.vertices, n2 = this.worldVertices;
    for (let r2 = 0; r2 !== this.vertices.length; r2++) e2.vmult(i2[r2], n2[r2]), t6.vadd(n2[r2], n2[r2]);
    this.worldVerticesNeedsUpdate = false;
  }
  computeLocalAABB(t6, e2) {
    const i2 = this.vertices;
    t6.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), e2.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    for (let n2 = 0; n2 < this.vertices.length; n2++) {
      const r2 = i2[n2];
      r2.x < t6.x ? t6.x = r2.x : r2.x > e2.x && (e2.x = r2.x), r2.y < t6.y ? t6.y = r2.y : r2.y > e2.y && (e2.y = r2.y), r2.z < t6.z ? t6.z = r2.z : r2.z > e2.z && (e2.z = r2.z);
    }
  }
  computeWorldFaceNormals(t6) {
    const e2 = this.faceNormals.length;
    for (; this.worldFaceNormals.length < e2; ) this.worldFaceNormals.push(new GS());
    const i2 = this.faceNormals, n2 = this.worldFaceNormals;
    for (let r2 = 0; r2 !== e2; r2++) t6.vmult(i2[r2], n2[r2]);
    this.worldFaceNormalsNeedsUpdate = false;
  }
  updateBoundingSphereRadius() {
    let t6 = 0;
    const e2 = this.vertices;
    for (let i2 = 0; i2 !== e2.length; i2++) {
      const n2 = e2[i2].lengthSquared();
      n2 > t6 && (t6 = n2);
    }
    this.boundingSphereRadius = Math.sqrt(t6);
  }
  calculateWorldAABB(t6, e2, i2, n2) {
    const r2 = this.vertices;
    let s2, o2, a2, l2, c2, h2, u2 = new GS();
    for (let i3 = 0; i3 < r2.length; i3++) {
      u2.copy(r2[i3]), e2.vmult(u2, u2), t6.vadd(u2, u2);
      const n3 = u2;
      (void 0 === s2 || n3.x < s2) && (s2 = n3.x), (void 0 === l2 || n3.x > l2) && (l2 = n3.x), (void 0 === o2 || n3.y < o2) && (o2 = n3.y), (void 0 === c2 || n3.y > c2) && (c2 = n3.y), (void 0 === a2 || n3.z < a2) && (a2 = n3.z), (void 0 === h2 || n3.z > h2) && (h2 = n3.z);
    }
    i2.set(s2, o2, a2), n2.set(l2, c2, h2);
  }
  volume() {
    return 4 * Math.PI * this.boundingSphereRadius / 3;
  }
  getAveragePointLocal(t6 = new GS()) {
    const e2 = this.vertices;
    for (let i2 = 0; i2 < e2.length; i2++) t6.vadd(e2[i2], t6);
    return t6.scale(1 / e2.length, t6), t6;
  }
  transformAllPoints(t6, e2) {
    const i2 = this.vertices.length, n2 = this.vertices;
    if (e2) {
      for (let t7 = 0; t7 < i2; t7++) {
        const i3 = n2[t7];
        e2.vmult(i3, i3);
      }
      for (let t7 = 0; t7 < this.faceNormals.length; t7++) {
        const i3 = this.faceNormals[t7];
        e2.vmult(i3, i3);
      }
    }
    if (t6) for (let e3 = 0; e3 < i2; e3++) {
      const i3 = n2[e3];
      i3.vadd(t6, i3);
    }
  }
  pointIsInside(t6) {
    const e2 = this.vertices, i2 = this.faces, n2 = this.faceNormals, r2 = new GS();
    this.getAveragePointLocal(r2);
    for (let s2 = 0; s2 < this.faces.length; s2++) {
      let o2 = n2[s2];
      const a2 = e2[i2[s2][0]], l2 = new GS();
      t6.vsub(a2, l2);
      const c2 = o2.dot(l2), h2 = new GS();
      r2.vsub(a2, h2);
      const u2 = o2.dot(h2);
      if (c2 < 0 && u2 > 0 || c2 > 0 && u2 < 0) return false;
    }
    return -1;
  }
  static project(t6, e2, i2, n2, r2) {
    const s2 = t6.vertices.length, o2 = lM;
    let a2 = 0, l2 = 0;
    const c2 = cM, h2 = t6.vertices;
    c2.setZero(), nM.vectorToLocalFrame(i2, n2, e2, o2), nM.pointToLocalFrame(i2, n2, c2, c2);
    const u2 = c2.dot(o2);
    l2 = a2 = h2[0].dot(o2);
    for (let t7 = 1; t7 < s2; t7++) {
      const e3 = h2[t7].dot(o2);
      e3 > a2 && (a2 = e3), e3 < l2 && (l2 = e3);
    }
    if (l2 -= u2, a2 -= u2, l2 > a2) {
      const t7 = l2;
      l2 = a2, a2 = t7;
    }
    r2[0] = a2, r2[1] = l2;
  }
};
var oM = [];
var aM = [];
var lM = new GS();
var cM = new GS();
var hM = class _hM extends iM {
  constructor(t6) {
    super({ type: iM.types.BOX }), this.halfExtents = void 0, this.convexPolyhedronRepresentation = void 0, this.halfExtents = t6, this.convexPolyhedronRepresentation = null, this.updateConvexPolyhedronRepresentation(), this.updateBoundingSphereRadius();
  }
  updateConvexPolyhedronRepresentation() {
    const t6 = this.halfExtents.x, e2 = this.halfExtents.y, i2 = this.halfExtents.z, n2 = GS, r2 = [new n2(-t6, -e2, -i2), new n2(t6, -e2, -i2), new n2(t6, e2, -i2), new n2(-t6, e2, -i2), new n2(-t6, -e2, i2), new n2(t6, -e2, i2), new n2(t6, e2, i2), new n2(-t6, e2, i2)], s2 = [new n2(0, 0, 1), new n2(0, 1, 0), new n2(1, 0, 0)], o2 = new sM({ vertices: r2, faces: [[3, 2, 1, 0], [4, 5, 6, 7], [5, 4, 0, 1], [2, 3, 7, 6], [0, 4, 7, 3], [1, 2, 6, 5]], axes: s2 });
    this.convexPolyhedronRepresentation = o2, o2.material = this.material;
  }
  calculateLocalInertia(t6, e2 = new GS()) {
    return _hM.calculateInertia(this.halfExtents, t6, e2), e2;
  }
  static calculateInertia(t6, e2, i2) {
    const n2 = t6;
    i2.x = 1 / 12 * e2 * (2 * n2.y * 2 * n2.y + 2 * n2.z * 2 * n2.z), i2.y = 1 / 12 * e2 * (2 * n2.x * 2 * n2.x + 2 * n2.z * 2 * n2.z), i2.z = 1 / 12 * e2 * (2 * n2.y * 2 * n2.y + 2 * n2.x * 2 * n2.x);
  }
  getSideNormals(t6, e2) {
    const i2 = t6, n2 = this.halfExtents;
    if (i2[0].set(n2.x, 0, 0), i2[1].set(0, n2.y, 0), i2[2].set(0, 0, n2.z), i2[3].set(-n2.x, 0, 0), i2[4].set(0, -n2.y, 0), i2[5].set(0, 0, -n2.z), void 0 !== e2) for (let t7 = 0; t7 !== i2.length; t7++) e2.vmult(i2[t7], i2[t7]);
    return i2;
  }
  volume() {
    return 8 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
  }
  updateBoundingSphereRadius() {
    this.boundingSphereRadius = this.halfExtents.length();
  }
  forEachWorldCorner(t6, e2, i2) {
    const n2 = this.halfExtents, r2 = [[n2.x, n2.y, n2.z], [-n2.x, n2.y, n2.z], [-n2.x, -n2.y, n2.z], [-n2.x, -n2.y, -n2.z], [n2.x, -n2.y, -n2.z], [n2.x, n2.y, -n2.z], [-n2.x, n2.y, -n2.z], [n2.x, -n2.y, n2.z]];
    for (let n3 = 0; n3 < r2.length; n3++) uM.set(r2[n3][0], r2[n3][1], r2[n3][2]), e2.vmult(uM, uM), t6.vadd(uM, uM), i2(uM.x, uM.y, uM.z);
  }
  calculateWorldAABB(t6, e2, i2, n2) {
    const r2 = this.halfExtents;
    dM[0].set(r2.x, r2.y, r2.z), dM[1].set(-r2.x, r2.y, r2.z), dM[2].set(-r2.x, -r2.y, r2.z), dM[3].set(-r2.x, -r2.y, -r2.z), dM[4].set(r2.x, -r2.y, -r2.z), dM[5].set(r2.x, r2.y, -r2.z), dM[6].set(-r2.x, r2.y, -r2.z), dM[7].set(r2.x, -r2.y, r2.z);
    const s2 = dM[0];
    e2.vmult(s2, s2), t6.vadd(s2, s2), n2.copy(s2), i2.copy(s2);
    for (let r3 = 1; r3 < 8; r3++) {
      const s3 = dM[r3];
      e2.vmult(s3, s3), t6.vadd(s3, s3);
      const o2 = s3.x, a2 = s3.y, l2 = s3.z;
      o2 > n2.x && (n2.x = o2), a2 > n2.y && (n2.y = a2), l2 > n2.z && (n2.z = l2), o2 < i2.x && (i2.x = o2), a2 < i2.y && (i2.y = a2), l2 < i2.z && (i2.z = l2);
    }
  }
};
var uM = new GS();
var dM = [new GS(), new GS(), new GS(), new GS(), new GS(), new GS(), new GS(), new GS()];
var pM = 1;
var fM = 2;
var mM = 4;
var gM = 0;
var vM = 1;
var yM = 2;
var xM = class _xM extends $S {
  constructor(t6 = {}) {
    super(), this.id = void 0, this.index = void 0, this.world = void 0, this.preStep = void 0, this.postStep = void 0, this.vlambda = void 0, this.collisionFilterGroup = void 0, this.collisionFilterMask = void 0, this.collisionResponse = void 0, this.position = void 0, this.previousPosition = void 0, this.interpolatedPosition = void 0, this.initPosition = void 0, this.velocity = void 0, this.initVelocity = void 0, this.force = void 0, this.mass = void 0, this.invMass = void 0, this.material = void 0, this.linearDamping = void 0, this.type = void 0, this.allowSleep = void 0, this.sleepState = void 0, this.sleepSpeedLimit = void 0, this.sleepTimeLimit = void 0, this.timeLastSleepy = void 0, this.wakeUpAfterNarrowphase = void 0, this.torque = void 0, this.quaternion = void 0, this.initQuaternion = void 0, this.previousQuaternion = void 0, this.interpolatedQuaternion = void 0, this.angularVelocity = void 0, this.initAngularVelocity = void 0, this.shapes = void 0, this.shapeOffsets = void 0, this.shapeOrientations = void 0, this.inertia = void 0, this.invInertia = void 0, this.invInertiaWorld = void 0, this.invMassSolve = void 0, this.invInertiaSolve = void 0, this.invInertiaWorldSolve = void 0, this.fixedRotation = void 0, this.angularDamping = void 0, this.linearFactor = void 0, this.angularFactor = void 0, this.aabb = void 0, this.aabbNeedsUpdate = void 0, this.boundingRadius = void 0, this.wlambda = void 0, this.isTrigger = void 0, this.id = _xM.idCounter++, this.index = -1, this.world = null, this.preStep = null, this.postStep = null, this.vlambda = new GS(), this.collisionFilterGroup = "number" == typeof t6.collisionFilterGroup ? t6.collisionFilterGroup : 1, this.collisionFilterMask = "number" == typeof t6.collisionFilterMask ? t6.collisionFilterMask : -1, this.collisionResponse = "boolean" != typeof t6.collisionResponse || t6.collisionResponse, this.position = new GS(), this.previousPosition = new GS(), this.interpolatedPosition = new GS(), this.initPosition = new GS(), t6.position && (this.position.copy(t6.position), this.previousPosition.copy(t6.position), this.interpolatedPosition.copy(t6.position), this.initPosition.copy(t6.position)), this.velocity = new GS(), t6.velocity && this.velocity.copy(t6.velocity), this.initVelocity = new GS(), this.force = new GS();
    const e2 = "number" == typeof t6.mass ? t6.mass : 0;
    this.mass = e2, this.invMass = e2 > 0 ? 1 / e2 : 0, this.material = t6.material || null, this.linearDamping = "number" == typeof t6.linearDamping ? t6.linearDamping : 0.01, this.type = e2 <= 0 ? _xM.STATIC : _xM.DYNAMIC, typeof t6.type == typeof _xM.STATIC && (this.type = t6.type), this.allowSleep = void 0 === t6.allowSleep || t6.allowSleep, this.sleepState = _xM.AWAKE, this.sleepSpeedLimit = void 0 !== t6.sleepSpeedLimit ? t6.sleepSpeedLimit : 0.1, this.sleepTimeLimit = void 0 !== t6.sleepTimeLimit ? t6.sleepTimeLimit : 1, this.timeLastSleepy = 0, this.wakeUpAfterNarrowphase = false, this.torque = new GS(), this.quaternion = new QS(), this.initQuaternion = new QS(), this.previousQuaternion = new QS(), this.interpolatedQuaternion = new QS(), t6.quaternion && (this.quaternion.copy(t6.quaternion), this.initQuaternion.copy(t6.quaternion), this.previousQuaternion.copy(t6.quaternion), this.interpolatedQuaternion.copy(t6.quaternion)), this.angularVelocity = new GS(), t6.angularVelocity && this.angularVelocity.copy(t6.angularVelocity), this.initAngularVelocity = new GS(), this.shapes = [], this.shapeOffsets = [], this.shapeOrientations = [], this.inertia = new GS(), this.invInertia = new GS(), this.invInertiaWorld = new VS(), this.invMassSolve = 0, this.invInertiaSolve = new GS(), this.invInertiaWorldSolve = new VS(), this.fixedRotation = void 0 !== t6.fixedRotation && t6.fixedRotation, this.angularDamping = void 0 !== t6.angularDamping ? t6.angularDamping : 0.01, this.linearFactor = new GS(1, 1, 1), t6.linearFactor && this.linearFactor.copy(t6.linearFactor), this.angularFactor = new GS(1, 1, 1), t6.angularFactor && this.angularFactor.copy(t6.angularFactor), this.aabb = new YS(), this.aabbNeedsUpdate = true, this.boundingRadius = 0, this.wlambda = new GS(), this.isTrigger = Boolean(t6.isTrigger), t6.shape && this.addShape(t6.shape), this.updateMassProperties();
  }
  wakeUp() {
    const t6 = this.sleepState;
    this.sleepState = _xM.AWAKE, this.wakeUpAfterNarrowphase = false, t6 === _xM.SLEEPING && this.dispatchEvent(_xM.wakeupEvent);
  }
  sleep() {
    this.sleepState = _xM.SLEEPING, this.velocity.set(0, 0, 0), this.angularVelocity.set(0, 0, 0), this.wakeUpAfterNarrowphase = false;
  }
  sleepTick(t6) {
    if (this.allowSleep) {
      const e2 = this.sleepState, i2 = this.velocity.lengthSquared() + this.angularVelocity.lengthSquared(), n2 = this.sleepSpeedLimit ** 2;
      e2 === _xM.AWAKE && i2 < n2 ? (this.sleepState = _xM.SLEEPY, this.timeLastSleepy = t6, this.dispatchEvent(_xM.sleepyEvent)) : e2 === _xM.SLEEPY && i2 > n2 ? this.wakeUp() : e2 === _xM.SLEEPY && t6 - this.timeLastSleepy > this.sleepTimeLimit && (this.sleep(), this.dispatchEvent(_xM.sleepEvent));
    }
  }
  updateSolveMassProperties() {
    this.sleepState === _xM.SLEEPING || this.type === _xM.KINEMATIC ? (this.invMassSolve = 0, this.invInertiaSolve.setZero(), this.invInertiaWorldSolve.setZero()) : (this.invMassSolve = this.invMass, this.invInertiaSolve.copy(this.invInertia), this.invInertiaWorldSolve.copy(this.invInertiaWorld));
  }
  pointToLocalFrame(t6, e2 = new GS()) {
    return t6.vsub(this.position, e2), this.quaternion.conjugate().vmult(e2, e2), e2;
  }
  vectorToLocalFrame(t6, e2 = new GS()) {
    return this.quaternion.conjugate().vmult(t6, e2), e2;
  }
  pointToWorldFrame(t6, e2 = new GS()) {
    return this.quaternion.vmult(t6, e2), e2.vadd(this.position, e2), e2;
  }
  vectorToWorldFrame(t6, e2 = new GS()) {
    return this.quaternion.vmult(t6, e2), e2;
  }
  addShape(t6, e2, i2) {
    const n2 = new GS(), r2 = new QS();
    return e2 && n2.copy(e2), i2 && r2.copy(i2), this.shapes.push(t6), this.shapeOffsets.push(n2), this.shapeOrientations.push(r2), this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = true, t6.body = this, this;
  }
  removeShape(t6) {
    const e2 = this.shapes.indexOf(t6);
    return -1 === e2 ? (console.warn("Shape does not belong to the body"), this) : (this.shapes.splice(e2, 1), this.shapeOffsets.splice(e2, 1), this.shapeOrientations.splice(e2, 1), this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = true, t6.body = null, this);
  }
  updateBoundingRadius() {
    const t6 = this.shapes, e2 = this.shapeOffsets, i2 = t6.length;
    let n2 = 0;
    for (let r2 = 0; r2 !== i2; r2++) {
      const i3 = t6[r2];
      i3.updateBoundingSphereRadius();
      const s2 = e2[r2].length(), o2 = i3.boundingSphereRadius;
      s2 + o2 > n2 && (n2 = s2 + o2);
    }
    this.boundingRadius = n2;
  }
  updateAABB() {
    const t6 = this.shapes, e2 = this.shapeOffsets, i2 = this.shapeOrientations, n2 = t6.length, r2 = bM, s2 = wM, o2 = this.quaternion, a2 = this.aabb, l2 = _M;
    for (let c2 = 0; c2 !== n2; c2++) {
      const n3 = t6[c2];
      o2.vmult(e2[c2], r2), r2.vadd(this.position, r2), o2.mult(i2[c2], s2), n3.calculateWorldAABB(r2, s2, l2.lowerBound, l2.upperBound), 0 === c2 ? a2.copy(l2) : a2.extend(l2);
    }
    this.aabbNeedsUpdate = false;
  }
  updateInertiaWorld(t6) {
    const e2 = this.invInertia;
    if (e2.x !== e2.y || e2.y !== e2.z || t6) {
      const t7 = SM, i2 = MM;
      t7.setRotationFromQuaternion(this.quaternion), t7.transpose(i2), t7.scale(e2, t7), t7.mmult(i2, this.invInertiaWorld);
    } else ;
  }
  applyForce(t6, e2 = new GS()) {
    if (this.type !== _xM.DYNAMIC) return;
    this.sleepState === _xM.SLEEPING && this.wakeUp();
    const i2 = TM;
    e2.cross(t6, i2), this.force.vadd(t6, this.force), this.torque.vadd(i2, this.torque);
  }
  applyLocalForce(t6, e2 = new GS()) {
    if (this.type !== _xM.DYNAMIC) return;
    const i2 = EM, n2 = AM;
    this.vectorToWorldFrame(t6, i2), this.vectorToWorldFrame(e2, n2), this.applyForce(i2, n2);
  }
  applyTorque(t6) {
    this.type === _xM.DYNAMIC && (this.sleepState === _xM.SLEEPING && this.wakeUp(), this.torque.vadd(t6, this.torque));
  }
  applyImpulse(t6, e2 = new GS()) {
    if (this.type !== _xM.DYNAMIC) return;
    this.sleepState === _xM.SLEEPING && this.wakeUp();
    const i2 = e2, n2 = CM;
    n2.copy(t6), n2.scale(this.invMass, n2), this.velocity.vadd(n2, this.velocity);
    const r2 = RM;
    i2.cross(t6, r2), this.invInertiaWorld.vmult(r2, r2), this.angularVelocity.vadd(r2, this.angularVelocity);
  }
  applyLocalImpulse(t6, e2 = new GS()) {
    if (this.type !== _xM.DYNAMIC) return;
    const i2 = PM, n2 = LM;
    this.vectorToWorldFrame(t6, i2), this.vectorToWorldFrame(e2, n2), this.applyImpulse(i2, n2);
  }
  updateMassProperties() {
    const t6 = IM;
    this.invMass = this.mass > 0 ? 1 / this.mass : 0;
    const e2 = this.inertia, i2 = this.fixedRotation;
    this.updateAABB(), t6.set((this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2, (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2, (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2), hM.calculateInertia(t6, this.mass, e2), this.invInertia.set(e2.x > 0 && !i2 ? 1 / e2.x : 0, e2.y > 0 && !i2 ? 1 / e2.y : 0, e2.z > 0 && !i2 ? 1 / e2.z : 0), this.updateInertiaWorld(true);
  }
  getVelocityAtWorldPoint(t6, e2) {
    const i2 = new GS();
    return t6.vsub(this.position, i2), this.angularVelocity.cross(i2, e2), this.velocity.vadd(e2, e2), e2;
  }
  integrate(t6, e2, i2) {
    if (this.previousPosition.copy(this.position), this.previousQuaternion.copy(this.quaternion), this.type !== _xM.DYNAMIC && this.type !== _xM.KINEMATIC || this.sleepState === _xM.SLEEPING) return;
    const n2 = this.velocity, r2 = this.angularVelocity, s2 = this.position, o2 = this.force, a2 = this.torque, l2 = this.quaternion, c2 = this.invMass, h2 = this.invInertiaWorld, u2 = this.linearFactor, d2 = c2 * t6;
    n2.x += o2.x * d2 * u2.x, n2.y += o2.y * d2 * u2.y, n2.z += o2.z * d2 * u2.z;
    const p2 = h2.elements, f2 = this.angularFactor, m2 = a2.x * f2.x, g2 = a2.y * f2.y, v2 = a2.z * f2.z;
    r2.x += t6 * (p2[0] * m2 + p2[1] * g2 + p2[2] * v2), r2.y += t6 * (p2[3] * m2 + p2[4] * g2 + p2[5] * v2), r2.z += t6 * (p2[6] * m2 + p2[7] * g2 + p2[8] * v2), s2.x += n2.x * t6, s2.y += n2.y * t6, s2.z += n2.z * t6, l2.integrate(this.angularVelocity, t6, this.angularFactor, l2), e2 && (i2 ? l2.normalizeFast() : l2.normalize()), this.aabbNeedsUpdate = true, this.updateInertiaWorld();
  }
};
xM.idCounter = 0, xM.COLLIDE_EVENT_NAME = "collide", xM.DYNAMIC = pM, xM.STATIC = fM, xM.KINEMATIC = mM, xM.AWAKE = gM, xM.SLEEPY = vM, xM.SLEEPING = yM, xM.wakeupEvent = { type: "wakeup" }, xM.sleepyEvent = { type: "sleepy" }, xM.sleepEvent = { type: "sleep" };
var bM = new GS();
var wM = new QS();
var _M = new YS();
var SM = new VS();
var MM = new VS();
var TM = new GS();
var EM = new GS();
var AM = new GS();
var CM = new GS();
var RM = new GS();
var PM = new GS();
var LM = new GS();
var IM = new GS();
var DM = class {
  constructor() {
    this.world = void 0, this.useBoundingBoxes = void 0, this.dirty = void 0, this.world = null, this.useBoundingBoxes = false, this.dirty = true;
  }
  collisionPairs(t6, e2, i2) {
    throw new Error("collisionPairs not implemented for this BroadPhase class!");
  }
  needBroadphaseCollision(t6, e2) {
    return !!(t6.collisionFilterGroup & e2.collisionFilterMask && e2.collisionFilterGroup & t6.collisionFilterMask) && (!(t6.type & xM.STATIC || t6.sleepState === xM.SLEEPING) || !(e2.type & xM.STATIC || e2.sleepState === xM.SLEEPING));
  }
  intersectionTest(t6, e2, i2, n2) {
    this.useBoundingBoxes ? this.doBoundingBoxBroadphase(t6, e2, i2, n2) : this.doBoundingSphereBroadphase(t6, e2, i2, n2);
  }
  doBoundingSphereBroadphase(t6, e2, i2, n2) {
    const r2 = OM;
    e2.position.vsub(t6.position, r2);
    const s2 = (t6.boundingRadius + e2.boundingRadius) ** 2;
    r2.lengthSquared() < s2 && (i2.push(t6), n2.push(e2));
  }
  doBoundingBoxBroadphase(t6, e2, i2, n2) {
    t6.aabbNeedsUpdate && t6.updateAABB(), e2.aabbNeedsUpdate && e2.updateAABB(), t6.aabb.overlaps(e2.aabb) && (i2.push(t6), n2.push(e2));
  }
  makePairsUnique(t6, e2) {
    const i2 = zM, n2 = FM, r2 = NM, s2 = t6.length;
    for (let i3 = 0; i3 !== s2; i3++) n2[i3] = t6[i3], r2[i3] = e2[i3];
    t6.length = 0, e2.length = 0;
    for (let t7 = 0; t7 !== s2; t7++) {
      const e3 = n2[t7].id, s3 = r2[t7].id, o2 = e3 < s3 ? e3 + "," + s3 : s3 + "," + e3;
      i2[o2] = t7, i2.keys.push(o2);
    }
    for (let s3 = 0; s3 !== i2.keys.length; s3++) {
      const s4 = i2.keys.pop(), o2 = i2[s4];
      t6.push(n2[o2]), e2.push(r2[o2]), delete i2[s4];
    }
  }
  setWorld(t6) {
  }
  static boundingSphereCheck(t6, e2) {
    const i2 = new GS();
    t6.position.vsub(e2.position, i2);
    const n2 = t6.shapes[0], r2 = e2.shapes[0];
    return Math.pow(n2.boundingSphereRadius + r2.boundingSphereRadius, 2) > i2.lengthSquared();
  }
  aabbQuery(t6, e2, i2) {
    return console.warn(".aabbQuery is not implemented in this Broadphase subclass."), [];
  }
};
var OM = new GS();
var zM = { keys: [] };
var FM = [];
var NM = [];
new GS();
var BM = class extends DM {
  constructor() {
    super();
  }
  collisionPairs(t6, e2, i2) {
    const n2 = t6.bodies, r2 = n2.length;
    let s2, o2;
    for (let t7 = 0; t7 !== r2; t7++) for (let r3 = 0; r3 !== t7; r3++) s2 = n2[t7], o2 = n2[r3], this.needBroadphaseCollision(s2, o2) && this.intersectionTest(s2, o2, e2, i2);
  }
  aabbQuery(t6, e2, i2 = []) {
    for (let n2 = 0; n2 < t6.bodies.length; n2++) {
      const r2 = t6.bodies[n2];
      r2.aabbNeedsUpdate && r2.updateAABB(), r2.aabb.overlaps(e2) && i2.push(r2);
    }
    return i2;
  }
};
var kM = class {
  constructor() {
    this.rayFromWorld = void 0, this.rayToWorld = void 0, this.hitNormalWorld = void 0, this.hitPointWorld = void 0, this.hasHit = void 0, this.shape = void 0, this.body = void 0, this.hitFaceIndex = void 0, this.distance = void 0, this.shouldStop = void 0, this.rayFromWorld = new GS(), this.rayToWorld = new GS(), this.hitNormalWorld = new GS(), this.hitPointWorld = new GS(), this.hasHit = false, this.shape = null, this.body = null, this.hitFaceIndex = -1, this.distance = -1, this.shouldStop = false;
  }
  reset() {
    this.rayFromWorld.setZero(), this.rayToWorld.setZero(), this.hitNormalWorld.setZero(), this.hitPointWorld.setZero(), this.hasHit = false, this.shape = null, this.body = null, this.hitFaceIndex = -1, this.distance = -1, this.shouldStop = false;
  }
  abort() {
    this.shouldStop = true;
  }
  set(t6, e2, i2, n2, r2, s2, o2) {
    this.rayFromWorld.copy(t6), this.rayToWorld.copy(e2), this.hitNormalWorld.copy(i2), this.hitPointWorld.copy(n2), this.shape = r2, this.body = s2, this.distance = o2;
  }
};
var UM;
var HM;
var VM;
var jM;
var GM;
var WM;
var qM;
var XM = 1;
var YM = 2;
var ZM = 4;
UM = iM.types.SPHERE, HM = iM.types.PLANE, VM = iM.types.BOX, jM = iM.types.CYLINDER, GM = iM.types.CONVEXPOLYHEDRON, WM = iM.types.HEIGHTFIELD, qM = iM.types.TRIMESH;
var JM = class _JM {
  get [UM]() {
    return this._intersectSphere;
  }
  get [HM]() {
    return this._intersectPlane;
  }
  get [VM]() {
    return this._intersectBox;
  }
  get [jM]() {
    return this._intersectConvex;
  }
  get [GM]() {
    return this._intersectConvex;
  }
  get [WM]() {
    return this._intersectHeightfield;
  }
  get [qM]() {
    return this._intersectTrimesh;
  }
  constructor(t6 = new GS(), e2 = new GS()) {
    this.from = void 0, this.to = void 0, this.direction = void 0, this.precision = void 0, this.checkCollisionResponse = void 0, this.skipBackfaces = void 0, this.collisionFilterMask = void 0, this.collisionFilterGroup = void 0, this.mode = void 0, this.result = void 0, this.hasHit = void 0, this.callback = void 0, this.from = t6.clone(), this.to = e2.clone(), this.direction = new GS(), this.precision = 1e-4, this.checkCollisionResponse = true, this.skipBackfaces = false, this.collisionFilterMask = -1, this.collisionFilterGroup = -1, this.mode = _JM.ANY, this.result = new kM(), this.hasHit = false, this.callback = (t7) => {
    };
  }
  intersectWorld(t6, e2) {
    return this.mode = e2.mode || _JM.ANY, this.result = e2.result || new kM(), this.skipBackfaces = !!e2.skipBackfaces, this.collisionFilterMask = void 0 !== e2.collisionFilterMask ? e2.collisionFilterMask : -1, this.collisionFilterGroup = void 0 !== e2.collisionFilterGroup ? e2.collisionFilterGroup : -1, this.checkCollisionResponse = void 0 === e2.checkCollisionResponse || e2.checkCollisionResponse, e2.from && this.from.copy(e2.from), e2.to && this.to.copy(e2.to), this.callback = e2.callback || (() => {
    }), this.hasHit = false, this.result.reset(), this.updateDirection(), this.getAABB(KM), $M.length = 0, t6.broadphase.aabbQuery(t6, KM, $M), this.intersectBodies($M), this.hasHit;
  }
  intersectBody(t6, e2) {
    e2 && (this.result = e2, this.updateDirection());
    const i2 = this.checkCollisionResponse;
    if (i2 && !t6.collisionResponse) return;
    if (!(this.collisionFilterGroup & t6.collisionFilterMask && t6.collisionFilterGroup & this.collisionFilterMask)) return;
    const n2 = eT, r2 = iT;
    for (let e3 = 0, s2 = t6.shapes.length; e3 < s2; e3++) {
      const s3 = t6.shapes[e3];
      if ((!i2 || s3.collisionResponse) && (t6.quaternion.mult(t6.shapeOrientations[e3], r2), t6.quaternion.vmult(t6.shapeOffsets[e3], n2), n2.vadd(t6.position, n2), this.intersectShape(s3, r2, n2, t6), this.result.shouldStop)) break;
    }
  }
  intersectBodies(t6, e2) {
    e2 && (this.result = e2, this.updateDirection());
    for (let e3 = 0, i2 = t6.length; !this.result.shouldStop && e3 < i2; e3++) this.intersectBody(t6[e3]);
  }
  updateDirection() {
    this.to.vsub(this.from, this.direction), this.direction.normalize();
  }
  intersectShape(t6, e2, i2, n2) {
    const r2 = (function(t7, e3, i3) {
      i3.vsub(t7, ST);
      const n3 = ST.dot(e3);
      e3.scale(n3, MT), MT.vadd(t7, MT);
      const r3 = i3.distanceTo(MT);
      return r3;
    })(this.from, this.direction, i2);
    if (r2 > t6.boundingSphereRadius) return;
    const s2 = this[t6.type];
    s2 && s2.call(this, t6, e2, i2, n2, t6);
  }
  _intersectBox(t6, e2, i2, n2, r2) {
    return this._intersectConvex(t6.convexPolyhedronRepresentation, e2, i2, n2, r2);
  }
  _intersectPlane(t6, e2, i2, n2, r2) {
    const s2 = this.from, o2 = this.to, a2 = this.direction, l2 = new GS(0, 0, 1);
    e2.vmult(l2, l2);
    const c2 = new GS();
    s2.vsub(i2, c2);
    const h2 = c2.dot(l2);
    o2.vsub(i2, c2);
    if (h2 * c2.dot(l2) > 0) return;
    if (s2.distanceTo(o2) < h2) return;
    const u2 = l2.dot(a2);
    if (Math.abs(u2) < this.precision) return;
    const d2 = new GS(), p2 = new GS(), f2 = new GS();
    s2.vsub(i2, d2);
    const m2 = -l2.dot(d2) / u2;
    a2.scale(m2, p2), s2.vadd(p2, f2), this.reportIntersection(l2, f2, r2, n2, -1);
  }
  getAABB(t6) {
    const { lowerBound: e2, upperBound: i2 } = t6, n2 = this.to, r2 = this.from;
    e2.x = Math.min(n2.x, r2.x), e2.y = Math.min(n2.y, r2.y), e2.z = Math.min(n2.z, r2.z), i2.x = Math.max(n2.x, r2.x), i2.y = Math.max(n2.y, r2.y), i2.z = Math.max(n2.z, r2.z);
  }
  _intersectHeightfield(t6, e2, i2, n2, r2) {
    t6.data, t6.elementSize;
    const s2 = cT;
    s2.from.copy(this.from), s2.to.copy(this.to), nM.pointToLocalFrame(i2, e2, s2.from, s2.from), nM.pointToLocalFrame(i2, e2, s2.to, s2.to), s2.updateDirection();
    const o2 = hT;
    let a2, l2, c2, h2;
    a2 = l2 = 0, c2 = h2 = t6.data.length - 1;
    const u2 = new YS();
    s2.getAABB(u2), t6.getIndexOfPosition(u2.lowerBound.x, u2.lowerBound.y, o2, true), a2 = Math.max(a2, o2[0]), l2 = Math.max(l2, o2[1]), t6.getIndexOfPosition(u2.upperBound.x, u2.upperBound.y, o2, true), c2 = Math.min(c2, o2[0] + 1), h2 = Math.min(h2, o2[1] + 1);
    for (let o3 = a2; o3 < c2; o3++) for (let a3 = l2; a3 < h2; a3++) {
      if (this.result.shouldStop) return;
      if (t6.getAabbAtIndex(o3, a3, u2), u2.overlapsRay(s2)) {
        if (t6.getConvexTrianglePillar(o3, a3, false), nM.pointToWorldFrame(i2, e2, t6.pillarOffset, lT), this._intersectConvex(t6.pillarConvex, e2, lT, n2, r2, aT), this.result.shouldStop) return;
        t6.getConvexTrianglePillar(o3, a3, true), nM.pointToWorldFrame(i2, e2, t6.pillarOffset, lT), this._intersectConvex(t6.pillarConvex, e2, lT, n2, r2, aT);
      }
    }
  }
  _intersectSphere(t6, e2, i2, n2, r2) {
    const s2 = this.from, o2 = this.to, a2 = t6.radius, l2 = (o2.x - s2.x) ** 2 + (o2.y - s2.y) ** 2 + (o2.z - s2.z) ** 2, c2 = 2 * ((o2.x - s2.x) * (s2.x - i2.x) + (o2.y - s2.y) * (s2.y - i2.y) + (o2.z - s2.z) * (s2.z - i2.z)), h2 = c2 ** 2 - 4 * l2 * ((s2.x - i2.x) ** 2 + (s2.y - i2.y) ** 2 + (s2.z - i2.z) ** 2 - a2 ** 2), u2 = uT, d2 = dT;
    if (!(h2 < 0)) if (0 === h2) s2.lerp(o2, h2, u2), u2.vsub(i2, d2), d2.normalize(), this.reportIntersection(d2, u2, r2, n2, -1);
    else {
      const t7 = (-c2 - Math.sqrt(h2)) / (2 * l2), e3 = (-c2 + Math.sqrt(h2)) / (2 * l2);
      if (t7 >= 0 && t7 <= 1 && (s2.lerp(o2, t7, u2), u2.vsub(i2, d2), d2.normalize(), this.reportIntersection(d2, u2, r2, n2, -1)), this.result.shouldStop) return;
      e3 >= 0 && e3 <= 1 && (s2.lerp(o2, e3, u2), u2.vsub(i2, d2), d2.normalize(), this.reportIntersection(d2, u2, r2, n2, -1));
    }
  }
  _intersectConvex(t6, e2, i2, n2, r2, s2) {
    const o2 = pT, a2 = fT, l2 = s2 && s2.faceList || null, c2 = t6.faces, h2 = t6.vertices, u2 = t6.faceNormals, d2 = this.direction, p2 = this.from, f2 = this.to, m2 = p2.distanceTo(f2), g2 = l2 ? l2.length : c2.length, v2 = this.result;
    for (let t7 = 0; !v2.shouldStop && t7 < g2; t7++) {
      const s3 = l2 ? l2[t7] : t7, f3 = c2[s3], g3 = u2[s3], y2 = e2, x2 = i2;
      a2.copy(h2[f3[0]]), y2.vmult(a2, a2), a2.vadd(x2, a2), a2.vsub(p2, a2), y2.vmult(g3, o2);
      const b2 = d2.dot(o2);
      if (Math.abs(b2) < this.precision) continue;
      const w2 = o2.dot(a2) / b2;
      if (!(w2 < 0)) {
        d2.scale(w2, nT), nT.vadd(p2, nT), rT.copy(h2[f3[0]]), y2.vmult(rT, rT), x2.vadd(rT, rT);
        for (let t8 = 1; !v2.shouldStop && t8 < f3.length - 1; t8++) {
          sT.copy(h2[f3[t8]]), oT.copy(h2[f3[t8 + 1]]), y2.vmult(sT, sT), y2.vmult(oT, oT), x2.vadd(sT, sT), x2.vadd(oT, oT);
          const e3 = nT.distanceTo(p2);
          !_JM.pointInTriangle(nT, rT, sT, oT) && !_JM.pointInTriangle(nT, sT, rT, oT) || e3 > m2 || this.reportIntersection(o2, nT, r2, n2, s3);
        }
      }
    }
  }
  _intersectTrimesh(t6, e2, i2, n2, r2, s2) {
    const o2 = mT, a2 = wT, l2 = _T, c2 = fT, h2 = gT, u2 = vT, d2 = yT, p2 = bT, f2 = xT, m2 = t6.indices;
    t6.vertices;
    const g2 = this.from, v2 = this.to, y2 = this.direction;
    l2.position.copy(i2), l2.quaternion.copy(e2), nM.vectorToLocalFrame(i2, e2, y2, h2), nM.pointToLocalFrame(i2, e2, g2, u2), nM.pointToLocalFrame(i2, e2, v2, d2), d2.x *= t6.scale.x, d2.y *= t6.scale.y, d2.z *= t6.scale.z, u2.x *= t6.scale.x, u2.y *= t6.scale.y, u2.z *= t6.scale.z, d2.vsub(u2, h2), h2.normalize();
    const x2 = u2.distanceSquared(d2);
    t6.tree.rayQuery(this, l2, a2);
    for (let s3 = 0, l3 = a2.length; !this.result.shouldStop && s3 !== l3; s3++) {
      const l4 = a2[s3];
      t6.getNormal(l4, o2), t6.getVertex(m2[3 * l4], rT), rT.vsub(u2, c2);
      const d3 = h2.dot(o2), g3 = o2.dot(c2) / d3;
      if (g3 < 0) continue;
      h2.scale(g3, nT), nT.vadd(u2, nT), t6.getVertex(m2[3 * l4 + 1], sT), t6.getVertex(m2[3 * l4 + 2], oT);
      const v3 = nT.distanceSquared(u2);
      !_JM.pointInTriangle(nT, sT, rT, oT) && !_JM.pointInTriangle(nT, rT, sT, oT) || v3 > x2 || (nM.vectorToWorldFrame(e2, o2, f2), nM.pointToWorldFrame(i2, e2, nT, p2), this.reportIntersection(f2, p2, r2, n2, l4));
    }
    a2.length = 0;
  }
  reportIntersection(t6, e2, i2, n2, r2) {
    const s2 = this.from, o2 = this.to, a2 = s2.distanceTo(e2), l2 = this.result;
    if (!(this.skipBackfaces && t6.dot(this.direction) > 0)) switch (l2.hitFaceIndex = void 0 !== r2 ? r2 : -1, this.mode) {
      case _JM.ALL:
        this.hasHit = true, l2.set(s2, o2, t6, e2, i2, n2, a2), l2.hasHit = true, this.callback(l2);
        break;
      case _JM.CLOSEST:
        (a2 < l2.distance || !l2.hasHit) && (this.hasHit = true, l2.hasHit = true, l2.set(s2, o2, t6, e2, i2, n2, a2));
        break;
      case _JM.ANY:
        this.hasHit = true, l2.hasHit = true, l2.set(s2, o2, t6, e2, i2, n2, a2), l2.shouldStop = true;
    }
  }
  static pointInTriangle(t6, e2, i2, n2) {
    n2.vsub(e2, ST), i2.vsub(e2, QM), t6.vsub(e2, tT);
    const r2 = ST.dot(ST), s2 = ST.dot(QM), o2 = ST.dot(tT), a2 = QM.dot(QM), l2 = QM.dot(tT);
    let c2, h2;
    return (c2 = a2 * o2 - s2 * l2) >= 0 && (h2 = r2 * l2 - s2 * o2) >= 0 && c2 + h2 < r2 * a2 - s2 * s2;
  }
};
JM.CLOSEST = XM, JM.ANY = YM, JM.ALL = ZM;
var KM = new YS();
var $M = [];
var QM = new GS();
var tT = new GS();
var eT = new GS();
var iT = new QS();
var nT = new GS();
var rT = new GS();
var sT = new GS();
var oT = new GS();
var aT = { faceList: [0] };
var lT = new GS();
var cT = new JM();
var hT = [];
var uT = new GS();
var dT = new GS();
var pT = new GS();
var fT = new GS();
var mT = new GS();
var gT = new GS();
var vT = new GS();
var yT = new GS();
var xT = new GS();
var bT = new GS();
new YS();
var wT = [];
var _T = new nM();
var ST = new GS();
var MT = new GS();
var TT = class {
  static defaults(t6 = {}, e2) {
    for (let i2 in e2) i2 in t6 || (t6[i2] = e2[i2]);
    return t6;
  }
};
var ET = class _ET {
  constructor(t6, e2, i2 = {}) {
    this.equations = void 0, this.bodyA = void 0, this.bodyB = void 0, this.id = void 0, this.collideConnected = void 0, i2 = TT.defaults(i2, { collideConnected: true, wakeUpBodies: true }), this.equations = [], this.bodyA = t6, this.bodyB = e2, this.id = _ET.idCounter++, this.collideConnected = i2.collideConnected, i2.wakeUpBodies && (t6 && t6.wakeUp(), e2 && e2.wakeUp());
  }
  update() {
    throw new Error("method update() not implmemented in this Constraint subclass!");
  }
  enable() {
    const t6 = this.equations;
    for (let e2 = 0; e2 < t6.length; e2++) t6[e2].enabled = true;
  }
  disable() {
    const t6 = this.equations;
    for (let e2 = 0; e2 < t6.length; e2++) t6[e2].enabled = false;
  }
};
ET.idCounter = 0;
var AT = class {
  constructor() {
    this.spatial = void 0, this.rotational = void 0, this.spatial = new GS(), this.rotational = new GS();
  }
  multiplyElement(t6) {
    return t6.spatial.dot(this.spatial) + t6.rotational.dot(this.rotational);
  }
  multiplyVectors(t6, e2) {
    return t6.dot(this.spatial) + e2.dot(this.rotational);
  }
};
var CT = class _CT {
  constructor(t6, e2, i2 = -1e6, n2 = 1e6) {
    this.id = void 0, this.minForce = void 0, this.maxForce = void 0, this.bi = void 0, this.bj = void 0, this.si = void 0, this.sj = void 0, this.a = void 0, this.b = void 0, this.eps = void 0, this.jacobianElementA = void 0, this.jacobianElementB = void 0, this.enabled = void 0, this.multiplier = void 0, this.id = _CT.idCounter++, this.minForce = i2, this.maxForce = n2, this.bi = t6, this.bj = e2, this.a = 0, this.b = 0, this.eps = 0, this.jacobianElementA = new AT(), this.jacobianElementB = new AT(), this.enabled = true, this.multiplier = 0, this.setSpookParams(1e7, 4, 1 / 60);
  }
  setSpookParams(t6, e2, i2) {
    const n2 = e2, r2 = t6, s2 = i2;
    this.a = 4 / (s2 * (1 + 4 * n2)), this.b = 4 * n2 / (1 + 4 * n2), this.eps = 4 / (s2 * s2 * r2 * (1 + 4 * n2));
  }
  computeB(t6, e2, i2) {
    const n2 = this.computeGW();
    return -this.computeGq() * t6 - n2 * e2 - this.computeGiMf() * i2;
  }
  computeGq() {
    const t6 = this.jacobianElementA, e2 = this.jacobianElementB, i2 = this.bi, n2 = this.bj, r2 = i2.position, s2 = n2.position;
    return t6.spatial.dot(r2) + e2.spatial.dot(s2);
  }
  computeGW() {
    const t6 = this.jacobianElementA, e2 = this.jacobianElementB, i2 = this.bi, n2 = this.bj, r2 = i2.velocity, s2 = n2.velocity, o2 = i2.angularVelocity, a2 = n2.angularVelocity;
    return t6.multiplyVectors(r2, o2) + e2.multiplyVectors(s2, a2);
  }
  computeGWlambda() {
    const t6 = this.jacobianElementA, e2 = this.jacobianElementB, i2 = this.bi, n2 = this.bj, r2 = i2.vlambda, s2 = n2.vlambda, o2 = i2.wlambda, a2 = n2.wlambda;
    return t6.multiplyVectors(r2, o2) + e2.multiplyVectors(s2, a2);
  }
  computeGiMf() {
    const t6 = this.jacobianElementA, e2 = this.jacobianElementB, i2 = this.bi, n2 = this.bj, r2 = i2.force, s2 = i2.torque, o2 = n2.force, a2 = n2.torque, l2 = i2.invMassSolve, c2 = n2.invMassSolve;
    return r2.scale(l2, RT), o2.scale(c2, PT), i2.invInertiaWorldSolve.vmult(s2, LT), n2.invInertiaWorldSolve.vmult(a2, IT), t6.multiplyVectors(RT, LT) + e2.multiplyVectors(PT, IT);
  }
  computeGiMGt() {
    const t6 = this.jacobianElementA, e2 = this.jacobianElementB, i2 = this.bi, n2 = this.bj, r2 = i2.invMassSolve, s2 = n2.invMassSolve, o2 = i2.invInertiaWorldSolve, a2 = n2.invInertiaWorldSolve;
    let l2 = r2 + s2;
    return o2.vmult(t6.rotational, DT), l2 += DT.dot(t6.rotational), a2.vmult(e2.rotational, DT), l2 += DT.dot(e2.rotational), l2;
  }
  addToWlambda(t6) {
    const e2 = this.jacobianElementA, i2 = this.jacobianElementB, n2 = this.bi, r2 = this.bj, s2 = OT;
    n2.vlambda.addScaledVector(n2.invMassSolve * t6, e2.spatial, n2.vlambda), r2.vlambda.addScaledVector(r2.invMassSolve * t6, i2.spatial, r2.vlambda), n2.invInertiaWorldSolve.vmult(e2.rotational, s2), n2.wlambda.addScaledVector(t6, s2, n2.wlambda), r2.invInertiaWorldSolve.vmult(i2.rotational, s2), r2.wlambda.addScaledVector(t6, s2, r2.wlambda);
  }
  computeC() {
    return this.computeGiMGt() + this.eps;
  }
};
CT.idCounter = 0;
var RT = new GS();
var PT = new GS();
var LT = new GS();
var IT = new GS();
var DT = new GS();
var OT = new GS();
var zT = class extends CT {
  constructor(t6, e2, i2 = 1e6) {
    super(t6, e2, 0, i2), this.restitution = void 0, this.ri = void 0, this.rj = void 0, this.ni = void 0, this.restitution = 0, this.ri = new GS(), this.rj = new GS(), this.ni = new GS();
  }
  computeB(t6) {
    const e2 = this.a, i2 = this.b, n2 = this.bi, r2 = this.bj, s2 = this.ri, o2 = this.rj, a2 = FT, l2 = NT, c2 = n2.velocity, h2 = n2.angularVelocity;
    n2.force, n2.torque;
    const u2 = r2.velocity, d2 = r2.angularVelocity;
    r2.force, r2.torque;
    const p2 = BT, f2 = this.jacobianElementA, m2 = this.jacobianElementB, g2 = this.ni;
    s2.cross(g2, a2), o2.cross(g2, l2), g2.negate(f2.spatial), a2.negate(f2.rotational), m2.spatial.copy(g2), m2.rotational.copy(l2), p2.copy(r2.position), p2.vadd(o2, p2), p2.vsub(n2.position, p2), p2.vsub(s2, p2);
    const v2 = g2.dot(p2), y2 = this.restitution + 1;
    return -v2 * e2 - (y2 * u2.dot(g2) - y2 * c2.dot(g2) + d2.dot(l2) - h2.dot(a2)) * i2 - t6 * this.computeGiMf();
  }
  getImpactVelocityAlongNormal() {
    const t6 = kT, e2 = UT, i2 = HT, n2 = VT, r2 = jT;
    return this.bi.position.vadd(this.ri, i2), this.bj.position.vadd(this.rj, n2), this.bi.getVelocityAtWorldPoint(i2, t6), this.bj.getVelocityAtWorldPoint(n2, e2), t6.vsub(e2, r2), this.ni.dot(r2);
  }
};
var FT = new GS();
var NT = new GS();
var BT = new GS();
var kT = new GS();
var UT = new GS();
var HT = new GS();
var VT = new GS();
var jT = new GS();
new GS(), new GS();
new GS(), new GS();
new GS(), new GS();
var GT = class extends CT {
  constructor(t6, e2, i2) {
    super(t6, e2, -i2, i2), this.ri = void 0, this.rj = void 0, this.t = void 0, this.ri = new GS(), this.rj = new GS(), this.t = new GS();
  }
  computeB(t6) {
    this.a;
    const e2 = this.b;
    this.bi, this.bj;
    const i2 = this.ri, n2 = this.rj, r2 = WT, s2 = qT, o2 = this.t;
    i2.cross(o2, r2), n2.cross(o2, s2);
    const a2 = this.jacobianElementA, l2 = this.jacobianElementB;
    o2.negate(a2.spatial), r2.negate(a2.rotational), l2.spatial.copy(o2), l2.rotational.copy(s2);
    return -this.computeGW() * e2 - t6 * this.computeGiMf();
  }
};
var WT = new GS();
var qT = new GS();
var XT = class _XT {
  constructor(t6, e2, i2) {
    this.id = void 0, this.materials = void 0, this.friction = void 0, this.restitution = void 0, this.contactEquationStiffness = void 0, this.contactEquationRelaxation = void 0, this.frictionEquationStiffness = void 0, this.frictionEquationRelaxation = void 0, i2 = TT.defaults(i2, { friction: 0.3, restitution: 0.3, contactEquationStiffness: 1e7, contactEquationRelaxation: 3, frictionEquationStiffness: 1e7, frictionEquationRelaxation: 3 }), this.id = _XT.idCounter++, this.materials = [t6, e2], this.friction = i2.friction, this.restitution = i2.restitution, this.contactEquationStiffness = i2.contactEquationStiffness, this.contactEquationRelaxation = i2.contactEquationRelaxation, this.frictionEquationStiffness = i2.frictionEquationStiffness, this.frictionEquationRelaxation = i2.frictionEquationRelaxation;
  }
};
XT.idCounter = 0;
var YT = class _YT {
  constructor(t6 = {}) {
    this.name = void 0, this.id = void 0, this.friction = void 0, this.restitution = void 0;
    let e2 = "";
    "string" == typeof t6 && (e2 = t6, t6 = {}), this.name = e2, this.id = _YT.idCounter++, this.friction = void 0 !== t6.friction ? t6.friction : -1, this.restitution = void 0 !== t6.restitution ? t6.restitution : -1;
  }
};
YT.idCounter = 0;
new GS(), new GS(), new GS(), new GS(), new GS(), new GS(), new GS(), new GS(), new GS(), new GS(), new GS();
new GS(), new GS();
new GS(), new GS(), new GS();
new JM();
new GS(), new GS(), new GS(1, 0, 0), new GS(0, 1, 0), new GS(0, 0, 1), new GS(), new GS(), new GS(), new GS();
new GS(), new GS(), new GS(), new GS();
new GS(), new GS(), new GS();
new GS(), new GS();
new GS(), new GS(), new GS(), new GS(), new GS(), new GS(), new GS();
var ZT = class extends iM {
  constructor() {
    super({ type: iM.types.PLANE }), this.worldNormal = void 0, this.worldNormalNeedsUpdate = void 0, this.boundingSphereRadius = void 0, this.worldNormal = new GS(), this.worldNormalNeedsUpdate = true, this.boundingSphereRadius = Number.MAX_VALUE;
  }
  computeWorldNormal(t6) {
    const e2 = this.worldNormal;
    e2.set(0, 0, 1), t6.vmult(e2, e2), this.worldNormalNeedsUpdate = false;
  }
  calculateLocalInertia(t6, e2 = new GS()) {
    return e2;
  }
  volume() {
    return Number.MAX_VALUE;
  }
  calculateWorldAABB(t6, e2, i2, n2) {
    JT.set(0, 0, 1), e2.vmult(JT, JT);
    const r2 = Number.MAX_VALUE;
    i2.set(-r2, -r2, -r2), n2.set(r2, r2, r2), 1 === JT.x ? n2.x = t6.x : -1 === JT.x && (i2.x = t6.x), 1 === JT.y ? n2.y = t6.y : -1 === JT.y && (i2.y = t6.y), 1 === JT.z ? n2.z = t6.z : -1 === JT.z && (i2.z = t6.z);
  }
  updateBoundingSphereRadius() {
    this.boundingSphereRadius = Number.MAX_VALUE;
  }
};
var JT = new GS();
new GS(), new GS(), new GS(), new GS(), new GS(), new GS(), new GS(), new GS(), new GS();
new GS(), new YS();
new GS(), new YS(), new GS(), new GS(), new GS(), new GS(), new GS(), new GS(), new GS(), new YS(), new GS(), new nM(), new YS();
var KT = class {
  constructor() {
    this.equations = void 0, this.equations = [];
  }
  solve(t6, e2) {
    return 0;
  }
  addEquation(t6) {
    !t6.enabled || t6.bi.isTrigger || t6.bj.isTrigger || this.equations.push(t6);
  }
  removeEquation(t6) {
    const e2 = this.equations, i2 = e2.indexOf(t6);
    -1 !== i2 && e2.splice(i2, 1);
  }
  removeAllEquations() {
    this.equations.length = 0;
  }
};
var $T = class extends KT {
  constructor() {
    super(), this.iterations = void 0, this.tolerance = void 0, this.iterations = 10, this.tolerance = 1e-7;
  }
  solve(t6, e2) {
    let i2 = 0;
    const n2 = this.iterations, r2 = this.tolerance * this.tolerance, s2 = this.equations, o2 = s2.length, a2 = e2.bodies, l2 = a2.length, c2 = t6;
    let h2, u2, d2, p2, f2, m2;
    if (0 !== o2) for (let t7 = 0; t7 !== l2; t7++) a2[t7].updateSolveMassProperties();
    const g2 = tE, v2 = eE, y2 = QT;
    g2.length = o2, v2.length = o2, y2.length = o2;
    for (let t7 = 0; t7 !== o2; t7++) {
      const e3 = s2[t7];
      y2[t7] = 0, v2[t7] = e3.computeB(c2), g2[t7] = 1 / e3.computeC();
    }
    if (0 !== o2) {
      for (let t8 = 0; t8 !== l2; t8++) {
        const e4 = a2[t8], i3 = e4.vlambda, n3 = e4.wlambda;
        i3.set(0, 0, 0), n3.set(0, 0, 0);
      }
      for (i2 = 0; i2 !== n2; i2++) {
        p2 = 0;
        for (let t8 = 0; t8 !== o2; t8++) {
          const e4 = s2[t8];
          h2 = v2[t8], u2 = g2[t8], m2 = y2[t8], f2 = e4.computeGWlambda(), d2 = u2 * (h2 - f2 - e4.eps * m2), m2 + d2 < e4.minForce ? d2 = e4.minForce - m2 : m2 + d2 > e4.maxForce && (d2 = e4.maxForce - m2), y2[t8] += d2, p2 += d2 > 0 ? d2 : -d2, e4.addToWlambda(d2);
        }
        if (p2 * p2 < r2) break;
      }
      for (let t8 = 0; t8 !== l2; t8++) {
        const e4 = a2[t8], i3 = e4.velocity, n3 = e4.angularVelocity;
        e4.vlambda.vmul(e4.linearFactor, e4.vlambda), i3.vadd(e4.vlambda, i3), e4.wlambda.vmul(e4.angularFactor, e4.wlambda), n3.vadd(e4.wlambda, n3);
      }
      let t7 = s2.length;
      const e3 = 1 / c2;
      for (; t7--; ) s2[t7].multiplier = y2[t7] * e3;
    }
    return i2;
  }
};
var QT = [];
var tE = [];
var eE = [];
xM.STATIC;
var iE = class {
  constructor() {
    this.objects = [], this.type = Object;
  }
  release(...t6) {
    const e2 = t6.length;
    for (let i2 = 0; i2 !== e2; i2++) this.objects.push(t6[i2]);
    return this;
  }
  get() {
    return 0 === this.objects.length ? this.constructObject() : this.objects.pop();
  }
  constructObject() {
    throw new Error("constructObject() not implemented in this Pool subclass yet!");
  }
  resize(t6) {
    const e2 = this.objects;
    for (; e2.length > t6; ) e2.pop();
    for (; e2.length < t6; ) e2.push(this.constructObject());
    return this;
  }
};
var nE = class extends iE {
  constructor(...t6) {
    super(...t6), this.type = GS;
  }
  constructObject() {
    return new GS();
  }
};
var rE;
var sE;
var oE;
var aE;
var lE;
var cE;
var hE;
var uE;
var dE;
var pE;
var fE;
var mE;
var gE;
var vE;
var yE;
var xE;
var bE;
var wE;
var _E;
var SE;
var ME;
var TE;
var EE;
var AE;
var CE;
var RE = { sphereSphere: iM.types.SPHERE, spherePlane: iM.types.SPHERE | iM.types.PLANE, boxBox: iM.types.BOX | iM.types.BOX, sphereBox: iM.types.SPHERE | iM.types.BOX, planeBox: iM.types.PLANE | iM.types.BOX, convexConvex: iM.types.CONVEXPOLYHEDRON, sphereConvex: iM.types.SPHERE | iM.types.CONVEXPOLYHEDRON, planeConvex: iM.types.PLANE | iM.types.CONVEXPOLYHEDRON, boxConvex: iM.types.BOX | iM.types.CONVEXPOLYHEDRON, sphereHeightfield: iM.types.SPHERE | iM.types.HEIGHTFIELD, boxHeightfield: iM.types.BOX | iM.types.HEIGHTFIELD, convexHeightfield: iM.types.CONVEXPOLYHEDRON | iM.types.HEIGHTFIELD, sphereParticle: iM.types.PARTICLE | iM.types.SPHERE, planeParticle: iM.types.PLANE | iM.types.PARTICLE, boxParticle: iM.types.BOX | iM.types.PARTICLE, convexParticle: iM.types.PARTICLE | iM.types.CONVEXPOLYHEDRON, cylinderCylinder: iM.types.CYLINDER, sphereCylinder: iM.types.SPHERE | iM.types.CYLINDER, planeCylinder: iM.types.PLANE | iM.types.CYLINDER, boxCylinder: iM.types.BOX | iM.types.CYLINDER, convexCylinder: iM.types.CONVEXPOLYHEDRON | iM.types.CYLINDER, heightfieldCylinder: iM.types.HEIGHTFIELD | iM.types.CYLINDER, particleCylinder: iM.types.PARTICLE | iM.types.CYLINDER, sphereTrimesh: iM.types.SPHERE | iM.types.TRIMESH, planeTrimesh: iM.types.PLANE | iM.types.TRIMESH };
rE = RE.sphereSphere, sE = RE.spherePlane, oE = RE.boxBox, aE = RE.sphereBox, lE = RE.planeBox, cE = RE.convexConvex, hE = RE.sphereConvex, uE = RE.planeConvex, dE = RE.boxConvex, pE = RE.sphereHeightfield, fE = RE.boxHeightfield, mE = RE.convexHeightfield, gE = RE.sphereParticle, vE = RE.planeParticle, yE = RE.boxParticle, xE = RE.convexParticle, bE = RE.cylinderCylinder, wE = RE.sphereCylinder, _E = RE.planeCylinder, SE = RE.boxCylinder, ME = RE.convexCylinder, TE = RE.heightfieldCylinder, EE = RE.particleCylinder, AE = RE.sphereTrimesh, CE = RE.planeTrimesh;
var PE = class {
  get [rE]() {
    return this.sphereSphere;
  }
  get [sE]() {
    return this.spherePlane;
  }
  get [oE]() {
    return this.boxBox;
  }
  get [aE]() {
    return this.sphereBox;
  }
  get [lE]() {
    return this.planeBox;
  }
  get [cE]() {
    return this.convexConvex;
  }
  get [hE]() {
    return this.sphereConvex;
  }
  get [uE]() {
    return this.planeConvex;
  }
  get [dE]() {
    return this.boxConvex;
  }
  get [pE]() {
    return this.sphereHeightfield;
  }
  get [fE]() {
    return this.boxHeightfield;
  }
  get [mE]() {
    return this.convexHeightfield;
  }
  get [gE]() {
    return this.sphereParticle;
  }
  get [vE]() {
    return this.planeParticle;
  }
  get [yE]() {
    return this.boxParticle;
  }
  get [xE]() {
    return this.convexParticle;
  }
  get [bE]() {
    return this.convexConvex;
  }
  get [wE]() {
    return this.sphereConvex;
  }
  get [_E]() {
    return this.planeConvex;
  }
  get [SE]() {
    return this.boxConvex;
  }
  get [ME]() {
    return this.convexConvex;
  }
  get [TE]() {
    return this.heightfieldCylinder;
  }
  get [EE]() {
    return this.particleCylinder;
  }
  get [AE]() {
    return this.sphereTrimesh;
  }
  get [CE]() {
    return this.planeTrimesh;
  }
  constructor(t6) {
    this.contactPointPool = void 0, this.frictionEquationPool = void 0, this.result = void 0, this.frictionResult = void 0, this.v3pool = void 0, this.world = void 0, this.currentContactMaterial = void 0, this.enableFrictionReduction = void 0, this.contactPointPool = [], this.frictionEquationPool = [], this.result = [], this.frictionResult = [], this.v3pool = new nE(), this.world = t6, this.currentContactMaterial = t6.defaultContactMaterial, this.enableFrictionReduction = false;
  }
  createContactEquation(t6, e2, i2, n2, r2, s2) {
    let o2;
    this.contactPointPool.length ? (o2 = this.contactPointPool.pop(), o2.bi = t6, o2.bj = e2) : o2 = new zT(t6, e2), o2.enabled = t6.collisionResponse && e2.collisionResponse && i2.collisionResponse && n2.collisionResponse;
    const a2 = this.currentContactMaterial;
    o2.restitution = a2.restitution, o2.setSpookParams(a2.contactEquationStiffness, a2.contactEquationRelaxation, this.world.dt);
    const l2 = i2.material || t6.material, c2 = n2.material || e2.material;
    return l2 && c2 && l2.restitution >= 0 && c2.restitution >= 0 && (o2.restitution = l2.restitution * c2.restitution), o2.si = r2 || i2, o2.sj = s2 || n2, o2;
  }
  createFrictionEquationsFromContact(t6, e2) {
    const i2 = t6.bi, n2 = t6.bj, r2 = t6.si, s2 = t6.sj, o2 = this.world, a2 = this.currentContactMaterial;
    let l2 = a2.friction;
    const c2 = r2.material || i2.material, h2 = s2.material || n2.material;
    if (c2 && h2 && c2.friction >= 0 && h2.friction >= 0 && (l2 = c2.friction * h2.friction), l2 > 0) {
      const r3 = l2 * o2.gravity.length();
      let s3 = i2.invMass + n2.invMass;
      s3 > 0 && (s3 = 1 / s3);
      const c3 = this.frictionEquationPool, h3 = c3.length ? c3.pop() : new GT(i2, n2, r3 * s3), u2 = c3.length ? c3.pop() : new GT(i2, n2, r3 * s3);
      return h3.bi = u2.bi = i2, h3.bj = u2.bj = n2, h3.minForce = u2.minForce = -r3 * s3, h3.maxForce = u2.maxForce = r3 * s3, h3.ri.copy(t6.ri), h3.rj.copy(t6.rj), u2.ri.copy(t6.ri), u2.rj.copy(t6.rj), t6.ni.tangents(h3.t, u2.t), h3.setSpookParams(a2.frictionEquationStiffness, a2.frictionEquationRelaxation, o2.dt), u2.setSpookParams(a2.frictionEquationStiffness, a2.frictionEquationRelaxation, o2.dt), h3.enabled = u2.enabled = t6.enabled, e2.push(h3, u2), true;
    }
    return false;
  }
  createFrictionFromAverage(t6) {
    let e2 = this.result[this.result.length - 1];
    if (!this.createFrictionEquationsFromContact(e2, this.frictionResult) || 1 === t6) return;
    const i2 = this.frictionResult[this.frictionResult.length - 2], n2 = this.frictionResult[this.frictionResult.length - 1];
    LE.setZero(), IE.setZero(), DE.setZero();
    const r2 = e2.bi;
    e2.bj;
    for (let i3 = 0; i3 !== t6; i3++) e2 = this.result[this.result.length - 1 - i3], e2.bi !== r2 ? (LE.vadd(e2.ni, LE), IE.vadd(e2.ri, IE), DE.vadd(e2.rj, DE)) : (LE.vsub(e2.ni, LE), IE.vadd(e2.rj, IE), DE.vadd(e2.ri, DE));
    const s2 = 1 / t6;
    IE.scale(s2, i2.ri), DE.scale(s2, i2.rj), n2.ri.copy(i2.ri), n2.rj.copy(i2.rj), LE.normalize(), LE.tangents(i2.t, n2.t);
  }
  getContacts(t6, e2, i2, n2, r2, s2, o2) {
    this.contactPointPool = r2, this.frictionEquationPool = o2, this.result = n2, this.frictionResult = s2;
    const a2 = FE, l2 = NE, c2 = OE, h2 = zE;
    for (let n3 = 0, r3 = t6.length; n3 !== r3; n3++) {
      const r4 = t6[n3], s3 = e2[n3];
      let o3 = null;
      r4.material && s3.material && (o3 = i2.getContactMaterial(r4.material, s3.material) || null);
      const u2 = r4.type & xM.KINEMATIC && s3.type & xM.STATIC || r4.type & xM.STATIC && s3.type & xM.KINEMATIC || r4.type & xM.KINEMATIC && s3.type & xM.KINEMATIC;
      for (let t7 = 0; t7 < r4.shapes.length; t7++) {
        r4.quaternion.mult(r4.shapeOrientations[t7], a2), r4.quaternion.vmult(r4.shapeOffsets[t7], c2), c2.vadd(r4.position, c2);
        const e3 = r4.shapes[t7];
        for (let t8 = 0; t8 < s3.shapes.length; t8++) {
          s3.quaternion.mult(s3.shapeOrientations[t8], l2), s3.quaternion.vmult(s3.shapeOffsets[t8], h2), h2.vadd(s3.position, h2);
          const n4 = s3.shapes[t8];
          if (!(e3.collisionFilterMask & n4.collisionFilterGroup && n4.collisionFilterMask & e3.collisionFilterGroup)) continue;
          if (c2.distanceTo(h2) > e3.boundingSphereRadius + n4.boundingSphereRadius) continue;
          let d2 = null;
          e3.material && n4.material && (d2 = i2.getContactMaterial(e3.material, n4.material) || null), this.currentContactMaterial = d2 || o3 || i2.defaultContactMaterial;
          const p2 = this[e3.type | n4.type];
          if (p2) {
            let t9 = false;
            t9 = e3.type < n4.type ? p2.call(this, e3, n4, c2, h2, a2, l2, r4, s3, e3, n4, u2) : p2.call(this, n4, e3, h2, c2, l2, a2, s3, r4, e3, n4, u2), t9 && u2 && (i2.shapeOverlapKeeper.set(e3.id, n4.id), i2.bodyOverlapKeeper.set(r4.id, s3.id));
          }
        }
      }
    }
  }
  sphereSphere(t6, e2, i2, n2, r2, s2, o2, a2, l2, c2, h2) {
    if (h2) return i2.distanceSquared(n2) < (t6.radius + e2.radius) ** 2;
    const u2 = this.createContactEquation(o2, a2, t6, e2, l2, c2);
    n2.vsub(i2, u2.ni), u2.ni.normalize(), u2.ri.copy(u2.ni), u2.rj.copy(u2.ni), u2.ri.scale(t6.radius, u2.ri), u2.rj.scale(-e2.radius, u2.rj), u2.ri.vadd(i2, u2.ri), u2.ri.vsub(o2.position, u2.ri), u2.rj.vadd(n2, u2.rj), u2.rj.vsub(a2.position, u2.rj), this.result.push(u2), this.createFrictionEquationsFromContact(u2, this.frictionResult);
  }
  spherePlane(t6, e2, i2, n2, r2, s2, o2, a2, l2, c2, h2) {
    const u2 = this.createContactEquation(o2, a2, t6, e2, l2, c2);
    if (u2.ni.set(0, 0, 1), s2.vmult(u2.ni, u2.ni), u2.ni.negate(u2.ni), u2.ni.normalize(), u2.ni.scale(t6.radius, u2.ri), i2.vsub(n2, iA), u2.ni.scale(u2.ni.dot(iA), nA), iA.vsub(nA, u2.rj), -iA.dot(u2.ni) <= t6.radius) {
      if (h2) return true;
      const t7 = u2.ri, e3 = u2.rj;
      t7.vadd(i2, t7), t7.vsub(o2.position, t7), e3.vadd(n2, e3), e3.vsub(a2.position, e3), this.result.push(u2), this.createFrictionEquationsFromContact(u2, this.frictionResult);
    }
  }
  boxBox(t6, e2, i2, n2, r2, s2, o2, a2, l2, c2, h2) {
    return t6.convexPolyhedronRepresentation.material = t6.material, e2.convexPolyhedronRepresentation.material = e2.material, t6.convexPolyhedronRepresentation.collisionResponse = t6.collisionResponse, e2.convexPolyhedronRepresentation.collisionResponse = e2.collisionResponse, this.convexConvex(t6.convexPolyhedronRepresentation, e2.convexPolyhedronRepresentation, i2, n2, r2, s2, o2, a2, t6, e2, h2);
  }
  sphereBox(t6, e2, i2, n2, r2, s2, o2, a2, l2, c2, h2) {
    const u2 = this.v3pool, d2 = dA;
    i2.vsub(n2, lA), e2.getSideNormals(d2, s2);
    const p2 = t6.radius;
    let f2 = false;
    const m2 = fA, g2 = mA, v2 = gA;
    let y2 = null, x2 = 0, b2 = 0, w2 = 0, _2 = null;
    for (let t7 = 0, e3 = d2.length; t7 !== e3 && false === f2; t7++) {
      const e4 = cA;
      e4.copy(d2[t7]);
      const i3 = e4.length();
      e4.normalize();
      const n3 = lA.dot(e4);
      if (n3 < i3 + p2 && n3 > 0) {
        const r3 = hA, s3 = uA;
        r3.copy(d2[(t7 + 1) % 3]), s3.copy(d2[(t7 + 2) % 3]);
        const o3 = r3.length(), a3 = s3.length();
        r3.normalize(), s3.normalize();
        const l3 = lA.dot(r3), c3 = lA.dot(s3);
        if (l3 < o3 && l3 > -o3 && c3 < a3 && c3 > -a3) {
          const t8 = Math.abs(n3 - i3 - p2);
          if ((null === _2 || t8 < _2) && (_2 = t8, b2 = l3, w2 = c3, y2 = i3, m2.copy(e4), g2.copy(r3), v2.copy(s3), x2++, h2)) return true;
        }
      }
    }
    if (x2) {
      f2 = true;
      const r3 = this.createContactEquation(o2, a2, t6, e2, l2, c2);
      m2.scale(-p2, r3.ri), r3.ni.copy(m2), r3.ni.negate(r3.ni), m2.scale(y2, m2), g2.scale(b2, g2), m2.vadd(g2, m2), v2.scale(w2, v2), m2.vadd(v2, r3.rj), r3.ri.vadd(i2, r3.ri), r3.ri.vsub(o2.position, r3.ri), r3.rj.vadd(n2, r3.rj), r3.rj.vsub(a2.position, r3.rj), this.result.push(r3), this.createFrictionEquationsFromContact(r3, this.frictionResult);
    }
    let S2 = u2.get();
    const M2 = pA;
    for (let r3 = 0; 2 !== r3 && !f2; r3++) for (let s3 = 0; 2 !== s3 && !f2; s3++) for (let u3 = 0; 2 !== u3 && !f2; u3++) if (S2.set(0, 0, 0), r3 ? S2.vadd(d2[0], S2) : S2.vsub(d2[0], S2), s3 ? S2.vadd(d2[1], S2) : S2.vsub(d2[1], S2), u3 ? S2.vadd(d2[2], S2) : S2.vsub(d2[2], S2), n2.vadd(S2, M2), M2.vsub(i2, M2), M2.lengthSquared() < p2 * p2) {
      if (h2) return true;
      f2 = true;
      const r4 = this.createContactEquation(o2, a2, t6, e2, l2, c2);
      r4.ri.copy(M2), r4.ri.normalize(), r4.ni.copy(r4.ri), r4.ri.scale(p2, r4.ri), r4.rj.copy(S2), r4.ri.vadd(i2, r4.ri), r4.ri.vsub(o2.position, r4.ri), r4.rj.vadd(n2, r4.rj), r4.rj.vsub(a2.position, r4.rj), this.result.push(r4), this.createFrictionEquationsFromContact(r4, this.frictionResult);
    }
    u2.release(S2), S2 = null;
    const T2 = u2.get(), E2 = u2.get(), A2 = u2.get(), C2 = u2.get(), R2 = u2.get(), P2 = d2.length;
    for (let r3 = 0; r3 !== P2 && !f2; r3++) for (let s3 = 0; s3 !== P2 && !f2; s3++) if (r3 % 3 != s3 % 3) {
      d2[s3].cross(d2[r3], T2), T2.normalize(), d2[r3].vadd(d2[s3], E2), A2.copy(i2), A2.vsub(E2, A2), A2.vsub(n2, A2);
      const u3 = A2.dot(T2);
      T2.scale(u3, C2);
      let m3 = 0;
      for (; m3 === r3 % 3 || m3 === s3 % 3; ) m3++;
      R2.copy(i2), R2.vsub(C2, R2), R2.vsub(E2, R2), R2.vsub(n2, R2);
      const g3 = Math.abs(u3), v3 = R2.length();
      if (g3 < d2[m3].length() && v3 < p2) {
        if (h2) return true;
        f2 = true;
        const r4 = this.createContactEquation(o2, a2, t6, e2, l2, c2);
        E2.vadd(C2, r4.rj), r4.rj.copy(r4.rj), R2.negate(r4.ni), r4.ni.normalize(), r4.ri.copy(r4.rj), r4.ri.vadd(n2, r4.ri), r4.ri.vsub(i2, r4.ri), r4.ri.normalize(), r4.ri.scale(p2, r4.ri), r4.ri.vadd(i2, r4.ri), r4.ri.vsub(o2.position, r4.ri), r4.rj.vadd(n2, r4.rj), r4.rj.vsub(a2.position, r4.rj), this.result.push(r4), this.createFrictionEquationsFromContact(r4, this.frictionResult);
      }
    }
    u2.release(T2, E2, A2, C2, R2);
  }
  planeBox(t6, e2, i2, n2, r2, s2, o2, a2, l2, c2, h2) {
    return e2.convexPolyhedronRepresentation.material = e2.material, e2.convexPolyhedronRepresentation.collisionResponse = e2.collisionResponse, e2.convexPolyhedronRepresentation.id = e2.id, this.planeConvex(t6, e2.convexPolyhedronRepresentation, i2, n2, r2, s2, o2, a2, t6, e2, h2);
  }
  convexConvex(t6, e2, i2, n2, r2, s2, o2, a2, l2, c2, h2, u2, d2) {
    const p2 = LA;
    if (!(i2.distanceTo(n2) > t6.boundingSphereRadius + e2.boundingSphereRadius) && t6.findSeparatingAxis(e2, i2, r2, n2, s2, p2, u2, d2)) {
      const u3 = [], d3 = IA;
      t6.clipAgainstHull(i2, r2, e2, n2, s2, p2, -100, 100, u3);
      let f2 = 0;
      for (let r3 = 0; r3 !== u3.length; r3++) {
        if (h2) return true;
        const s3 = this.createContactEquation(o2, a2, t6, e2, l2, c2), m2 = s3.ri, g2 = s3.rj;
        p2.negate(s3.ni), u3[r3].normal.negate(d3), d3.scale(u3[r3].depth, d3), u3[r3].point.vadd(d3, m2), g2.copy(u3[r3].point), m2.vsub(i2, m2), g2.vsub(n2, g2), m2.vadd(i2, m2), m2.vsub(o2.position, m2), g2.vadd(n2, g2), g2.vsub(a2.position, g2), this.result.push(s3), f2++, this.enableFrictionReduction || this.createFrictionEquationsFromContact(s3, this.frictionResult);
      }
      this.enableFrictionReduction && f2 && this.createFrictionFromAverage(f2);
    }
  }
  sphereConvex(t6, e2, i2, n2, r2, s2, o2, a2, l2, c2, h2) {
    const u2 = this.v3pool;
    i2.vsub(n2, vA);
    const d2 = e2.faceNormals, p2 = e2.faces, f2 = e2.vertices, m2 = t6.radius;
    let g2 = false;
    for (let r3 = 0; r3 !== f2.length; r3++) {
      const u3 = f2[r3], d3 = wA;
      s2.vmult(u3, d3), n2.vadd(d3, d3);
      const p3 = bA;
      if (d3.vsub(i2, p3), p3.lengthSquared() < m2 * m2) {
        if (h2) return true;
        g2 = true;
        const r4 = this.createContactEquation(o2, a2, t6, e2, l2, c2);
        return r4.ri.copy(p3), r4.ri.normalize(), r4.ni.copy(r4.ri), r4.ri.scale(m2, r4.ri), d3.vsub(n2, r4.rj), r4.ri.vadd(i2, r4.ri), r4.ri.vsub(o2.position, r4.ri), r4.rj.vadd(n2, r4.rj), r4.rj.vsub(a2.position, r4.rj), this.result.push(r4), void this.createFrictionEquationsFromContact(r4, this.frictionResult);
      }
    }
    for (let r3 = 0, v2 = p2.length; r3 !== v2 && false === g2; r3++) {
      const v3 = d2[r3], y2 = p2[r3], x2 = _A;
      s2.vmult(v3, x2);
      const b2 = SA;
      s2.vmult(f2[y2[0]], b2), b2.vadd(n2, b2);
      const w2 = MA;
      x2.scale(-m2, w2), i2.vadd(w2, w2);
      const _2 = TA;
      w2.vsub(b2, _2);
      const S2 = _2.dot(x2), M2 = EA;
      if (i2.vsub(b2, M2), S2 < 0 && M2.dot(x2) > 0) {
        const r4 = [];
        for (let t7 = 0, e3 = y2.length; t7 !== e3; t7++) {
          const e4 = u2.get();
          s2.vmult(f2[y2[t7]], e4), n2.vadd(e4, e4), r4.push(e4);
        }
        if (aA(r4, x2, i2)) {
          if (h2) return true;
          g2 = true;
          const s3 = this.createContactEquation(o2, a2, t6, e2, l2, c2);
          x2.scale(-m2, s3.ri), x2.negate(s3.ni);
          const d3 = u2.get();
          x2.scale(-S2, d3);
          const p3 = u2.get();
          x2.scale(-m2, p3), i2.vsub(n2, s3.rj), s3.rj.vadd(p3, s3.rj), s3.rj.vadd(d3, s3.rj), s3.rj.vadd(n2, s3.rj), s3.rj.vsub(a2.position, s3.rj), s3.ri.vadd(i2, s3.ri), s3.ri.vsub(o2.position, s3.ri), u2.release(d3), u2.release(p3), this.result.push(s3), this.createFrictionEquationsFromContact(s3, this.frictionResult);
          for (let t7 = 0, e3 = r4.length; t7 !== e3; t7++) u2.release(r4[t7]);
          return;
        }
        for (let d3 = 0; d3 !== y2.length; d3++) {
          const p3 = u2.get(), g3 = u2.get();
          s2.vmult(f2[y2[(d3 + 1) % y2.length]], p3), s2.vmult(f2[y2[(d3 + 2) % y2.length]], g3), n2.vadd(p3, p3), n2.vadd(g3, g3);
          const v4 = yA;
          g3.vsub(p3, v4);
          const x3 = xA;
          v4.unit(x3);
          const b3 = u2.get(), w3 = u2.get();
          i2.vsub(p3, w3);
          const _3 = w3.dot(x3);
          x3.scale(_3, b3), b3.vadd(p3, b3);
          const S3 = u2.get();
          if (b3.vsub(i2, S3), _3 > 0 && _3 * _3 < v4.lengthSquared() && S3.lengthSquared() < m2 * m2) {
            if (h2) return true;
            const s3 = this.createContactEquation(o2, a2, t6, e2, l2, c2);
            b3.vsub(n2, s3.rj), b3.vsub(i2, s3.ni), s3.ni.normalize(), s3.ni.scale(m2, s3.ri), s3.rj.vadd(n2, s3.rj), s3.rj.vsub(a2.position, s3.rj), s3.ri.vadd(i2, s3.ri), s3.ri.vsub(o2.position, s3.ri), this.result.push(s3), this.createFrictionEquationsFromContact(s3, this.frictionResult);
            for (let t7 = 0, e3 = r4.length; t7 !== e3; t7++) u2.release(r4[t7]);
            return u2.release(p3), u2.release(g3), u2.release(b3), u2.release(S3), void u2.release(w3);
          }
          u2.release(p3), u2.release(g3), u2.release(b3), u2.release(S3), u2.release(w3);
        }
        for (let t7 = 0, e3 = r4.length; t7 !== e3; t7++) u2.release(r4[t7]);
      }
    }
  }
  planeConvex(t6, e2, i2, n2, r2, s2, o2, a2, l2, c2, h2) {
    const u2 = AA, d2 = CA;
    d2.set(0, 0, 1), r2.vmult(d2, d2);
    let p2 = 0;
    const f2 = RA;
    for (let r3 = 0; r3 !== e2.vertices.length; r3++) {
      u2.copy(e2.vertices[r3]), s2.vmult(u2, u2), n2.vadd(u2, u2), u2.vsub(i2, f2);
      if (d2.dot(f2) <= 0) {
        if (h2) return true;
        const r4 = this.createContactEquation(o2, a2, t6, e2, l2, c2), s3 = PA;
        d2.scale(d2.dot(f2), s3), u2.vsub(s3, s3), s3.vsub(i2, r4.ri), r4.ni.copy(d2), u2.vsub(n2, r4.rj), r4.ri.vadd(i2, r4.ri), r4.ri.vsub(o2.position, r4.ri), r4.rj.vadd(n2, r4.rj), r4.rj.vsub(a2.position, r4.rj), this.result.push(r4), p2++, this.enableFrictionReduction || this.createFrictionEquationsFromContact(r4, this.frictionResult);
      }
    }
    this.enableFrictionReduction && p2 && this.createFrictionFromAverage(p2);
  }
  boxConvex(t6, e2, i2, n2, r2, s2, o2, a2, l2, c2, h2) {
    return t6.convexPolyhedronRepresentation.material = t6.material, t6.convexPolyhedronRepresentation.collisionResponse = t6.collisionResponse, this.convexConvex(t6.convexPolyhedronRepresentation, e2, i2, n2, r2, s2, o2, a2, t6, e2, h2);
  }
  sphereHeightfield(t6, e2, i2, n2, r2, s2, o2, a2, l2, c2, h2) {
    const u2 = e2.data, d2 = t6.radius, p2 = e2.elementSize, f2 = qA, m2 = WA;
    nM.pointToLocalFrame(n2, s2, i2, m2);
    let g2 = Math.floor((m2.x - d2) / p2) - 1, v2 = Math.ceil((m2.x + d2) / p2) + 1, y2 = Math.floor((m2.y - d2) / p2) - 1, x2 = Math.ceil((m2.y + d2) / p2) + 1;
    if (v2 < 0 || x2 < 0 || g2 > u2.length || y2 > u2[0].length) return;
    g2 < 0 && (g2 = 0), v2 < 0 && (v2 = 0), y2 < 0 && (y2 = 0), x2 < 0 && (x2 = 0), g2 >= u2.length && (g2 = u2.length - 1), v2 >= u2.length && (v2 = u2.length - 1), x2 >= u2[0].length && (x2 = u2[0].length - 1), y2 >= u2[0].length && (y2 = u2[0].length - 1);
    const b2 = [];
    e2.getRectMinMax(g2, y2, v2, x2, b2);
    const w2 = b2[0], _2 = b2[1];
    if (m2.z - d2 > _2 || m2.z + d2 < w2) return;
    const S2 = this.result;
    for (let l3 = g2; l3 < v2; l3++) for (let c3 = y2; c3 < x2; c3++) {
      const u3 = S2.length;
      let d3 = false;
      if (e2.getConvexTrianglePillar(l3, c3, false), nM.pointToWorldFrame(n2, s2, e2.pillarOffset, f2), i2.distanceTo(f2) < e2.pillarConvex.boundingSphereRadius + t6.boundingSphereRadius && (d3 = this.sphereConvex(t6, e2.pillarConvex, i2, f2, r2, s2, o2, a2, t6, e2, h2)), h2 && d3) return true;
      if (e2.getConvexTrianglePillar(l3, c3, true), nM.pointToWorldFrame(n2, s2, e2.pillarOffset, f2), i2.distanceTo(f2) < e2.pillarConvex.boundingSphereRadius + t6.boundingSphereRadius && (d3 = this.sphereConvex(t6, e2.pillarConvex, i2, f2, r2, s2, o2, a2, t6, e2, h2)), h2 && d3) return true;
      if (S2.length - u3 > 2) return;
    }
  }
  boxHeightfield(t6, e2, i2, n2, r2, s2, o2, a2, l2, c2, h2) {
    return t6.convexPolyhedronRepresentation.material = t6.material, t6.convexPolyhedronRepresentation.collisionResponse = t6.collisionResponse, this.convexHeightfield(t6.convexPolyhedronRepresentation, e2, i2, n2, r2, s2, o2, a2, t6, e2, h2);
  }
  convexHeightfield(t6, e2, i2, n2, r2, s2, o2, a2, l2, c2, h2) {
    const u2 = e2.data, d2 = e2.elementSize, p2 = t6.boundingSphereRadius, f2 = jA, m2 = GA, g2 = VA;
    nM.pointToLocalFrame(n2, s2, i2, g2);
    let v2 = Math.floor((g2.x - p2) / d2) - 1, y2 = Math.ceil((g2.x + p2) / d2) + 1, x2 = Math.floor((g2.y - p2) / d2) - 1, b2 = Math.ceil((g2.y + p2) / d2) + 1;
    if (y2 < 0 || b2 < 0 || v2 > u2.length || x2 > u2[0].length) return;
    v2 < 0 && (v2 = 0), y2 < 0 && (y2 = 0), x2 < 0 && (x2 = 0), b2 < 0 && (b2 = 0), v2 >= u2.length && (v2 = u2.length - 1), y2 >= u2.length && (y2 = u2.length - 1), b2 >= u2[0].length && (b2 = u2[0].length - 1), x2 >= u2[0].length && (x2 = u2[0].length - 1);
    const w2 = [];
    e2.getRectMinMax(v2, x2, y2, b2, w2);
    const _2 = w2[0], S2 = w2[1];
    if (!(g2.z - p2 > S2 || g2.z + p2 < _2)) for (let l3 = v2; l3 < y2; l3++) for (let c3 = x2; c3 < b2; c3++) {
      let u3 = false;
      if (e2.getConvexTrianglePillar(l3, c3, false), nM.pointToWorldFrame(n2, s2, e2.pillarOffset, f2), i2.distanceTo(f2) < e2.pillarConvex.boundingSphereRadius + t6.boundingSphereRadius && (u3 = this.convexConvex(t6, e2.pillarConvex, i2, f2, r2, s2, o2, a2, null, null, h2, m2, null)), h2 && u3) return true;
      if (e2.getConvexTrianglePillar(l3, c3, true), nM.pointToWorldFrame(n2, s2, e2.pillarOffset, f2), i2.distanceTo(f2) < e2.pillarConvex.boundingSphereRadius + t6.boundingSphereRadius && (u3 = this.convexConvex(t6, e2.pillarConvex, i2, f2, r2, s2, o2, a2, null, null, h2, m2, null)), h2 && u3) return true;
    }
  }
  sphereParticle(t6, e2, i2, n2, r2, s2, o2, a2, l2, c2, h2) {
    const u2 = FA;
    u2.set(0, 0, 1), n2.vsub(i2, u2);
    if (u2.lengthSquared() <= t6.radius * t6.radius) {
      if (h2) return true;
      const i3 = this.createContactEquation(a2, o2, e2, t6, l2, c2);
      u2.normalize(), i3.rj.copy(u2), i3.rj.scale(t6.radius, i3.rj), i3.ni.copy(u2), i3.ni.negate(i3.ni), i3.ri.set(0, 0, 0), this.result.push(i3), this.createFrictionEquationsFromContact(i3, this.frictionResult);
    }
  }
  planeParticle(t6, e2, i2, n2, r2, s2, o2, a2, l2, c2, h2) {
    const u2 = DA;
    u2.set(0, 0, 1), o2.quaternion.vmult(u2, u2);
    const d2 = OA;
    n2.vsub(o2.position, d2);
    if (u2.dot(d2) <= 0) {
      if (h2) return true;
      const i3 = this.createContactEquation(a2, o2, e2, t6, l2, c2);
      i3.ni.copy(u2), i3.ni.negate(i3.ni), i3.ri.set(0, 0, 0);
      const r3 = zA;
      u2.scale(u2.dot(n2), r3), n2.vsub(r3, r3), i3.rj.copy(r3), this.result.push(i3), this.createFrictionEquationsFromContact(i3, this.frictionResult);
    }
  }
  boxParticle(t6, e2, i2, n2, r2, s2, o2, a2, l2, c2, h2) {
    return t6.convexPolyhedronRepresentation.material = t6.material, t6.convexPolyhedronRepresentation.collisionResponse = t6.collisionResponse, this.convexParticle(t6.convexPolyhedronRepresentation, e2, i2, n2, r2, s2, o2, a2, t6, e2, h2);
  }
  convexParticle(t6, e2, i2, n2, r2, s2, o2, a2, l2, c2, h2) {
    let u2 = -1;
    const d2 = kA, p2 = HA;
    let f2 = null;
    const m2 = BA;
    if (m2.copy(n2), m2.vsub(i2, m2), r2.conjugate(NA), NA.vmult(m2, m2), t6.pointIsInside(m2)) {
      t6.worldVerticesNeedsUpdate && t6.computeWorldVertices(i2, r2), t6.worldFaceNormalsNeedsUpdate && t6.computeWorldFaceNormals(r2);
      for (let e3 = 0, i3 = t6.faces.length; e3 !== i3; e3++) {
        const i4 = [t6.worldVertices[t6.faces[e3][0]]], r3 = t6.worldFaceNormals[e3];
        n2.vsub(i4[0], UA);
        const s3 = -r3.dot(UA);
        if (null === f2 || Math.abs(s3) < Math.abs(f2)) {
          if (h2) return true;
          f2 = s3, u2 = e3, d2.copy(r3);
        }
      }
      if (-1 !== u2) {
        const r3 = this.createContactEquation(a2, o2, e2, t6, l2, c2);
        d2.scale(f2, p2), p2.vadd(n2, p2), p2.vsub(i2, p2), r3.rj.copy(p2), d2.negate(r3.ni), r3.ri.set(0, 0, 0);
        const s3 = r3.ri, h3 = r3.rj;
        s3.vadd(n2, s3), s3.vsub(a2.position, s3), h3.vadd(i2, h3), h3.vsub(o2.position, h3), this.result.push(r3), this.createFrictionEquationsFromContact(r3, this.frictionResult);
      } else console.warn("Point found inside convex, but did not find penetrating face!");
    }
  }
  heightfieldCylinder(t6, e2, i2, n2, r2, s2, o2, a2, l2, c2, h2) {
    return this.convexHeightfield(e2, t6, n2, i2, s2, r2, a2, o2, l2, c2, h2);
  }
  particleCylinder(t6, e2, i2, n2, r2, s2, o2, a2, l2, c2, h2) {
    return this.convexParticle(e2, t6, n2, i2, s2, r2, a2, o2, l2, c2, h2);
  }
  sphereTrimesh(t6, e2, i2, n2, r2, s2, o2, a2, l2, c2, h2) {
    const u2 = WE, d2 = qE, p2 = XE, f2 = YE, m2 = ZE, g2 = JE, v2 = tA, y2 = GE, x2 = VE, b2 = eA;
    nM.pointToLocalFrame(n2, s2, i2, m2);
    const w2 = t6.radius;
    v2.lowerBound.set(m2.x - w2, m2.y - w2, m2.z - w2), v2.upperBound.set(m2.x + w2, m2.y + w2, m2.z + w2), e2.getTrianglesInAABB(v2, b2);
    const _2 = jE, S2 = t6.radius * t6.radius;
    for (let r3 = 0; r3 < b2.length; r3++) for (let u3 = 0; u3 < 3; u3++) if (e2.getVertex(e2.indices[3 * b2[r3] + u3], _2), _2.vsub(m2, x2), x2.lengthSquared() <= S2) {
      if (y2.copy(_2), nM.pointToWorldFrame(n2, s2, y2, _2), _2.vsub(i2, x2), h2) return true;
      let r4 = this.createContactEquation(o2, a2, t6, e2, l2, c2);
      r4.ni.copy(x2), r4.ni.normalize(), r4.ri.copy(r4.ni), r4.ri.scale(t6.radius, r4.ri), r4.ri.vadd(i2, r4.ri), r4.ri.vsub(o2.position, r4.ri), r4.rj.copy(_2), r4.rj.vsub(a2.position, r4.rj), this.result.push(r4), this.createFrictionEquationsFromContact(r4, this.frictionResult);
    }
    for (let r3 = 0; r3 < b2.length; r3++) for (let v3 = 0; v3 < 3; v3++) {
      e2.getVertex(e2.indices[3 * b2[r3] + v3], u2), e2.getVertex(e2.indices[3 * b2[r3] + (v3 + 1) % 3], d2), d2.vsub(u2, p2), m2.vsub(d2, g2);
      const y3 = g2.dot(p2);
      m2.vsub(u2, g2);
      let x3 = g2.dot(p2);
      if (x3 > 0 && y3 < 0) {
        m2.vsub(u2, g2), f2.copy(p2), f2.normalize(), x3 = g2.dot(f2), f2.scale(x3, g2), g2.vadd(u2, g2);
        if (g2.distanceTo(m2) < t6.radius) {
          if (h2) return true;
          const r4 = this.createContactEquation(o2, a2, t6, e2, l2, c2);
          g2.vsub(m2, r4.ni), r4.ni.normalize(), r4.ni.scale(t6.radius, r4.ri), r4.ri.vadd(i2, r4.ri), r4.ri.vsub(o2.position, r4.ri), nM.pointToWorldFrame(n2, s2, g2, g2), g2.vsub(a2.position, r4.rj), nM.vectorToWorldFrame(s2, r4.ni, r4.ni), nM.vectorToWorldFrame(s2, r4.ri, r4.ri), this.result.push(r4), this.createFrictionEquationsFromContact(r4, this.frictionResult);
        }
      }
    }
    const M2 = KE, T2 = $E, E2 = QE, A2 = HE;
    for (let r3 = 0, u3 = b2.length; r3 !== u3; r3++) {
      e2.getTriangleVertices(b2[r3], M2, T2, E2), e2.getNormal(b2[r3], A2), m2.vsub(M2, g2);
      let u4 = g2.dot(A2);
      if (A2.scale(u4, g2), m2.vsub(g2, g2), u4 = g2.distanceTo(m2), JM.pointInTriangle(g2, M2, T2, E2) && u4 < t6.radius) {
        if (h2) return true;
        let r4 = this.createContactEquation(o2, a2, t6, e2, l2, c2);
        g2.vsub(m2, r4.ni), r4.ni.normalize(), r4.ni.scale(t6.radius, r4.ri), r4.ri.vadd(i2, r4.ri), r4.ri.vsub(o2.position, r4.ri), nM.pointToWorldFrame(n2, s2, g2, g2), g2.vsub(a2.position, r4.rj), nM.vectorToWorldFrame(s2, r4.ni, r4.ni), nM.vectorToWorldFrame(s2, r4.ri, r4.ri), this.result.push(r4), this.createFrictionEquationsFromContact(r4, this.frictionResult);
      }
    }
    b2.length = 0;
  }
  planeTrimesh(t6, e2, i2, n2, r2, s2, o2, a2, l2, c2, h2) {
    const u2 = new GS(), d2 = BE;
    d2.set(0, 0, 1), r2.vmult(d2, d2);
    for (let r3 = 0; r3 < e2.vertices.length / 3; r3++) {
      e2.getVertex(r3, u2);
      const p2 = new GS();
      p2.copy(u2), nM.pointToWorldFrame(n2, s2, p2, u2);
      const f2 = kE;
      u2.vsub(i2, f2);
      if (d2.dot(f2) <= 0) {
        if (h2) return true;
        const i3 = this.createContactEquation(o2, a2, t6, e2, l2, c2);
        i3.ni.copy(d2);
        const n3 = UE;
        d2.scale(f2.dot(d2), n3), u2.vsub(n3, n3), i3.ri.copy(n3), i3.ri.vsub(o2.position, i3.ri), i3.rj.copy(u2), i3.rj.vsub(a2.position, i3.rj), this.result.push(i3), this.createFrictionEquationsFromContact(i3, this.frictionResult);
      }
    }
  }
};
var LE = new GS();
var IE = new GS();
var DE = new GS();
var OE = new GS();
var zE = new GS();
var FE = new QS();
var NE = new QS();
var BE = new GS();
var kE = new GS();
var UE = new GS();
var HE = new GS();
var VE = new GS();
var jE = new GS();
var GE = new GS();
var WE = new GS();
var qE = new GS();
var XE = new GS();
var YE = new GS();
var ZE = new GS();
var JE = new GS();
var KE = new GS();
var $E = new GS();
var QE = new GS();
var tA = new YS();
var eA = [];
var iA = new GS();
var nA = new GS();
var rA = new GS();
var sA = new GS();
var oA = new GS();
function aA(t6, e2, i2) {
  let n2 = null;
  const r2 = t6.length;
  for (let s2 = 0; s2 !== r2; s2++) {
    const o2 = t6[s2], a2 = rA;
    t6[(s2 + 1) % r2].vsub(o2, a2);
    const l2 = sA;
    a2.cross(e2, l2);
    const c2 = oA;
    i2.vsub(o2, c2);
    const h2 = l2.dot(c2);
    if (!(null === n2 || h2 > 0 && true === n2 || h2 <= 0 && false === n2)) return false;
    null === n2 && (n2 = h2 > 0);
  }
  return true;
}
var lA = new GS();
var cA = new GS();
var hA = new GS();
var uA = new GS();
var dA = [new GS(), new GS(), new GS(), new GS(), new GS(), new GS()];
var pA = new GS();
var fA = new GS();
var mA = new GS();
var gA = new GS();
var vA = new GS();
var yA = new GS();
var xA = new GS();
var bA = new GS();
var wA = new GS();
var _A = new GS();
var SA = new GS();
var MA = new GS();
var TA = new GS();
var EA = new GS();
var AA = new GS();
var CA = new GS();
var RA = new GS();
var PA = new GS();
var LA = new GS();
var IA = new GS();
var DA = new GS();
var OA = new GS();
var zA = new GS();
var FA = new GS();
var NA = new QS();
var BA = new GS();
var kA = new GS();
var UA = new GS();
var HA = new GS();
var VA = new GS();
var jA = new GS();
var GA = [0];
var WA = new GS();
var qA = new GS();
var XA = class {
  constructor() {
    this.current = void 0, this.previous = void 0, this.current = [], this.previous = [];
  }
  getKey(t6, e2) {
    if (e2 < t6) {
      const i2 = e2;
      e2 = t6, t6 = i2;
    }
    return t6 << 16 | e2;
  }
  set(t6, e2) {
    const i2 = this.getKey(t6, e2), n2 = this.current;
    let r2 = 0;
    for (; i2 > n2[r2]; ) r2++;
    if (i2 !== n2[r2]) {
      for (let t7 = n2.length - 1; t7 >= r2; t7--) n2[t7 + 1] = n2[t7];
      n2[r2] = i2;
    }
  }
  tick() {
    const t6 = this.current;
    this.current = this.previous, this.previous = t6, this.current.length = 0;
  }
  getDiff(t6, e2) {
    const i2 = this.current, n2 = this.previous, r2 = i2.length, s2 = n2.length;
    let o2 = 0;
    for (let e3 = 0; e3 < r2; e3++) {
      let r3 = false;
      const s3 = i2[e3];
      for (; s3 > n2[o2]; ) o2++;
      r3 = s3 === n2[o2], r3 || YA(t6, s3);
    }
    o2 = 0;
    for (let t7 = 0; t7 < s2; t7++) {
      let r3 = false;
      const s3 = n2[t7];
      for (; s3 > i2[o2]; ) o2++;
      r3 = i2[o2] === s3, r3 || YA(e2, s3);
    }
  }
};
function YA(t6, e2) {
  t6.push((4294901760 & e2) >> 16, 65535 & e2);
}
var ZA = class {
  constructor() {
    this.data = { keys: [] };
  }
  get(t6, e2) {
    if (t6 > e2) {
      const i2 = e2;
      e2 = t6, t6 = i2;
    }
    return this.data[t6 + "-" + e2];
  }
  set(t6, e2, i2) {
    if (t6 > e2) {
      const i3 = e2;
      e2 = t6, t6 = i3;
    }
    const n2 = t6 + "-" + e2;
    this.get(t6, e2) || this.data.keys.push(n2), this.data[n2] = i2;
  }
  reset() {
    const t6 = this.data, e2 = t6.keys;
    for (; e2.length > 0; ) {
      delete t6[e2.pop()];
    }
  }
};
var JA = class extends $S {
  constructor(t6 = {}) {
    super(), this.dt = void 0, this.allowSleep = void 0, this.contacts = void 0, this.frictionEquations = void 0, this.quatNormalizeSkip = void 0, this.quatNormalizeFast = void 0, this.time = void 0, this.stepnumber = void 0, this.default_dt = void 0, this.nextId = void 0, this.gravity = void 0, this.broadphase = void 0, this.bodies = void 0, this.hasActiveBodies = void 0, this.solver = void 0, this.constraints = void 0, this.narrowphase = void 0, this.collisionMatrix = void 0, this.collisionMatrixPrevious = void 0, this.bodyOverlapKeeper = void 0, this.shapeOverlapKeeper = void 0, this.materials = void 0, this.contactmaterials = void 0, this.contactMaterialTable = void 0, this.defaultMaterial = void 0, this.defaultContactMaterial = void 0, this.doProfiling = void 0, this.profile = void 0, this.accumulator = void 0, this.subsystems = void 0, this.addBodyEvent = void 0, this.removeBodyEvent = void 0, this.idToBodyMap = void 0, this.dt = -1, this.allowSleep = !!t6.allowSleep, this.contacts = [], this.frictionEquations = [], this.quatNormalizeSkip = void 0 !== t6.quatNormalizeSkip ? t6.quatNormalizeSkip : 0, this.quatNormalizeFast = void 0 !== t6.quatNormalizeFast && t6.quatNormalizeFast, this.time = 0, this.stepnumber = 0, this.default_dt = 1 / 60, this.nextId = 0, this.gravity = new GS(), t6.gravity && this.gravity.copy(t6.gravity), this.broadphase = void 0 !== t6.broadphase ? t6.broadphase : new BM(), this.bodies = [], this.hasActiveBodies = false, this.solver = void 0 !== t6.solver ? t6.solver : new $T(), this.constraints = [], this.narrowphase = new PE(this), this.collisionMatrix = new KS(), this.collisionMatrixPrevious = new KS(), this.bodyOverlapKeeper = new XA(), this.shapeOverlapKeeper = new XA(), this.materials = [], this.contactmaterials = [], this.contactMaterialTable = new ZA(), this.defaultMaterial = new YT("default"), this.defaultContactMaterial = new XT(this.defaultMaterial, this.defaultMaterial, { friction: 0.3, restitution: 0 }), this.doProfiling = false, this.profile = { solve: 0, makeContactConstraints: 0, broadphase: 0, integrate: 0, narrowphase: 0 }, this.accumulator = 0, this.subsystems = [], this.addBodyEvent = { type: "addBody", body: null }, this.removeBodyEvent = { type: "removeBody", body: null }, this.idToBodyMap = {}, this.broadphase.setWorld(this);
  }
  getContactMaterial(t6, e2) {
    return this.contactMaterialTable.get(t6.id, e2.id);
  }
  numObjects() {
    return this.bodies.length;
  }
  collisionMatrixTick() {
    const t6 = this.collisionMatrixPrevious;
    this.collisionMatrixPrevious = this.collisionMatrix, this.collisionMatrix = t6, this.collisionMatrix.reset(), this.bodyOverlapKeeper.tick(), this.shapeOverlapKeeper.tick();
  }
  addConstraint(t6) {
    this.constraints.push(t6);
  }
  removeConstraint(t6) {
    const e2 = this.constraints.indexOf(t6);
    -1 !== e2 && this.constraints.splice(e2, 1);
  }
  rayTest(t6, e2, i2) {
    i2 instanceof kM ? this.raycastClosest(t6, e2, { skipBackfaces: true }, i2) : this.raycastAll(t6, e2, { skipBackfaces: true }, i2);
  }
  raycastAll(t6, e2, i2 = {}, n2) {
    return i2.mode = JM.ALL, i2.from = t6, i2.to = e2, i2.callback = n2, KA.intersectWorld(this, i2);
  }
  raycastAny(t6, e2, i2 = {}, n2) {
    return i2.mode = JM.ANY, i2.from = t6, i2.to = e2, i2.result = n2, KA.intersectWorld(this, i2);
  }
  raycastClosest(t6, e2, i2 = {}, n2) {
    return i2.mode = JM.CLOSEST, i2.from = t6, i2.to = e2, i2.result = n2, KA.intersectWorld(this, i2);
  }
  addBody(t6) {
    this.bodies.includes(t6) || (t6.index = this.bodies.length, this.bodies.push(t6), t6.world = this, t6.initPosition.copy(t6.position), t6.initVelocity.copy(t6.velocity), t6.timeLastSleepy = this.time, t6 instanceof xM && (t6.initAngularVelocity.copy(t6.angularVelocity), t6.initQuaternion.copy(t6.quaternion)), this.collisionMatrix.setNumObjects(this.bodies.length), this.addBodyEvent.body = t6, this.idToBodyMap[t6.id] = t6, this.dispatchEvent(this.addBodyEvent));
  }
  removeBody(t6) {
    t6.world = null;
    const e2 = this.bodies.length - 1, i2 = this.bodies, n2 = i2.indexOf(t6);
    if (-1 !== n2) {
      i2.splice(n2, 1);
      for (let t7 = 0; t7 !== i2.length; t7++) i2[t7].index = t7;
      this.collisionMatrix.setNumObjects(e2), this.removeBodyEvent.body = t6, delete this.idToBodyMap[t6.id], this.dispatchEvent(this.removeBodyEvent);
    }
  }
  getBodyById(t6) {
    return this.idToBodyMap[t6];
  }
  getShapeById(t6) {
    const e2 = this.bodies;
    for (let i2 = 0; i2 < e2.length; i2++) {
      const n2 = e2[i2].shapes;
      for (let e3 = 0; e3 < n2.length; e3++) {
        const i3 = n2[e3];
        if (i3.id === t6) return i3;
      }
    }
    return null;
  }
  addMaterial(t6) {
    this.materials.push(t6);
  }
  addContactMaterial(t6) {
    this.contactmaterials.push(t6), this.contactMaterialTable.set(t6.materials[0].id, t6.materials[1].id, t6);
  }
  step(t6, e2, i2 = 10) {
    if (void 0 === e2) this.internalStep(t6), this.time += t6;
    else {
      this.accumulator += e2;
      const n2 = $A.now();
      let r2 = 0;
      for (; this.accumulator >= t6 && r2 < i2 && (this.internalStep(t6), this.accumulator -= t6, r2++, !($A.now() - n2 > 1e3 * t6)); ) ;
      this.accumulator = this.accumulator % t6;
      const s2 = this.accumulator / t6;
      for (let t7 = 0; t7 !== this.bodies.length; t7++) {
        const e3 = this.bodies[t7];
        e3.previousPosition.lerp(e3.position, s2, e3.interpolatedPosition), e3.previousQuaternion.slerp(e3.quaternion, s2, e3.interpolatedQuaternion), e3.previousQuaternion.normalize();
      }
      this.time += e2;
    }
  }
  internalStep(t6) {
    this.dt = t6;
    const e2 = this.contacts, i2 = rC, n2 = sC, r2 = this.numObjects(), s2 = this.bodies, o2 = this.solver, a2 = this.gravity, l2 = this.doProfiling, c2 = this.profile, h2 = xM.DYNAMIC;
    let u2 = -1 / 0;
    const d2 = this.constraints, p2 = nC;
    a2.length();
    const f2 = a2.x, m2 = a2.y, g2 = a2.z;
    let v2 = 0;
    for (l2 && (u2 = $A.now()), v2 = 0; v2 !== r2; v2++) {
      const t7 = s2[v2];
      if (t7.type === h2) {
        const e3 = t7.force, i3 = t7.mass;
        e3.x += i3 * f2, e3.y += i3 * m2, e3.z += i3 * g2;
      }
    }
    for (let t7 = 0, e3 = this.subsystems.length; t7 !== e3; t7++) this.subsystems[t7].update();
    l2 && (u2 = $A.now()), i2.length = 0, n2.length = 0, this.broadphase.collisionPairs(this, i2, n2), l2 && (c2.broadphase = $A.now() - u2);
    let y2 = d2.length;
    for (v2 = 0; v2 !== y2; v2++) {
      const t7 = d2[v2];
      if (!t7.collideConnected) for (let e3 = i2.length - 1; e3 >= 0; e3 -= 1) (t7.bodyA === i2[e3] && t7.bodyB === n2[e3] || t7.bodyB === i2[e3] && t7.bodyA === n2[e3]) && (i2.splice(e3, 1), n2.splice(e3, 1));
    }
    this.collisionMatrixTick(), l2 && (u2 = $A.now());
    const x2 = iC, b2 = e2.length;
    for (v2 = 0; v2 !== b2; v2++) x2.push(e2[v2]);
    e2.length = 0;
    const w2 = this.frictionEquations.length;
    for (v2 = 0; v2 !== w2; v2++) p2.push(this.frictionEquations[v2]);
    for (this.frictionEquations.length = 0, this.narrowphase.getContacts(i2, n2, this, e2, x2, this.frictionEquations, p2), l2 && (c2.narrowphase = $A.now() - u2), l2 && (u2 = $A.now()), v2 = 0; v2 < this.frictionEquations.length; v2++) o2.addEquation(this.frictionEquations[v2]);
    const _2 = e2.length;
    for (let t7 = 0; t7 !== _2; t7++) {
      const i3 = e2[t7], n3 = i3.bi, r3 = i3.bj, s3 = i3.si, a3 = i3.sj;
      let l3;
      if (l3 = n3.material && r3.material && this.getContactMaterial(n3.material, r3.material) || this.defaultContactMaterial, l3.friction, n3.material && r3.material && (n3.material.friction >= 0 && r3.material.friction >= 0 && (n3.material.friction, r3.material.friction), n3.material.restitution >= 0 && r3.material.restitution >= 0 && (i3.restitution = n3.material.restitution * r3.material.restitution)), o2.addEquation(i3), n3.allowSleep && n3.type === xM.DYNAMIC && n3.sleepState === xM.SLEEPING && r3.sleepState === xM.AWAKE && r3.type !== xM.STATIC) {
        r3.velocity.lengthSquared() + r3.angularVelocity.lengthSquared() >= 2 * r3.sleepSpeedLimit ** 2 && (n3.wakeUpAfterNarrowphase = true);
      }
      if (r3.allowSleep && r3.type === xM.DYNAMIC && r3.sleepState === xM.SLEEPING && n3.sleepState === xM.AWAKE && n3.type !== xM.STATIC) {
        n3.velocity.lengthSquared() + n3.angularVelocity.lengthSquared() >= 2 * n3.sleepSpeedLimit ** 2 && (r3.wakeUpAfterNarrowphase = true);
      }
      this.collisionMatrix.set(n3, r3, true), this.collisionMatrixPrevious.get(n3, r3) || (eC.body = r3, eC.contact = i3, n3.dispatchEvent(eC), eC.body = n3, r3.dispatchEvent(eC)), this.bodyOverlapKeeper.set(n3.id, r3.id), this.shapeOverlapKeeper.set(s3.id, a3.id);
    }
    for (this.emitContactEvents(), l2 && (c2.makeContactConstraints = $A.now() - u2, u2 = $A.now()), v2 = 0; v2 !== r2; v2++) {
      const t7 = s2[v2];
      t7.wakeUpAfterNarrowphase && (t7.wakeUp(), t7.wakeUpAfterNarrowphase = false);
    }
    for (y2 = d2.length, v2 = 0; v2 !== y2; v2++) {
      const t7 = d2[v2];
      t7.update();
      for (let e3 = 0, i3 = t7.equations.length; e3 !== i3; e3++) {
        const i4 = t7.equations[e3];
        o2.addEquation(i4);
      }
    }
    o2.solve(t6, this), l2 && (c2.solve = $A.now() - u2), o2.removeAllEquations();
    const S2 = Math.pow;
    for (v2 = 0; v2 !== r2; v2++) {
      const e3 = s2[v2];
      if (e3.type & h2) {
        const i3 = S2(1 - e3.linearDamping, t6), n3 = e3.velocity;
        n3.scale(i3, n3);
        const r3 = e3.angularVelocity;
        if (r3) {
          const i4 = S2(1 - e3.angularDamping, t6);
          r3.scale(i4, r3);
        }
      }
    }
    for (this.dispatchEvent(tC), v2 = 0; v2 !== r2; v2++) {
      const t7 = s2[v2];
      t7.preStep && t7.preStep.call(t7);
    }
    l2 && (u2 = $A.now());
    const M2 = this.stepnumber % (this.quatNormalizeSkip + 1) == 0, T2 = this.quatNormalizeFast;
    for (v2 = 0; v2 !== r2; v2++) s2[v2].integrate(t6, M2, T2);
    for (this.clearForces(), this.broadphase.dirty = true, l2 && (c2.integrate = $A.now() - u2), this.stepnumber += 1, this.dispatchEvent(QA), v2 = 0; v2 !== r2; v2++) {
      const t7 = s2[v2], e3 = t7.postStep;
      e3 && e3.call(t7);
    }
    let E2 = true;
    if (this.allowSleep) for (E2 = false, v2 = 0; v2 !== r2; v2++) {
      const t7 = s2[v2];
      t7.sleepTick(this.time), t7.sleepState !== xM.SLEEPING && (E2 = true);
    }
    this.hasActiveBodies = E2;
  }
  emitContactEvents() {
    const t6 = this.hasAnyEventListener("beginContact"), e2 = this.hasAnyEventListener("endContact");
    if ((t6 || e2) && this.bodyOverlapKeeper.getDiff(oC, aC), t6) {
      for (let t7 = 0, e3 = oC.length; t7 < e3; t7 += 2) lC.bodyA = this.getBodyById(oC[t7]), lC.bodyB = this.getBodyById(oC[t7 + 1]), this.dispatchEvent(lC);
      lC.bodyA = lC.bodyB = null;
    }
    if (e2) {
      for (let t7 = 0, e3 = aC.length; t7 < e3; t7 += 2) cC.bodyA = this.getBodyById(aC[t7]), cC.bodyB = this.getBodyById(aC[t7 + 1]), this.dispatchEvent(cC);
      cC.bodyA = cC.bodyB = null;
    }
    oC.length = aC.length = 0;
    const i2 = this.hasAnyEventListener("beginShapeContact"), n2 = this.hasAnyEventListener("endShapeContact");
    if ((i2 || n2) && this.shapeOverlapKeeper.getDiff(oC, aC), i2) {
      for (let t7 = 0, e3 = oC.length; t7 < e3; t7 += 2) {
        const e4 = this.getShapeById(oC[t7]), i3 = this.getShapeById(oC[t7 + 1]);
        hC.shapeA = e4, hC.shapeB = i3, e4 && (hC.bodyA = e4.body), i3 && (hC.bodyB = i3.body), this.dispatchEvent(hC);
      }
      hC.bodyA = hC.bodyB = hC.shapeA = hC.shapeB = null;
    }
    if (n2) {
      for (let t7 = 0, e3 = aC.length; t7 < e3; t7 += 2) {
        const e4 = this.getShapeById(aC[t7]), i3 = this.getShapeById(aC[t7 + 1]);
        uC.shapeA = e4, uC.shapeB = i3, e4 && (uC.bodyA = e4.body), i3 && (uC.bodyB = i3.body), this.dispatchEvent(uC);
      }
      uC.bodyA = uC.bodyB = uC.shapeA = uC.shapeB = null;
    }
  }
  clearForces() {
    const t6 = this.bodies, e2 = t6.length;
    for (let i2 = 0; i2 !== e2; i2++) {
      const e3 = t6[i2];
      e3.force, e3.torque, e3.force.set(0, 0, 0), e3.torque.set(0, 0, 0);
    }
  }
};
new YS();
var KA = new JM();
var $A = globalThis.performance || {};
if (!$A.now) {
  let t6 = Date.now();
  $A.timing && $A.timing.navigationStart && (t6 = $A.timing.navigationStart), $A.now = () => Date.now() - t6;
}
var QA = { type: "postStep" };
var tC = { type: "preStep" };
var eC = { type: xM.COLLIDE_EVENT_NAME, body: null, contact: null };
var iC = [];
var nC = [];
var rC = [];
var sC = [];
var oC = [];
var aC = [];
var lC = { type: "beginContact", bodyA: null, bodyB: null };
var cC = { type: "endContact", bodyA: null, bodyB: null };
var hC = { type: "beginShapeContact", bodyA: null, bodyB: null, shapeA: null, shapeB: null };
var uC = { type: "endShapeContact", bodyA: null, bodyB: null, shapeA: null, shapeB: null };
var dC = i(4801);
var pC = i.n(dC);
var fC = new pa();
var mC = new uv();
var gC = new Pc();
var vC = new pa();
var yC = new El();
var xC = class {
  constructor() {
    this.tolerance = -1, this.faces = [], this.newFaces = [], this.assigned = new SC(), this.unassigned = new SC(), this.vertices = [];
  }
  setFromPoints(t6) {
    if (t6.length >= 4) {
      this.makeEmpty();
      for (let e2 = 0, i2 = t6.length; e2 < i2; e2++) this.vertices.push(new _C(t6[e2]));
      this.compute();
    }
    return this;
  }
  setFromObject(t6) {
    const e2 = [];
    return t6.updateMatrixWorld(true), t6.traverse((function(t7) {
      const i2 = t7.geometry;
      if (void 0 !== i2) {
        const n2 = i2.attributes.position;
        if (void 0 !== n2) for (let i3 = 0, r2 = n2.count; i3 < r2; i3++) {
          const r3 = new pa();
          r3.fromBufferAttribute(n2, i3).applyMatrix4(t7.matrixWorld), e2.push(r3);
        }
      }
    })), this.setFromPoints(e2);
  }
  containsPoint(t6) {
    const e2 = this.faces;
    for (let i2 = 0, n2 = e2.length; i2 < n2; i2++) {
      if (e2[i2].distanceToPoint(t6) > this.tolerance) return false;
    }
    return true;
  }
  intersectRay(t6, e2) {
    const i2 = this.faces;
    let n2 = -1 / 0, r2 = 1 / 0;
    for (let e3 = 0, s2 = i2.length; e3 < s2; e3++) {
      const s3 = i2[e3], o2 = s3.distanceToPoint(t6.origin), a2 = s3.normal.dot(t6.direction);
      if (o2 > 0 && a2 >= 0) return null;
      const l2 = 0 !== a2 ? -o2 / a2 : 0;
      if (!(l2 <= 0) && (a2 > 0 ? r2 = Math.min(l2, r2) : n2 = Math.max(l2, n2), n2 > r2)) return null;
    }
    return n2 !== -1 / 0 ? t6.at(n2, e2) : t6.at(r2, e2), e2;
  }
  intersectsRay(t6) {
    return null !== this.intersectRay(t6, fC);
  }
  makeEmpty() {
    return this.faces = [], this.vertices = [], this;
  }
  addVertexToFace(t6, e2) {
    return t6.face = e2, null === e2.outside ? this.assigned.append(t6) : this.assigned.insertBefore(e2.outside, t6), e2.outside = t6, this;
  }
  removeVertexFromFace(t6, e2) {
    return t6 === e2.outside && (null !== t6.next && t6.next.face === e2 ? e2.outside = t6.next : e2.outside = null), this.assigned.remove(t6), this;
  }
  removeAllVerticesFromFace(t6) {
    if (null !== t6.outside) {
      const e2 = t6.outside;
      let i2 = t6.outside;
      for (; null !== i2.next && i2.next.face === t6; ) i2 = i2.next;
      return this.assigned.removeSubList(e2, i2), e2.prev = i2.next = null, t6.outside = null, e2;
    }
  }
  deleteFaceVertices(t6, e2) {
    const i2 = this.removeAllVerticesFromFace(t6);
    if (void 0 !== i2) if (void 0 === e2) this.unassigned.appendChain(i2);
    else {
      let t7 = i2;
      do {
        const i3 = t7.next;
        e2.distanceToPoint(t7.point) > this.tolerance ? this.addVertexToFace(t7, e2) : this.unassigned.append(t7), t7 = i3;
      } while (null !== t7);
    }
    return this;
  }
  resolveUnassignedPoints(t6) {
    if (false === this.unassigned.isEmpty()) {
      let e2 = this.unassigned.first();
      do {
        const i2 = e2.next;
        let n2 = this.tolerance, r2 = null;
        for (let i3 = 0; i3 < t6.length; i3++) {
          const s2 = t6[i3];
          if (0 === s2.mark) {
            const t7 = s2.distanceToPoint(e2.point);
            if (t7 > n2 && (n2 = t7, r2 = s2), n2 > 1e3 * this.tolerance) break;
          }
        }
        null !== r2 && this.addVertexToFace(e2, r2), e2 = i2;
      } while (null !== e2);
    }
    return this;
  }
  computeExtremes() {
    const t6 = new pa(), e2 = new pa(), i2 = [], n2 = [];
    for (let t7 = 0; t7 < 3; t7++) i2[t7] = n2[t7] = this.vertices[0];
    t6.copy(this.vertices[0].point), e2.copy(this.vertices[0].point);
    for (let r2 = 0, s2 = this.vertices.length; r2 < s2; r2++) {
      const s3 = this.vertices[r2], o2 = s3.point;
      for (let e3 = 0; e3 < 3; e3++) o2.getComponent(e3) < t6.getComponent(e3) && (t6.setComponent(e3, o2.getComponent(e3)), i2[e3] = s3);
      for (let t7 = 0; t7 < 3; t7++) o2.getComponent(t7) > e2.getComponent(t7) && (e2.setComponent(t7, o2.getComponent(t7)), n2[t7] = s3);
    }
    return this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(t6.x), Math.abs(e2.x)) + Math.max(Math.abs(t6.y), Math.abs(e2.y)) + Math.max(Math.abs(t6.z), Math.abs(e2.z))), { min: i2, max: n2 };
  }
  computeInitialHull() {
    const t6 = this.vertices, e2 = this.computeExtremes(), i2 = e2.min, n2 = e2.max;
    let r2 = 0, s2 = 0;
    for (let t7 = 0; t7 < 3; t7++) {
      const e3 = n2[t7].point.getComponent(t7) - i2[t7].point.getComponent(t7);
      e3 > r2 && (r2 = e3, s2 = t7);
    }
    const o2 = i2[s2], a2 = n2[s2];
    let l2, c2;
    r2 = 0, mC.set(o2.point, a2.point);
    for (let e3 = 0, i3 = this.vertices.length; e3 < i3; e3++) {
      const i4 = t6[e3];
      if (i4 !== o2 && i4 !== a2) {
        mC.closestPointToPoint(i4.point, true, vC);
        const t7 = vC.distanceToSquared(i4.point);
        t7 > r2 && (r2 = t7, l2 = i4);
      }
    }
    r2 = -1, gC.setFromCoplanarPoints(o2.point, a2.point, l2.point);
    for (let e3 = 0, i3 = this.vertices.length; e3 < i3; e3++) {
      const i4 = t6[e3];
      if (i4 !== o2 && i4 !== a2 && i4 !== l2) {
        const t7 = Math.abs(gC.distanceToPoint(i4.point));
        t7 > r2 && (r2 = t7, c2 = i4);
      }
    }
    const h2 = [];
    if (gC.distanceToPoint(c2.point) < 0) {
      h2.push(bC.create(o2, a2, l2), bC.create(c2, a2, o2), bC.create(c2, l2, a2), bC.create(c2, o2, l2));
      for (let t7 = 0; t7 < 3; t7++) {
        const e3 = (t7 + 1) % 3;
        h2[t7 + 1].getEdge(2).setTwin(h2[0].getEdge(e3)), h2[t7 + 1].getEdge(1).setTwin(h2[e3 + 1].getEdge(0));
      }
    } else {
      h2.push(bC.create(o2, l2, a2), bC.create(c2, o2, a2), bC.create(c2, a2, l2), bC.create(c2, l2, o2));
      for (let t7 = 0; t7 < 3; t7++) {
        const e3 = (t7 + 1) % 3;
        h2[t7 + 1].getEdge(2).setTwin(h2[0].getEdge((3 - t7) % 3)), h2[t7 + 1].getEdge(0).setTwin(h2[e3 + 1].getEdge(1));
      }
    }
    for (let t7 = 0; t7 < 4; t7++) this.faces.push(h2[t7]);
    for (let e3 = 0, i3 = t6.length; e3 < i3; e3++) {
      const i4 = t6[e3];
      if (i4 !== o2 && i4 !== a2 && i4 !== l2 && i4 !== c2) {
        r2 = this.tolerance;
        let t7 = null;
        for (let e4 = 0; e4 < 4; e4++) {
          const n3 = this.faces[e4].distanceToPoint(i4.point);
          n3 > r2 && (r2 = n3, t7 = this.faces[e4]);
        }
        null !== t7 && this.addVertexToFace(i4, t7);
      }
    }
    return this;
  }
  reindexFaces() {
    const t6 = [];
    for (let e2 = 0; e2 < this.faces.length; e2++) {
      const i2 = this.faces[e2];
      0 === i2.mark && t6.push(i2);
    }
    return this.faces = t6, this;
  }
  nextVertexToAdd() {
    if (false === this.assigned.isEmpty()) {
      let t6, e2 = 0;
      const i2 = this.assigned.first().face;
      let n2 = i2.outside;
      do {
        const r2 = i2.distanceToPoint(n2.point);
        r2 > e2 && (e2 = r2, t6 = n2), n2 = n2.next;
      } while (null !== n2 && n2.face === i2);
      return t6;
    }
  }
  computeHorizon(t6, e2, i2, n2) {
    let r2;
    this.deleteFaceVertices(i2), i2.mark = 1, r2 = null === e2 ? e2 = i2.getEdge(0) : e2.next;
    do {
      const e3 = r2.twin, i3 = e3.face;
      0 === i3.mark && (i3.distanceToPoint(t6) > this.tolerance ? this.computeHorizon(t6, e3, i3, n2) : n2.push(r2)), r2 = r2.next;
    } while (r2 !== e2);
    return this;
  }
  addAdjoiningFace(t6, e2) {
    const i2 = bC.create(t6, e2.tail(), e2.head());
    return this.faces.push(i2), i2.getEdge(-1).setTwin(e2.twin), i2.getEdge(0);
  }
  addNewFaces(t6, e2) {
    this.newFaces = [];
    let i2 = null, n2 = null;
    for (let r2 = 0; r2 < e2.length; r2++) {
      const s2 = e2[r2], o2 = this.addAdjoiningFace(t6, s2);
      null === i2 ? i2 = o2 : o2.next.setTwin(n2), this.newFaces.push(o2.face), n2 = o2;
    }
    return i2.next.setTwin(n2), this;
  }
  addVertexToHull(t6) {
    const e2 = [];
    return this.unassigned.clear(), this.removeVertexFromFace(t6, t6.face), this.computeHorizon(t6.point, null, t6.face, e2), this.addNewFaces(t6, e2), this.resolveUnassignedPoints(this.newFaces), this;
  }
  cleanup() {
    return this.assigned.clear(), this.unassigned.clear(), this.newFaces = [], this;
  }
  compute() {
    let t6;
    for (this.computeInitialHull(); void 0 !== (t6 = this.nextVertexToAdd()); ) this.addVertexToHull(t6);
    return this.reindexFaces(), this.cleanup(), this;
  }
};
var bC = class _bC {
  constructor() {
    this.normal = new pa(), this.midpoint = new pa(), this.area = 0, this.constant = 0, this.outside = null, this.mark = 0, this.edge = null;
  }
  static create(t6, e2, i2) {
    const n2 = new _bC(), r2 = new wC(t6, n2), s2 = new wC(e2, n2), o2 = new wC(i2, n2);
    return r2.next = o2.prev = s2, s2.next = r2.prev = o2, o2.next = s2.prev = r2, n2.edge = r2, n2.compute();
  }
  getEdge(t6) {
    let e2 = this.edge;
    for (; t6 > 0; ) e2 = e2.next, t6--;
    for (; t6 < 0; ) e2 = e2.prev, t6++;
    return e2;
  }
  compute() {
    const t6 = this.edge.tail(), e2 = this.edge.head(), i2 = this.edge.next.head();
    return yC.set(t6.point, e2.point, i2.point), yC.getNormal(this.normal), yC.getMidpoint(this.midpoint), this.area = yC.getArea(), this.constant = this.normal.dot(this.midpoint), this;
  }
  distanceToPoint(t6) {
    return this.normal.dot(t6) - this.constant;
  }
};
var wC = class {
  constructor(t6, e2) {
    this.vertex = t6, this.prev = null, this.next = null, this.twin = null, this.face = e2;
  }
  head() {
    return this.vertex;
  }
  tail() {
    return this.prev ? this.prev.vertex : null;
  }
  length() {
    const t6 = this.head(), e2 = this.tail();
    return null !== e2 ? e2.point.distanceTo(t6.point) : -1;
  }
  lengthSquared() {
    const t6 = this.head(), e2 = this.tail();
    return null !== e2 ? e2.point.distanceToSquared(t6.point) : -1;
  }
  setTwin(t6) {
    return this.twin = t6, t6.twin = this, this;
  }
};
var _C = class {
  constructor(t6) {
    this.point = t6, this.prev = null, this.next = null, this.face = null;
  }
};
var SC = class {
  constructor() {
    this.head = null, this.tail = null;
  }
  first() {
    return this.head;
  }
  last() {
    return this.tail;
  }
  clear() {
    return this.head = this.tail = null, this;
  }
  insertBefore(t6, e2) {
    return e2.prev = t6.prev, e2.next = t6, null === e2.prev ? this.head = e2 : e2.prev.next = e2, t6.prev = e2, this;
  }
  insertAfter(t6, e2) {
    return e2.prev = t6, e2.next = t6.next, null === e2.next ? this.tail = e2 : e2.next.prev = e2, t6.next = e2, this;
  }
  append(t6) {
    return null === this.head ? this.head = t6 : this.tail.next = t6, t6.prev = this.tail, t6.next = null, this.tail = t6, this;
  }
  appendChain(t6) {
    for (null === this.head ? this.head = t6 : this.tail.next = t6, t6.prev = this.tail; null !== t6.next; ) t6 = t6.next;
    return this.tail = t6, this;
  }
  remove(t6) {
    return null === t6.prev ? this.head = t6.next : t6.prev.next = t6.next, null === t6.next ? this.tail = t6.prev : t6.next.prev = t6.prev, this;
  }
  removeSubList(t6, e2) {
    return null === t6.prev ? this.head = e2.next : t6.prev.next = e2.next, null === e2.next ? this.tail = t6.prev : e2.next.prev = t6.prev, this;
  }
  isEmpty() {
    return null === this.head;
  }
};
var MC = class extends Jl {
  constructor(t6 = []) {
    super();
    const e2 = [], i2 = [];
    void 0 === xC && console.error("THREE.ConvexGeometry: ConvexGeometry relies on ConvexHull");
    const n2 = new xC().setFromPoints(t6).faces;
    for (let t7 = 0; t7 < n2.length; t7++) {
      const r2 = n2[t7];
      let s2 = r2.edge;
      do {
        const t8 = s2.head().point;
        e2.push(t8.x, t8.y, t8.z), i2.push(r2.normal.x, r2.normal.y, r2.normal.z), s2 = s2.next;
      } while (s2 !== r2.edge);
    }
    this.setAttribute("position", new Hl(e2, 3)), this.setAttribute("normal", new Hl(i2, 3));
  }
};
var TC = "Alpha";
var EC = "Attraction";
var AC = "Color";
var CC = "CrossZone";
var RC = "Force";
var PC = "Gravity";
var LC = "RandomDrift";
var IC = "Repulsion";
var DC = "Rotate";
var OC = "Scale";
var zC = "Spring";
var FC = "Body";
var NC = "BodySprite";
var BC = "Texture";
var kC = "Life";
var UC = "Mass";
var HC = "Position";
var VC = "Radius";
var jC = "VectorVelocity";
var GC = "PolarVelocity";
var WC = "RadialVelocity";
var qC = [NC, BC];
var XC = "BoxZone";
var YC = "LineZone";
var ZC = "MeshZone";
var JC = "PointZone";
var KC = "SphereZone";
var $C = "SpriteRenderer";
var QC = i(5606);
var tR = 3.142;
var eR = 500;
var iR = tR / 180;
var nR = "euler";
var rR = () => !!QC && (QC.env, false);
var sR = { easeLinear: function(t6) {
  return t6;
}, easeInQuad: function(t6) {
  return Math.pow(t6, 2);
}, easeOutQuad: function(t6) {
  return -(Math.pow(t6 - 1, 2) - 1);
}, easeInOutQuad: function(t6) {
  return (t6 /= 0.5) < 1 ? 0.5 * Math.pow(t6, 2) : -0.5 * ((t6 -= 2) * t6 - 2);
}, easeInCubic: function(t6) {
  return Math.pow(t6, 3);
}, easeOutCubic: function(t6) {
  return Math.pow(t6 - 1, 3) + 1;
}, easeInOutCubic: function(t6) {
  return (t6 /= 0.5) < 1 ? 0.5 * Math.pow(t6, 3) : 0.5 * (Math.pow(t6 - 2, 3) + 2);
}, easeInQuart: function(t6) {
  return Math.pow(t6, 4);
}, easeOutQuart: function(t6) {
  return -(Math.pow(t6 - 1, 4) - 1);
}, easeInOutQuart: function(t6) {
  return (t6 /= 0.5) < 1 ? 0.5 * Math.pow(t6, 4) : -0.5 * ((t6 -= 2) * Math.pow(t6, 3) - 2);
}, easeInSine: function(t6) {
  return 1 - Math.cos(t6 * (tR / 2));
}, easeOutSine: function(t6) {
  return Math.sin(t6 * (tR / 2));
}, easeInOutSine: function(t6) {
  return -0.5 * (Math.cos(tR * t6) - 1);
}, easeInExpo: function(t6) {
  return 0 === t6 ? 0 : Math.pow(2, 10 * (t6 - 1));
}, easeOutExpo: function(t6) {
  return 1 === t6 ? 1 : 1 - Math.pow(2, -10 * t6);
}, easeInOutExpo: function(t6) {
  return 0 === t6 ? 0 : 1 === t6 ? 1 : (t6 /= 0.5) < 1 ? 0.5 * Math.pow(2, 10 * (t6 - 1)) : 0.5 * (2 - Math.pow(2, -10 * --t6));
}, easeInCirc: function(t6) {
  return -(Math.sqrt(1 - t6 * t6) - 1);
}, easeOutCirc: function(t6) {
  return Math.sqrt(1 - Math.pow(t6 - 1, 2));
}, easeInOutCirc: function(t6) {
  return (t6 /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t6 * t6) - 1) : 0.5 * (Math.sqrt(1 - (t6 -= 2) * t6) + 1);
}, easeInBack: function(t6) {
  var e2 = 1.70158;
  return t6 * t6 * ((e2 + 1) * t6 - e2);
}, easeOutBack: function(t6) {
  var e2 = 1.70158;
  return (t6 -= 1) * t6 * ((e2 + 1) * t6 + e2) + 1;
}, easeInOutBack: function(t6) {
  var e2 = 1.70158;
  return (t6 /= 0.5) < 1 ? t6 * t6 * ((1 + (e2 *= 1.525)) * t6 - e2) * 0.5 : 0.5 * ((t6 -= 2) * t6 * ((1 + (e2 *= 1.525)) * t6 + e2) + 2);
} };
var { easeLinear: oR, easeInQuad: aR, easeOutQuad: lR, easeInOutQuad: cR, easeInCubic: hR, easeOutCubic: uR, easeInOutCubic: dR, easeInQuart: pR, easeOutQuart: fR, easeInOutQuart: mR, easeInSine: gR, easeOutSine: vR, easeInOutSine: yR, easeInExpo: xR, easeOutExpo: bR, easeInOutExpo: wR, easeInCirc: _R, easeOutCirc: SR, easeInOutCirc: MR, easeInBack: TR, easeOutBack: ER, easeInOutBack: AR } = sR;
var CR = (t6) => sR[t6] ? sR[t6] : sR.easeLinear;
var RR = 1 / 0;
var PR = false;
var LR = false;
var IR = false;
var DR = false;
var OR = oR;
var zR = 0.0167;
var FR = [HC, kC, VC, UC, FC, NC, BC, GC, WC, jC];
var NR = [TC, EC, AC, CC, RC, PC, LC, IC, DC, OC, zC];
var BR = [XC, YC, ZC, JC, KC];
function kR(t6) {
  return kR = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t7) {
    return typeof t7;
  } : function(t7) {
    return t7 && "function" == typeof Symbol && t7.constructor === Symbol && t7 !== Symbol.prototype ? "symbol" : typeof t7;
  }, kR(t6);
}
function UR(t6) {
  var e2 = (function(t7, e3) {
    if ("object" != kR(t7) || !t7) return t7;
    var i2 = t7[Symbol.toPrimitive];
    if (void 0 !== i2) {
      var n2 = i2.call(t7, e3 || "default");
      if ("object" != kR(n2)) return n2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === e3 ? String : Number)(t7);
  })(t6, "string");
  return "symbol" == kR(e2) ? e2 : e2 + "";
}
function HR(t6, e2, i2) {
  return (e2 = UR(e2)) in t6 ? Object.defineProperty(t6, e2, { value: i2, enumerable: true, configurable: true, writable: true }) : t6[e2] = i2, t6;
}
var VR = function(t6) {
  var e2 = {};
  if ("number" == typeof t6) n2 = Math.floor(t6), e2.r = (t6 >> 16 & 255) / 255, e2.g = (t6 >> 8 & 255) / 255, e2.b = (255 & t6) / 255;
  else if ("string" == typeof t6) {
    var i2;
    if (i2 = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(t6)) e2.r = Math.min(255, parseInt(i2[1], 10)) / 255, e2.g = Math.min(255, parseInt(i2[2], 10)) / 255, e2.b = Math.min(255, parseInt(i2[3], 10)) / 255;
    else if (i2 = /^\#([A-Fa-f0-9]+)$/.exec(t6)) {
      var n2 = i2[1];
      e2.r = parseInt(n2.charAt(0) + n2.charAt(1), 16) / 255, e2.g = parseInt(n2.charAt(2) + n2.charAt(3), 16) / 255, e2.b = parseInt(n2.charAt(4) + n2.charAt(5), 16) / 255;
    }
  } else e2.r = t6.r, e2.g = t6.g, e2.b = t6.b;
  return e2;
};
var jR = { _id: 0, _uids: /* @__PURE__ */ new Map(), getNewId: function() {
  return "PUID_" + ++this._id;
}, id: function(t6) {
  if (this._uids.has(t6)) return this._uids.get(t6);
  const e2 = this.getNewId();
  return this._uids.set(t6, e2), e2;
} };
var GR;
var WR;
var qR;
var XR;
var YR;
var ZR;
var JR = { DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: (function() {
  for (var t6 = [], e2 = 0; e2 < 256; e2++) t6[e2] = (e2 < 16 ? "0" : "") + e2.toString(16);
  return function() {
    var e3 = 4294967295 * Math.random() | 0, i2 = 4294967295 * Math.random() | 0, n2 = 4294967295 * Math.random() | 0, r2 = 4294967295 * Math.random() | 0;
    return (t6[255 & e3] + t6[e3 >> 8 & 255] + t6[e3 >> 16 & 255] + t6[e3 >> 24 & 255] + "-" + t6[255 & i2] + t6[i2 >> 8 & 255] + "-" + t6[i2 >> 16 & 15 | 64] + t6[i2 >> 24 & 255] + "-" + t6[63 & n2 | 128] + t6[n2 >> 8 & 255] + "-" + t6[n2 >> 16 & 255] + t6[n2 >> 24 & 255] + t6[255 & r2] + t6[r2 >> 8 & 255] + t6[r2 >> 16 & 255] + t6[r2 >> 24 & 255]).toUpperCase();
  };
})(), clamp: function(t6, e2, i2) {
  return Math.max(e2, Math.min(i2, t6));
}, euclideanModulo: function(t6, e2) {
  return (t6 % e2 + e2) % e2;
}, mapLinear: function(t6, e2, i2, n2, r2) {
  return n2 + (t6 - e2) * (r2 - n2) / (i2 - e2);
}, lerp: function(t6, e2, i2) {
  return (1 - i2) * t6 + i2 * e2;
}, smoothstep: function(t6, e2, i2) {
  return t6 <= e2 ? 0 : t6 >= i2 ? 1 : (t6 = (t6 - e2) / (i2 - e2)) * t6 * (3 - 2 * t6);
}, smootherstep: function(t6, e2, i2) {
  return t6 <= e2 ? 0 : t6 >= i2 ? 1 : (t6 = (t6 - e2) / (i2 - e2)) * t6 * t6 * (t6 * (6 * t6 - 15) + 10);
}, randInt: function(t6, e2) {
  return t6 + Math.floor(Math.random() * (e2 - t6 + 1));
}, randFloat: function(t6, e2) {
  return t6 + Math.random() * (e2 - t6);
}, randFloatSpread: function(t6) {
  return t6 * (0.5 - Math.random());
}, degToRad: function(t6) {
  return t6 * JR.DEG2RAD;
}, radToDeg: function(t6) {
  return t6 * JR.RAD2DEG;
}, isPowerOfTwo: function(t6) {
  return !(t6 & t6 - 1) && 0 !== t6;
}, ceilPowerOfTwo: function(t6) {
  return Math.pow(2, Math.ceil(Math.log(t6) / Math.LN2));
}, floorPowerOfTwo: function(t6) {
  return Math.pow(2, Math.floor(Math.log(t6) / Math.LN2));
} };
function KR(t6, e2, i2, n2) {
  this._x = t6 || 0, this._y = e2 || 0, this._z = i2 || 0, this._w = void 0 !== n2 ? n2 : 1;
}
function $R(t6, e2, i2) {
  this.x = t6 || 0, this.y = e2 || 0, this.z = i2 || 0;
}
function QR() {
  this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
}
function tP(t6, e2, i2, n2) {
  this._x = t6 || 0, this._y = e2 || 0, this._z = i2 || 0, this._order = n2 || tP.DefaultOrder;
}
Object.assign(KR, { slerp: function(t6, e2, i2, n2) {
  return i2.copy(t6).slerp(e2, n2);
}, slerpFlat: function(t6, e2, i2, n2, r2, s2, o2) {
  var a2 = i2[n2 + 0], l2 = i2[n2 + 1], c2 = i2[n2 + 2], h2 = i2[n2 + 3], u2 = r2[s2 + 0], d2 = r2[s2 + 1], p2 = r2[s2 + 2], f2 = r2[s2 + 3];
  if (h2 !== f2 || a2 !== u2 || l2 !== d2 || c2 !== p2) {
    var m2 = 1 - o2, g2 = a2 * u2 + l2 * d2 + c2 * p2 + h2 * f2, v2 = g2 >= 0 ? 1 : -1, y2 = 1 - g2 * g2;
    if (y2 > Number.EPSILON) {
      var x2 = Math.sqrt(y2), b2 = Math.atan2(x2, g2 * v2);
      m2 = Math.sin(m2 * b2) / x2, o2 = Math.sin(o2 * b2) / x2;
    }
    var w2 = o2 * v2;
    if (a2 = a2 * m2 + u2 * w2, l2 = l2 * m2 + d2 * w2, c2 = c2 * m2 + p2 * w2, h2 = h2 * m2 + f2 * w2, m2 === 1 - o2) {
      var _2 = 1 / Math.sqrt(a2 * a2 + l2 * l2 + c2 * c2 + h2 * h2);
      a2 *= _2, l2 *= _2, c2 *= _2, h2 *= _2;
    }
  }
  t6[e2] = a2, t6[e2 + 1] = l2, t6[e2 + 2] = c2, t6[e2 + 3] = h2;
} }), Object.defineProperties(KR.prototype, { x: { get: function() {
  return this._x;
}, set: function(t6) {
  this._x = t6, this._onChangeCallback();
} }, y: { get: function() {
  return this._y;
}, set: function(t6) {
  this._y = t6, this._onChangeCallback();
} }, z: { get: function() {
  return this._z;
}, set: function(t6) {
  this._z = t6, this._onChangeCallback();
} }, w: { get: function() {
  return this._w;
}, set: function(t6) {
  this._w = t6, this._onChangeCallback();
} } }), Object.assign(KR.prototype, { isQuaternion: true, set: function(t6, e2, i2, n2) {
  return this._x = t6, this._y = e2, this._z = i2, this._w = n2, this._onChangeCallback(), this;
}, clone: function() {
  return new this.constructor(this._x, this._y, this._z, this._w);
}, copy: function(t6) {
  return this._x = t6.x, this._y = t6.y, this._z = t6.z, this._w = t6.w, this._onChangeCallback(), this;
}, setFromEuler: function(t6, e2) {
  if (!t6 || !t6.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
  var i2 = t6._x, n2 = t6._y, r2 = t6._z, s2 = t6.order, o2 = Math.cos, a2 = Math.sin, l2 = o2(i2 / 2), c2 = o2(n2 / 2), h2 = o2(r2 / 2), u2 = a2(i2 / 2), d2 = a2(n2 / 2), p2 = a2(r2 / 2);
  return "XYZ" === s2 ? (this._x = u2 * c2 * h2 + l2 * d2 * p2, this._y = l2 * d2 * h2 - u2 * c2 * p2, this._z = l2 * c2 * p2 + u2 * d2 * h2, this._w = l2 * c2 * h2 - u2 * d2 * p2) : "YXZ" === s2 ? (this._x = u2 * c2 * h2 + l2 * d2 * p2, this._y = l2 * d2 * h2 - u2 * c2 * p2, this._z = l2 * c2 * p2 - u2 * d2 * h2, this._w = l2 * c2 * h2 + u2 * d2 * p2) : "ZXY" === s2 ? (this._x = u2 * c2 * h2 - l2 * d2 * p2, this._y = l2 * d2 * h2 + u2 * c2 * p2, this._z = l2 * c2 * p2 + u2 * d2 * h2, this._w = l2 * c2 * h2 - u2 * d2 * p2) : "ZYX" === s2 ? (this._x = u2 * c2 * h2 - l2 * d2 * p2, this._y = l2 * d2 * h2 + u2 * c2 * p2, this._z = l2 * c2 * p2 - u2 * d2 * h2, this._w = l2 * c2 * h2 + u2 * d2 * p2) : "YZX" === s2 ? (this._x = u2 * c2 * h2 + l2 * d2 * p2, this._y = l2 * d2 * h2 + u2 * c2 * p2, this._z = l2 * c2 * p2 - u2 * d2 * h2, this._w = l2 * c2 * h2 - u2 * d2 * p2) : "XZY" === s2 && (this._x = u2 * c2 * h2 - l2 * d2 * p2, this._y = l2 * d2 * h2 - u2 * c2 * p2, this._z = l2 * c2 * p2 + u2 * d2 * h2, this._w = l2 * c2 * h2 + u2 * d2 * p2), false !== e2 && this._onChangeCallback(), this;
}, setFromAxisAngle: function(t6, e2) {
  var i2 = e2 / 2, n2 = Math.sin(i2);
  return this._x = t6.x * n2, this._y = t6.y * n2, this._z = t6.z * n2, this._w = Math.cos(i2), this._onChangeCallback(), this;
}, setFromRotationMatrix: function(t6) {
  var e2, i2 = t6.elements, n2 = i2[0], r2 = i2[4], s2 = i2[8], o2 = i2[1], a2 = i2[5], l2 = i2[9], c2 = i2[2], h2 = i2[6], u2 = i2[10], d2 = n2 + a2 + u2;
  return d2 > 0 ? (e2 = 0.5 / Math.sqrt(d2 + 1), this._w = 0.25 / e2, this._x = (h2 - l2) * e2, this._y = (s2 - c2) * e2, this._z = (o2 - r2) * e2) : n2 > a2 && n2 > u2 ? (e2 = 2 * Math.sqrt(1 + n2 - a2 - u2), this._w = (h2 - l2) / e2, this._x = 0.25 * e2, this._y = (r2 + o2) / e2, this._z = (s2 + c2) / e2) : a2 > u2 ? (e2 = 2 * Math.sqrt(1 + a2 - n2 - u2), this._w = (s2 - c2) / e2, this._x = (r2 + o2) / e2, this._y = 0.25 * e2, this._z = (l2 + h2) / e2) : (e2 = 2 * Math.sqrt(1 + u2 - n2 - a2), this._w = (o2 - r2) / e2, this._x = (s2 + c2) / e2, this._y = (l2 + h2) / e2, this._z = 0.25 * e2), this._onChangeCallback(), this;
}, setFromUnitVectors: function(t6, e2) {
  var i2 = t6.dot(e2) + 1;
  return i2 < 1e-6 ? (i2 = 0, Math.abs(t6.x) > Math.abs(t6.z) ? (this._x = -t6.y, this._y = t6.x, this._z = 0, this._w = i2) : (this._x = 0, this._y = -t6.z, this._z = t6.y, this._w = i2)) : (this._x = t6.y * e2.z - t6.z * e2.y, this._y = t6.z * e2.x - t6.x * e2.z, this._z = t6.x * e2.y - t6.y * e2.x, this._w = i2), this.normalize();
}, angleTo: function(t6) {
  return 2 * Math.acos(Math.abs(JR.clamp(this.dot(t6), -1, 1)));
}, rotateTowards: function(t6, e2) {
  var i2 = this.angleTo(t6);
  if (0 === i2) return this;
  var n2 = Math.min(1, e2 / i2);
  return this.slerp(t6, n2), this;
}, inverse: function() {
  return this.conjugate();
}, conjugate: function() {
  return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
}, dot: function(t6) {
  return this._x * t6._x + this._y * t6._y + this._z * t6._z + this._w * t6._w;
}, lengthSq: function() {
  return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
}, length: function() {
  return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
}, normalize: function() {
  var t6 = this.length();
  return 0 === t6 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t6 = 1 / t6, this._x = this._x * t6, this._y = this._y * t6, this._z = this._z * t6, this._w = this._w * t6), this._onChangeCallback(), this;
}, multiply: function(t6, e2) {
  return void 0 !== e2 ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t6, e2)) : this.multiplyQuaternions(this, t6);
}, premultiply: function(t6) {
  return this.multiplyQuaternions(t6, this);
}, multiplyQuaternions: function(t6, e2) {
  var i2 = t6._x, n2 = t6._y, r2 = t6._z, s2 = t6._w, o2 = e2._x, a2 = e2._y, l2 = e2._z, c2 = e2._w;
  return this._x = i2 * c2 + s2 * o2 + n2 * l2 - r2 * a2, this._y = n2 * c2 + s2 * a2 + r2 * o2 - i2 * l2, this._z = r2 * c2 + s2 * l2 + i2 * a2 - n2 * o2, this._w = s2 * c2 - i2 * o2 - n2 * a2 - r2 * l2, this._onChangeCallback(), this;
}, slerp: function(t6, e2) {
  if (0 === e2) return this;
  if (1 === e2) return this.copy(t6);
  var i2 = this._x, n2 = this._y, r2 = this._z, s2 = this._w, o2 = s2 * t6._w + i2 * t6._x + n2 * t6._y + r2 * t6._z;
  if (o2 < 0 ? (this._w = -t6._w, this._x = -t6._x, this._y = -t6._y, this._z = -t6._z, o2 = -o2) : this.copy(t6), o2 >= 1) return this._w = s2, this._x = i2, this._y = n2, this._z = r2, this;
  var a2 = 1 - o2 * o2;
  if (a2 <= Number.EPSILON) {
    var l2 = 1 - e2;
    return this._w = l2 * s2 + e2 * this._w, this._x = l2 * i2 + e2 * this._x, this._y = l2 * n2 + e2 * this._y, this._z = l2 * r2 + e2 * this._z, this.normalize(), this._onChangeCallback(), this;
  }
  var c2 = Math.sqrt(a2), h2 = Math.atan2(c2, o2), u2 = Math.sin((1 - e2) * h2) / c2, d2 = Math.sin(e2 * h2) / c2;
  return this._w = s2 * u2 + this._w * d2, this._x = i2 * u2 + this._x * d2, this._y = n2 * u2 + this._y * d2, this._z = r2 * u2 + this._z * d2, this._onChangeCallback(), this;
}, equals: function(t6) {
  return t6._x === this._x && t6._y === this._y && t6._z === this._z && t6._w === this._w;
}, fromArray: function(t6, e2) {
  return void 0 === e2 && (e2 = 0), this._x = t6[e2], this._y = t6[e2 + 1], this._z = t6[e2 + 2], this._w = t6[e2 + 3], this._onChangeCallback(), this;
}, toArray: function(t6, e2) {
  return void 0 === t6 && (t6 = []), void 0 === e2 && (e2 = 0), t6[e2] = this._x, t6[e2 + 1] = this._y, t6[e2 + 2] = this._z, t6[e2 + 3] = this._w, t6;
}, _onChange: function(t6) {
  return this._onChangeCallback = t6, this;
}, _onChangeCallback: function() {
} }), Object.assign($R.prototype, { isVector3: true, set: function(t6, e2, i2) {
  return this.x = t6, this.y = e2, this.z = i2, this;
}, setScalar: function(t6) {
  return this.x = t6, this.y = t6, this.z = t6, this;
}, setX: function(t6) {
  return this.x = t6, this;
}, setY: function(t6) {
  return this.y = t6, this;
}, setZ: function(t6) {
  return this.z = t6, this;
}, setComponent: function(t6, e2) {
  switch (t6) {
    case 0:
      this.x = e2;
      break;
    case 1:
      this.y = e2;
      break;
    case 2:
      this.z = e2;
      break;
    default:
      throw new Error("index is out of range: " + t6);
  }
  return this;
}, getComponent: function(t6) {
  switch (t6) {
    case 0:
      return this.x;
    case 1:
      return this.y;
    case 2:
      return this.z;
    default:
      throw new Error("index is out of range: " + t6);
  }
}, clone: function() {
  return new this.constructor(this.x, this.y, this.z);
}, copy: function(t6) {
  return this.x = t6.x, this.y = t6.y, this.z = t6.z, this;
}, add: function(t6, e2) {
  return void 0 !== e2 ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t6, e2)) : (this.x += t6.x, this.y += t6.y, this.z += t6.z, this);
}, addScalar: function(t6) {
  return this.x += t6, this.y += t6, this.z += t6, this;
}, addVectors: function(t6, e2) {
  return this.x = t6.x + e2.x, this.y = t6.y + e2.y, this.z = t6.z + e2.z, this;
}, addScaledVector: function(t6, e2) {
  return this.x += t6.x * e2, this.y += t6.y * e2, this.z += t6.z * e2, this;
}, sub: function(t6, e2) {
  return void 0 !== e2 ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t6, e2)) : (this.x -= t6.x, this.y -= t6.y, this.z -= t6.z, this);
}, subScalar: function(t6) {
  return this.x -= t6, this.y -= t6, this.z -= t6, this;
}, subVectors: function(t6, e2) {
  return this.x = t6.x - e2.x, this.y = t6.y - e2.y, this.z = t6.z - e2.z, this;
}, multiply: function(t6, e2) {
  return void 0 !== e2 ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t6, e2)) : (this.x *= t6.x, this.y *= t6.y, this.z *= t6.z, this);
}, multiplyScalar: function(t6) {
  return this.x *= t6, this.y *= t6, this.z *= t6, this;
}, multiplyVectors: function(t6, e2) {
  return this.x = t6.x * e2.x, this.y = t6.y * e2.y, this.z = t6.z * e2.z, this;
}, applyEuler: (GR = new KR(), function(t6) {
  return t6 && t6.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(GR.setFromEuler(t6));
}), applyAxisAngle: (function() {
  var t6 = new KR();
  return function(e2, i2) {
    return this.applyQuaternion(t6.setFromAxisAngle(e2, i2));
  };
})(), applyMatrix3: function(t6) {
  var e2 = this.x, i2 = this.y, n2 = this.z, r2 = t6.elements;
  return this.x = r2[0] * e2 + r2[3] * i2 + r2[6] * n2, this.y = r2[1] * e2 + r2[4] * i2 + r2[7] * n2, this.z = r2[2] * e2 + r2[5] * i2 + r2[8] * n2, this;
}, applyMatrix4: function(t6) {
  var e2 = this.x, i2 = this.y, n2 = this.z, r2 = t6.elements, s2 = 1 / (r2[3] * e2 + r2[7] * i2 + r2[11] * n2 + r2[15]);
  return this.x = (r2[0] * e2 + r2[4] * i2 + r2[8] * n2 + r2[12]) * s2, this.y = (r2[1] * e2 + r2[5] * i2 + r2[9] * n2 + r2[13]) * s2, this.z = (r2[2] * e2 + r2[6] * i2 + r2[10] * n2 + r2[14]) * s2, this;
}, applyQuaternion: function(t6) {
  var e2 = this.x, i2 = this.y, n2 = this.z, r2 = t6.x, s2 = t6.y, o2 = t6.z, a2 = t6.w, l2 = a2 * e2 + s2 * n2 - o2 * i2, c2 = a2 * i2 + o2 * e2 - r2 * n2, h2 = a2 * n2 + r2 * i2 - s2 * e2, u2 = -r2 * e2 - s2 * i2 - o2 * n2;
  return this.x = l2 * a2 + u2 * -r2 + c2 * -o2 - h2 * -s2, this.y = c2 * a2 + u2 * -s2 + h2 * -r2 - l2 * -o2, this.z = h2 * a2 + u2 * -o2 + l2 * -s2 - c2 * -r2, this;
}, project: function(t6) {
  return this.applyMatrix4(t6.matrixWorldInverse).applyMatrix4(t6.projectionMatrix);
}, unproject: function(t6) {
  return this.applyMatrix4(t6.projectionMatrixInverse).applyMatrix4(t6.matrixWorld);
}, transformDirection: function(t6) {
  var e2 = this.x, i2 = this.y, n2 = this.z, r2 = t6.elements;
  return this.x = r2[0] * e2 + r2[4] * i2 + r2[8] * n2, this.y = r2[1] * e2 + r2[5] * i2 + r2[9] * n2, this.z = r2[2] * e2 + r2[6] * i2 + r2[10] * n2, this.normalize();
}, divide: function(t6) {
  return this.x /= t6.x, this.y /= t6.y, this.z /= t6.z, this;
}, divideScalar: function(t6) {
  return this.multiplyScalar(1 / t6);
}, min: function(t6) {
  return this.x = Math.min(this.x, t6.x), this.y = Math.min(this.y, t6.y), this.z = Math.min(this.z, t6.z), this;
}, max: function(t6) {
  return this.x = Math.max(this.x, t6.x), this.y = Math.max(this.y, t6.y), this.z = Math.max(this.z, t6.z), this;
}, clamp: function(t6, e2) {
  return this.x = Math.max(t6.x, Math.min(e2.x, this.x)), this.y = Math.max(t6.y, Math.min(e2.y, this.y)), this.z = Math.max(t6.z, Math.min(e2.z, this.z)), this;
}, clampScalar: function(t6, e2) {
  return this.x = Math.max(t6, Math.min(e2, this.x)), this.y = Math.max(t6, Math.min(e2, this.y)), this.z = Math.max(t6, Math.min(e2, this.z)), this;
}, clampLength: function(t6, e2) {
  var i2 = this.length();
  return this.divideScalar(i2 || 1).multiplyScalar(Math.max(t6, Math.min(e2, i2)));
}, floor: function() {
  return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
}, ceil: function() {
  return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
}, round: function() {
  return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
}, roundToZero: function() {
  return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
}, negate: function() {
  return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
}, dot: function(t6) {
  return this.x * t6.x + this.y * t6.y + this.z * t6.z;
}, lengthSq: function() {
  return this.x * this.x + this.y * this.y + this.z * this.z;
}, length: function() {
  return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
}, manhattanLength: function() {
  return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
}, normalize: function() {
  return this.divideScalar(this.length() || 1);
}, setLength: function(t6) {
  return this.normalize().multiplyScalar(t6);
}, lerp: function(t6, e2) {
  return this.x += (t6.x - this.x) * e2, this.y += (t6.y - this.y) * e2, this.z += (t6.z - this.z) * e2, this;
}, lerpVectors: function(t6, e2, i2) {
  return this.subVectors(e2, t6).multiplyScalar(i2).add(t6);
}, cross: function(t6, e2) {
  return void 0 !== e2 ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t6, e2)) : this.crossVectors(this, t6);
}, crossVectors: function(t6, e2) {
  var i2 = t6.x, n2 = t6.y, r2 = t6.z, s2 = e2.x, o2 = e2.y, a2 = e2.z;
  return this.x = n2 * a2 - r2 * o2, this.y = r2 * s2 - i2 * a2, this.z = i2 * o2 - n2 * s2, this;
}, projectOnVector: function(t6) {
  var e2 = t6.dot(this) / t6.lengthSq();
  return this.copy(t6).multiplyScalar(e2);
}, projectOnPlane: (function() {
  var t6 = new $R();
  return function(e2) {
    return t6.copy(this).projectOnVector(e2), this.sub(t6);
  };
})(), reflect: (function() {
  var t6 = new $R();
  return function(e2) {
    return this.sub(t6.copy(e2).multiplyScalar(2 * this.dot(e2)));
  };
})(), angleTo: function(t6) {
  var e2 = this.dot(t6) / Math.sqrt(this.lengthSq() * t6.lengthSq());
  return Math.acos(JR.clamp(e2, -1, 1));
}, distanceTo: function(t6) {
  return Math.sqrt(this.distanceToSquared(t6));
}, distanceToSquared: function(t6) {
  var e2 = this.x - t6.x, i2 = this.y - t6.y, n2 = this.z - t6.z;
  return e2 * e2 + i2 * i2 + n2 * n2;
}, manhattanDistanceTo: function(t6) {
  return Math.abs(this.x - t6.x) + Math.abs(this.y - t6.y) + Math.abs(this.z - t6.z);
}, setFromSpherical: function(t6) {
  return this.setFromSphericalCoords(t6.radius, t6.phi, t6.theta);
}, setFromSphericalCoords: function(t6, e2, i2) {
  var n2 = Math.sin(e2) * t6;
  return this.x = n2 * Math.sin(i2), this.y = Math.cos(e2) * t6, this.z = n2 * Math.cos(i2), this;
}, setFromCylindrical: function(t6) {
  return this.setFromCylindricalCoords(t6.radius, t6.theta, t6.y);
}, setFromCylindricalCoords: function(t6, e2, i2) {
  return this.x = t6 * Math.sin(e2), this.y = i2, this.z = t6 * Math.cos(e2), this;
}, setFromMatrixPosition: function(t6) {
  var e2 = t6.elements;
  return this.x = e2[12], this.y = e2[13], this.z = e2[14], this;
}, setFromMatrixScale: function(t6) {
  var e2 = this.setFromMatrixColumn(t6, 0).length(), i2 = this.setFromMatrixColumn(t6, 1).length(), n2 = this.setFromMatrixColumn(t6, 2).length();
  return this.x = e2, this.y = i2, this.z = n2, this;
}, setFromMatrixColumn: function(t6, e2) {
  return this.fromArray(t6.elements, 4 * e2);
}, equals: function(t6) {
  return t6.x === this.x && t6.y === this.y && t6.z === this.z;
}, fromArray: function(t6, e2) {
  return void 0 === e2 && (e2 = 0), this.x = t6[e2], this.y = t6[e2 + 1], this.z = t6[e2 + 2], this;
}, toArray: function(t6, e2) {
  return void 0 === t6 && (t6 = []), void 0 === e2 && (e2 = 0), t6[e2] = this.x, t6[e2 + 1] = this.y, t6[e2 + 2] = this.z, t6;
}, fromBufferAttribute: function(t6, e2, i2) {
  return void 0 !== i2 && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t6.getX(e2), this.y = t6.getY(e2), this.z = t6.getZ(e2), this;
} }), Object.assign(QR.prototype, { isMatrix4: true, set: function(t6, e2, i2, n2, r2, s2, o2, a2, l2, c2, h2, u2, d2, p2, f2, m2) {
  var g2 = this.elements;
  return g2[0] = t6, g2[4] = e2, g2[8] = i2, g2[12] = n2, g2[1] = r2, g2[5] = s2, g2[9] = o2, g2[13] = a2, g2[2] = l2, g2[6] = c2, g2[10] = h2, g2[14] = u2, g2[3] = d2, g2[7] = p2, g2[11] = f2, g2[15] = m2, this;
}, identity: function() {
  return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
}, clone: function() {
  return new QR().fromArray(this.elements);
}, copy: function(t6) {
  var e2 = this.elements, i2 = t6.elements;
  return e2[0] = i2[0], e2[1] = i2[1], e2[2] = i2[2], e2[3] = i2[3], e2[4] = i2[4], e2[5] = i2[5], e2[6] = i2[6], e2[7] = i2[7], e2[8] = i2[8], e2[9] = i2[9], e2[10] = i2[10], e2[11] = i2[11], e2[12] = i2[12], e2[13] = i2[13], e2[14] = i2[14], e2[15] = i2[15], this;
}, copyPosition: function(t6) {
  var e2 = this.elements, i2 = t6.elements;
  return e2[12] = i2[12], e2[13] = i2[13], e2[14] = i2[14], this;
}, extractBasis: function(t6, e2, i2) {
  return t6.setFromMatrixColumn(this, 0), e2.setFromMatrixColumn(this, 1), i2.setFromMatrixColumn(this, 2), this;
}, makeBasis: function(t6, e2, i2) {
  return this.set(t6.x, e2.x, i2.x, 0, t6.y, e2.y, i2.y, 0, t6.z, e2.z, i2.z, 0, 0, 0, 0, 1), this;
}, extractRotation: (function() {
  var t6 = new $R();
  return function(e2) {
    var i2 = this.elements, n2 = e2.elements, r2 = 1 / t6.setFromMatrixColumn(e2, 0).length(), s2 = 1 / t6.setFromMatrixColumn(e2, 1).length(), o2 = 1 / t6.setFromMatrixColumn(e2, 2).length();
    return i2[0] = n2[0] * r2, i2[1] = n2[1] * r2, i2[2] = n2[2] * r2, i2[3] = 0, i2[4] = n2[4] * s2, i2[5] = n2[5] * s2, i2[6] = n2[6] * s2, i2[7] = 0, i2[8] = n2[8] * o2, i2[9] = n2[9] * o2, i2[10] = n2[10] * o2, i2[11] = 0, i2[12] = 0, i2[13] = 0, i2[14] = 0, i2[15] = 1, this;
  };
})(), makeRotationFromEuler: function(t6) {
  t6 && t6.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
  var e2 = this.elements, i2 = t6.x, n2 = t6.y, r2 = t6.z, s2 = Math.cos(i2), o2 = Math.sin(i2), a2 = Math.cos(n2), l2 = Math.sin(n2), c2 = Math.cos(r2), h2 = Math.sin(r2);
  if ("XYZ" === t6.order) {
    var u2 = s2 * c2, d2 = s2 * h2, p2 = o2 * c2, f2 = o2 * h2;
    e2[0] = a2 * c2, e2[4] = -a2 * h2, e2[8] = l2, e2[1] = d2 + p2 * l2, e2[5] = u2 - f2 * l2, e2[9] = -o2 * a2, e2[2] = f2 - u2 * l2, e2[6] = p2 + d2 * l2, e2[10] = s2 * a2;
  } else if ("YXZ" === t6.order) {
    var m2 = a2 * c2, g2 = a2 * h2, v2 = l2 * c2, y2 = l2 * h2;
    e2[0] = m2 + y2 * o2, e2[4] = v2 * o2 - g2, e2[8] = s2 * l2, e2[1] = s2 * h2, e2[5] = s2 * c2, e2[9] = -o2, e2[2] = g2 * o2 - v2, e2[6] = y2 + m2 * o2, e2[10] = s2 * a2;
  } else if ("ZXY" === t6.order) {
    m2 = a2 * c2, g2 = a2 * h2, v2 = l2 * c2, y2 = l2 * h2;
    e2[0] = m2 - y2 * o2, e2[4] = -s2 * h2, e2[8] = v2 + g2 * o2, e2[1] = g2 + v2 * o2, e2[5] = s2 * c2, e2[9] = y2 - m2 * o2, e2[2] = -s2 * l2, e2[6] = o2, e2[10] = s2 * a2;
  } else if ("ZYX" === t6.order) {
    u2 = s2 * c2, d2 = s2 * h2, p2 = o2 * c2, f2 = o2 * h2;
    e2[0] = a2 * c2, e2[4] = p2 * l2 - d2, e2[8] = u2 * l2 + f2, e2[1] = a2 * h2, e2[5] = f2 * l2 + u2, e2[9] = d2 * l2 - p2, e2[2] = -l2, e2[6] = o2 * a2, e2[10] = s2 * a2;
  } else if ("YZX" === t6.order) {
    var x2 = s2 * a2, b2 = s2 * l2, w2 = o2 * a2, _2 = o2 * l2;
    e2[0] = a2 * c2, e2[4] = _2 - x2 * h2, e2[8] = w2 * h2 + b2, e2[1] = h2, e2[5] = s2 * c2, e2[9] = -o2 * c2, e2[2] = -l2 * c2, e2[6] = b2 * h2 + w2, e2[10] = x2 - _2 * h2;
  } else if ("XZY" === t6.order) {
    x2 = s2 * a2, b2 = s2 * l2, w2 = o2 * a2, _2 = o2 * l2;
    e2[0] = a2 * c2, e2[4] = -h2, e2[8] = l2 * c2, e2[1] = x2 * h2 + _2, e2[5] = s2 * c2, e2[9] = b2 * h2 - w2, e2[2] = w2 * h2 - b2, e2[6] = o2 * c2, e2[10] = _2 * h2 + x2;
  }
  return e2[3] = 0, e2[7] = 0, e2[11] = 0, e2[12] = 0, e2[13] = 0, e2[14] = 0, e2[15] = 1, this;
}, makeRotationFromQuaternion: (XR = new $R(0, 0, 0), YR = new $R(1, 1, 1), function(t6) {
  return this.compose(XR, t6, YR);
}), lookAt: (function() {
  var t6 = new $R(), e2 = new $R(), i2 = new $R();
  return function(n2, r2, s2) {
    var o2 = this.elements;
    return i2.subVectors(n2, r2), 0 === i2.lengthSq() && (i2.z = 1), i2.normalize(), t6.crossVectors(s2, i2), 0 === t6.lengthSq() && (1 === Math.abs(s2.z) ? i2.x += 1e-4 : i2.z += 1e-4, i2.normalize(), t6.crossVectors(s2, i2)), t6.normalize(), e2.crossVectors(i2, t6), o2[0] = t6.x, o2[4] = e2.x, o2[8] = i2.x, o2[1] = t6.y, o2[5] = e2.y, o2[9] = i2.y, o2[2] = t6.z, o2[6] = e2.z, o2[10] = i2.z, this;
  };
})(), multiply: function(t6, e2) {
  return void 0 !== e2 ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t6, e2)) : this.multiplyMatrices(this, t6);
}, premultiply: function(t6) {
  return this.multiplyMatrices(t6, this);
}, multiplyMatrices: function(t6, e2) {
  var i2 = t6.elements, n2 = e2.elements, r2 = this.elements, s2 = i2[0], o2 = i2[4], a2 = i2[8], l2 = i2[12], c2 = i2[1], h2 = i2[5], u2 = i2[9], d2 = i2[13], p2 = i2[2], f2 = i2[6], m2 = i2[10], g2 = i2[14], v2 = i2[3], y2 = i2[7], x2 = i2[11], b2 = i2[15], w2 = n2[0], _2 = n2[4], S2 = n2[8], M2 = n2[12], T2 = n2[1], E2 = n2[5], A2 = n2[9], C2 = n2[13], R2 = n2[2], P2 = n2[6], L2 = n2[10], I2 = n2[14], D2 = n2[3], O2 = n2[7], z2 = n2[11], F2 = n2[15];
  return r2[0] = s2 * w2 + o2 * T2 + a2 * R2 + l2 * D2, r2[4] = s2 * _2 + o2 * E2 + a2 * P2 + l2 * O2, r2[8] = s2 * S2 + o2 * A2 + a2 * L2 + l2 * z2, r2[12] = s2 * M2 + o2 * C2 + a2 * I2 + l2 * F2, r2[1] = c2 * w2 + h2 * T2 + u2 * R2 + d2 * D2, r2[5] = c2 * _2 + h2 * E2 + u2 * P2 + d2 * O2, r2[9] = c2 * S2 + h2 * A2 + u2 * L2 + d2 * z2, r2[13] = c2 * M2 + h2 * C2 + u2 * I2 + d2 * F2, r2[2] = p2 * w2 + f2 * T2 + m2 * R2 + g2 * D2, r2[6] = p2 * _2 + f2 * E2 + m2 * P2 + g2 * O2, r2[10] = p2 * S2 + f2 * A2 + m2 * L2 + g2 * z2, r2[14] = p2 * M2 + f2 * C2 + m2 * I2 + g2 * F2, r2[3] = v2 * w2 + y2 * T2 + x2 * R2 + b2 * D2, r2[7] = v2 * _2 + y2 * E2 + x2 * P2 + b2 * O2, r2[11] = v2 * S2 + y2 * A2 + x2 * L2 + b2 * z2, r2[15] = v2 * M2 + y2 * C2 + x2 * I2 + b2 * F2, this;
}, multiplyScalar: function(t6) {
  var e2 = this.elements;
  return e2[0] *= t6, e2[4] *= t6, e2[8] *= t6, e2[12] *= t6, e2[1] *= t6, e2[5] *= t6, e2[9] *= t6, e2[13] *= t6, e2[2] *= t6, e2[6] *= t6, e2[10] *= t6, e2[14] *= t6, e2[3] *= t6, e2[7] *= t6, e2[11] *= t6, e2[15] *= t6, this;
}, applyToBufferAttribute: (function() {
  var t6 = new $R();
  return function(e2) {
    for (var i2 = 0, n2 = e2.count; i2 < n2; i2++) t6.x = e2.getX(i2), t6.y = e2.getY(i2), t6.z = e2.getZ(i2), t6.applyMatrix4(this), e2.setXYZ(i2, t6.x, t6.y, t6.z);
    return e2;
  };
})(), determinant: function() {
  var t6 = this.elements, e2 = t6[0], i2 = t6[4], n2 = t6[8], r2 = t6[12], s2 = t6[1], o2 = t6[5], a2 = t6[9], l2 = t6[13], c2 = t6[2], h2 = t6[6], u2 = t6[10], d2 = t6[14];
  return t6[3] * (+r2 * a2 * h2 - n2 * l2 * h2 - r2 * o2 * u2 + i2 * l2 * u2 + n2 * o2 * d2 - i2 * a2 * d2) + t6[7] * (+e2 * a2 * d2 - e2 * l2 * u2 + r2 * s2 * u2 - n2 * s2 * d2 + n2 * l2 * c2 - r2 * a2 * c2) + t6[11] * (+e2 * l2 * h2 - e2 * o2 * d2 - r2 * s2 * h2 + i2 * s2 * d2 + r2 * o2 * c2 - i2 * l2 * c2) + t6[15] * (-n2 * o2 * c2 - e2 * a2 * h2 + e2 * o2 * u2 + n2 * s2 * h2 - i2 * s2 * u2 + i2 * a2 * c2);
}, transpose: function() {
  var t6, e2 = this.elements;
  return t6 = e2[1], e2[1] = e2[4], e2[4] = t6, t6 = e2[2], e2[2] = e2[8], e2[8] = t6, t6 = e2[6], e2[6] = e2[9], e2[9] = t6, t6 = e2[3], e2[3] = e2[12], e2[12] = t6, t6 = e2[7], e2[7] = e2[13], e2[13] = t6, t6 = e2[11], e2[11] = e2[14], e2[14] = t6, this;
}, setPosition: function(t6, e2, i2) {
  var n2 = this.elements;
  return t6.isVector3 ? (n2[12] = t6.x, n2[13] = t6.y, n2[14] = t6.z) : (n2[12] = t6, n2[13] = e2, n2[14] = i2), this;
}, getInverse: function(t6, e2) {
  var i2 = this.elements, n2 = t6.elements, r2 = n2[0], s2 = n2[1], o2 = n2[2], a2 = n2[3], l2 = n2[4], c2 = n2[5], h2 = n2[6], u2 = n2[7], d2 = n2[8], p2 = n2[9], f2 = n2[10], m2 = n2[11], g2 = n2[12], v2 = n2[13], y2 = n2[14], x2 = n2[15], b2 = p2 * y2 * u2 - v2 * f2 * u2 + v2 * h2 * m2 - c2 * y2 * m2 - p2 * h2 * x2 + c2 * f2 * x2, w2 = g2 * f2 * u2 - d2 * y2 * u2 - g2 * h2 * m2 + l2 * y2 * m2 + d2 * h2 * x2 - l2 * f2 * x2, _2 = d2 * v2 * u2 - g2 * p2 * u2 + g2 * c2 * m2 - l2 * v2 * m2 - d2 * c2 * x2 + l2 * p2 * x2, S2 = g2 * p2 * h2 - d2 * v2 * h2 - g2 * c2 * f2 + l2 * v2 * f2 + d2 * c2 * y2 - l2 * p2 * y2, M2 = r2 * b2 + s2 * w2 + o2 * _2 + a2 * S2;
  if (0 === M2) {
    var T2 = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
    if (true === e2) throw new Error(T2);
    return console.warn(T2), this.identity();
  }
  var E2 = 1 / M2;
  return i2[0] = b2 * E2, i2[1] = (v2 * f2 * a2 - p2 * y2 * a2 - v2 * o2 * m2 + s2 * y2 * m2 + p2 * o2 * x2 - s2 * f2 * x2) * E2, i2[2] = (c2 * y2 * a2 - v2 * h2 * a2 + v2 * o2 * u2 - s2 * y2 * u2 - c2 * o2 * x2 + s2 * h2 * x2) * E2, i2[3] = (p2 * h2 * a2 - c2 * f2 * a2 - p2 * o2 * u2 + s2 * f2 * u2 + c2 * o2 * m2 - s2 * h2 * m2) * E2, i2[4] = w2 * E2, i2[5] = (d2 * y2 * a2 - g2 * f2 * a2 + g2 * o2 * m2 - r2 * y2 * m2 - d2 * o2 * x2 + r2 * f2 * x2) * E2, i2[6] = (g2 * h2 * a2 - l2 * y2 * a2 - g2 * o2 * u2 + r2 * y2 * u2 + l2 * o2 * x2 - r2 * h2 * x2) * E2, i2[7] = (l2 * f2 * a2 - d2 * h2 * a2 + d2 * o2 * u2 - r2 * f2 * u2 - l2 * o2 * m2 + r2 * h2 * m2) * E2, i2[8] = _2 * E2, i2[9] = (g2 * p2 * a2 - d2 * v2 * a2 - g2 * s2 * m2 + r2 * v2 * m2 + d2 * s2 * x2 - r2 * p2 * x2) * E2, i2[10] = (l2 * v2 * a2 - g2 * c2 * a2 + g2 * s2 * u2 - r2 * v2 * u2 - l2 * s2 * x2 + r2 * c2 * x2) * E2, i2[11] = (d2 * c2 * a2 - l2 * p2 * a2 - d2 * s2 * u2 + r2 * p2 * u2 + l2 * s2 * m2 - r2 * c2 * m2) * E2, i2[12] = S2 * E2, i2[13] = (d2 * v2 * o2 - g2 * p2 * o2 + g2 * s2 * f2 - r2 * v2 * f2 - d2 * s2 * y2 + r2 * p2 * y2) * E2, i2[14] = (g2 * c2 * o2 - l2 * v2 * o2 - g2 * s2 * h2 + r2 * v2 * h2 + l2 * s2 * y2 - r2 * c2 * y2) * E2, i2[15] = (l2 * p2 * o2 - d2 * c2 * o2 + d2 * s2 * h2 - r2 * p2 * h2 - l2 * s2 * f2 + r2 * c2 * f2) * E2, this;
}, scale: function(t6) {
  var e2 = this.elements, i2 = t6.x, n2 = t6.y, r2 = t6.z;
  return e2[0] *= i2, e2[4] *= n2, e2[8] *= r2, e2[1] *= i2, e2[5] *= n2, e2[9] *= r2, e2[2] *= i2, e2[6] *= n2, e2[10] *= r2, e2[3] *= i2, e2[7] *= n2, e2[11] *= r2, this;
}, getMaxScaleOnAxis: function() {
  var t6 = this.elements, e2 = t6[0] * t6[0] + t6[1] * t6[1] + t6[2] * t6[2], i2 = t6[4] * t6[4] + t6[5] * t6[5] + t6[6] * t6[6], n2 = t6[8] * t6[8] + t6[9] * t6[9] + t6[10] * t6[10];
  return Math.sqrt(Math.max(e2, i2, n2));
}, makeTranslation: function(t6, e2, i2) {
  return this.set(1, 0, 0, t6, 0, 1, 0, e2, 0, 0, 1, i2, 0, 0, 0, 1), this;
}, makeRotationX: function(t6) {
  var e2 = Math.cos(t6), i2 = Math.sin(t6);
  return this.set(1, 0, 0, 0, 0, e2, -i2, 0, 0, i2, e2, 0, 0, 0, 0, 1), this;
}, makeRotationY: function(t6) {
  var e2 = Math.cos(t6), i2 = Math.sin(t6);
  return this.set(e2, 0, i2, 0, 0, 1, 0, 0, -i2, 0, e2, 0, 0, 0, 0, 1), this;
}, makeRotationZ: function(t6) {
  var e2 = Math.cos(t6), i2 = Math.sin(t6);
  return this.set(e2, -i2, 0, 0, i2, e2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
}, makeRotationAxis: function(t6, e2) {
  var i2 = Math.cos(e2), n2 = Math.sin(e2), r2 = 1 - i2, s2 = t6.x, o2 = t6.y, a2 = t6.z, l2 = r2 * s2, c2 = r2 * o2;
  return this.set(l2 * s2 + i2, l2 * o2 - n2 * a2, l2 * a2 + n2 * o2, 0, l2 * o2 + n2 * a2, c2 * o2 + i2, c2 * a2 - n2 * s2, 0, l2 * a2 - n2 * o2, c2 * a2 + n2 * s2, r2 * a2 * a2 + i2, 0, 0, 0, 0, 1), this;
}, makeScale: function(t6, e2, i2) {
  return this.set(t6, 0, 0, 0, 0, e2, 0, 0, 0, 0, i2, 0, 0, 0, 0, 1), this;
}, makeShear: function(t6, e2, i2) {
  return this.set(1, e2, i2, 0, t6, 1, i2, 0, t6, e2, 1, 0, 0, 0, 0, 1), this;
}, compose: function(t6, e2, i2) {
  var n2 = this.elements, r2 = e2._x, s2 = e2._y, o2 = e2._z, a2 = e2._w, l2 = r2 + r2, c2 = s2 + s2, h2 = o2 + o2, u2 = r2 * l2, d2 = r2 * c2, p2 = r2 * h2, f2 = s2 * c2, m2 = s2 * h2, g2 = o2 * h2, v2 = a2 * l2, y2 = a2 * c2, x2 = a2 * h2, b2 = i2.x, w2 = i2.y, _2 = i2.z;
  return n2[0] = (1 - (f2 + g2)) * b2, n2[1] = (d2 + x2) * b2, n2[2] = (p2 - y2) * b2, n2[3] = 0, n2[4] = (d2 - x2) * w2, n2[5] = (1 - (u2 + g2)) * w2, n2[6] = (m2 + v2) * w2, n2[7] = 0, n2[8] = (p2 + y2) * _2, n2[9] = (m2 - v2) * _2, n2[10] = (1 - (u2 + f2)) * _2, n2[11] = 0, n2[12] = t6.x, n2[13] = t6.y, n2[14] = t6.z, n2[15] = 1, this;
}, decompose: (WR = new $R(), qR = new QR(), function(t6, e2, i2) {
  var n2 = this.elements, r2 = WR.set(n2[0], n2[1], n2[2]).length(), s2 = WR.set(n2[4], n2[5], n2[6]).length(), o2 = WR.set(n2[8], n2[9], n2[10]).length();
  this.determinant() < 0 && (r2 = -r2), t6.x = n2[12], t6.y = n2[13], t6.z = n2[14], qR.copy(this);
  var a2 = 1 / r2, l2 = 1 / s2, c2 = 1 / o2;
  return qR.elements[0] *= a2, qR.elements[1] *= a2, qR.elements[2] *= a2, qR.elements[4] *= l2, qR.elements[5] *= l2, qR.elements[6] *= l2, qR.elements[8] *= c2, qR.elements[9] *= c2, qR.elements[10] *= c2, e2.setFromRotationMatrix(qR), i2.x = r2, i2.y = s2, i2.z = o2, this;
}), makePerspective: function(t6, e2, i2, n2, r2, s2) {
  void 0 === s2 && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
  var o2 = this.elements, a2 = 2 * r2 / (e2 - t6), l2 = 2 * r2 / (i2 - n2), c2 = (e2 + t6) / (e2 - t6), h2 = (i2 + n2) / (i2 - n2), u2 = -(s2 + r2) / (s2 - r2), d2 = -2 * s2 * r2 / (s2 - r2);
  return o2[0] = a2, o2[4] = 0, o2[8] = c2, o2[12] = 0, o2[1] = 0, o2[5] = l2, o2[9] = h2, o2[13] = 0, o2[2] = 0, o2[6] = 0, o2[10] = u2, o2[14] = d2, o2[3] = 0, o2[7] = 0, o2[11] = -1, o2[15] = 0, this;
}, makeOrthographic: function(t6, e2, i2, n2, r2, s2) {
  var o2 = this.elements, a2 = 1 / (e2 - t6), l2 = 1 / (i2 - n2), c2 = 1 / (s2 - r2), h2 = (e2 + t6) * a2, u2 = (i2 + n2) * l2, d2 = (s2 + r2) * c2;
  return o2[0] = 2 * a2, o2[4] = 0, o2[8] = 0, o2[12] = -h2, o2[1] = 0, o2[5] = 2 * l2, o2[9] = 0, o2[13] = -u2, o2[2] = 0, o2[6] = 0, o2[10] = -2 * c2, o2[14] = -d2, o2[3] = 0, o2[7] = 0, o2[11] = 0, o2[15] = 1, this;
}, equals: function(t6) {
  for (var e2 = this.elements, i2 = t6.elements, n2 = 0; n2 < 16; n2++) if (e2[n2] !== i2[n2]) return false;
  return true;
}, fromArray: function(t6, e2) {
  void 0 === e2 && (e2 = 0);
  for (var i2 = 0; i2 < 16; i2++) this.elements[i2] = t6[i2 + e2];
  return this;
}, toArray: function(t6, e2) {
  void 0 === t6 && (t6 = []), void 0 === e2 && (e2 = 0);
  var i2 = this.elements;
  return t6[e2] = i2[0], t6[e2 + 1] = i2[1], t6[e2 + 2] = i2[2], t6[e2 + 3] = i2[3], t6[e2 + 4] = i2[4], t6[e2 + 5] = i2[5], t6[e2 + 6] = i2[6], t6[e2 + 7] = i2[7], t6[e2 + 8] = i2[8], t6[e2 + 9] = i2[9], t6[e2 + 10] = i2[10], t6[e2 + 11] = i2[11], t6[e2 + 12] = i2[12], t6[e2 + 13] = i2[13], t6[e2 + 14] = i2[14], t6[e2 + 15] = i2[15], t6;
} }), tP.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], tP.DefaultOrder = "XYZ", Object.defineProperties(tP.prototype, { x: { get: function() {
  return this._x;
}, set: function(t6) {
  this._x = t6, this._onChangeCallback();
} }, y: { get: function() {
  return this._y;
}, set: function(t6) {
  this._y = t6, this._onChangeCallback();
} }, z: { get: function() {
  return this._z;
}, set: function(t6) {
  this._z = t6, this._onChangeCallback();
} }, order: { get: function() {
  return this._order;
}, set: function(t6) {
  this._order = t6, this._onChangeCallback();
} } }), Object.assign(tP.prototype, { isEuler: true, set: function(t6, e2, i2, n2) {
  return this._x = t6, this._y = e2, this._z = i2, this._order = n2 || this._order, this._onChangeCallback(), this;
}, clone: function() {
  return new this.constructor(this._x, this._y, this._z, this._order);
}, copy: function(t6) {
  return this._x = t6._x, this._y = t6._y, this._z = t6._z, this._order = t6._order, this._onChangeCallback(), this;
}, setFromRotationMatrix: function(t6, e2, i2) {
  var n2 = JR.clamp, r2 = t6.elements, s2 = r2[0], o2 = r2[4], a2 = r2[8], l2 = r2[1], c2 = r2[5], h2 = r2[9], u2 = r2[2], d2 = r2[6], p2 = r2[10];
  return "XYZ" === (e2 = e2 || this._order) ? (this._y = Math.asin(n2(a2, -1, 1)), Math.abs(a2) < 0.99999 ? (this._x = Math.atan2(-h2, p2), this._z = Math.atan2(-o2, s2)) : (this._x = Math.atan2(d2, c2), this._z = 0)) : "YXZ" === e2 ? (this._x = Math.asin(-n2(h2, -1, 1)), Math.abs(h2) < 0.99999 ? (this._y = Math.atan2(a2, p2), this._z = Math.atan2(l2, c2)) : (this._y = Math.atan2(-u2, s2), this._z = 0)) : "ZXY" === e2 ? (this._x = Math.asin(n2(d2, -1, 1)), Math.abs(d2) < 0.99999 ? (this._y = Math.atan2(-u2, p2), this._z = Math.atan2(-o2, c2)) : (this._y = 0, this._z = Math.atan2(l2, s2))) : "ZYX" === e2 ? (this._y = Math.asin(-n2(u2, -1, 1)), Math.abs(u2) < 0.99999 ? (this._x = Math.atan2(d2, p2), this._z = Math.atan2(l2, s2)) : (this._x = 0, this._z = Math.atan2(-o2, c2))) : "YZX" === e2 ? (this._z = Math.asin(n2(l2, -1, 1)), Math.abs(l2) < 0.99999 ? (this._x = Math.atan2(-h2, c2), this._y = Math.atan2(-u2, s2)) : (this._x = 0, this._y = Math.atan2(a2, p2))) : "XZY" === e2 ? (this._z = Math.asin(-n2(o2, -1, 1)), Math.abs(o2) < 0.99999 ? (this._x = Math.atan2(d2, c2), this._y = Math.atan2(a2, s2)) : (this._x = Math.atan2(-h2, p2), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e2), this._order = e2, false !== i2 && this._onChangeCallback(), this;
}, setFromQuaternion: (function() {
  var t6 = new QR();
  return function(e2, i2, n2) {
    return t6.makeRotationFromQuaternion(e2), this.setFromRotationMatrix(t6, i2, n2);
  };
})(), setFromVector3: function(t6, e2) {
  return this.set(t6.x, t6.y, t6.z, e2 || this._order);
}, reorder: (ZR = new KR(), function(t6) {
  return ZR.setFromEuler(this), this.setFromQuaternion(ZR, t6);
}), equals: function(t6) {
  return t6._x === this._x && t6._y === this._y && t6._z === this._z && t6._order === this._order;
}, fromArray: function(t6) {
  return this._x = t6[0], this._y = t6[1], this._z = t6[2], void 0 !== t6[3] && (this._order = t6[3]), this._onChangeCallback(), this;
}, toArray: function(t6, e2) {
  return void 0 === t6 && (t6 = []), void 0 === e2 && (e2 = 0), t6[e2] = this._x, t6[e2 + 1] = this._y, t6[e2 + 2] = this._z, t6[e2 + 3] = this._order, t6;
}, toVector3: function(t6) {
  return t6 ? t6.set(this._x, this._y, this._z) : new $R(this._x, this._y, this._z);
}, _onChange: function(t6) {
  return this._onChangeCallback = t6, this;
}, _onChangeCallback: function() {
} });
var eP = { toScreenPos: (function() {
  var t6 = new $R();
  return function(e2, i2, n2) {
    return t6.copy(e2), t6.project(i2), t6.x = Math.round((t6.x + 1) * n2.width / 2), t6.y = Math.round((1 - t6.y) * n2.height / 2), t6.z = 0, t6;
  };
})(), toSpacePos: (function() {
  var t6, e2 = new $R(), i2 = new $R();
  return function(n2, r2, s2) {
    return e2.set(n2.x / s2.width * 2 - 1, -n2.y / s2.height * 2 + 1, 0.5), e2.unproject(r2), i2.copy(e2.sub(r2.position).normalize()), t6 = -r2.position.z / i2.z, e2.copy(r2.position), e2.add(i2.multiplyScalar(t6)), e2;
  };
})() };
var iP = { initValue: function(t6, e2) {
  return null != t6 && null != t6 ? t6 : e2;
}, isArray: function(t6) {
  return "[object Array]" === Object.prototype.toString.call(t6);
}, destroyArray: function(t6) {
  t6.length = 0;
}, destroyObject: function(t6) {
  for (var e2 in t6) delete t6[e2];
}, isUndefined: function() {
  for (var t6 in arguments) {
    if (void 0 !== arguments[t6]) return false;
  }
  return true;
}, setVectorByObj: function(t6, e2) {
  void 0 !== e2.x && (t6.position.x = e2.x), void 0 !== e2.y && (t6.position.y = e2.y), void 0 !== e2.z && (t6.position.z = e2.z), void 0 !== e2.vx && (t6.velocity.x = e2.vx), void 0 !== e2.vy && (t6.velocity.y = e2.vy), void 0 !== e2.vz && (t6.velocity.z = e2.vz), void 0 !== e2.ax && (t6.acceleration.x = e2.ax), void 0 !== e2.ay && (t6.acceleration.y = e2.ay), void 0 !== e2.az && (t6.acceleration.z = e2.az), void 0 !== e2.p && t6.position.copy(e2.p), void 0 !== e2.v && t6.velocity.copy(e2.v), void 0 !== e2.a && t6.acceleration.copy(e2.a), void 0 !== e2.position && t6.position.copy(e2.position), void 0 !== e2.velocity && t6.velocity.copy(e2.velocity), void 0 !== e2.accelerate && t6.acceleration.copy(e2.accelerate);
}, setPrototypeByObj: function(t6, e2, i2) {
  for (var n2 in e2) t6.hasOwnProperty(n2) && (i2 ? i2.indexOf(n2) < 0 && (t6[n2] = this._getValue(e2[n2])) : t6[n2] = this._getValue(e2[n2]));
  return t6;
}, _getValue: function(t6) {
  return "Span" === t6.constructor.type ? t6.getValue() : t6;
} };
var nP = i(8389);
var rP = i.n(nP)();
function sP(t6, e2) {
  var i2 = Object.keys(t6);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(t6);
    e2 && (n2 = n2.filter((function(e3) {
      return Object.getOwnPropertyDescriptor(t6, e3).enumerable;
    }))), i2.push.apply(i2, n2);
  }
  return i2;
}
function oP(t6) {
  for (var e2 = 1; e2 < arguments.length; e2++) {
    var i2 = null != arguments[e2] ? arguments[e2] : {};
    e2 % 2 ? sP(Object(i2), true).forEach((function(e3) {
      HR(t6, e3, i2[e3]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t6, Object.getOwnPropertyDescriptors(i2)) : sP(Object(i2)).forEach((function(e3) {
      Object.defineProperty(t6, e3, Object.getOwnPropertyDescriptor(i2, e3));
    }));
  }
  return t6;
}
var aP = (t6, e2) => oP(oP({}, t6), e2);
var lP = { randomAToB: function(t6, e2, i2) {
  return i2 ? (Math.random() * (e2 - t6) | 0) + t6 : t6 + Math.random() * (e2 - t6);
}, randomFloating: function(t6, e2, i2) {
  return this.randomAToB(t6 - e2, t6 + e2, i2);
}, randomZone: function(t6) {
}, degreeTransform: function(t6) {
  return t6 * tR / 180;
}, toColor16: function(t6) {
  return "#" + t6.toString(16);
}, randomColor: function() {
  return "#" + ("00000" + (16777216 * Math.random() | 0).toString(16)).slice(-6);
}, lerp: function(t6, e2, i2) {
  return e2 + (t6 - e2) * i2;
}, getNormal: function(t6, e2) {
  return 0 == t6.x && 0 == t6.y ? 0 == t6.z ? e2.set(1, 0, 1) : e2.set(1, 1, -t6.y / t6.z) : 0 == t6.x ? e2.set(1, 0, 1) : e2.set(-t6.y / t6.x, 1, 1), e2.normalize();
}, axisRotate: function(t6, e2, i2, n2) {
  var r2 = Math.cos(n2), s2 = Math.sin(n2), o2 = i2.dot(e2) * (1 - r2);
  t6.copy(i2), t6.cross(e2).scalar(s2), t6.addValue(e2.x * r2, e2.y * r2, e2.z * r2), t6.addValue(i2.x * o2, i2.y * o2, i2.z * o2);
} };
var cP = class {
  constructor(t6, e2, i2) {
    this._isArray = false, this.type = "Span", iP.isArray(t6) ? (this._isArray = true, this.a = t6) : (this.a = iP.initValue(t6, 1), this.b = iP.initValue(e2, this.a), this._center = iP.initValue(i2, false));
  }
  getValue(t6) {
    return this._isArray ? this.a[this.a.length * Math.random() | 0] : this._center ? lP.randomFloating(this.a, this.b, t6) : lP.randomAToB(this.a, this.b, t6);
  }
};
var hP = (t6, e2, i2) => t6 instanceof cP ? t6 : void 0 === e2 ? new cP(t6) : void 0 === i2 ? new cP(t6, e2) : new cP(t6, e2, i2);
var uP = i(5620);
var dP = i.n(uP);
var pP = class extends cP {
  constructor(t6) {
    super(), this.type = "ArraySpan", this.items = Array.isArray(t6) ? t6 : [t6];
  }
  getValue() {
    return dP()(this.items);
  }
};
var fP = class extends cP {
  constructor(t6) {
    super(), this.type = "ColorSpan", this.shouldRandomize = "random" === t6, this.colors = Array.isArray(t6) ? t6 : [t6];
  }
  getValue() {
    return this.shouldRandomize ? lP.randomColor() : dP()(this.colors);
  }
};
var mP = (t6) => (t6 || (console.warn(`Invalid colors argument ${t6} passed to createColorSpan. Defaulting to 'random'.`), t6 = "random"), t6 instanceof fP ? t6 : new fP(t6));
var gP = "EULER";
var vP = (t6, e2, i2) => {
  t6.sleep || (t6.old.position.copy(t6.position), t6.old.velocity.copy(t6.velocity), t6.acceleration.scalar(1 / t6.mass), t6.velocity.add(t6.acceleration.scalar(e2)), t6.position.add(t6.old.velocity.scalar(e2)), i2 && t6.velocity.scalar(Math.pow(i2, e2 / zR)), t6.acceleration.clear());
};
var yP = (t6, e2, i2, n2 = gP) => {
  vP(t6, e2, i2);
};
var xP = class extends $R {
  clear() {
    return this.x = 0, this.y = 0, this.z = 0, this;
  }
  scalar(t6) {
    return this.x *= t6, this.y *= t6, this.z *= t6, this;
  }
  addValue(t6, e2, i2) {
    return this.x += t6, this.y += e2, this.z += i2, this;
  }
  toString() {
    return "x:" + this.x + "y:" + this.y + "z:" + this.z;
  }
  eulerFromDir(t6) {
    return new tP().setFromVector3(t6);
  }
};
var bP = class _bP {
  constructor(t6, e2, i2) {
    this.type = "Polar3D", this.radius = t6 || 1, this.phi = i2 || 0, this.theta = e2 || 0;
  }
  set(t6, e2, i2) {
    return this.radius = t6 || 1, this.phi = i2 || 0, this.theta = e2 || 0, this;
  }
  setRadius(t6) {
    return this.radius = t6, this;
  }
  setPhi(t6) {
    return this.phi = t6, this;
  }
  setTheta(t6) {
    return this.theta = t6, this;
  }
  copy(t6) {
    return this.radius = t6.radius, this.phi = t6.phi, this.theta = t6.theta, this;
  }
  toVector3D() {
    return new xP(this.getX(), this.getY(), this.getZ());
  }
  getX() {
    return this.radius * Math.sin(this.theta) * Math.cos(this.phi);
  }
  getY() {
    return -this.radius * Math.sin(this.theta) * Math.sin(this.phi);
  }
  getZ() {
    return this.radius * Math.cos(this.theta);
  }
  normalize() {
    return this.radius = 1, this;
  }
  equals(t6) {
    return t6.radius === this.radius && t6.phi === this.phi && t6.theta === this.theta;
  }
  clear() {
    return this.radius = 0, this.phi = 0, this.theta = 0, this;
  }
  clone() {
    return new _bP(this.radius, this.phi, this.theta);
  }
};
var wP = class {
  constructor(t6) {
    this.id = `particle-${rP()}`, this.type = "Particle", this.life = RR, this.age = 0, this.energy = 1, this.dead = PR, this.sleep = LR, this.body = null, this.parent = null, this.mass = 1, this.radius = 10, this.alpha = 1, this.scale = 1, this.useColor = IR, this.useAlpha = DR, this.easing = OR, this.position = new xP(), this.velocity = new xP(), this.acceleration = new xP(), this.old = {}, this.old.position = this.position.clone(), this.old.velocity = this.velocity.clone(), this.old.acceleration = this.acceleration.clone(), this.behaviours = [], this.transform = {}, this.color = { r: 0, g: 0, b: 0 }, this.rotation = new xP(), this.distanceToCamera = 0, iP.setPrototypeByObj(this, t6);
  }
  getDirection() {
    return Math.atan2(this.velocity.x, -this.velocity.y) * (180 / tR);
  }
  reset() {
    return this.life = RR, this.age = 0, this.energy = 1, this.dead = PR, this.sleep = LR, this.body = null, this.parent = null, this.mass = 1, this.radius = 10, this.alpha = 1, this.scale = 1, this.useColor = IR, this.useAlpha = DR, this.easing = OR, this.position.set(0, 0, 0), this.velocity.set(0, 0, 0), this.acceleration.set(0, 0, 0), this.old.position.set(0, 0, 0), this.old.velocity.set(0, 0, 0), this.old.acceleration.set(0, 0, 0), this.color.r = 0, this.color.g = 0, this.color.b = 0, this.rotation.clear(), iP.destroyObject(this.transform), this.removeAllBehaviours(), this;
  }
  update(t6, e2) {
    if (!this.sleep) {
      this.age += t6;
      let i2 = this.behaviours.length;
      for (; i2--; ) {
        this.behaviours[i2].applyBehaviour(this, t6, e2);
      }
    }
    if (this.age >= this.life) this.destroy();
    else {
      const t7 = this.easing(this.age / this.life);
      this.energy = Math.max(1 - t7, 0);
    }
  }
  addBehaviour(t6) {
    this.behaviours.push(t6), t6.initialize(this);
  }
  addBehaviours(t6) {
    let e2 = t6.length;
    for (; e2--; ) this.addBehaviour(t6[e2]);
  }
  removeBehaviour(t6) {
    const e2 = this.behaviours.indexOf(t6);
    e2 > -1 && this.behaviours.splice(e2, 1);
  }
  removeAllBehaviours() {
    iP.destroyArray(this.behaviours);
  }
  destroy() {
    this.removeAllBehaviours(), this.energy = 0, this.dead = true, this.parent = null;
  }
};
var _P = class {
  constructor() {
    this.type = "Pool", this.cID = 0, this.list = {};
  }
  create(t6, ...e2) {
    if (!this.canCreateNewObject(t6)) throw new Error("The pool is unable to create or clone the object supplied");
    return this.cID++, this.canInstantiateObject(t6) ? new t6(...e2) : this.canCloneObject(t6) ? t6.clone() : void 0;
  }
  canInstantiateObject(t6) {
    return "function" == typeof t6;
  }
  canCloneObject(t6) {
    return t6.clone && "function" == typeof t6.clone;
  }
  canCreateNewObject(t6) {
    return !(!this.canInstantiateObject(t6) && !this.canCloneObject(t6));
  }
  getCount() {
    var t6 = 0;
    for (var e2 in this.list) t6 += this.list[e2].length;
    return t6++;
  }
  get(t6, ...e2) {
    var i2, n2 = t6.__puid || jR.id(t6);
    return (i2 = this.list[n2] && this.list[n2].length > 0 ? this.list[n2].pop() : this.create(t6, ...e2)).__puid = t6.__puid || n2, i2;
  }
  expire(t6) {
    return this._getList(t6.__puid).push(t6);
  }
  destroy() {
    for (var t6 in this.list) this.list[t6].length = 0, delete this.list[t6];
  }
  _getList(t6) {
    return t6 = t6 || "default", this.list[t6] || (this.list[t6] = []), this.list[t6];
  }
};
var SP = class {
  constructor() {
    this.listeners = null;
  }
  set listeners(t6) {
    this._listeners = t6;
  }
  get listeners() {
    return this._listeners;
  }
  addEventListener(t6, e2) {
    return this.listeners ? this.removeEventListener(t6, e2) : this.listeners = {}, this.listeners[t6] || (this.listeners[t6] = []), this.listeners[t6].push(e2), e2;
  }
  removeEventListener(t6, e2) {
    if (this.listeners && this.listeners[t6]) {
      for (var i2 = this.listeners[t6], n2 = 0, r2 = i2.length; n2 < r2; n2++) if (i2[n2] == e2) {
        1 == r2 ? delete this.listeners[t6] : i2.splice(n2, 1);
        break;
      }
    }
  }
  removeAllEventListeners(t6) {
    t6 ? this.listeners && delete this.listeners[t6] : this.listeners = null;
  }
  dispatchEvent(t6, e2) {
    var i2 = false, n2 = this.listeners;
    if (t6 && n2) {
      var r2 = n2[t6];
      if (!r2) return i2;
      for (var s2, o2 = (r2 = r2.slice()).length; o2--; ) s2 = r2[o2], i2 = i2 || s2(e2);
    }
    return !!i2;
  }
  hasEventListener(t6) {
    var e2 = this.listeners;
    return !(!e2 || !e2[t6]);
  }
};
var MP = "SYSTEM_UPDATE";
var TP = "PARTICLE_CREATED";
var EP = "PARTICLE_UPDATE";
var AP = "PARTICLE_DEAD";
var CP = "EMITTER_DEAD";
var RP = class {
  constructor(t6 = "Initializer", e2 = true) {
    this.type = t6, this.isEnabled = e2;
  }
  init(t6, e2) {
    this.isEnabled && (e2 ? (this.initialize(e2), e2.hasBeenInitialized = true) : (this.initialize(t6), t6.hasBeenInitialized = true));
  }
  reset() {
  }
  initialize(t6) {
  }
  static requiresWebGlApi() {
    return false;
  }
  static fromJSON(t6) {
  }
};
var PP = class _PP extends RP {
  constructor(t6, e2, i2, n2 = true) {
    var r2;
    super(FC, n2), this.body = (r2 = t6) ? r2 instanceof pP ? r2 : new pP(r2) : null, this.w = e2, this.h = i2 || e2;
  }
  initialize(t6) {
    var e2 = this.body.getValue();
    this.w ? t6.body = { width: this.w, height: this.h, body: e2 } : t6.body = e2;
  }
  static fromJSON(t6) {
    const { body: e2, width: i2, height: n2, isEnabled: r2 = true } = t6;
    return new _PP(e2, i2, n2, r2);
  }
};
function LP(t6, e2) {
  var i2 = Object.keys(t6);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(t6);
    e2 && (n2 = n2.filter((function(e3) {
      return Object.getOwnPropertyDescriptor(t6, e3).enumerable;
    }))), i2.push.apply(i2, n2);
  }
  return i2;
}
function IP(t6) {
  for (var e2 = 1; e2 < arguments.length; e2++) {
    var i2 = null != arguments[e2] ? arguments[e2] : {};
    e2 % 2 ? LP(Object(i2), true).forEach((function(e3) {
      HR(t6, e3, i2[e3]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t6, Object.getOwnPropertyDescriptors(i2)) : LP(Object(i2)).forEach((function(e3) {
      Object.defineProperty(t6, e3, Object.getOwnPropertyDescriptor(i2, e3));
    }));
  }
  return t6;
}
var DP = { AdditiveBlending: 2, CustomBlending: 5, MultiplyBlending: 4, NoBlending: 0, NormalBlending: 1, SubtractiveBlending: 3 };
var OP = { color: 16711680, blending: 2, fog: true };
var zP = IP(IP({}, OP), {}, { blending: "AdditiveBlending" });
function FP(t6, e2) {
  var i2 = Object.keys(t6);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(t6);
    e2 && (n2 = n2.filter((function(e3) {
      return Object.getOwnPropertyDescriptor(t6, e3).enumerable;
    }))), i2.push.apply(i2, n2);
  }
  return i2;
}
function NP(t6) {
  for (var e2 = 1; e2 < arguments.length; e2++) {
    var i2 = null != arguments[e2] ? arguments[e2] : {};
    e2 % 2 ? FP(Object(i2), true).forEach((function(e3) {
      HR(t6, e3, i2[e3]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t6, Object.getOwnPropertyDescriptors(i2)) : FP(Object(i2)).forEach((function(e3) {
      Object.defineProperty(t6, e3, Object.getOwnPropertyDescriptor(i2, e3));
    }));
  }
  return t6;
}
var BP = class _BP extends RP {
  constructor(t6, e2, i2 = OP, n2 = true) {
    super(NC, n2);
    const { Sprite: r2, SpriteMaterial: s2, TextureLoader: o2 } = t6;
    this.materialProperties = aP(OP, i2), new o2().load(e2, ((t7) => {
      this.texture = t7, this.material = new s2(NP(NP({}, { map: t7 }), this.materialProperties)), this.sprite = new r2(this.material);
    }), void 0, ((t7) => {
      throw new Error(t7);
    }));
  }
  initialize(t6) {
    t6.body = this.sprite;
  }
  static fromJSON(t6, e2) {
    const { texture: i2, materialProperties: n2 = zP, isEnabled: r2 = true } = t6;
    return new _BP(e2, i2, aP(zP, ((t7) => {
      const { blending: e3 } = t7;
      return NP(NP({}, t7), {}, { blending: e3 ? DP[e3] : DP[zP.blending] });
    })(n2)), r2);
  }
};
var kP = new tP();
var UP = { particleEuler: null, initialize: function(t6, e2, i2) {
  let n2 = i2.length;
  for (; n2--; ) i2[n2].init(t6, e2);
  t6.bindEmitter && this.bindEmitter(t6, e2);
}, bindEmitter: function(t6, e2) {
  const { rotation: { x: i2, y: n2, z: r2 } } = t6;
  e2.position.add(t6.position), e2.velocity.add(t6.velocity), e2.acceleration.add(t6.acceleration), e2.velocity.applyEuler(kP.set(i2, n2, r2));
} };
var HP = class _HP extends RP {
  constructor(t6, e2, i2, n2 = true) {
    super(kC, n2), this.lifePan = hP(t6, e2, i2);
  }
  initialize(t6) {
    this.lifePan.a == 1 / 0 || "infi" == this.lifePan.a ? t6.life = 1 / 0 : t6.life = this.lifePan.getValue();
  }
  static fromJSON(t6) {
    const { min: e2, max: i2, center: n2 = false, isEnabled: r2 = true } = t6;
    return new _HP(e2, i2, n2, r2);
  }
};
var VP = class _VP extends RP {
  constructor(t6, e2, i2 = false, n2 = true) {
    super(UC, n2), this.massPan = hP(t6, e2, i2);
  }
  initialize(t6) {
    t6.mass = this.massPan.getValue();
  }
  static fromJSON(t6) {
    const { min: e2, max: i2, center: n2 = false, isEnabled: r2 = true } = t6;
    return new _VP(e2, i2, n2, r2);
  }
};
var jP = class {
  constructor(t6 = "Zone") {
    this.type = t6, this.vector = new xP(0, 0, 0), this.random = 0, this.crossType = "dead", this.log = true, this.supportsCrossing = true;
  }
  getPosition() {
    return null;
  }
  crossing(t6) {
    if (!this.supportsCrossing) return console.warn(`${this.constructor.name} does not support the crossing method`);
    switch (this.crossType) {
      case "bound":
        this._bound(t6);
        break;
      case "cross":
        this._cross(t6);
        break;
      case "dead":
        this._dead(t6);
    }
  }
  isBoxZone() {
    return false;
  }
  isLineZone() {
    return false;
  }
  isMeshZone() {
    return false;
  }
  isPointZone() {
    return false;
  }
  isScreenZone() {
    return false;
  }
  isSphereZone() {
    return false;
  }
  _dead(t6) {
  }
  _bound(t6) {
  }
  _cross(t6) {
  }
};
var GP = class extends jP {
  constructor(t6, e2, i2, n2, r2, s2) {
    var o2, a2, l2, c2, h2;
    super(XC), iP.isUndefined(e2, i2, n2, r2, s2) ? (o2 = a2 = l2 = 0, c2 = h2 = n2 = t6 || 100) : iP.isUndefined(n2, r2, s2) ? (o2 = a2 = l2 = 0, c2 = t6, h2 = e2, n2 = i2) : (o2 = t6, a2 = e2, l2 = i2, c2 = n2, h2 = r2, n2 = s2), this.x = o2, this.y = a2, this.z = l2, this.width = c2, this.height = h2, this.depth = n2, this.friction = 0.85, this.max = 6;
  }
  isBoxZone() {
    return true;
  }
  getPosition() {
    return this.vector.x = this.x + lP.randomAToB(-0.5, 0.5) * this.width, this.vector.y = this.y + lP.randomAToB(-0.5, 0.5) * this.height, this.vector.z = this.z + lP.randomAToB(-0.5, 0.5) * this.depth, this.vector;
  }
  _dead(t6) {
    (t6.position.x + t6.radius < this.x - this.width / 2 || t6.position.x - t6.radius > this.x + this.width / 2) && (t6.dead = true), (t6.position.y + t6.radius < this.y - this.height / 2 || t6.position.y - t6.radius > this.y + this.height / 2) && (t6.dead = true), (t6.position.z + t6.radius < this.z - this.depth / 2 || t6.position.z - t6.radius > this.z + this.depth / 2) && (t6.dead = true);
  }
  _bound(t6) {
    t6.position.x - t6.radius < this.x - this.width / 2 ? (t6.position.x = this.x - this.width / 2 + t6.radius, t6.velocity.x *= -this.friction, this._static(t6, "x")) : t6.position.x + t6.radius > this.x + this.width / 2 && (t6.position.x = this.x + this.width / 2 - t6.radius, t6.velocity.x *= -this.friction, this._static(t6, "x")), t6.position.y - t6.radius < this.y - this.height / 2 ? (t6.position.y = this.y - this.height / 2 + t6.radius, t6.velocity.y *= -this.friction, this._static(t6, "y")) : t6.position.y + t6.radius > this.y + this.height / 2 && (t6.position.y = this.y + this.height / 2 - t6.radius, t6.velocity.y *= -this.friction, this._static(t6, "y")), t6.position.z - t6.radius < this.z - this.depth / 2 ? (t6.position.z = this.z - this.depth / 2 + t6.radius, t6.velocity.z *= -this.friction, this._static(t6, "z")) : t6.position.z + t6.radius > this.z + this.depth / 2 && (t6.position.z = this.z + this.depth / 2 - t6.radius, t6.velocity.z *= -this.friction, this._static(t6, "z"));
  }
  _static(t6, e2) {
    t6.velocity[e2] * t6.acceleration[e2] > 0 || Math.abs(t6.velocity[e2]) < 0.0167 * Math.abs(t6.acceleration[e2]) * this.max && (t6.velocity[e2] = 0, t6.acceleration[e2] = 0);
  }
  _cross(t6) {
    t6.position.x + t6.radius < this.x - this.width / 2 && t6.velocity.x <= 0 ? t6.position.x = this.x + this.width / 2 + t6.radius : t6.position.x - t6.radius > this.x + this.width / 2 && t6.velocity.x >= 0 && (t6.position.x = this.x - this.width / 2 - t6.radius), t6.position.y + t6.radius < this.y - this.height / 2 && t6.velocity.y <= 0 ? t6.position.y = this.y + this.height / 2 + t6.radius : t6.position.y - t6.radius > this.y + this.height / 2 && t6.velocity.y >= 0 && (t6.position.y = this.y - this.height / 2 - t6.radius), t6.position.z + t6.radius < this.z - this.depth / 2 && t6.velocity.z <= 0 ? t6.position.z = this.z + this.depth / 2 + t6.radius : t6.position.z - t6.radius > this.z + this.depth / 2 && t6.velocity.z >= 0 && (t6.position.z = this.z - this.depth / 2 - t6.radius);
  }
};
var WP = class extends jP {
  constructor(t6, e2, i2, n2, r2, s2) {
    super(YC), t6 instanceof xP ? (this.x1 = t6.x, this.y1 = t6.y, this.z1 = t6.z, this.x2 = n2.x, this.y2 = n2.y, this.z2 = n2.z) : (this.x1 = t6, this.y1 = e2, this.z1 = i2, this.x2 = n2, this.y2 = r2, this.z2 = s2), this.supportsCrossing = false;
  }
  isLineZone() {
    return true;
  }
  getPosition() {
    return this.random = Math.random(), this.vector.x = this.x1 + this.random * (this.x2 - this.x1), this.vector.y = this.y1 + this.random * (this.y2 - this.y1), this.vector.z = this.z1 + this.random * (this.z2 - this.z1), this.vector;
  }
};
var qP = class extends jP {
  constructor(t6, e2 = 1, i2) {
    if (super(ZC), this.geometry = null, this.scale = e2, this.supportsCrossing = false, t6.type && "Geometry" === t6.type && (this.geometry = t6), t6.geometry && (this.geometry = t6.geometry), !this.geometry) throw new Error("MeshZone unable to set geometry from the supplied bounds");
    this.geometry.isBufferGeometry && (this.geometry = new i2().fromBufferGeometry(this.geometry));
  }
  isMeshZone() {
    return true;
  }
  getPosition() {
    const t6 = this.geometry.vertices, e2 = t6[t6.length * Math.random() | 0];
    return this.vector.x = e2.x * this.scale, this.vector.y = e2.y * this.scale, this.vector.z = e2.z * this.scale, this.vector;
  }
};
var XP = class extends jP {
  constructor(t6, e2, i2) {
    var n2;
    super(JC), iP.isUndefined(t6, e2, i2) ? n2 = 0 : n2 = t6, this.x = n2, this.y = n2, this.z = n2, this.supportsCrossing = false;
  }
  isPointZone() {
    return true;
  }
  getPosition() {
    return this.vector.x = this.x, this.vector.y = this.y, this.vector.z = this.z, this.vector;
  }
};
var YP = class extends jP {
  constructor(t6, e2, i2, n2) {
    super("ScreenZone"), this.camera = t6, this.renderer = e2, this.dis = i2 || 20, n2 = n2 || "1234";
    for (var r2 = 1; r2 < 5; r2++) this["d" + r2] = n2.indexOf(r2 + "") >= 0;
  }
  isScreenZone() {
    return true;
  }
  _dead(t6) {
    var e2 = eP.toScreenPos(t6.position, this.camera, this.renderer.domElement), i2 = this.renderer.domElement;
    (e2.y + t6.radius < -this.dis && this.d1 || e2.y - t6.radius > i2.height + this.dis && this.d3) && (t6.dead = true), (e2.x + t6.radius < -this.dis && this.d4 || e2.x - t6.radius > i2.width + this.dis && this.d2) && (t6.dead = true);
  }
  _bound(t6) {
    var e2 = eP.toScreenPos(t6.position, this.camera, this.renderer.domElement), i2 = this.renderer.domElement;
    (e2.y + t6.radius < -this.dis || e2.y - t6.radius > i2.height + this.dis) && (t6.velocity.y *= -1), (e2.x + t6.radius < -this.dis || e2.x - t6.radius > i2.width + this.dis) && (t6.velocity.y *= -1);
  }
};
var ZP;
var JP;
var KP;
var $P;
var QP;
YP.prototype.getPosition = (JP = new xP(), function() {
  return ZP = this.renderer.domElement, JP.x = Math.random() * ZP.width, JP.y = Math.random() * ZP.height, this.vector.copy(eP.toSpacePos(JP, this.camera, ZP)), this.vector;
}), YP.prototype._cross = (function() {
  var t6 = new xP();
  return function(e2) {
    var i2 = eP.toScreenPos(e2.position, this.camera, this.renderer.domElement), n2 = this.renderer.domElement;
    i2.y + e2.radius < -this.dis ? (t6.x = i2.x, t6.y = n2.height + this.dis + e2.radius, e2.position.y = eP.toSpacePos(t6, this.camera, n2).y) : i2.y - e2.radius > n2.height + this.dis && (t6.x = i2.x, t6.y = -this.dis - e2.radius, e2.position.y = eP.toSpacePos(t6, this.camera, n2).y), i2.x + e2.radius < -this.dis ? (t6.y = i2.y, t6.x = n2.width + this.dis + e2.radius, e2.position.x = eP.toSpacePos(t6, this.camera, n2).x) : i2.x - e2.radius > n2.width + this.dis && (t6.y = i2.y, t6.x = -this.dis - e2.radius, e2.position.x = eP.toSpacePos(t6, this.camera, n2).x);
  };
})();
var tL = class extends jP {
  constructor(t6, e2, i2, n2) {
    let r2, s2, o2, a2;
    super(KC), iP.isUndefined(e2, i2, n2) ? (r2 = s2 = o2 = 0, a2 = t6 || 100) : (r2 = t6, s2 = e2, o2 = i2, a2 = n2), this.x = r2, this.y = r2, this.z = r2, this.radius = a2, this.the = this.phi = 0;
  }
  isSphereZone() {
    return true;
  }
  _dead(t6) {
    t6.position.distanceTo(this) - t6.radius > this.radius && (t6.dead = true);
  }
  _cross() {
    console.warn(`${this.constructor.name} does not support the _cross method`);
  }
};
tL.prototype.getPosition = function() {
  return this.random = Math.random(), QP = this.random * this.radius, KP = tR * Math.random(), $P = 2 * tR * Math.random(), this.vector.x = this.x + QP * Math.sin(KP) * Math.cos($P), this.vector.y = this.y + QP * Math.sin($P) * Math.sin(KP), this.vector.z = this.z + QP * Math.cos(KP), this.vector;
}, tL.prototype._bound = (function() {
  var t6, e2 = new xP(), i2 = new xP();
  return function(n2) {
    n2.position.distanceTo(this) + n2.radius >= this.radius && (e2.copy(n2.position).sub(this).normalize(), i2.copy(n2.velocity), t6 = 2 * i2.dot(e2), n2.velocity.sub(e2.scalar(t6)));
  };
})();
var eL = ["zoneType"];
var iL = class _iL extends RP {
  constructor() {
    super(HC), this.reset.apply(this, arguments);
  }
  reset() {
    this.zones ? this.zones.length = 0 : this.zones = [], this.zones = this.zones.concat(Array.prototype.slice.call(arguments));
  }
  addZone() {
    this.zones = this.zones.concat(Array.prototype.slice.call(arguments));
  }
  static fromJSON(t6) {
    const { zoneType: e2 } = t6, i2 = (function(t7, e3) {
      if (null == t7) return {};
      var i3, n2, r2 = (function(t8, e4) {
        if (null == t8) return {};
        var i4 = {};
        for (var n3 in t8) if ({}.hasOwnProperty.call(t8, n3)) {
          if (-1 !== e4.indexOf(n3)) continue;
          i4[n3] = t8[n3];
        }
        return i4;
      })(t7, e3);
      if (Object.getOwnPropertySymbols) {
        var s2 = Object.getOwnPropertySymbols(t7);
        for (n2 = 0; n2 < s2.length; n2++) i3 = s2[n2], -1 === e3.indexOf(i3) && {}.propertyIsEnumerable.call(t7, i3) && (r2[i3] = t7[i3]);
      }
      return r2;
    })(t6, eL);
    if (!BR.includes(e2)) throw new Error(`The zone type ${e2} is invalid or not yet supported`);
    return new _iL(new a[e2](...Object.values(i2)));
  }
};
iL.prototype.initialize = /* @__PURE__ */ (function() {
  let t6;
  return function(e2) {
    t6 = this.zones[Math.random() * this.zones.length | 0], t6.getPosition(), e2.position.x = t6.vector.x, e2.position.y = t6.vector.y, e2.position.z = t6.vector.z;
  };
})();
var nL = class _nL extends RP {
  constructor(t6, e2, i2 = false, n2 = true) {
    super(VC, n2), this.radius = hP(t6, e2, i2);
  }
  reset(t6, e2, i2 = false) {
    this.radius = hP(t6, e2, i2);
  }
  initialize(t6) {
    t6.radius = this.radius.getValue(), t6.transform.oldRadius = t6.radius;
  }
  static fromJSON(t6) {
    const { width: e2, height: i2, center: n2 = false, isEnabled: r2 = true } = t6;
    return new _nL(e2, i2, n2, r2);
  }
};
var rL = class _rL extends RP {
  constructor(t6 = 1, e2 = 1) {
    super("Rate"), this.numPan = hP(t6), this.timePan = hP(e2), this.startTime = 0, this.nextTime = 0, this.init();
  }
  init() {
    this.startTime = 0, this.nextTime = this.timePan.getValue();
  }
  getValue(t6) {
    return this.startTime += t6, this.startTime >= this.nextTime ? (this.init(), 1 == this.numPan.b ? this.numPan.getValue("Float") > 0.5 ? 1 : 0 : this.numPan.getValue("Int")) : 0;
  }
  static fromJSON(t6) {
    const { particlesMin: e2, particlesMax: i2, perSecondMin: n2, perSecondMax: r2 } = t6;
    return new _rL(new cP(e2, i2), new cP(n2, r2));
  }
};
function sL(t6, e2) {
  var i2 = Object.keys(t6);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(t6);
    e2 && (n2 = n2.filter((function(e3) {
      return Object.getOwnPropertyDescriptor(t6, e3).enumerable;
    }))), i2.push.apply(i2, n2);
  }
  return i2;
}
function oL(t6) {
  for (var e2 = 1; e2 < arguments.length; e2++) {
    var i2 = null != arguments[e2] ? arguments[e2] : {};
    e2 % 2 ? sL(Object(i2), true).forEach((function(e3) {
      HR(t6, e3, i2[e3]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t6, Object.getOwnPropertyDescriptors(i2)) : sL(Object(i2)).forEach((function(e3) {
      Object.defineProperty(t6, e3, Object.getOwnPropertyDescriptor(i2, e3));
    }));
  }
  return t6;
}
var aL = class _aL extends RP {
  constructor(t6, e2, i2 = OP, n2 = true) {
    super(BC, n2);
    const { Sprite: r2, SpriteMaterial: s2 } = t6;
    this.materialProperties = aP(OP, i2), this.texture = e2, this.material = new s2(oL(oL({}, { map: e2 }), this.materialProperties)), this.sprite = new r2(this.material);
  }
  initialize(t6) {
    t6.body = this.sprite;
  }
  static fromJSON(t6, e2) {
    const { loadedTexture: i2, materialProperties: n2 = zP, isEnabled: r2 = true } = t6;
    return new _aL(e2, i2, aP(zP, ((t7) => {
      const { blending: e3 } = t7;
      return oL(oL({}, t7), {}, { blending: e3 ? DP[e3] : DP[zP.blending] });
    })(n2)), r2);
  }
};
var lL = class extends RP {
  constructor(t6, e2 = true) {
    super(t6, e2), this.dirVec = new xP(0, 0, 0);
  }
  normalize(t6) {
    return 100 * t6;
  }
};
lL.prototype.initialize = (function() {
  var t6, e2 = new xP(0, 0, 1), i2 = new xP(0, 0, 0);
  return function(n2) {
    return t6 = this.tha * Math.random(), this._useV && this.dirVec.copy(this.dir).scalar(this.radiusPan.getValue()), lP.getNormal(this.dirVec, e2), i2.copy(this.dirVec).applyAxisAngle(e2, t6), i2.applyAxisAngle(this.dirVec.normalize(), Math.random() * tR * 2), n2.velocity.copy(i2), this;
  };
})();
var cL = class _cL extends lL {
  constructor(t6, e2, i2 = true) {
    super(GC, i2), this.tha = e2 * iR, this.dirVec = t6.toVector3D(), this._useV = false;
  }
  static fromJSON(t6) {
    const { polarRadius: e2, polarTheta: i2, polarPhi: n2, velocityTheta: r2, isEnabled: s2 = true } = t6;
    return new _cL(new bP(e2, i2, n2), r2, s2);
  }
};
var hL = class _hL extends lL {
  constructor(t6, e2, i2, n2 = true) {
    super(WC, n2), this.radiusPan = hP(t6), this.dir = e2.clone().normalize(), this.tha = i2 * iR, this._useV = true;
  }
  static fromJSON(t6) {
    const { radius: e2, x: i2, y: n2, z: r2, theta: s2, isEnabled: o2 = true } = t6;
    return new _hL(e2, new xP(i2, n2, r2), s2, o2);
  }
};
var uL = class _uL extends lL {
  constructor(t6, e2, i2 = true) {
    super(jC, i2), this.radiusPan = hP(1), this.dir = t6.clone(), this.tha = e2 * iR, this._useV = true;
  }
  static fromJSON(t6) {
    const { x: e2, y: i2, z: n2, theta: r2, isEnabled: s2 = true } = t6;
    return new _uL(new xP(e2, i2, n2), r2, s2);
  }
};
var dL = new rL(1, 0.1);
var pL = i(8023);
var fL = i.n(pL);
var mL = class extends wP {
  constructor(t6) {
    super(t6), this.type = "Emitter", this.particles = [], this.initializers = [], this.behaviours = [], this.emitterBehaviours = [], this.currentEmitTime = 0, this.totalEmitTimes = -1, this.damping = 6e-3, this.bindEmitter = true, this.bindEmitterEvent = false, this.rate = dL, this.isEmitting = false, this.id = `emitter-${rP()}`, this.cID = 0, this.name = "Emitter", this.index = void 0, this.eventDispatcher = new SP();
  }
  dispatch(t6, e2 = this) {
    this.eventDispatcher.dispatchEvent(t6, e2);
  }
  setRate(t6) {
    return this.rate = t6, this;
  }
  setPosition(t6 = {}) {
    const { position: e2 } = this, { x: i2 = e2.x, y: n2 = e2.y, z: r2 = e2.z } = t6;
    return this.position.set(i2, n2, r2), this;
  }
  setRotation(t6 = {}) {
    const { rotation: e2 } = this, { x: i2 = e2.x, y: n2 = e2.y, z: r2 = e2.z } = t6;
    return this.rotation.set(i2, n2, r2), this;
  }
  emit(t6 = 1 / 0, e2 = 1 / 0) {
    return this.currentEmitTime = 0, this.totalEmitTimes = fL()(t6) ? t6 : 1 / 0, this.life = 1 === t6 ? t6 : fL()(e2) ? e2 : 1 / 0, this.rate.init(), this.isEmitting = true, this;
  }
  experimental_emit() {
    const { isEmitting: t6, totalEmitTimes: e2, life: i2 } = this;
    return t6 || (this.currentEmitTime = 0, e2 || this.setTotalEmitTimes(1 / 0), i2 || this.setLife(1 / 0), this.rate.init(), this.isEmitting = true), this;
  }
  setTotalEmitTimes(t6 = 1 / 0) {
    return this.totalEmitTimes = fL()(t6) ? t6 : 1 / 0, this;
  }
  setLife(t6 = 1 / 0) {
    return 1 === this.totalEmitTimes ? this.life = this.totalEmitTimes : this.life = fL()(t6) ? t6 : 1 / 0, this;
  }
  stopEmit() {
    this.totalEmitTimes = -1, this.currentEmitTime = 0, this.isEmitting = false;
  }
  removeAllParticles() {
    let t6 = this.particles.length;
    for (; t6--; ) this.particles[t6].dead = true;
  }
  addInitializer(t6) {
    return this.initializers.push(t6), this;
  }
  addInitializers(t6) {
    let e2 = t6.length;
    for (; e2--; ) this.addInitializer(t6[e2]);
    return this;
  }
  setInitializers(t6) {
    return this.initializers = t6, this;
  }
  removeInitializer(t6) {
    const e2 = this.initializers.indexOf(t6);
    return e2 > -1 && this.initializers.splice(e2, 1), this;
  }
  removeAllInitializers() {
    return iP.destroyArray(this.initializers), this;
  }
  addBehaviour(t6) {
    return this.behaviours.push(t6), this;
  }
  addBehaviours(t6) {
    let e2 = t6.length;
    for (; e2--; ) this.addBehaviour(t6[e2]);
    return this;
  }
  setBehaviours(t6) {
    return this.behaviours = t6, this;
  }
  removeBehaviour(t6) {
    const e2 = this.behaviours.indexOf(t6);
    return e2 > -1 && this.behaviours.splice(e2, 1), this;
  }
  removeAllBehaviours() {
    return iP.destroyArray(this.behaviours), this;
  }
  addEmitterBehaviour(t6) {
    return this.emitterBehaviours.push(t6), t6.initialize(this), this;
  }
  addEmitterBehaviours(t6) {
    let e2 = t6.length;
    for (; e2--; ) this.addEmitterBehaviour(t6[e2]);
    return this;
  }
  setEmitterBehaviours(t6) {
    const e2 = t6.length;
    this.emitterBehaviours = t6;
    for (let t7 = 0; t7 < e2; t7++) this.emitterBehaviours[t7].initialize(this);
    return this;
  }
  removeEmitterBehaviour(t6) {
    const e2 = this.emitterBehaviours.indexOf(t6);
    return e2 > -1 && this.emitterBehaviours.splice(e2, 1), this;
  }
  removeAllEmitterBehaviours() {
    return iP.destroyArray(this.emitterBehaviours), this;
  }
  addOnEmitterDeadEventListener(t6) {
    return this.eventDispatcher.addEventListener(`${this.id}_${CP}`, (() => t6())), this;
  }
  createParticle() {
    const t6 = this.parent.pool.get(wP), e2 = this.particles.length;
    return this.setupParticle(t6, e2), this.parent && this.parent.dispatch(TP, t6), this.bindEmitterEvent && this.dispatch(TP, t6), t6;
  }
  setupParticle(t6, e2) {
    const { initializers: i2, behaviours: n2 } = this;
    UP.initialize(this, t6, i2), t6.addBehaviours(n2), t6.parent = this, t6.index = e2, this.particles.push(t6);
  }
  update(t6) {
    if (!this.isEmitting) return;
    this.age += t6, (this.dead || this.age >= this.life) && this.destroy(), this.generate(t6), this.integrate(t6);
    let e2 = this.particles.length;
    for (; e2--; ) {
      const t7 = this.particles[e2];
      t7.dead && (this.parent && this.parent.dispatch(AP, t7), this.bindEmitterEvent && this.dispatch(AP, t7), this.parent.pool.expire(t7.reset()), this.particles.splice(e2, 1));
    }
    this.updateEmitterBehaviours(t6);
  }
  updateEmitterBehaviours(t6) {
    if (this.sleep) return;
    const e2 = this.emitterBehaviours.length;
    for (let i2 = 0; i2 < e2; i2++) this.emitterBehaviours[i2].applyBehaviour(this, t6, i2);
  }
  integrate(t6) {
    const e2 = this.parent ? this.parent.integrationType : gP, i2 = 1 - this.damping;
    yP(this, t6, i2, e2);
    let n2 = this.particles.length;
    for (; n2--; ) {
      const r2 = this.particles[n2];
      r2.update(t6, n2), yP(r2, t6, i2, e2), this.parent && this.parent.dispatch(EP, r2), this.bindEmitterEvent && this.dispatch(EP, r2);
    }
  }
  generate(t6) {
    if (1 !== this.totalEmitTimes) {
      if (this.currentEmitTime += t6, this.currentEmitTime < this.totalEmitTimes) {
        let e2 = this.rate.getValue(t6);
        for (e2 > 0 && (this.cID = e2); e2--; ) this.createParticle();
      }
    } else {
      let t7 = this.rate.getValue(99999);
      for (t7 > 0 && (this.cID = t7); t7--; ) this.createParticle();
      this.totalEmitTimes = 0;
    }
  }
  destroy() {
    this.dead = true, this.energy = 0, this.totalEmitTimes = -1, 0 == this.particles.length && (this.isEmitting = false, this.removeAllInitializers(), this.removeAllBehaviours(), this.dispatch(`${this.id}_${CP}`), this.parent && this.parent.removeEmitter(this));
  }
};
var gL = 1 / 0;
var vL = oR;
var yL = class {
  constructor(t6 = 1 / 0, e2 = vL, i2 = "Behaviour", n2 = true) {
    this.type = i2, this.isEnabled = n2, this.id = `behaviour-${rP()}`, this.life = t6, this.easing = e2, this.age = 0, this.energy = 1, this.dead = false;
  }
  reset(t6 = Infinity, e2 = vL) {
    this.life = t6, this.easing = e2 || vL;
  }
  set life(t6) {
    this._life = fL()(t6) ? t6 : gL;
  }
  get life() {
    return this._life;
  }
  normalizeForce(t6) {
    return t6.scalar(100);
  }
  normalizeValue(t6) {
    return 100 * t6;
  }
  initialize(t6) {
  }
  applyBehaviour(t6, e2, i2) {
    this.isEnabled && this.mutate(t6, e2, i2);
  }
  mutate(t6, e2, i2) {
  }
  energize(t6, e2) {
    if (this.dead) return;
    if (this.age += e2, this.age >= this.life) return this.energy = 0, void (this.dead = true);
    const i2 = this.easing(t6.age / t6.life);
    this.energy = Math.max(1 - i2, 0);
  }
  destroy() {
  }
  fromJSON(t6) {
  }
};
var xL = class _xL extends yL {
  constructor(t6 = 1, e2 = null, i2, n2, r2 = true) {
    super(i2, n2, TC, r2), this.alphaA = t6, this.alphaB = e2, this.reset(t6, e2);
  }
  get same() {
    return this._same;
  }
  set same(t6) {
    this._same = t6;
  }
  reset(t6 = 1, e2 = null, i2, n2) {
    this.same = null == e2, this.alphaA = hP(t6), this.alphaB = hP(e2), i2 && super.reset(i2, n2);
  }
  initialize(t6) {
    t6.useAlpha = true, t6.transform.alphaA = this.alphaA.getValue(), t6.transform.alphaB = this.same ? t6.transform.alphaA : this.alphaB.getValue();
  }
  mutate(t6, e2, i2) {
    this.energize(t6, e2, i2), t6.alpha = lP.lerp(t6.transform.alphaA, t6.transform.alphaB, this.energy), t6.alpha < 2e-3 && (t6.alpha = 0);
  }
  static fromJSON(t6) {
    const { alphaA: e2, alphaB: i2, life: n2, easing: r2, isEnabled: s2 = true } = t6;
    return new _xL(e2, i2, n2, CR(r2), s2);
  }
};
var bL = class _bL extends yL {
  constructor(t6 = new xP(), e2 = 100, i2 = 1e3, n2 = Infinity, r2 = vL, s2 = true) {
    super(n2, r2, EC, s2), this.targetPosition = t6, this.radius = i2, this.force = this.normalizeValue(e2), this.radiusSq = this.radius * this.radius, this.attractionForce = new xP(), this.lengthSq = 0;
  }
  reset(t6 = new xP(), e2 = 100, i2 = 1e3, n2, r2) {
    this.targetPosition = t6, this.radius = i2, this.force = this.normalizeValue(e2), this.radiusSq = this.radius * this.radius, this.attractionForce = new xP(), this.lengthSq = 0, n2 && super.reset(n2, r2);
  }
  mutate(t6, e2, i2) {
    this.energize(t6, e2, i2), this.attractionForce.copy(this.targetPosition), this.attractionForce.sub(t6.position), this.lengthSq = this.attractionForce.lengthSq(), this.lengthSq > 4e-6 && this.lengthSq < this.radiusSq && (this.attractionForce.normalize(), this.attractionForce.scalar(1 - this.lengthSq / this.radiusSq), this.attractionForce.scalar(this.force), t6.acceleration.add(this.attractionForce));
  }
  static fromJSON(t6) {
    const { x: e2, y: i2, z: n2, force: r2, radius: s2, life: o2, easing: a2, isEnabled: l2 = true } = t6;
    return new _bL(new xP(e2, i2, n2), r2, s2, o2, CR(a2), l2);
  }
};
var wL = class extends yL {
  constructor(t6, e2, i2, n2, r2, s2 = true) {
    super(n2, r2, "Collision", s2), this.reset(t6, e2, i2);
  }
  reset(t6, e2, i2, n2, r2) {
    this.emitter = t6, this.useMass = e2, this.onCollide = i2, this.particles = [], this.delta = new xP(), n2 && super.reset(n2, r2);
  }
  mutate(t6, e2, i2) {
    const n2 = this.emitter ? this.emitter.particles.slice(i2) : this.particles.slice(i2);
    let r2, s2, o2, a2, l2, c2, h2 = n2.length;
    for (; h2--; ) r2 = n2[h2], r2 != t6 && (this.delta.copy(r2.position).sub(t6.position), s2 = this.delta.lengthSq(), a2 = t6.radius + r2.radius, s2 <= a2 * a2 && (o2 = a2 - Math.sqrt(s2), o2 += 0.5, l2 = this._getAverageMass(t6, r2), c2 = this._getAverageMass(r2, t6), t6.position.add(this.delta.clone().normalize().scalar(o2 * -l2)), r2.position.add(this.delta.normalize().scalar(o2 * c2)), this.onCollide && this.onCollide(t6, r2)));
  }
  _getAverageMass(t6, e2) {
    return this.useMass ? e2.mass / (t6.mass + e2.mass) : 0.5;
  }
  fromJSON(t6) {
  }
};
var _L = class __L extends yL {
  constructor(t6, e2, i2, n2, r2 = true) {
    super(i2, n2, AC, r2), this.reset(t6, e2);
  }
  get same() {
    return this._same;
  }
  set same(t6) {
    this._same = t6;
  }
  reset(t6, e2, i2, n2) {
    this.same = null == e2, this.colorA = mP(t6), this.colorB = mP(e2), i2 && super.reset(i2, n2);
  }
  initialize(t6) {
    t6.transform.colorA = VR(this.colorA.getValue()), t6.useColor = true, t6.transform.colorB = this.same ? t6.transform.colorA : VR(this.colorB.getValue());
  }
  mutate(t6, e2, i2) {
    this.energize(t6, e2, i2), this._same ? (t6.color.r = t6.transform.colorA.r, t6.color.g = t6.transform.colorA.g, t6.color.b = t6.transform.colorA.b) : (t6.color.r = lP.lerp(t6.transform.colorA.r, t6.transform.colorB.r, this.energy), t6.color.g = lP.lerp(t6.transform.colorA.g, t6.transform.colorB.g, this.energy), t6.color.b = lP.lerp(t6.transform.colorA.b, t6.transform.colorB.b, this.energy));
  }
  static fromJSON(t6) {
    const { colorA: e2, colorB: i2, life: n2, easing: r2, isEnabled: s2 = true } = t6;
    return new __L(e2, i2, n2, CR(r2), s2);
  }
};
var SL = class _SL extends yL {
  constructor(t6, e2, i2, n2, r2) {
    super(i2, n2, CC, r2), this.reset(t6, e2);
  }
  reset(t6, e2 = "dead", i2, n2) {
    this.zone = t6, this.zone.crossType = e2, i2 && super.reset(i2, n2);
  }
  mutate(t6, e2, i2) {
    this.energize(t6, e2, i2), this.zone.crossing.call(this.zone, t6);
  }
  static fromJSON(t6) {
    const { zoneType: e2, zoneParams: i2, crossType: n2, life: r2, easing: s2, isEnabled: o2 = true } = t6, l2 = new a[e2](...Object.values(i2));
    return new _SL(l2, n2, r2, CR(s2), o2);
  }
};
var ML = class _ML extends yL {
  constructor(t6, e2, i2, n2, r2, s2 = true) {
    super(n2, r2, RC, s2), this.reset(t6, e2, i2);
  }
  reset(t6, e2, i2) {
    this.force = this.normalizeForce(new xP(t6, e2, i2)), this.force.id = Math.random();
  }
  mutate(t6, e2, i2) {
    this.energize(t6, e2, i2), t6.acceleration.add(this.force);
  }
  static fromJSON(t6) {
    const { fx: e2, fy: i2, fz: n2, life: r2, easing: s2, isEnabled: o2 = true } = t6;
    return new _ML(e2, i2, n2, r2, CR(s2), o2);
  }
};
var TL = class _TL extends ML {
  constructor(t6, e2, i2, n2 = true) {
    super(0, -t6, 0, e2, i2, n2), this.type = PC;
  }
  static fromJSON(t6) {
    const { gravity: e2, life: i2, easing: n2, isEnabled: r2 = true } = t6;
    return new _TL(e2, i2, CR(n2), r2);
  }
};
var EL = class _EL extends yL {
  constructor(t6, e2, i2, n2 = 0.03, r2, s2, o2 = true) {
    super(r2, s2, LC, o2), this.reset(t6, e2, i2, n2), this.time = 0;
  }
  reset(t6, e2, i2, n2 = 0.03, r2, s2) {
    this.randomForce = this.normalizeForce(new xP(t6, e2, i2)), this.delayPan = hP(n2), this.time = 0, r2 && super.reset(r2, s2);
  }
  mutate(t6, e2, i2) {
    if (this.energize(t6, e2, i2), this.time += e2, this.time >= this.delayPan.getValue()) {
      const e3 = lP.randomAToB(-this.randomForce.x, this.randomForce.x), i3 = lP.randomAToB(-this.randomForce.y, this.randomForce.y), n2 = lP.randomAToB(-this.randomForce.z, this.randomForce.z);
      t6.acceleration.addValue(e3, i3, n2), this.time = 0;
    }
  }
  static fromJSON(t6) {
    const { x: e2, y: i2, z: n2, delay: r2, life: s2, easing: o2, isEnabled: a2 = true } = t6;
    return new _EL(e2, i2, n2, r2, s2, CR(o2), a2);
  }
};
var AL = class _AL extends bL {
  constructor(t6, e2, i2, n2, r2, s2 = true) {
    super(t6, e2, i2, n2, r2, s2), this.force *= -1, this.type = IC;
  }
  reset(t6, e2, i2, n2, r2) {
    super.reset(t6, e2, i2, n2, r2), this.force *= -1;
  }
  static fromJSON(t6) {
    const { x: e2, y: i2, z: n2, force: r2, radius: s2, life: o2, easing: a2, isEnabled: l2 = true } = t6;
    return new _AL(new xP(e2, i2, n2), r2, s2, o2, CR(a2), l2);
  }
};
var CL = class _CL extends yL {
  constructor(t6, e2, i2, n2, r2, s2 = true) {
    super(n2, r2, DC, s2), this.reset(t6, e2, i2);
  }
  get rotationType() {
    return this._rotationType;
  }
  set rotationType(t6) {
    this._rotationType = t6;
  }
  reset(t6, e2, i2, n2, r2) {
    this.x = t6 || 0, this.y = e2 || 0, this.z = i2 || 0, void 0 === t6 || "same" == t6 ? this.rotationType = "same" : null == e2 ? this.rotationType = "set" : void 0 === i2 ? this.rotationType = "to" : (this.rotationType = "add", this.x = hP(this.x * iR), this.y = hP(this.y * iR), this.z = hP(this.z * iR)), n2 && super.reset(n2, r2);
  }
  initialize(t6) {
    switch (this.rotationType) {
      case "same":
        break;
      case "set":
        this._setRotation(t6.rotation, this.x);
        break;
      case "to":
        t6.transform.fR = t6.transform.fR || new xP(), t6.transform.tR = t6.transform.tR || new xP(), this._setRotation(t6.transform.fR, this.x), this._setRotation(t6.transform.tR, this.y);
        break;
      case "add":
        t6.transform.addR = new xP(this.x.getValue(), this.y.getValue(), this.z.getValue());
    }
  }
  _setRotation(t6, e2) {
    if (t6 = t6 || new xP(), "random" == e2) {
      var i2 = lP.randomAToB(-tR, tR), n2 = lP.randomAToB(-tR, tR), r2 = lP.randomAToB(-tR, tR);
      t6.set(i2, n2, r2);
    } else e2 instanceof xP && t6.copy(e2);
  }
  mutate(t6, e2, i2) {
    switch (this.energize(t6, e2, i2), this.rotationType) {
      case "same":
        t6.rotation || (t6.rotation = new xP()), t6.rotation.eulerFromDir(t6.velocity);
        break;
      case "set":
        break;
      case "to":
        t6.rotation.x = lP.lerp(t6.transform.fR.x, t6.transform.tR.x, this.energy), t6.rotation.y = lP.lerp(t6.transform.fR.y, t6.transform.tR.y, this.energy), t6.rotation.z = lP.lerp(t6.transform.fR.z, t6.transform.tR.z, this.energy);
        break;
      case "add":
        t6.rotation.add(t6.transform.addR);
    }
  }
  static fromJSON(t6) {
    const { x: e2, y: i2, z: n2, life: r2, easing: s2, isEnabled: o2 = true } = t6;
    return new _CL(e2, i2, n2, r2, CR(s2), o2);
  }
};
var RL = class _RL extends yL {
  constructor(t6, e2, i2, n2, r2 = true) {
    super(i2, n2, OC, r2), this.reset(t6, e2);
  }
  get same() {
    return this._same;
  }
  set same(t6) {
    this._same = t6;
  }
  reset(t6, e2, i2, n2) {
    this.same = null == e2, this.scaleA = hP(t6 || 1), this.scaleB = hP(e2), i2 && super.reset(i2, n2);
  }
  initialize(t6) {
    t6.transform.scaleA = this.scaleA.getValue(), t6.transform.oldRadius = t6.radius, t6.transform.scaleB = this.same ? t6.transform.scaleA : this.scaleB.getValue();
  }
  mutate(t6, e2, i2) {
    this.energize(t6, e2, i2), t6.scale = lP.lerp(t6.transform.scaleA, t6.transform.scaleB, this.energy), t6.scale < 5e-4 && (t6.scale = 0), t6.radius = t6.transform.oldRadius * t6.scale;
  }
  static fromJSON(t6) {
    const { scaleA: e2, scaleB: i2, life: n2, easing: r2, isEnabled: s2 = true } = t6;
    return new _RL(e2, i2, n2, CR(r2), s2);
  }
};
var PL = class _PL extends yL {
  constructor(t6, e2, i2, n2, r2, s2, o2, a2 = true) {
    super(s2, o2, zC, a2), this.reset(t6, e2, i2, n2, r2);
  }
  reset(t6, e2, i2, n2, r2) {
    this.pos ? this.pos.set(t6, e2, i2) : this.pos = new xP(t6, e2, i2), this.spring = n2 || 0.1, this.friction = r2 || 0.98;
  }
  mutate(t6, e2, i2) {
    this.energize(t6, e2, i2), t6.velocity.x += (this.pos.x - t6.position.x) * this.spring, t6.velocity.y += (this.pos.y - t6.position.y) * this.spring, t6.velocity.z += (this.pos.z - t6.position.z) * this.spring;
  }
  static fromJSON(t6) {
    const { x: e2, y: i2, z: n2, spring: r2, friction: s2, life: o2, easing: a2, isEnabled: l2 = true } = t6;
    return new _PL(e2, i2, n2, r2, s2, o2, CR(a2), l2);
  }
};
var LL = (t6) => {
  const e2 = [];
  return t6.forEach(((t7) => {
    const { type: i2, properties: n2 } = t7;
    if (!NR.includes(i2)) throw new Error(`The behaviour type ${i2} is invalid or not yet supported`);
    e2.push(c[i2].fromJSON(n2));
  })), e2;
};
var IL = (t6, e2, i2, n2) => {
  const { preParticles: r2 = eR, integrationType: s2 = nR, emitters: o2 = [] } = t6, a2 = new i2(e2, r2, s2);
  return o2.forEach(((t7) => {
    const i3 = new n2(), { rate: r3, rotation: s3, initializers: o3, behaviours: c2, emitterBehaviours: h2 = [], position: u2, totalEmitTimes: d2 = 1 / 0, life: p2 = 1 / 0 } = t7;
    i3.setRate(((t8) => rL.fromJSON(t8))(r3)).setRotation(s3).setInitializers(((t8, e3) => {
      const i4 = [];
      return t8.forEach(((t9) => {
        const { type: n3, properties: r4 } = t9;
        if (!FR.includes(n3)) throw new Error(`The initializer type ${n3} is invalid or not yet supported`);
        qC.includes(n3) ? i4.push(l[n3].fromJSON(r4, e3)) : i4.push(l[n3].fromJSON(r4));
      })), i4;
    })(o3, e2)).setBehaviours(LL(c2)).setEmitterBehaviours(LL(h2)).setPosition(u2).emit(d2, p2), a2.addEmitter(i3);
  })), a2;
};
function DL(t6, e2) {
  var i2 = Object.keys(t6);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(t6);
    e2 && (n2 = n2.filter((function(e3) {
      return Object.getOwnPropertyDescriptor(t6, e3).enumerable;
    }))), i2.push.apply(i2, n2);
  }
  return i2;
}
function OL(t6) {
  for (var e2 = 1; e2 < arguments.length; e2++) {
    var i2 = null != arguments[e2] ? arguments[e2] : {};
    e2 % 2 ? DL(Object(i2), true).forEach((function(e3) {
      HR(t6, e3, i2[e3]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t6, Object.getOwnPropertyDescriptors(i2)) : DL(Object(i2)).forEach((function(e3) {
      Object.defineProperty(t6, e3, Object.getOwnPropertyDescriptor(i2, e3));
    }));
  }
  return t6;
}
var zL = { shouldAutoEmit: true };
var FL = (t6) => new Promise(((e2, i2) => {
  if (!t6.length) return e2([]);
  const n2 = t6.length, r2 = [];
  t6.forEach(((t7) => {
    const { type: s2, properties: o2 } = t7;
    return NR.includes(s2) ? (r2.push(c[s2].fromJSON(o2)), r2.length === n2 ? e2(r2) : void 0) : i2(`The behaviour type ${s2} is invalid or not yet supported`);
  }));
}));
var NL = (t6, e2, i2, n2) => new Promise(((r2, s2) => {
  if (!t6.length) return r2([]);
  const o2 = [], a2 = t6.length;
  if (!a2) return r2(o2);
  t6.forEach(((t7) => {
    const c2 = new e2(), { rate: h2, rotation: u2, initializers: d2, behaviours: p2, emitterBehaviours: f2 = [], position: m2, totalEmitTimes: g2 = 1 / 0, life: v2 = 1 / 0 } = t7;
    var y2;
    c2.setRate((y2 = h2, rL.fromJSON(y2))).setRotation(u2).setPosition(m2), ((t8, e3) => new Promise(((i3, n3) => {
      if (!t8.length) return i3([]);
      const r3 = t8.length, s3 = [], o3 = t8.filter((({ properties: t9 }) => !t9.texture)), a3 = t8.filter((({ properties: t9 }) => t9.texture));
      o3.forEach(((t9) => {
        const { type: o4, properties: a4 } = t9;
        return FR.includes(o4) ? (qC.includes(o4) ? s3.push(l[o4].fromJSON(a4, e3)) : s3.push(l[o4].fromJSON(a4)), s3.length === r3 ? i3(s3) : void 0) : n3(`The initializer type ${o4} is invalid or not yet supported`);
      })), a3.forEach(((t9) => {
        const { type: o4, properties: a4, properties: { texture: l2 } } = t9, c3 = new e3.TextureLoader();
        if (!FR.includes(o4)) return n3(`The initializer type ${o4} is invalid or not yet supported`);
        c3.load(l2, ((t10) => {
          if (s3.push(aL.fromJSON(OL(OL({}, a4), {}, { loadedTexture: t10 }), e3)), s3.length === r3) return i3(s3);
        }), void 0, n3);
      }));
    })))(d2, i2).then(((t8) => (c2.setInitializers(t8), FL(p2)))).then(((t8) => (c2.setBehaviours(t8), FL(f2)))).then(((t8) => (c2.setEmitterBehaviours(t8), Promise.resolve(c2)))).then(((t8) => {
      if (o2.push(n2 ? t8.emit(g2, v2) : t8.setTotalEmitTimes(g2).setLife(v2)), o2.length === a2) return r2(o2);
    })).catch(s2);
  }));
}));
var BL = class _BL {
  constructor(t6 = eR, e2 = gP) {
    this.type = "System", this.canUpdate = true, this.preParticles = t6, this.integrationType = e2, this.emitters = [], this.renderers = [], this.pool = new _P(), this.eventDispatcher = new SP();
  }
  static fromJSON(t6, e2) {
    return IL(t6, e2, _BL, mL);
  }
  static fromJSONAsync(t6, e2, i2) {
    return ((t7, e3, i3, n2, r2 = {}) => new Promise(((s2, o2) => {
      const { preParticles: a2 = eR, integrationType: l2 = nR, emitters: c2 = [] } = t7, h2 = new i3(a2, l2), { shouldAutoEmit: u2 } = OL(OL({}, zL), r2);
      NL(c2, n2, e3, u2).then(((t8) => {
        const e4 = t8.length;
        if (!e4) return s2(h2);
        t8.forEach(((t9) => {
          h2.addEmitter(t9), h2.emitters.length === e4 && s2(h2);
        }));
      })).catch(o2);
    })))(t6, e2, _BL, mL, i2);
  }
  dispatch(t6, e2 = this) {
    this.eventDispatcher.dispatchEvent(t6, e2);
  }
  addRenderer(t6) {
    return this.renderers.push(t6), t6.init(this), this;
  }
  removeRenderer(t6) {
    return this.renderers.splice(this.renderers.indexOf(t6), 1), t6.remove(this), this;
  }
  addEmitter(t6) {
    const e2 = this.emitters.length;
    return t6.parent = this, t6.index = e2, this.emitters.push(t6), this.dispatch("EMITTER_ADDED", t6), this;
  }
  removeEmitter(t6) {
    return t6.parent !== this || (t6.parent = null, t6.index = void 0, this.emitters.splice(this.emitters.indexOf(t6), 1), this.dispatch("EMITTER_REMOVED", t6)), this;
  }
  emit({ onStart: t6, onUpdate: e2, onEnd: i2 }) {
    t6 && t6(), e2 && this.eventDispatcher.addEventListener(MP, e2);
    const n2 = this.emitters.map(((t7) => {
      const { life: e3 } = t7;
      return e3 === 1 / 0 ? (i2 && i2(), t7.experimental_emit(), Promise.resolve()) : new Promise(((e4) => {
        t7.addOnEmitterDeadEventListener((() => {
          i2 && i2(), e4();
        })), t7.experimental_emit();
      }));
    }));
    try {
      return Promise.all(n2);
    } catch (t7) {
      console.warn(t7);
    }
  }
  update(t6 = 0.0167) {
    const e2 = t6 || zR;
    if (this.canUpdate) {
      if (e2 > 0) {
        let t7 = this.emitters.length;
        for (; t7--; ) {
          const i2 = this.emitters[t7];
          i2.update(e2), i2.isEmitting && this.dispatch(MP);
        }
      }
      this.dispatch("SYSTEM_UPDATE_AFTER");
    }
    return Promise.resolve();
  }
  getCount() {
    const t6 = this.emitters.length;
    let e2, i2 = 0;
    for (e2 = 0; e2 < t6; e2++) i2 += this.emitters[e2].particles.length;
    return i2;
  }
  destroy() {
    const t6 = this.emitters.length;
    this.canUpdate = false;
    for (let e2 = 0; e2 < t6; e2++) this.emitters[e2] && this.emitters[e2].destroy(), delete this.emitters[e2];
    for (let e2 = 0; e2 < t6; e2++) this.renderers[e2] && this.renderers[e2].destroy && (this.renderers[e2].destroy(), delete this.renderers[e2]);
    this.emitters.length = 0, this.pool.destroy(), this.canUpdate = true;
  }
};
var kL = class {
  constructor(t6 = "BaseRenderer") {
    this.type = t6;
  }
  init(t6) {
    var e2 = this;
    this.system = t6, this.system.eventDispatcher.addEventListener(MP, (function(t7) {
      e2.onSystemUpdate.call(e2, t7);
    })), this.system.eventDispatcher.addEventListener(TP, (function(t7) {
      e2.onParticleCreated.call(e2, t7);
    })), this.system.eventDispatcher.addEventListener(EP, (function(t7) {
      e2.onParticleUpdate.call(e2, t7);
    })), this.system.eventDispatcher.addEventListener(AP, (function(t7) {
      e2.onParticleDead.call(e2, t7);
    })), this.logRendererType();
  }
  remove() {
    this.system = null;
  }
  onParticleCreated(t6) {
  }
  onParticleUpdate(t6) {
  }
  onParticleDead(t6) {
  }
  onSystemUpdate(t6) {
  }
  logRendererType() {
    rR && console.log(`${this.type}`);
  }
};
var UL = class extends kL {
  constructor(t6, e2) {
    super("MeshRenderer"), this.container = t6, this._targetPool = new _P(), this._materialPool = new _P(), this._body = new e2.Mesh(new e2.BoxGeometry(50, 50, 50), new e2.MeshLambertMaterial({ color: "#ff0000" }));
  }
  isThreeSprite(t6) {
    return t6.target.isSprite;
  }
  onSystemUpdate() {
  }
  onParticleCreated(t6) {
    t6.target || (t6.body || (t6.body = this._body), t6.target = this._targetPool.get(t6.body), (t6.useAlpha || t6.useColor) && (t6.target.material.__puid = jR.id(t6.body.material), t6.target.material = this._materialPool.get(t6.target.material))), t6.target && (t6.target.position.copy(t6.position), this.container.add(t6.target));
  }
  onParticleUpdate(t6) {
    const { target: e2, useAlpha: i2, useColor: n2, rotation: r2 } = t6;
    e2 && (e2.position.copy(t6.position), this.isThreeSprite(t6) || e2.rotation.set(r2.x, r2.y, r2.z), this.scale(t6), i2 && (e2.material.opacity = t6.alpha, e2.material.transparent = true), n2 && e2.material.color.copy(t6.color));
  }
  scale(t6) {
    t6.target.scale.set(t6.scale, t6.scale, t6.scale);
  }
  onParticleDead(t6) {
    t6.target && ((t6.useAlpha || t6.useColor) && this._materialPool.expire(t6.target.material), this._targetPool.expire(t6.target), this.container.remove(t6.target), t6.target = null);
  }
};
var HL = class extends UL {
  constructor(t6, e2) {
    super(t6, e2), this.type = $C, this._body = new e2.Sprite(new e2.SpriteMaterial({ color: 16777215 }));
  }
  scale(t6) {
    t6.target.scale.set(t6.scale * t6.radius, t6.scale * t6.radius, 1);
  }
};
[12, 4, 16].reduce(((t6, e2) => t6 + e2));
var VL = 3;
var jL = 1;
var GL = 4;
var WL = 1;
var qL = 2;
[VL, jL, GL, WL, qL].reduce(((t6, e2) => t6 + e2));
var XL = BL;
function YL() {
  return "visible" === document.visibilityState;
}
var ZL = i(7833);
var JL = i.n(ZL);
var KL = "dddice";
function $L(t6, e2) {
  return JL()(`${KL}:${t6}:${e2}`);
}
function QL(t6) {
  return { debug: $L(t6, "debug"), error: $L(t6, "error"), info: $L(t6, "info"), warn: $L(t6, "warn") };
}
var tI = QL("physics");
var eI = class _eI {
  constructor(t6) {
    this.physics = new JA(), this.walls = [], this.add = (t7) => this.physics.addBody(t7), this.init = (t7, e3) => {
      const i2 = new QS();
      i2.setFromAxisAngle(new GS(1, 0, 0), -Math.PI);
      const n2 = this.createWall(i2, new GS(0, 0, e3 / 2));
      i2.setFromAxisAngle(new GS(1, 0, 0), 0);
      const r2 = this.createWall(i2, new GS(0, 0, -e3 / 2));
      i2.setFromAxisAngle(new GS(0, 1, 0), Math.PI / 2);
      const s2 = this.createWall(i2, new GS(-t7 / 2, 0, 0));
      i2.setFromAxisAngle(new GS(0, 1, 0), -Math.PI / 2);
      const o2 = this.createWall(i2, new GS(t7 / 2, 0, 0));
      this.walls.push(r2, o2, n2, s2);
    }, this.setConfig = (t7) => {
      this.config = t7, this.physics.gravity.set(20 * this.config.gravity.x, 20 * this.config.gravity.y, 20 * this.config.gravity.z);
    }, this.remove = (t7) => this.physics.removeBody(t7), this.resize = (t7, e3) => {
      const [i2, n2, r2, s2] = this.walls, o2 = new QS();
      o2.setFromAxisAngle(new GS(1, 0, 0), -Math.PI), r2.quaternion.copy(o2), r2.position.copy(new GS(0, 0, e3 / 2)), o2.setFromAxisAngle(new GS(1, 0, 0), 0), i2.quaternion.copy(o2), i2.position.copy(new GS(0, 0, -e3 / 2)), o2.setFromAxisAngle(new GS(0, 1, 0), Math.PI / 2), s2.quaternion.copy(o2), s2.position.copy(new GS(-t7 / 2, 0, 0)), o2.setFromAxisAngle(new GS(0, 1, 0), -Math.PI / 2), n2.quaternion.copy(o2), n2.position.copy(new GS(t7 / 2, 0, 0));
    }, this.attachKeyframeApplier = (t7) => new Promise(((e3) => {
      const i2 = this.physics.stepnumber + 1, n2 = () => {
        let r2 = false;
        if ((this.physics.stepnumber - i2) % _eI.KEYFRAME_INTERVAL == 0) {
          const s2 = (this.physics.stepnumber - i2) / _eI.KEYFRAME_INTERVAL;
          0 !== t7.length && s2 !== t7[0].keyframes.length - 1 || (r2 = true);
          for (let e4 = 0; e4 < t7.length; e4++) {
            const i3 = t7[e4], n3 = i3.keyframes[s2];
            i3.dice.loadState(n3), n3.isCollision && i3.dice.onCollide();
          }
          r2 && (this.physics.removeEventListener("postStep", n2), e3());
        }
      };
      this.physics.addEventListener("postStep", n2);
    })), this.runOffscreenSimulation = (t7) => new Promise(((e3) => {
      const i2 = [];
      for (let e4 = 0; e4 < t7.length; e4++) t7[e4].dice.simulationRunning = true, t7[e4].dice.saveState(), i2[e4] = () => {
        const i3 = t7[e4].keyframes.at(-1);
        i3 && (i3.isCollision = true);
      }, t7[e4].dice.getPhysicsBody().addEventListener("collide", i2[e4]);
      const n2 = this.physics.stepnumber + 1, r2 = performance.now(), s2 = () => {
        const e4 = (this.physics.stepnumber - n2) % _eI.KEYFRAME_INTERVAL == 0;
        let r3 = true;
        for (let i3 = 0; i3 < t7.length; i3++) t7[i3].dice.isFinished() ? t7[i3].stableCount++ : t7[i3].stableCount = 0, t7[i3].stableCount < 10 && (r3 = false), e4 && (YL() ? t7[i3].keyframes.push(t7[i3].dice.getState()) : t7[i3].keyframes[0] = t7[i3].dice.getState());
        if (r3) {
          for (let e5 = 0; e5 < t7.length; e5++) t7[e5].dice.shiftUpsideValue(t7[e5].value), t7[e5].dice.loadState(), t7[e5].dice.simulationRunning = false, t7[e5].dice.getPhysicsBody().removeEventListener("collide", i2[e5]);
          return true;
        }
        return false;
      };
      tI.debug("simulation start "), this.physics.allowSleep = false;
      let o2 = 0;
      for (; !s2() && ++o2 < 500; ) this.physics.step(_eI.PHYSICS_STEP);
      tI.debug("simulation took (s): ", (performance.now() - r2) / 1e3), tI.debug("simulation took physics steps: ", this.physics.stepnumber - n2), this.physics.allowSleep = true, e3();
    })), this.update = (t7 = 0) => {
      this.physics.bodies.forEach(((t8) => {
        if (void 0 !== t8.targetPosition && void 0 !== t8.startPosition) {
          void 0 === t8.startTime && (t8.startTime = this.physics.time);
          const e3 = (this.physics.time - t8.startTime) / _eI.TWEEN_TIME, i2 = new GS(), n2 = new GS();
          t8.targetPosition.vsub(t8.startPosition, n2);
          const r2 = n2.length();
          n2.normalize();
          const s2 = r2 / _eI.TWEEN_TIME;
          n2.scale(s2, t8.velocity), e3 < 1 ? (n2.scale(e3 * r2, i2), t8.startPosition.vadd(i2, t8.position)) : (t8.position.copy(t8.targetPosition), t8.velocity.setZero(), t8.targetPosition = void 0, t8.startPosition = void 0, t8.startTime = void 0);
        }
      })), this.physics.step(_eI.PHYSICS_STEP, t7);
    }, this.createWall = (t7, e3) => {
      const i2 = new xM({ mass: 0, shape: new ZT(), material: _eI.FLOOR_MATERIAL });
      return i2.quaternion.copy(t7), i2.position.copy(e3), this.physics.addBody(i2), i2;
    }, this.physics.allowSleep = true, this.physics.addContactMaterial(new XT(_eI.FLOOR_MATERIAL, _eI.DICE_MATERIAL, { friction: 0.01, restitution: 0.5 })), this.physics.addContactMaterial(new XT(_eI.BARRIER_MATERIAL, _eI.DICE_MATERIAL, { friction: 0, restitution: 1 })), this.physics.addContactMaterial(new XT(_eI.DICE_MATERIAL, _eI.DICE_MATERIAL, { friction: 0.3, restitution: 0.5 }));
    const e2 = new xM({ mass: 0, shape: new ZT(), material: _eI.FLOOR_MATERIAL });
    e2.quaternion.setFromAxisAngle(new GS(1, 0, 0), -Math.PI / 2), this.physics.addBody(e2), this.physics.broadphase = new BM(), this.setConfig(t6);
  }
};
eI.BARRIER_MATERIAL = new YT("barrier_material"), eI.DICE_MATERIAL = new YT("dice_material"), eI.FLOOR_MATERIAL = new YT("floor_material"), eI.KEYFRAME_INTERVAL = 1, eI.PHYSICS_ITERATIONS = 16, eI.PHYSICS_STEP = 1 / 60, eI.TWEEN_TIME = 0.2;
var iI = eI;
var nI = ((t6) => {
  const e2 = Object.assign({}, t6);
  return e2.defines = { ENABLE_DITHER_TRANSPARENCY: 1 }, e2.fragmentShader = `uniform float opacity;

		 	// adapted from https://www.shadertoy.com/view/Mlt3z8
			float bayerDither2x2( vec2 v ) {
				return mod( 3.0 * v.y + 2.0 * v.x, 4.0 );
			}

			float bayerDither4x4( vec2 v ) {
				vec2 P1 = mod( v, 2.0 );
				vec2 P2 = mod( floor( 0.5  * v ), 2.0 );
				return 4.0 * bayerDither2x2( P1 ) + bayerDither2x2( P2 );
			}

float rand2(vec2 c){
	return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

float noise(vec2 p, float freq ){
	float unit = 128./freq;
	vec2 ij = floor(p/unit);
	vec2 xy = mod(p,unit)/unit;
	//xy = 3.*xy*xy-2.*xy*xy*xy;
	xy = .5*(1.-cos(3.1415*xy));
	float a = rand2((ij+vec2(0.,0.)));
	float b = rand2((ij+vec2(1.,0.)));
	float c = rand2((ij+vec2(0.,1.)));
	float d = rand2((ij+vec2(1.,1.)));
	float x1 = mix(a, b, xy.x);
	float x2 = mix(c, d, xy.x);
	return mix(x1, x2, xy.y);
}

float pNoise(vec2 p, int res){
	float persistance = .5;
	float n = 0.;
	float normK = 0.;
	float f = 20.;
	float amp = 1.;
	int iCount = 0;
	for (int i = 0; i<50; i++){
		n+=amp*noise(p, f);
		f*=2.;
		normK+=amp;
		amp*=persistance;
		if (iCount == res) break;
		iCount++;
	}
	float nf = n/normK;
	return nf*nf*nf*nf;
}

${e2.fragmentShader}
	`.replace(/main\(\) {/, ((t7) => `
			${t7}
			#if ENABLE_DITHER_TRANSPARENCY
			if( clamp(pNoise( gl_FragCoord.xy, 1), 0.0, 1.0 ) > opacity ) discard;

			#endif
		`)), e2;
})(kc.depth);
var rI = class {
  constructor(t6, e2, i2 = false) {
    var n2, r2;
    this.invertUpside = false, this.faceNormals = [], this.scaleFactor = 1, this.mass = 1, this.inertia = 1, this.particlesRotate = false, this.values = 0, this.simulationRunning = false, this.addSound = (t7, e3 = Ei.DieCollide) => {
      t7.name = e3, t7.setRefDistance(10 * this.size), this.getObject().add(t7);
    }, this.finish = () => {
      this.physicsBody.removeEventListener("collide", this.onCollide), this.playSound(Ei.DieRollHigh, false), this.playSound(Ei.DieRollLow, false), this.playSound(Ei.DieValue, false), this.lock();
    }, this.lock = () => {
      this.physicsBody.sleep(), this.physicsBody.angularDamping = 1, this.physicsBody.velocity.set(0, 0, 0), this.physicsBody.inertia.set(0, 0, 0), this.physicsBody.sleepSpeedLimit = 1;
    }, this.unlock = () => {
      this.physicsBody.velocity.set(0, 0, 0), this.physicsBody.inertia.set(0, 0, 0), this.physicsBody.wakeUp();
    }, this.onCollide = () => {
      this.playSound(Ei.DieCollide);
    }, this.playSound = (t7, e3 = true, i3 = false, n3 = 1) => {
      const r3 = this.getObject().getObjectByName(t7);
      r3 && (r3.isPlaying && r3.stop(), e3 && this.isFinished() || r3.setLoop(i3).setVolume(n3).play());
    }, this.fadeOutSound = (t7, e3) => {
      const i3 = this.getObject().getObjectByName(t7);
      if (i3 && i3.isPlaying) {
        const t8 = i3.getVolume() - e3;
        t8 < 1e-3 ? i3.stop() : i3.setVolume(t8);
      }
    }, this.setSoundVolume = (t7, e3) => {
      const i3 = this.getObject().getObjectByName(t7);
      i3 && i3.isPlaying && i3.setVolume(e3);
    }, this.stopSound = (t7) => {
      const e3 = this.getObject().getObjectByName(t7);
      e3 && e3.stop();
    }, this.hasSound = (t7) => !!this.getObject().getObjectByName(t7), this.moveStart = (t7 = false) => {
      var e3;
      if (this.setUpsideValue(this.valueShiftedTo), this.lock(), t7) {
        this.object.material.opacity = (null === (e3 = this.getUniformValue("opacity")) || void 0 === e3 ? void 0 : e3.value) || 1, this.updateShader({ opacity: 0.45 });
      }
    }, this.moveEnd = () => {
      const t7 = this.object.material;
      this.updateShader({ opacity: t7.opacity || 1 }), t7.opacity = 1, this.physicsBody.startPosition = void 0, this.physicsBody.targetPosition = void 0, this.physicsBody.startTime = void 0, this.unlock();
      const e3 = setInterval((() => {
        this.isFinished() && (this.lock(), clearInterval(e3));
      }), 250);
    }, this.move = (t7, e3, i3) => {
      this.object.material.transparent = true, this.updateShader({ opacity: 0.45 }), this.physicsBody.position.set(t7, e3, i3);
    }, this.moveTo = (t7, e3, i3) => {
      void 0 === this.physicsBody.startPosition && (this.physicsBody.startPosition = new GS()), this.physicsBody.startPosition.copy(this.physicsBody.position), this.physicsBody.targetPosition = new GS(t7, e3, i3), this.physicsBody.startTime = void 0;
    }, this.wireframeFromCollisionMesh = () => {
      const t7 = this.size * this.scaleFactor, e3 = [];
      for (let i4 = 0; i4 < this.vertices.length; i4++) {
        const n3 = this.vertices[i4];
        e3.push(new pa(n3[0], n3[1], n3[2]).normalize().multiplyScalar(t7));
      }
      const i3 = new MC(e3);
      return new fc(i3, new Rl({ color: 16711680, wireframe: true }));
    }, this.randomSeed = pC()(t6.uuid)(), this.options = t6, this.drawDebug = i2, this.uuid = t6.uuid, this.roll = t6.roll, this.dieId = t6.dieId, this.theme = t6.theme, this.isRollHidden = t6.isRollHidden, this.shouldFadeOut = t6.shouldFadeOut, this.shiftRot = new QS(), this.vertices = e2.vertices, this.faces = e2.faces, this.scaleFactor = e2.scaleFactor, this.values = e2.values, this.mass = e2.mass, this.inertia = e2.inertia, this.invertUpside = e2.invertUpside, this.object = this.options.meshTemplate.clone(), this.object.geometry.computeBoundingBox(), this.object.material = this.options.material, this.object.material && this.object.material.uniforms && this.object.material.uniforms.opacity.value < 1 ? (this.object.material.transparent = true, this.object.castShadow = false) : this.object.castShadow = true;
    const o2 = new bc(nI);
    if (o2.defines.DEPTH_PACKING = Hs, o2.uniforms.opacity.value = 1, this.object.customDepthMaterial = o2.clone(), this.object.scale.set(this.size, this.size, this.size), this.object.receiveShadow = true, this.shape = this.createShape(), this.physicsBody = new xM({ mass: this.mass, shape: this.shape, material: iI.DICE_MATERIAL }), this.physicsBodyWireframe = this.wireframeFromCollisionMesh(), this.physicsBody.allowSleep = true, this.physicsBody.sleepSpeedLimit = 3, this.physicsBody.sleepTimeLimit = 0.1, this.physicsBody.linearDamping = 0.1, this.physicsBody.angularDamping = 0.1, (null === (n2 = t6.particles) || void 0 === n2 ? void 0 : n2.length) > 0) {
      this.particlesAnchor = new cd(), this.particlesAnchor.scale.set(this.size, this.size, this.size);
      const e3 = t6.particles.find(((t7) => t7.on === Ai.Always));
      e3 && (this.particlesRotate = e3.rotate_with_die, XL.fromJSONAsync(null !== (r2 = e3.system.particleSystemState) && void 0 !== r2 ? r2 : e3.system, s).then(((t7) => {
        const e4 = new HL(this.particlesAnchor, s);
        this.particles = t7.addRenderer(e4), this.particles.emitters.forEach(((t8) => t8.initializers.filter(((t9) => "Texture" === t9.type)).forEach(((t9) => {
          t9.material.alphaMap = t9.material.map, t9.material.map = void 0;
        }))));
      })));
    }
  }
  get size() {
    return this.options.size > 0 ? this.options.size : 0.5;
  }
  addToScene(t6, e2) {
    null == e2 || e2.add(this.getPhysicsBody()), t6.add(this.getObject()), this.drawDebug && t6.add(this.getPhysicsBodyWireframe()), this.getParticleSystem() && t6.add(this.getParticleSystem());
  }
  removeFromScene(t6, e2) {
    null == e2 || e2.remove(this.getPhysicsBody()), t6.remove(this.getObject()), this.drawDebug && t6.remove(this.getPhysicsBodyWireframe()), this.getParticleSystem() && t6.remove(this.getParticleSystem());
  }
  createShape() {
    const t6 = this.size * this.scaleFactor, e2 = new Array(this.vertices.length);
    for (let t7 = 0; t7 < this.vertices.length; ++t7) e2[t7] = new pa().fromArray(this.vertices[t7]).normalize();
    const i2 = this.faces, n2 = new Array(e2.length), r2 = new Array(i2.length);
    for (let i3 = 0; i3 < e2.length; ++i3) {
      const r3 = e2[i3];
      n2[i3] = new GS(r3.x * t6, r3.y * t6, r3.z * t6);
    }
    for (let t7 = 0; t7 < i2.length; ++t7) r2[t7] = i2[t7].slice(0, i2[t7].length - 1);
    return new sM({ vertices: n2, faces: r2 });
  }
  isFinished() {
    const t6 = this.physicsBody.angularVelocity, e2 = this.physicsBody.velocity;
    return Math.abs(t6.x) < 1 && Math.abs(t6.y) < 1 && Math.abs(t6.z) < 1 && Math.abs(e2.x) < 1 && Math.abs(e2.y) < 1 && Math.abs(e2.z) < 1;
  }
  saveState() {
    this.savedState = this.getState();
  }
  getState() {
    return { position: this.physicsBody.position.clone(), quaternion: this.physicsBody.quaternion.clone(), velocity: this.physicsBody.velocity.clone(), angularVelocity: this.physicsBody.angularVelocity.clone(), invInertiaSolve: this.physicsBody.invInertiaSolve.clone(), invMassSolve: this.physicsBody.invMassSolve, vlambda: this.physicsBody.vlambda.clone(), wlambda: this.physicsBody.wlambda.clone(), isCollision: false };
  }
  loadState(t6) {
    const e2 = t6 || this.savedState;
    e2 && (this.physicsBody.position.copy(e2.position), this.physicsBody.quaternion.copy(e2.quaternion), this.physicsBody.velocity.copy(e2.velocity), this.physicsBody.angularVelocity.copy(e2.angularVelocity), this.physicsBody.invInertiaSolve.copy(e2.invInertiaSolve), this.physicsBody.invMassSolve = e2.invMassSolve, this.physicsBody.vlambda.copy(e2.vlambda), this.physicsBody.wlambda.copy(e2.wlambda));
  }
  getFaceVector(t6) {
    const e2 = new GS();
    return this.shape.vertices[this.shape.faces[t6][0]].vsub(this.shape.vertices[this.shape.faces[t6][1]], e2), e2.normalize(), e2;
  }
  getFaceNormal(t6) {
    let e2 = new GS();
    return this.shape.getFaceNormal(t6, e2), this.invertUpside || (e2 = e2.negate()), e2.normalize(), e2;
  }
  getShiftedUpsideValue() {
    let t6 = 0, e2 = 0;
    for (let i2 = 0; i2 < this.values; ++i2) {
      let n2 = this.getFaceNormal(i2);
      n2 = this.physicsBody.quaternion.mult(this.shiftRot).vmult(n2), n2.normalize(), t6 < n2.y && (t6 = n2.y, e2 = i2);
    }
    return e2 + 1;
  }
  getUpsideValue() {
    let t6 = 0, e2 = 0;
    for (let i2 = 0; i2 < this.values; ++i2) {
      let n2 = this.getFaceNormal(i2);
      n2 = this.physicsBody.quaternion.vmult(n2), n2.normalize(), t6 < n2.y && (t6 = n2.y, e2 = i2);
    }
    return e2 + 1;
  }
  setUpsideValue(t6) {
    if (void 0 === t6 || t6 > this.values) return;
    const e2 = this.invertUpside ? new GS(0, 1, 0) : new GS(0, -1, 0), i2 = this.getFaceNormal(0), n2 = new QS();
    n2.setFromVectors(e2, i2), this.physicsBody.quaternion = n2, this.shiftUpsideValue(t6);
  }
  shiftUpsideValue(t6) {
    if (t6 > this.values) return;
    this.valueShiftedTo = t6;
    let e2 = this.physicsBody.quaternion;
    const i2 = e2.clone(), n2 = this.getUpsideValue();
    let r2 = this.getFaceVector(n2 - 1);
    r2 = e2.vmult(r2);
    const s2 = this.getFaceNormal(n2 - 1), o2 = this.getFaceNormal(t6 - 1), a2 = new QS();
    a2.setFromVectors(o2, s2), e2 = e2.mult(a2), e2.normalize();
    let l2 = this.getFaceVector(t6 - 1);
    l2 = e2.vmult(l2);
    let c2 = r2.dot(l2);
    c2 = Math.max(Math.min(c2, 1), -1);
    let h2 = Math.acos(c2);
    r2.cross(l2).dot(e2.vmult(o2)) > 0 && (h2 = -h2), a2.setFromAxisAngle(o2, h2), e2 = e2.mult(a2), e2.normalize(), this.shiftRot = new QS(), this.shiftRot = i2.inverse(), this.shiftRot = this.shiftRot.mult(e2), this.updateMeshFromBody();
  }
  getObject() {
    return this.object;
  }
  getParticleSystem() {
    return this.particlesAnchor;
  }
  getPhysicsBody() {
    return this.physicsBody;
  }
  getPhysicsBodyWireframe() {
    return this.physicsBodyWireframe;
  }
  updateShader(t6 = {}) {
    const e2 = this.object.material;
    for (const i2 in t6) e2.uniforms && i2 in e2.uniforms && (e2.uniforms[i2].value = t6[i2]);
  }
  getUniformValue(t6) {
    const e2 = this.object.material;
    return e2.uniforms ? e2.uniforms[t6] : void 0;
  }
  updateMeshFromBody() {
    const t6 = this.physicsBody.position, e2 = this.physicsBody.quaternion.mult(this.shiftRot);
    this.object.position.set(t6.x, t6.y, t6.z), this.object.quaternion.set(e2.x, e2.y, e2.z, e2.w), this.drawDebug && (this.physicsBodyWireframe.position.set(t6.x, t6.y, t6.z), this.physicsBodyWireframe.quaternion.set(e2.x, e2.y, e2.z, e2.w)), this.particles && (this.particlesAnchor.position.set(t6.x, t6.y, t6.z), this.particlesRotate && this.particlesAnchor.quaternion.set(e2.x, e2.y, e2.z, e2.w), this.particles.update());
  }
  updateBodyFromMesh() {
    const t6 = this.object.position;
    let e2 = new QS(this.object.quaternion.x, this.object.quaternion.y, this.object.quaternion.z, this.object.quaternion.w);
    e2 = e2.mult(this.shiftRot.inverse()), this.physicsBody.position.set(t6.x, t6.y, t6.z), this.physicsBody.quaternion.copy(e2), this.drawDebug && (this.physicsBodyWireframe.position.set(t6.x, t6.y, t6.z), this.physicsBodyWireframe.quaternion.copy(this.object.quaternion)), this.particles && (this.particlesAnchor.position.set(t6.x, t6.y, t6.z), this.particlesRotate && this.particlesAnchor.quaternion.set(e2.x, e2.y, e2.z, e2.w), this.particles.update());
  }
};
var sI = class extends rI {
  constructor(t6, e2, i2 = false) {
    const n2 = 10, r2 = [];
    for (let t7 = 0, e3 = 0; t7 < n2; ++t7, e3 += 2 * Math.PI / n2) r2.push([Math.cos(e3), Math.sin(e3), 0.1]);
    for (let t7 = 0, e3 = 0; t7 < n2; ++t7, e3 += 2 * Math.PI / n2) r2.push([Math.cos(e3), Math.sin(e3), -0.1]);
    const s2 = [];
    s2.push([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0]), s2.push([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 1]);
    for (let t7 = 0; t7 < n2; ++t7) s2.push([n2 + t7, n2 + (t7 + 1) % n2, (t7 + 1) % n2, t7, -1]);
    super(e2, { vertices: r2, faces: s2, scaleFactor: 0.9, values: 2, mass: "number" == typeof e2.weight ? e2.weight : 350, inertia: "number" == typeof e2.inertia ? e2.inertia : 9, invertUpside: false }, i2);
  }
  isFinished() {
    const t6 = this.physicsBody.angularVelocity, e2 = this.physicsBody.velocity;
    return Math.abs(t6.x) < 3 && Math.abs(t6.y) < 3 && Math.abs(t6.z) < 3 && Math.abs(e2.x) < 3 && Math.abs(e2.y) < 3 && Math.abs(e2.z) < 3;
  }
};
var oI = class extends rI {
  constructor(t6, e2, i2 = false) {
    super(e2, { vertices: [[1, 1, 1], [-1, -1, 1], [-1, 1, -1], [1, -1, -1]], faces: [[1, 0, 2, 1], [0, 1, 3, 2], [0, 3, 2, 3], [1, 2, 3, 4]], scaleFactor: 1.2, values: 4, mass: "number" == typeof e2.weight ? e2.weight : 300, inertia: "number" == typeof e2.inertia ? e2.inertia : 5, invertUpside: true }, i2);
  }
};
var aI = class extends rI {
  constructor(t6, e2, i2 = false) {
    super(e2, { vertices: [[-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1], [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]], faces: [[0, 3, 2, 1, 1], [1, 2, 6, 5, 2], [0, 1, 5, 4, 3], [3, 7, 6, 2, 4], [0, 4, 7, 3, 5], [4, 5, 6, 7, 6]], scaleFactor: 0.9, values: 6, mass: "number" == typeof e2.weight ? e2.weight : 300, inertia: "number" == typeof e2.inertia ? e2.inertia : 13, invertUpside: false }, i2);
  }
};
var lI = class extends rI {
  constructor(t6, e2, i2 = false) {
    super(e2, { vertices: [[1, 0, 0], [-1, 0, 0], [0, 1, 0], [0, -1, 0], [0, 0, 1], [0, 0, -1]], faces: [[0, 2, 4, 1], [0, 4, 3, 2], [0, 3, 5, 3], [0, 5, 2, 4], [1, 3, 4, 5], [1, 4, 2, 6], [1, 2, 5, 7], [1, 5, 3, 8]], scaleFactor: 1, values: 8, mass: "number" == typeof e2.weight ? e2.weight : 340, inertia: "number" == typeof e2.inertia ? e2.inertia : 10, invertUpside: false }, i2);
  }
};
var cI = class extends rI {
  constructor(t6, e2, i2 = false) {
    const n2 = [];
    for (let t7 = 0, e3 = 0; t7 < 10; ++t7, e3 += 2 * Math.PI / 10) n2.push([Math.cos(e3), Math.sin(e3), 0.105 * (t7 % 2 ? 1 : -1)]);
    n2.push([0, 0, -1]), n2.push([0, 0, 1]);
    super(e2, { vertices: n2, faces: [[5, 7, 11, 0], [4, 2, 10, 1], [1, 3, 11, 2], [0, 8, 10, 3], [7, 9, 11, 4], [8, 6, 10, 5], [9, 1, 11, 6], [2, 0, 10, 7], [3, 5, 11, 8], [6, 4, 10, 9], [1, 0, 2, -1], [1, 2, 3, -1], [3, 2, 4, -1], [3, 4, 5, -1], [5, 4, 6, -1], [5, 6, 7, -1], [7, 6, 8, -1], [7, 8, 9, -1], [9, 8, 0, -1], [9, 0, 1, -1]], scaleFactor: 0.9, values: 10, mass: "number" == typeof e2.weight ? e2.weight : 350, inertia: "number" == typeof e2.inertia ? e2.inertia : 9, invertUpside: false }, i2);
  }
};
var hI = class extends rI {
  constructor(t6, e2, i2 = false) {
    const n2 = (1 + Math.sqrt(5)) / 2, r2 = 1 / n2;
    super(e2, { vertices: [[0, r2, n2], [0, r2, -n2], [0, -r2, n2], [0, -r2, -n2], [n2, 0, r2], [n2, 0, -r2], [-n2, 0, r2], [-n2, 0, -r2], [r2, n2, 0], [r2, -n2, 0], [-r2, n2, 0], [-r2, -n2, 0], [1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1], [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1]], faces: [[2, 14, 4, 12, 0, 1], [15, 9, 11, 19, 3, 2], [16, 10, 17, 7, 6, 3], [6, 7, 19, 11, 18, 4], [6, 18, 2, 0, 16, 5], [18, 11, 9, 14, 2, 6], [1, 17, 10, 8, 13, 7], [1, 13, 5, 15, 3, 8], [13, 8, 12, 4, 5, 9], [5, 4, 14, 9, 15, 10], [0, 12, 8, 10, 16, 11], [3, 19, 7, 17, 1, 12]], scaleFactor: 0.9, values: 12, mass: "number" == typeof e2.weight ? e2.weight : 350, inertia: "number" == typeof e2.inertia ? e2.inertia : 8, invertUpside: false }, i2);
  }
};
var uI = class extends rI {
  constructor(t6, e2, i2 = false) {
    const n2 = 16, r2 = [];
    for (let t7 = 0, e3 = 0; t7 < 8; ++t7, e3 += 4 * Math.PI / n2) r2.push([Math.cos(e3), Math.sin(e3), 0]);
    r2.push([0, 0, 1]), r2.push([0, 0, -1]);
    let s2 = [];
    for (let t7 = 0; t7 < 8; ++t7) s2.push([8, t7, (t7 + 1) % 8, 2 * t7]), s2.push([9, (t7 + 1) % 8, t7, (o2 = 7 - 2 * t7, a2 = n2, o2 - Math.floor(o2 / a2) * a2)]);
    var o2, a2;
    s2 = s2.sort(((t7, e3) => t7[3] - e3[3])), super(e2, { vertices: r2, faces: s2, scaleFactor: 0.9, values: 16, mass: "number" == typeof e2.weight ? e2.weight : 350, inertia: "number" == typeof e2.inertia ? e2.inertia : 9, invertUpside: false }, i2);
  }
};
var dI = class extends rI {
  constructor(t6, e2, i2 = false) {
    const n2 = (1 + Math.sqrt(5)) / 2;
    super(e2, { vertices: [[-1, n2, 0], [1, n2, 0], [-1, -n2, 0], [1, -n2, 0], [0, -1, n2], [0, 1, n2], [0, -1, -n2], [0, 1, -n2], [n2, 0, -1], [n2, 0, 1], [-n2, 0, -1], [-n2, 0, 1]], faces: [[0, 11, 5, 1], [0, 5, 1, 2], [0, 1, 7, 3], [0, 7, 10, 4], [0, 10, 11, 5], [1, 5, 9, 6], [5, 11, 4, 7], [11, 10, 2, 8], [10, 7, 6, 9], [7, 1, 8, 10], [3, 9, 4, 11], [3, 4, 2, 12], [3, 2, 6, 13], [3, 6, 8, 14], [3, 8, 9, 15], [4, 9, 5, 16], [2, 4, 11, 17], [6, 2, 10, 18], [8, 6, 7, 19], [9, 8, 1, 20]], scaleFactor: 1, values: 20, mass: "number" == typeof e2.weight ? e2.weight : 400, inertia: "number" == typeof e2.inertia ? e2.inertia : 6, invertUpside: false }, i2);
  }
};
var pI = function(t6, e2, i2, n2) {
  return new (i2 || (i2 = Promise))((function(r2, s2) {
    function o2(t7) {
      try {
        l2(n2.next(t7));
      } catch (t8) {
        s2(t8);
      }
    }
    function a2(t7) {
      try {
        l2(n2.throw(t7));
      } catch (t8) {
        s2(t8);
      }
    }
    function l2(t7) {
      var e3;
      t7.done ? r2(t7.value) : (e3 = t7.value, e3 instanceof i2 ? e3 : new i2((function(t8) {
        t8(e3);
      }))).then(o2, a2);
    }
    l2((n2 = n2.apply(t6, e2 || [])).next());
  }));
};
var fI = class _fI {
  constructor(t6) {
    this.loadThemePreviews = () => pI(this, void 0, void 0, (function* () {
      if (this.themePreviewFetchQueue.length > 0) {
        const t7 = this.themePreviewFetchQueue.reduce(((t8, e2) => t8 && t8.nextScheduledFetch > e2.nextScheduledFetch ? e2 : t8));
        if ((null == t7 ? void 0 : t7.nextScheduledFetch) < Date.now()) {
          let e2;
          try {
            e2 = (yield Oe.get(`/api/1.0/theme/${t7.themeId}`)).data.data;
          } finally {
            (null == e2 ? void 0 : e2.preview) && Object.values(null == e2 ? void 0 : e2.preview).length > 0 ? (this.engine.loadTheme(e2, true), this.themePreviewFetchQueue = this.themePreviewFetchQueue.filter((({ themeId: e3 }) => e3 !== t7.themeId))) : (t7.tries++, t7.nextScheduledFetch = Date.now() + _fI.clamp(1e3 * (Math.pow(2, t7.tries) + Math.random()), 0, 1e4));
          }
        }
        if (this.themePreviewFetchQueue.length > 0) {
          const t8 = this.themePreviewFetchQueue.reduce(((t9, e2) => t9 && t9.nextScheduledFetch > e2.nextScheduledFetch ? e2 : t9));
          if (t8) return void (this.loadThemePreviewsTimeout = window.setTimeout(this.loadThemePreviews.bind(this), _fI.clamp(t8.nextScheduledFetch - Date.now(), 1e3, 1e4)));
        }
      }
      this.loadThemePreviewsTimeout = void 0;
    })), this.engine = t6, this.themePreviewFetchQueue = [];
  }
  queue(t6) {
    this.themePreviewFetchQueue = [...this.themePreviewFetchQueue, ...t6.filter((({ preview: t7 }) => !t7 || 0 === Object.keys(t7).length)).map(((t7) => ({ themeId: t7.id, tries: 0, nextScheduledFetch: Date.now() })))], this.loadThemePreviewsTimeout || (this.loadThemePreviewsTimeout = window.setTimeout(this.loadThemePreviews.bind(this), 0)), this.init = Date.now();
  }
};
fI.clamp = (t6, e2, i2) => Math.min(Math.max(t6, e2), i2);
var mI = function(t6, e2, i2, n2) {
  return new (i2 || (i2 = Promise))((function(r2, s2) {
    function o2(t7) {
      try {
        l2(n2.next(t7));
      } catch (t8) {
        s2(t8);
      }
    }
    function a2(t7) {
      try {
        l2(n2.throw(t7));
      } catch (t8) {
        s2(t8);
      }
    }
    function l2(t7) {
      var e3;
      t7.done ? r2(t7.value) : (e3 = t7.value, e3 instanceof i2 ? e3 : new i2((function(t8) {
        t8(e3);
      }))).then(o2, a2);
    }
    l2((n2 = n2.apply(t6, e2 || [])).next());
  }));
};
var gI = class _gI {
  static loadFromId(t6) {
    return mI(this, void 0, void 0, (function* () {
      const e2 = (yield Oe.get(`/api/1.0/theme/${t6}`)).data;
      return _gI.buildTheme(e2.data);
    }));
  }
  static load(t6) {
    return _gI.buildTheme(t6);
  }
  static loadBaseTheme(t6) {
    return mI(this, void 0, void 0, (function* () {
      const e2 = (yield Oe.get(`/api/1.0/theme/${t6}`)).data, { data: i2 } = e2;
      return Object.assign(Object.assign({}, vI), i2);
    }));
  }
  static buildTheme(t6) {
    const e2 = Object.assign(Object.assign({}, vI), t6);
    switch (e2.api_version) {
      case "1":
      case "1.0":
      case 1:
        _gI.checkSyntaxV1_0(e2);
        break;
      case "2":
      case "2.0":
      case 2:
        _gI.checkSyntaxV2_0(e2);
        break;
      default:
        throw new fi("Invalid api_version number specified in manifest.json", "1.0", e2.api_version);
    }
    const i2 = {};
    for (const t7 of Object.keys(e2.uniforms)) i2[t7] = this.transformColorUniform(e2.uniforms[t7], e2.api_version);
    return "2.0" != e2.api_version && e2.textures.map(((t7) => {
      "u_valueMap" !== t7.binding ? t7.encoding = "sRGB" : t7.encoding = "linear";
    })), e2.api_version = "2.0", e2.uniforms = i2, e2;
  }
  static transformColorUniform(t6, e2) {
    if ("color" === (null == t6 ? void 0 : t6.type) || "v3" === (null == t6 ? void 0 : t6.type)) {
      let i2;
      return "string" == typeof t6.value ? (i2 = new $o(t6.value), i2 = i2.convertSRGBToLinear()) : i2 = Array.isArray(t6.value) ? new $o(...t6.value) : new $o(t6.value.r, t6.value.g, t6.value.b), "1.0" === e2 && (i2 = i2.convertSRGBToLinear()), { type: "v3", value: [i2.r, i2.g, i2.b] };
    }
    return t6;
  }
  static formifyColorUniform(t6, e2) {
    if ("color" === (null == t6 ? void 0 : t6.type) || "v3" === (null == t6 ? void 0 : t6.type)) {
      let i2;
      return "string" == typeof t6.value ? (i2 = new $o(t6.value), "1.0" === e2 && (i2 = i2.convertSRGBToLinear())) : Array.isArray(t6.value) ? (i2 = new $o(...t6.value), "1.0" !== e2 && (i2 = i2.convertLinearToSRGB())) : (i2 = new $o(t6.value.r, t6.value.g, t6.value.b), "1.0" !== e2 && (i2 = i2.convertLinearToSRGB())), { type: "color", value: "#" + i2.getHexString() };
    }
    return t6;
  }
  static checkSyntaxV1_0(t6) {
  }
  static checkSyntaxV2_0(t6) {
  }
};
var vI = { name: "Untitled Dice", api_version: "2.0", version: void 0, options: { lights: true, transparent: true, extensions: { derivatives: true } }, textures: [], available_dice: [{ id: "d4", type: Mi.D4, notation: "d4" }, { id: "d6", type: Mi.D6, notation: "d6" }, { id: "d8", type: Mi.D8, notation: "d8" }, { id: "d10", type: Mi.D10, notation: "d10" }, { id: "d10x", type: Mi.D10, notation: "d10x" }, { id: "d12", type: Mi.D12, notation: "d12" }, { id: "d20", type: Mi.D20, notation: "d20" }], sizes: { d4: 1, d6: 1, d8: 1, d10: 1, d10x: 1, d12: 1, d20: 1 }, preview: {}, sounds: [{ src: "/sounds/roll-1.mp3", on: "die.collide" }, { src: "/sounds/roll-2.mp3", on: "die.collide" }, { src: "/sounds/roll-3.mp3", on: "die.collide" }, { src: "/sounds/roll-loading-sm.mp3", on: "roll.loading", value: "=2" }, { src: "/sounds/roll-loading-lg.mp3", on: "roll.loading", value: ">=3" }], uniforms: { dissolve: { type: "f", value: 0 }, bumpScale: { type: "f", value: 1 }, diffuse: { type: "color", value: { r: 1, g: 1, b: 1 } }, number: { type: "color", value: { r: 1, g: 1, b: 1 } }, emissive: { type: "color", value: { r: 0, g: 0, b: 0 } }, specular: { type: "color", value: { r: 0.1, g: 0.1, b: 0.1 } }, shininess: { type: "f", value: 30, min: 0, max: 100 }, hiddenness: { type: "f", value: 0, min: 0, max: 1 }, opacity: { type: "f", value: 1, min: 0, max: 1 } }, frag_shader: "\n#define USE_UV\nvarying vec2 vUvOverlapped;\nvarying vec2 vUvPacked;\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\nuniform float dissolve;\nuniform float hiddenness;\nuniform sampler2D u_numberMap;\nuniform vec3 number;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nfloat rand2(vec2 c){\n	return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 p, float freq ){\n	float unit = 128./freq;\n	vec2 ij = floor(p/unit);\n	vec2 xy = mod(p,unit)/unit;\n	//xy = 3.*xy*xy-2.*xy*xy*xy;\n	xy = .5*(1.-cos(3.1415*xy));\n	float a = rand2((ij+vec2(0.,0.)));\n	float b = rand2((ij+vec2(1.,0.)));\n	float c = rand2((ij+vec2(0.,1.)));\n	float d = rand2((ij+vec2(1.,1.)));\n	float x1 = mix(a, b, xy.x);\n	float x2 = mix(c, d, xy.x);\n	return mix(x1, x2, xy.y);\n}\n\nfloat pNoise(vec2 p, int res){\n	float persistance = .5;\n	float n = 0.;\n	float normK = 0.;\n	float f = 4.;\n	float amp = 2.;\n	int iCount = 0;\n	for (int i = 0; i<50; i++){\n		n+=amp*noise(p, f);\n		f*=2.;\n		normK+=amp;\n		amp*=persistance;\n		if (iCount == res) break;\n		iCount++;\n	}\n	float nf = n/normK;\n	return nf*nf*nf*nf;\n}\n\nvoid main(){\n    if( clamp(pNoise( gl_FragCoord.xy, 1), 0.0, 1.0 ) > 1.0-dissolve ) discard;\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n    #include <map_fragment>\n\n    vec4 u_numberMapIn = texture2D( u_numberMap, vUv );\n    // adjust color of numbers\n    u_numberMapIn.rgb *= number;\n    // overlay number map and apply hiddenness\n    diffuseColor.rgb = mix(diffuseColor.rgb, u_numberMapIn.rgb, u_numberMapIn.a * (1.0 - hiddenness));\n\n    #include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	// accumulation\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	// modulation\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}\n", vert_shader: "\n#define USE_UV\nattribute vec2 uv2;\nattribute vec2 uv3;\nvarying vec2 vUvOverlapped;\nvarying vec2 vUvPacked;\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vUv = uv;\n    vUvOverlapped = uv2;\n    vUvPacked = uv3;\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}\n", meshes: { d4: "/mesh/v2/d4.fbx", d6: "/mesh/v2/d6.fbx", d8: "/mesh/v2/d8.fbx", d10: "/mesh/v2/d10.fbx", d12: "/mesh/v2/d12.fbx", d20: "/mesh/v2/d20.fbx", d10x: "/mesh/v2/d10.fbx", d16: "/mesh/v2/d16.fbx", d2: "/mesh/v2/d2.fbx" }, values: { d4: [1, 2, 3, 4], d6: [1, 2, 3, 4, 5, 6], d8: [1, 2, 3, 4, 5, 6, 7, 8], d10: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], d12: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], d20: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], d10x: [10, 20, 30, 40, 50, 60, 70, 80, 90, 0], d16: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16], d2: [1, 2] } };
var yI = function(t6, e2, i2, n2) {
  return new (i2 || (i2 = Promise))((function(r2, s2) {
    function o2(t7) {
      try {
        l2(n2.next(t7));
      } catch (t8) {
        s2(t8);
      }
    }
    function a2(t7) {
      try {
        l2(n2.throw(t7));
      } catch (t8) {
        s2(t8);
      }
    }
    function l2(t7) {
      var e3;
      t7.done ? r2(t7.value) : (e3 = t7.value, e3 instanceof i2 ? e3 : new i2((function(t8) {
        t8(e3);
      }))).then(o2, a2);
    }
    l2((n2 = n2.apply(t6, e2 || [])).next());
  }));
};
var { degToRad: xI, generateUUID: bI } = zo;
var wI = QL("engine");
var _I = { d4: new pa(-3.0867288254763183, -1.5835987755982994, -1.9356601549083798), d6: new pa(-1.378659608417167, -0.10618582127064262, -1.5559572532637613), d8: new pa(0.22758859765479822, 0.02421315553119243, -2.329931582346396), d10: new pa(0.481922323241565, -0.03367648553255032, -1.534888522853727), d10x: new pa(0.481922323241565, -0.03367648553255032, -1.534888522853727), d12: new pa(2.187338290883551, -0.00394870437252205, 1.54734989095445), d20: new pa(-3.0867288254763183, -1.5835987755982994, -1.9356601549083798), d16: new pa(0.23094903679106366, -0.02040424937062346, -1.8942034807315247), d2: new pa(1.6401553208596278, 0.162339772838505, 0) };
var SI;
!(function(t6) {
  t6.AddDie = "addDie";
})(SI || (SI = {}));
var MI = class _MI {
  constructor(t6, e2, i2) {
    if (this._autoRotateEnabled = false, this._controlsEnabled = false, this._callbacks = /* @__PURE__ */ new Map(), this._isDiceThrowing = false, this._isDragging = false, this._lastRotation = new pa(_I.d20.x, _I.d20.y, _I.d20.z), this._lastTime = 0, this._pointerDown = false, this._pointerDownPosition = new Fo(0, 0), this._thrownUUIDs = /* @__PURE__ */ new Set(), this._previewMode = false, this.audio = [], this.clock = new Tg(), this.dice = /* @__PURE__ */ new Map(), this.diceDragging = /* @__PURE__ */ new Map(), this.events = /* @__PURE__ */ new Map(), this.fbxLoader = new w_(), this.gltfLoader = new U_(), this.loader = { audio: new yg(), object: { load: (t7, e3, i3, n2) => /.*\.fbx$/.test(t7) ? this.fbxLoader.load(t7, e3, i3, n2) : /.*\.(glb|gltf)$/.test(t7) ? this.gltfLoader.load(t7, e3, i3, n2) : void wI.debug(`no loader fround for mesh ${t7}`) }, texture: new Hm() }, this.loaderQueue = { audio: /* @__PURE__ */ new Set(), object: /* @__PURE__ */ new Set(), texture: /* @__PURE__ */ new Set() }, this.meshes = {}, this.outlinePasses = {}, this.participantFilter = /* @__PURE__ */ new Set(), this.pointer = new Fo(0, 0), this.raycaster = new iv(), this.rollQueue = [], this.scene = new bd(), this.shaderMaterials = {}, this.sounds = {}, this.textures = {}, this.themePreviewFetchQueue = new fI(this), this.themes = {}, this.shouldAnimate = false, this.addCallback = (t7, e3) => {
      this._callbacks.set(t7, e3);
    }, this.clear = () => {
      this.isDiceThrowing ? setTimeout((() => this.clear()), 300) : (this.composer && this.composer.passes.forEach(((t7) => {
        var e3;
        return t7 instanceof cx || (null === (e3 = this.composer) || void 0 === e3 ? void 0 : e3.removePass(t7));
      })), this.dice.forEach(((t7) => {
        t7.shouldFadeOut = true, this.physics.remove(t7.getPhysicsBody());
      })));
    }, this.connect = (t7, e3, i3) => {
      var n2, r2, s2;
      return this.api ? this.api.roomSlug != t7 && this.api.disconnect() : this.api = new Ci(this.apiKey), this.api.connect(t7, e3, i3), this.listen(vi.RollCreated, this.eventRollCreated), this.listen(vi.RollUpdated, this.eventRollUpdated), this.listen(yi.RoomUpdated, this.eventRoomUpdated), null === (n2 = this.api) || void 0 === n2 || n2.listenLocal("RollValueMoveStartEvent", this.eventRollValueMoveStart), null === (r2 = this.api) || void 0 === r2 || r2.listenLocal("RollValueMoveEndEvent", this.eventRollValueMoveEnd), null === (s2 = this.api) || void 0 === s2 || s2.listenLocal("RollValueMoveEvent", this.eventRollValueMove), this.listen("DicePreviewRollEvent", this.eventRollCreated), this;
    }, this.disconnect = () => (this.api && this.api.disconnect(), this), this.dispatch = (t7, ...e3) => {
      const i3 = this.events.get(t7);
      return "function" == typeof i3 && i3(...e3), this;
    }, this.getTheme = (t7) => this.themes[t7], this.getThemes = () => this.themes ? Object.values(this.themes) : [], this.getRollsFromDice = (t7) => {
      const e3 = [];
      return this.dice.forEach(((i3) => {
        var n2;
        i3.roll && (null === (n2 = i3.roll) || void 0 === n2 ? void 0 : n2.user.uuid) === t7 && e3.push(i3.roll);
      })), e3;
    }, this.filter = (t7) => (t7.forEach(((t8) => this.participantFilter.add(t8))), this), this.loadTheme = (t7, e3 = false, i3 = true) => {
      if (void 0 === this.themes[t7.id] || e3) {
        wI.info("Loading theme", t7.id), i3 && this.themePreviewFetchQueue.queue([t7]);
        const e4 = gI.load(t7);
        this.themes[t7.id] = e4, this.loadShaderMaterial(e4.id, e4.frag_shader, e4.vert_shader, e4.uniforms, e4.options);
      }
      return this;
    }, this.pause = () => {
      this.controls.enabled = false;
    }, this.pickUpRoll = (t7, e3 = []) => {
      if (!this.api) throw new hi();
      wI.debug("pickup roll", t7);
      const i3 = Array.isArray(t7) ? t7 : [t7], n2 = [], r2 = [];
      return i3.forEach(((t8) => {
        var i4;
        if (t8.values) {
          const s2 = t8.values.filter((({ uuid: t9 }) => !(e3.length > 0) || e3.indexOf(t9) >= 0)).map((({ uuid: t9 }) => ({ uuid: t9, is_cleared: true })));
          r2.push(...s2.map((({ uuid: t9 }) => t9))), t8.uuid && (null === (i4 = t8.room) || void 0 === i4 ? void 0 : i4.slug) && n2.push({ uuid: t8.uuid, dice: s2, room: t8.room.slug });
        }
      })), this.fadeOutDiceByUuid(r2), this.api.roll.updateBulk(n2);
    }, this.loadThemeResources = (t7, e3 = true) => {
      var i3;
      if (void 0 !== this.themes[t7]) {
        const n2 = /* @__PURE__ */ new Set(), r2 = /* @__PURE__ */ new Set(), s2 = /* @__PURE__ */ new Set(), o2 = this.getThemeOptions(t7);
        (null === (i3 = o2.sounds) || void 0 === i3 ? void 0 : i3.length) && o2.sounds.forEach(((t8) => {
          "string" == typeof t8.src ? r2.add(t8.src) : Object.values(t8.src).forEach(((t9) => {
            r2.add(t9);
          }));
        }));
        for (const t8 of o2.textures) "object" == typeof t8.src ? Object.values(t8.src).forEach(((t9) => {
          t9 && s2.add(t9);
        })) : t8.src && s2.add(t8.src);
        o2.meshes && Object.values(o2.meshes).map(((t8) => n2.add(t8)));
        const a2 = Array.from(n2).filter(((t8) => !this.meshes[t8])), l2 = Array.from(r2).filter(((t8) => !this.sounds[t8])), c2 = Array.from(s2).filter(((t8) => !this.textures[t8]));
        return e3 && (wI.info("Loading theme resources", t7), a2.forEach(this.loadMesh), l2.forEach(this.loadSound), c2.forEach(this.loadTexture)), [...a2, ...l2, ...c2];
      }
      return [];
    }, this.preview = (t7, e3, i3 = false) => yI(this, void 0, void 0, (function* () {
      var n2, r2;
      this.start(), this.dice.forEach(((t8) => {
        t8.removeFromScene(this.scene, this.physics);
      })), this.dice = /* @__PURE__ */ new Map(), this.previewMode = true;
      let s2 = void 0 !== this.themes[t7.id];
      this.loadTheme(t7, false, false);
      let o2 = this.loadThemeResources(t7.id, !s2);
      for (; o2.length > 0; ) yield new Promise(((t8) => setTimeout(t8, 100))), this.dice.forEach(((t8) => {
        t8.removeFromScene(this.scene, this.physics);
      })), this.dice = /* @__PURE__ */ new Map(), this.previewMode = true, s2 = void 0 !== this.themes[t7.id], this.loadTheme(t7, false, false), o2 = this.loadThemeResources(t7.id, !s2);
      const a2 = this.getThemeOptions(t7.id), l2 = null !== (n2 = e3.type) && void 0 !== n2 ? n2 : e3, c2 = null !== (r2 = e3.id) && void 0 !== r2 ? r2 : e3;
      this._lastRotation && !i3 || this._lastRotation.set(_I[l2].x, _I[l2].y, _I[l2].z);
      const h2 = this.createDie(c2, "#FFFFFF", a2, false, bI());
      if (!h2) return;
      const u2 = h2.getObject();
      return u2.name = `${c2}`, h2.addToScene(this.scene, this.physics), u2.position.x = 0, this.dice.set(h2.uuid, h2), h2;
    })), this.resetCamera = () => {
      var t7, e3, i3, n2, r2, s2;
      this.camera && this.canvas && (this.camera.fov = this.config.camera.fov, this.camera.aspect = this.canvas.clientWidth / this.canvas.clientHeight, this.camera.near = 0.01, this.camera.far = 1e3, this.camera.position.x = null !== (e3 = null === (t7 = this.config.camera.position) || void 0 === t7 ? void 0 : t7.x) && void 0 !== e3 ? e3 : 0, this.camera.position.y = null !== (n2 = null === (i3 = this.config.camera.position) || void 0 === i3 ? void 0 : i3.y) && void 0 !== n2 ? n2 : this.config.camera.distance, this.camera.position.z = null !== (s2 = null === (r2 = this.config.camera.position) || void 0 === r2 ? void 0 : r2.z) && void 0 !== s2 ? s2 : 0, this.camera.lookAt(new pa(0, 0, 0)), this.config.camera.rotation && this.camera.rotation.set(this.config.camera.rotation.x, this.config.camera.rotation.y, this.config.camera.rotation.z), this.config.camera.quaternion && this.camera.quaternion.set(this.config.camera.quaternion.x, this.config.camera.quaternion.y, this.config.camera.quaternion.z, this.config.camera.quaternion.w));
    }, this.resize = (t7, e3) => {
      var i3;
      const n2 = this.renderer.capabilities.maxTextureSize / window.devicePixelRatio, r2 = e3 > n2 ? n2 : e3, s2 = t7 > n2 ? n2 : t7;
      return this.canvas && this.camera && (this.camera.aspect = s2 / r2, this.camera.updateProjectionMatrix(), null === (i3 = this.composer) || void 0 === i3 || i3.setSize(s2, r2), this.renderer.setSize(s2, r2), this.resizePhysics(this.boardWidth(), this.boardHeight())), this;
    }, this.resume = () => {
      this.controls.enabled = this._controlsEnabled;
    }, this.roll = (t7, e3) => {
      if (!this.api) throw new hi();
      return this.api.roll.create(t7, e3);
    }, this.rollLocal = (t7, e3, i3, n2) => yI(this, void 0, void 0, (function* () {
      const r2 = t7.map(((t8) => {
        const e4 = this.getThemeOptions(t8.theme), i4 = zo.randInt(1, e4.values[t8.type].length);
        return { uuid: zo.generateUUID(), is_hidden: t8.is_hidden, is_user_value: false, is_visible: !t8.is_hidden, is_cleared: false, is_dropped: false, type: t8.type, theme: t8.theme, value: i4, value_to_display: e4.values[t8.type][i4 - 1], created_at: (/* @__PURE__ */ new Date()).toISOString(), updated_at: (/* @__PURE__ */ new Date()).toISOString() };
      }));
      let s2;
      s2 = r2.every((({ value_to_display: t8 }) => "number" == typeof t8 || "string" == typeof t8 && (!isNaN(t8) && !isNaN(parseFloat(t8))))) ? r2.reduce(((t8, e4) => e4.is_dropped ? t8 : t8 + parseFloat(e4.value_to_display)), 0) : r2.map(((t8) => t8.is_dropped ? void 0 : t8.value_to_display)).filter(((t8) => t8));
      const o2 = { uuid: zo.generateUUID(), user: i3, room: { participants: [{ username: "Player 1", user: i3 }] }, equation: "", direction: null != n2 ? n2 : 0, total_value: s2, values: r2, velocity: 10, operator: null == e3 ? void 0 : e3.operator, whisper: [], created_at: (/* @__PURE__ */ new Date()).toISOString(), updated_at: (/* @__PURE__ */ new Date()).toISOString() };
      return this.executeRoll(o2), { type: "roll", data: o2 };
    })), this.screenshot = (t7) => {
      if (this.camera) return this.renderer.render(this.scene, this.camera), this.renderer.domElement.toDataURL(t7);
    }, this.setConfig = (t7) => {
      var e3;
      this.config = TI(_MI.DefaultConfig, t7), this.config.dice = TI(_MI.DefaultConfig.dice, t7.dice), this.config.light = TI(_MI.DefaultConfig.light, t7.light), this.config.physics = TI(_MI.DefaultConfig.physics, t7.physics), this.config.camera = TI(_MI.DefaultConfig.camera, t7.camera);
      const i3 = this.scene.children.find(((t8) => "SpotLight" === t8.type));
      i3 && (i3.castShadow = this.config.light.castShadows, i3.intensity = this.config.light.directionalIntensity, i3.color = new $o(this.config.light.directionalColor));
      const n2 = this.scene.children.find(((t8) => "AmbientLight" === t8.type));
      n2 && (n2.intensity = this.config.light.ambientIntensity, n2.color = new $o(this.config.light.ambientColor)), null === (e3 = this.physics) || void 0 === e3 || e3.setConfig(this.config.physics);
    }, this.start = () => (this.shouldAnimate || (this.shouldAnimate = true, this.update()), this), this.stop = () => (this.shouldAnimate = false, this), this.createDie = (t7, e3, i3, n2, r2, s2, o2) => {
      var a2, l2, c2, h2, u2, d2, p2, f2, m2, g2, v2, y2, x2, b2, w2, _2, S2, M2, T2;
      const E2 = this.getDiceOptions(t7, e3, i3, n2, r2, s2, o2), A2 = i3.available_dice.find(((e4) => {
        var i4;
        return null !== (i4 = t7 === e4.id) && void 0 !== i4 ? i4 : e4;
      }));
      switch (null !== (a2 = null == A2 ? void 0 : A2.type) && void 0 !== a2 ? a2 : t7) {
        case Mi.D4:
          return new oI(this, E2, null === (c2 = null === (l2 = this.config) || void 0 === l2 ? void 0 : l2.drawDebug) || void 0 === c2 ? void 0 : c2.collisionMeshes);
        case Mi.D6:
          return new aI(this, E2, null === (u2 = null === (h2 = this.config) || void 0 === h2 ? void 0 : h2.drawDebug) || void 0 === u2 ? void 0 : u2.collisionMeshes);
        case Mi.D8:
          return new lI(this, E2, null === (p2 = null === (d2 = this.config) || void 0 === d2 ? void 0 : d2.drawDebug) || void 0 === p2 ? void 0 : p2.collisionMeshes);
        case Mi.D10:
          return new cI(this, E2, null === (m2 = null === (f2 = this.config) || void 0 === f2 ? void 0 : f2.drawDebug) || void 0 === m2 ? void 0 : m2.collisionMeshes);
        case Mi.D12:
          return new hI(this, E2, null === (v2 = null === (g2 = this.config) || void 0 === g2 ? void 0 : g2.drawDebug) || void 0 === v2 ? void 0 : v2.collisionMeshes);
        case Mi.D20:
          return new dI(this, E2, null === (x2 = null === (y2 = this.config) || void 0 === y2 ? void 0 : y2.drawDebug) || void 0 === x2 ? void 0 : x2.collisionMeshes);
        case Mi.D10X:
          return new cI(this, E2, null === (w2 = null === (b2 = this.config) || void 0 === b2 ? void 0 : b2.drawDebug) || void 0 === w2 ? void 0 : w2.collisionMeshes);
        case Mi.Modifier:
          return;
        case Mi.D16:
          return new uI(this, E2, null === (S2 = null === (_2 = this.config) || void 0 === _2 ? void 0 : _2.drawDebug) || void 0 === S2 ? void 0 : S2.collisionMeshes);
        case Mi.D2:
          return new sI(this, E2, null === (T2 = null === (M2 = this.config) || void 0 === M2 ? void 0 : M2.drawDebug) || void 0 === T2 ? void 0 : T2.collisionMeshes);
      }
    }, this.eventRollValueMoveStart = (t7) => {
      t7.dice.forEach((({ uuid: t8 }) => {
        var e3;
        return null === (e3 = this.dice.get(t8)) || void 0 === e3 ? void 0 : e3.moveStart(true);
      }));
    }, this.eventRollValueMoveEnd = (t7) => {
      t7.dice.forEach((({ uuid: t8 }) => {
        var e3;
        return null === (e3 = this.dice.get(t8)) || void 0 === e3 ? void 0 : e3.moveEnd();
      }));
    }, this.eventRollValueMove = (t7) => {
      t7.dice.forEach((({ uuid: t8, meta: e3, value: i3 }) => {
        if (null == e3 ? void 0 : e3.position) {
          const n2 = this.dice.get(t8);
          if (n2) {
            const t9 = this.boardHeight(), r2 = this.boardWidth(), s2 = e3.position, o2 = r2 * (s2.x / 100) - r2 / 2, a2 = 1.5, l2 = t9 * (s2.z / 100) - t9 / 2;
            n2.shiftUpsideValue(i3), n2.moveTo(o2, a2, l2);
          }
        }
      }));
    }, this.eventRollCreated = (t7, e3 = []) => {
      if (!this.shouldExecuteRollEvent(t7)) return;
      (() => {
        yI(this, void 0, void 0, (function* () {
          const i3 = [];
          t7.values.forEach((({ type: t8, theme: e4 }) => {
            t8 !== Mi.Modifier && !this.isThemeLoaded(e4) && i3.indexOf(e4) < 0 && i3.push(e4);
          })), i3.length > 0 && (yield Promise.all(i3.map(((t8) => yI(this, void 0, void 0, (function* () {
            return yield gI.loadFromId(t8);
          })))))).map(((t8) => {
            this.loadTheme(t8);
          })), this.executeRoll(t7, e3), this.dispatch(vi.RollCreated, t7);
        }));
      })();
    }, this.eventRollUpdated = (t7) => {
      if (!this.shouldExecuteRollEvent(t7)) return;
      const e3 = [], i3 = [], n2 = [], r2 = [...this.dice.keys()];
      t7.values.forEach((({ is_cleared: t8, is_hidden: s2, is_dropped: o2, uuid: a2, meta: l2 }) => {
        if (t8 && e3.push(a2), s2 || i3.push(a2), r2.indexOf(a2) < 0 && !t8 && !o2 && n2.push(a2), null == l2 ? void 0 : l2.position) {
          const t9 = this.dice.get(a2);
          if (t9) {
            const e4 = this.boardHeight(), i4 = this.boardWidth(), n3 = l2.position, r3 = t9.getPhysicsBody().position, s3 = i4 * (n3.x / 100) - i4 / 2, o3 = r3.y, a3 = e4 * (n3.z / 100) - e4 / 2;
            t9.moveTo(s3, o3, a3);
          }
        }
      })), e3.length > 0 && this.fadeOutDiceByUuid(e3), i3.length > 0 && this.unhideDiceByUuid(i3), n2.length > 0 ? this.eventRollCreated(t7, n2) : this.dispatch(vi.RollUpdated, t7);
    }, this.eventRoomUpdated = (t7) => {
      this.dispatch(yi.RoomUpdated, t7);
    }, this.executeRoll = (t7, e3 = []) => yI(this, void 0, void 0, (function* () {
      var i3, n2, r2, s2, o2, a2, l2, c2, h2;
      const { user: { uuid: u2 }, direction: d2, room: p2 } = t7;
      wI.debug("Executing roll", t7.uuid);
      let f2 = [];
      t7.values.forEach(((t8) => {
        (0 === e3.length || e3.indexOf(t8.uuid) >= 0) && !this._thrownUUIDs.has(t8.uuid) && f2.push(t8);
      }));
      const m2 = (null === (i3 = this.config) || void 0 === i3 ? void 0 : i3.dice.limit) || 25;
      f2.length >= m2 && (f2 = f2.filter(((t8, e4) => e4 < m2))), this.removeDiceIfOverLimit(m2 - f2.length);
      const g2 = [1 * Math.random(), 0.7241 * Math.random(), 1.4019 * Math.random(), 1 * Math.random(), 0.12891 * Math.random(), 0.0123 * Math.random(), 0.098 * Math.random(), 0.124575 * Math.random()];
      this.previewMode = false;
      const v2 = /* @__PURE__ */ new Set();
      for (let t8 = 0; t8 < f2.length; ++t8) {
        const { theme: e4 } = f2[t8];
        v2.add(e4);
      }
      if (Array.from(v2).map(((t8) => this.loadThemeResources(t8))).flat(), this._isDiceThrowing || Object.values(this.loaderQueue).some(((t8) => t8.size > 0))) return this._isDiceThrowing ? wI.warn("Roll is already in progress, waiting to finish ...") : wI.warn("Still loading resources ..."), void this.queueRoll(t7);
      t7.values.every(((t8) => t8.type === Mi.Modifier)) && (this._isDiceThrowing = false, this.dispatch(vi.RollFinished, t7), this.initDragControls(), this.processQueueRoll()), wI.debug("Starting roll", t7), this._isDiceThrowing = true, this.dispatch(vi.RollStarted, t7);
      let y2 = "#ffffff";
      if (p2) {
        const t8 = p2.participants.find((({ user: { uuid: t9 } }) => t9 === u2));
        if (!t8) throw new pi("Participant not found in roll");
        y2 = t8.color;
      }
      const x2 = this.config.dice.throw;
      wI.info("All textures ready");
      const b2 = [], w2 = [], _2 = Math.ceil(Math.cbrt(f2.length));
      for (let e4 = 0; e4 < f2.length; ++e4) {
        if (f2[e4].type === Mi.Modifier) continue;
        const { type: i4, value: h3, value_to_display: u3, uuid: p3, theme: m3, is_hidden: v3 } = f2[e4], S3 = this.getThemeOptions(m3), M2 = new pa(0, 0, -x2.distance).applyAxisAngle(new pa(0, 1, 0), xI(d2)), T2 = this.createDie(i4, y2, S3, v3, p3, { uuid: t7.uuid, user: t7.user, values: t7.values }, m3);
        if (!T2) continue;
        if (T2.color = y2, this.canvas && this.config.audio && (null === (n2 = S3.sounds) || void 0 === n2 ? void 0 : n2.length)) {
          const t8 = S3.sounds.filter((({ on: t9 }) => t9 === Ei.Always));
          if (t8.length > 0) {
            const e6 = Math.floor(g2[0] * Math.random() * t8.length), { src: n4 } = t8[e6];
            this.attachSound(n4, T2, i4, Ei.Always);
          }
          const e5 = S3.sounds.filter((({ on: t9 }) => t9 === Ei.DieCollide));
          if (e5.length > 0) {
            const t9 = Math.floor(g2[0] * Math.random() * e5.length), { src: n4 } = e5[t9];
            this.attachSound(n4, T2, i4, Ei.DieCollide);
          }
          const n3 = S3.sounds.filter((({ on: t9 }) => t9 === Ei.DieValue));
          if (n3.length > 0) {
            const t9 = n3.findIndex((({ value: t10 }) => parseInt(t10) === h3));
            if (t9 >= 0) {
              const { src: e6 } = n3[t9];
              this.attachSound(e6, T2, i4, Ei.DieValue);
            }
          }
          let r3;
          const s3 = Math.min(...S3.values[i4]), o3 = Math.max(...S3.values[i4]);
          if (isNaN(s3) || parseInt(u3) !== s3 ? isNaN(o3) || parseInt(u3) !== o3 || (r3 = Ei.DieRollHigh) : r3 = Ei.DieRollLow, void 0 !== r3) {
            const t9 = S3.sounds.filter((({ on: t10 }) => t10 === r3));
            if (t9.length) {
              const e6 = Math.floor(g2[0] * Math.random() * t9.length), { src: n4 } = t9[e6];
              this.attachSound(n4, T2, i4, r3);
            }
          }
        }
        const E2 = new pa(1, 1, 1);
        (null === (s2 = null === (r2 = null == T2 ? void 0 : T2.getObject()) || void 0 === r2 ? void 0 : r2.geometry) || void 0 === s2 ? void 0 : s2.boundingBox) && (null === (l2 = null === (a2 = null === (o2 = null == T2 ? void 0 : T2.getObject()) || void 0 === o2 ? void 0 : o2.geometry) || void 0 === a2 ? void 0 : a2.boundingBox) || void 0 === l2 || l2.getSize(E2));
        const A2 = 2 * Math.max(E2.x, E2.y, E2.z) * (null !== (c2 = T2.size) && void 0 !== c2 ? c2 : 1);
        T2.addToScene(this.scene, this.physics);
        const C2 = { x: 2 * (g2[1] - 0.5) * x2.posRandom + e4 % _2 * A2, y: Math.floor(e4 / _2) % _2 * A2, z: 2 * (g2[2] - 0.5) * x2.posRandom + Math.floor(e4 / (_2 * _2)) % _2 * A2 };
        T2.getObject().position.set(M2.x * this.boardWidth() / 2 + C2.x, x2.height + C2.y, M2.z * this.boardHeight() / 2 + C2.z);
        const R2 = d2 + 2 * (Math.random() - 0.5) * x2.directionCone, P2 = x2.speedHor + 2 * (0.3 * Math.random() - 0.5) * x2.speedRandom, L2 = new pa(0, 0, 1).applyAxisAngle(new pa(0, 1, 0), xI(R2)).setLength(P2);
        L2.y = x2.speedVert, T2.getPhysicsBody().velocity.set(L2.x, L2.y, L2.z), T2.getPhysicsBody().angularVelocity.set(xI(2 * (g2[5] - 0.5) * x2.maxSpin), xI(2 * (g2[6] - 0.5) * x2.maxSpin), xI(2 * (g2[7] - 0.5) * x2.maxSpin)), T2.updateBodyFromMesh(), w2.push({ dice: T2, keyframes: [], stableCount: 0, value: h3 }), b2.push(T2), this._thrownUUIDs.add(f2[e4].uuid);
      }
      wI.info("Dice values created");
      for (let t8 = 0; t8 < w2.length; t8++) if (w2[t8].value < 1 || w2[t8].dice.values < w2[t8].value) throw new pi("Cannot throw die to value " + w2[t8].value + ", because it has only " + w2[t8].dice.values + " sides.");
      const S2 = this.dice;
      if (S2.forEach(((t8) => t8.saveState())), this.camera && this.composer && b2.length > 0 && this.config.dice.drawOutlines) {
        const t8 = new Lx(this.scene, this.camera);
        t8.width = this.width, t8.height = this.height, t8.selection = new Tx(b2.map(((t9) => t9.getObject()))), t8.visibleEdgeColor.set(b2[0].color);
        const e4 = new px(this.camera, t8);
        b2.forEach(((t9) => this.outlinePasses[t9.uuid] = e4)), null === (h2 = this.composer) || void 0 === h2 || h2.addPass(e4);
      }
      b2.forEach(((t8) => {
        this.dice.set(t8.uuid, t8), t8.playSound(Ei.Always, false, true, 1);
      })), this.adjustAmbientDiceSoundsVolume(), this.start(), yield this.physics.runOffscreenSimulation(w2), S2.forEach(((t8) => t8.loadState())), this.physics.attachKeyframeApplier(w2).then((() => {
        b2.forEach(((t8) => t8.finish())), b2.forEach(((t8) => t8.getPhysicsBody().sleep())), this._isDiceThrowing = false, this.dispatch(vi.RollFinished, t7), this.initDragControls(), this.config.autoClear && !t7.values.some(((t8) => t8.is_hidden)) && t7.values.some(((t8) => !t8.is_cleared)) && setTimeout(this.fadeOutDiceByUuid.bind(this), 1e3 * this.config.autoClear, t7.values.map(((t8) => t8.uuid))), this.processQueueRoll();
      })), YL() || this.update(1e3 * iI.PHYSICS_STEP + performance.now());
    })), this.shouldExecuteRollEvent = (t7) => {
      if (this.participantFilter.size > 0 && void 0 !== t7.room) {
        const e3 = t7.user.uuid, i3 = t7.room.participants.find((({ user: { uuid: t8 } }) => t8 === e3));
        if (i3) return this.participantFilter.has(i3.id);
      }
      return true;
    }, this.getDiceOptions = (t7, e3, i3, n2, r2, s2, o2) => {
      var a2, l2, c2, h2, u2, d2;
      const p2 = [];
      for (const e4 of i3.textures) {
        const n3 = "object" == typeof e4.src ? e4.src[t7] : e4.src;
        "2.0" === i3.api_version ? this.textures[n3] && ("sRGB" === e4.encoding && this.textures[n3] ? this.textures[n3].encoding = ks : "linear" === e4.encoding && this.textures[n3] ? this.textures[n3].encoding = Bs : ["map", "u_numberMap", "u_outlineMap", "emissiveMap", "u_emissiveMap"].some(((t8) => t8 === e4.binding)) ? this.textures[n3].encoding = ks : "gradientMap" === e4.binding && (this.textures[n3].minFilter = xr, this.textures[n3].magFilter = xr)) : this.textures[n3] && ("gradientMap" === e4.binding ? (this.textures[n3].minFilter = xr, this.textures[n3].magFilter = xr) : "u_valueMap" !== e4.binding && (this.textures[n3].encoding = ks)), p2.push({ binding: e4.binding, texture: this.textures[n3] });
      }
      const f2 = "object" == typeof i3.sizes ? i3.sizes[t7] : i3.sizes;
      let m2, g2;
      "object" == typeof i3.physics && (m2 = "object" == typeof i3.physics.weight ? i3.physics.weight[t7] : i3.physics.weight, g2 = "object" == typeof i3.physics.inertia ? i3.physics.inertia[t7] : i3.physics.inertia);
      const v2 = { color: e3, inertia: g2, isRollHidden: n2, material: (void 0 !== (null === (l2 = null === (a2 = this.meshes[i3.meshes[t7]]) || void 0 === a2 ? void 0 : a2.material) || void 0 === l2 ? void 0 : l2.metalness) ? null === (c2 = this.meshes[i3.meshes[t7]]) || void 0 === c2 ? void 0 : c2.material : this.shaderMaterials[i3.id]).clone(), meshTemplate: this.meshes[i3.meshes[t7]], size: f2 * (null !== (d2 = null === (u2 = null === (h2 = this.config) || void 0 === h2 ? void 0 : h2.dice) || void 0 === u2 ? void 0 : u2.size) && void 0 !== d2 ? d2 : 1), textures: p2, uuid: r2, weight: m2, shouldFadeOut: false, particles: i3.particles, roll: s2, theme: o2, dieId: t7 };
      if (void 0 !== i3.uniforms && v2.material.uniforms) {
        v2.material.setValues({ uniforms: xc.merge([i3.uniforms, this.shaderMaterials[i3.id].uniforms]) });
        for (const t8 of p2) /^u_/.test(t8.binding) || (v2.material[t8.binding] = t8.texture), v2.material.uniforms && (v2.material.uniforms[t8.binding] = { type: "t", value: t8.texture }), v2.material.uniforms.hiddenness = { type: "f", value: 0 };
      }
      return v2.material.needsUpdate = true, v2;
    }, this.getThemeOptions = (t7) => {
      if (!t7) throw new Error("Theme not loaded");
      let e3;
      if ("object" == typeof t7) e3 = t7;
      else if (e3 = this.themes[t7], !e3) throw wI.error(`Theme ${t7} not found`), new Error("Theme not loaded");
      return { id: e3.id, api_version: e3.api_version, available_dice: e3.available_dice, meshes: e3.meshes, sizes: e3.sizes, sounds: e3.sounds, textures: e3.textures, uniforms: e3.uniforms, values: e3.values, particles: e3.particles };
    }, this.initAudioListener = () => {
      this.camera && (this.audioListener = new Lg(), this.camera.add(this.audioListener));
    }, this.initCamera = () => {
      var t7, e3;
      if (this.canvas) {
        const i3 = this.canvas.clientWidth / this.canvas.clientHeight;
        if (this.camera = new _c(this.config.camera.fov, i3, 0.01, 1e3), this.scene.add(this.camera), this.resetCamera(), null === (e3 = null === (t7 = this.config) || void 0 === t7 ? void 0 : t7.drawDebug) || void 0 === e3 ? void 0 : e3.clearColor) {
          const t8 = new gc(this.config.camera.distance * i3, 0.1, this.config.camera.distance), e4 = new Rl({ color: 65280 }), n2 = new fc(t8, e4);
          n2.name = "debug", this.scene.add(n2);
        }
      }
    }, this.initControls = () => {
      this.camera && (this.controls = new Wx(this.camera, this.canvas), this.controls.enableZoom = !this.previewMode, this.controls.enablePan = !this.previewMode, this.controls.enableDamping = !this.previewMode, this.controls.enableRotate = !this.previewMode);
    }, this.initDragControls = () => {
      if (this.dragControls && this.dragControls.dispose(), this.camera) {
        const t7 = [];
        this.dice.forEach(((e3) => t7.push(e3.getObject()))), this.dragControls = new Hx(t7, this.camera, this.canvas), this.dragControls.addEventListener("dragstart", this.onDragStart), this.dragControls.addEventListener("drag", this.onDrag), this.dragControls.addEventListener("dragend", this.onDragEnd);
      }
    }, this.initListeners = () => {
      this.on(Ei.RollLoading, this.onRollLoading), this.on(Ei.RollLoaded, this.onRollLoaded);
    }, this.initPhysics = () => {
      this.physics = new iI(this.config.physics), this.physics.init(this.boardWidth(), this.boardHeight());
    }, this.initRenderer = () => {
      var t7, e3;
      if (this.canvas) {
        const { clientWidth: i3, clientHeight: n2 } = this.canvas;
        this.renderer = new gd({ canvas: this.canvas, alpha: true, antialias: true, powerPreference: "high-performance", preserveDrawingBuffer: this.previewMode, logarithmicDepthBuffer: true }), this.renderer.setPixelRatio(window.devicePixelRatio), this.renderer.debug.checkShaderErrors = true, this.renderer.setSize(i3, n2), this.renderer.shadowMap.enabled = true, this.renderer.shadowMap.type = yn, this.renderer.outputEncoding = ks, (null === (e3 = null === (t7 = this.config) || void 0 === t7 ? void 0 : t7.drawDebug) || void 0 === e3 ? void 0 : e3.clearColor) && this.renderer.setClearColor(16711680, 1);
      }
    }, this.initScene = () => {
      const t7 = new ng(this.config.light.ambientColor, this.config.light.ambientIntensity);
      this.scene.add(t7);
      const e3 = new Zm(this.config.light.directionalColor, this.config.light.directionalIntensity);
      e3.position.set(this.config.light.direction.x, this.config.light.direction.y, this.config.light.direction.z), e3.lookAt(0, 0, 0), e3.castShadow = this.config.light.castShadows, e3.name = "light", e3.shadow.radius = 70, e3.shadow.mapSize.width = 4096, e3.shadow.mapSize.height = 4096, this.scene.add(e3);
      const i3 = new Fc(100, 100), n2 = new $f(), r2 = new fc(i3, n2);
      n2.shadowSide = bn, r2.position.set(0, -0.01, 0), r2.lookAt(0, 0, 0), r2.receiveShadow = true, r2.visible = !this.previewMode, this.scene.add(r2);
      const s2 = new km();
      s2.setPath(`${ci.CDN_URL}/images/environment/`);
      const o2 = s2.load(["px.webp", "nx.webp", "py.webp", "ny.webp", "pz.webp", "nz.webp"]);
      o2.mapping = ur, this.scene.environment = o2;
    }, this.initStats = () => {
      var t7, e3;
      (null === (e3 = null === (t7 = this.config) || void 0 === t7 ? void 0 : t7.drawDebug) || void 0 === e3 ? void 0 : e3.infoPane) && this.canvas && (this.stats = new (Dx())(), this.stats.showPanel(0), document.body.appendChild(this.stats.dom));
    }, this.initWindowListeners = () => {
      this.canvas && (this.canvas.addEventListener("pointerdown", this.onPointerDown), this.canvas.addEventListener("pointermove", this.onPointerMove), this.canvas.addEventListener("pointerup", this.onPointerUp), document.addEventListener("contextmenu", this.onContextMenu));
    }, this.isThemeLoaded = (t7) => this.themes.hasOwnProperty(t7), this.loadMesh = (t7) => {
      if (t7 in this.meshes) return wI.debug("Mesh %s found in cache", t7), this.meshes[t7];
      wI.debug("Loading mesh %s", t7), this.queueResource("object", t7);
    }, this.loadShaderMaterial = (t7, e3, i3, n2, r2) => (this.shaderMaterials[t7] || (this.shaderMaterials[t7] = new bc(Object.assign({ vertexShader: i3, fragmentShader: e3, uniforms: xc.merge([kc.phong.uniforms, kc.physical.uniforms, n2]) }, r2)), wI.debug("Loaded ShaderMaterial %s", t7)), this.shaderMaterials[t7]), this.loadSound = (t7) => {
      if (t7 in this.sounds) return wI.debug("Sound %s found in cache", t7), this.sounds[t7];
      wI.debug("Loading sound %s", t7), this.queueResource("audio", t7);
    }, this.loadTexture = (t7) => {
      if (t7 in this.textures) return wI.debug("Texture %s found in cache", t7), this.textures[t7];
      wI.debug("Loading texture %s", t7), this.queueResource("texture", t7);
    }, this.onDragStart = (t7) => {
      var e3;
      const { allowPlayerRollUpdates: i3, allowPlayerMoveDice: n2 } = this.config.dice;
      if (this.dice.forEach(((e4) => {
        var r2;
        const { roll: s2 } = e4;
        (i3 || (null == s2 ? void 0 : s2.user.uuid) === (null === (r2 = this.api) || void 0 === r2 ? void 0 : r2.userUuid)) && e4.getObject().uuid === t7.object.uuid && (n2 && e4.moveStart(), this.diceDragging.set(t7.object.uuid, e4.uuid));
      })), n2) {
        const t8 = [...this.diceDragging.values()].map(((t9) => ({ uuid: t9 })));
        t8.length && (null === (e3 = this.api) || void 0 === e3 || e3.sendLocal("RollValueMoveStartEvent", { dice: t8 }));
      }
    }, this.onDrag = (t7) => {
      const { allowPlayerMoveDice: e3 } = this.config.dice;
      if (e3 && this.diceDragging.size > 0) {
        this._isDragging = true;
        const e4 = this.diceDragging.get(t7.object.uuid), i3 = this.dice.get(e4);
        i3 && (i3.move(t7.object.position.x, 1.5, t7.object.position.z), this.onMoveLocal(i3));
      }
    }, this.onDragEnd = (t7) => {
      var e3;
      if (this.diceDragging.size > 0) {
        const { allowPlayerMoveDice: i3 } = this.config.dice;
        if (i3) {
          const t8 = [...this.diceDragging.values()].map(((t9) => ({ uuid: t9 })));
          null === (e3 = this.api) || void 0 === e3 || e3.sendLocal("RollValueMoveEndEvent", { dice: t8 });
        }
        const n2 = this.diceDragging.get(t7.object.uuid), r2 = this.dice.get(n2);
        r2 && (i3 && r2.moveEnd(), this._isDragging ? this.onMove(r2, true) : this.onClick(r2)), this._isDragging = false, this.diceDragging.clear();
      }
    }, this.onClick = (t7, e3) => {
      var i3, n2, r2, s2, o2, a2, l2;
      if (this._isDiceThrowing) return;
      const { allowPlayerRollUpdates: c2, defaultClickBehavior: h2 } = this.config.dice, u2 = null != e3 ? e3 : h2;
      if (this.api && u2 !== Si.Nothing) {
        const { uuid: e4, theme: h3, dieId: d2, roll: p2 } = t7;
        if (p2) {
          if (this.raycaster.intersectObject(t7.getObject()).length > 0 && (c2 || p2.user.uuid === (null === (i3 = this.api) || void 0 === i3 ? void 0 : i3.userUuid))) {
            const t8 = [];
            u2 === Si.Reroll ? t8.push({ uuid: e4, is_cleared: true, is_dropped: true }, { theme: h3, type: d2, is_hidden: null !== (r2 = null === (n2 = p2.values.find(((t9) => t9.uuid === e4))) || void 0 === n2 ? void 0 : n2.is_hidden) && void 0 !== r2 && r2 }) : u2 === Si.Drop ? t8.push({ uuid: e4, is_dropped: true, is_cleared: true }) : u2 === Si.Explode && t8.push({ uuid: e4, is_cleared: true }, { theme: h3, type: d2, is_hidden: null !== (o2 = null === (s2 = p2.values.find(((t9) => t9.uuid === e4))) || void 0 === s2 ? void 0 : s2.is_hidden) && void 0 !== o2 && o2 }), null === (a2 = this.api) || void 0 === a2 || a2.roll.update(p2.uuid, { dice: t8, room: null === (l2 = this.api) || void 0 === l2 ? void 0 : l2.roomSlug });
          }
        }
      }
    }, this.onMove = (t7, e3 = false) => {
      var i3, n2, r2;
      const { uuid: s2, roll: o2 } = t7;
      if (o2) {
        const a2 = t7.getPhysicsBody().position, l2 = this.boardWidth(), c2 = this.boardHeight(), h2 = { dice: [{ uuid: s2, meta: { position: { x: parseFloat(((l2 / 2 + a2.x) / l2 * 100).toFixed(2)), z: parseFloat(((c2 / 2 + a2.z) / c2 * 100).toFixed(2)) } } }], room: null === (i3 = this.api) || void 0 === i3 ? void 0 : i3.roomSlug };
        e3 ? null === (r2 = this.api) || void 0 === r2 || r2.roll.update(o2.uuid, h2) : null === (n2 = this.api) || void 0 === n2 || n2.sendLocal("RollValueMoveEvent", h2);
      }
    }, this.onMoveLocal = ln(((t7) => {
      this.onMove(t7, false);
    }), 250, { leading: false, trailing: true }), this.onPointerDown = (t7) => {
      if (2 === t7.button && this.dragControls && (this.dragControls.enabled = false), !this.previewMode || !this._controlsEnabled) return;
      t7.preventDefault(), this._pointerDown = true, this.pointer.set(t7.offsetX, t7.offsetY), this._pointerDownPosition.copy(this.pointer);
      const e3 = new Fo(t7.offsetX / this.renderer.domElement.clientWidth * 2 - 1, -t7.offsetY / this.renderer.domElement.clientHeight * 2 + 1);
      this.raycaster.setFromCamera(e3, this.camera);
    }, this.onPointerMove = (t7) => {
      if (this.pointer.set(t7.offsetX, t7.offsetY), !this.previewMode || !this._pointerDown || !this._controlsEnabled) return;
      if (1 === this.dice.size) {
        const t8 = new da().setFromEuler(new tl(xI(1 * (this.pointer.y - this._pointerDownPosition.y)), 0, -xI(1 * (this.pointer.x - this._pointerDownPosition.x)), "XYZ")), e3 = this.dice.values().next().value.getObject();
        e3.quaternion.multiplyQuaternions(t8, e3.quaternion), this._lastRotation.copy(new pa(...e3.rotation.toArray())), this._pointerDownPosition.copy(this.pointer);
      }
    }, this.onPointerUp = (t7) => {
      this.dragControls && (this.dragControls.enabled = true), this.previewMode && this._controlsEnabled && (t7.preventDefault(), this._pointerDown = false);
    }, this.onContextMenu = (t7) => {
      let e3 = false;
      const { allowPlayerRollUpdates: i3 } = this.config.dice;
      return this.dice.forEach(((t8) => {
        var n2;
        const r2 = this._callbacks.get("contextmenu");
        if ("function" == typeof r2 && this.api && this.camera) {
          const { roll: s2 } = t8;
          if (s2) {
            const o2 = this.raycaster.intersectObject(t8.getObject());
            if (o2.length > 0 && (i3 || s2.user.uuid === (null === (n2 = this.api) || void 0 === n2 ? void 0 : n2.userUuid))) {
              const i4 = o2[0].point.project(this.camera);
              r2({ x: (i4.x + 1) / 2 * this.width / window.devicePixelRatio, y: (1 - i4.y) / 2 * this.height / window.devicePixelRatio }, t8), e3 = true;
            }
          }
        }
      })), e3 && (t7.preventDefault(), t7.stopPropagation()), false;
    }, this.onRollLoading = (t7, e3, i3 = false) => {
      const n2 = this.getThemeOptions(t7);
      if (null == n2 ? void 0 : n2.sounds) {
        const t8 = n2.sounds.find((({ on: t9, value: i4 }) => t9 === Ei.RollLoading && (void 0 === e3 || _MI.compareEventValue(e3, i4))));
        if (t8) {
          const e4 = /* @__PURE__ */ new Set();
          "string" == typeof t8.src ? e4.add(t8.src) : Object.values(t8.src).forEach(((t9) => {
            e4.add(t9);
          })), Array.from(e4).forEach(((t9) => {
            const e5 = this.sounds[t9];
            if (e5) {
              const t10 = new Ig(this.audioListener);
              t10.setBuffer(e5).setLoop(i3).setVolume(1).play(), this.audio.push(t10);
            }
          }));
        }
      }
    }, this.onRollLoaded = () => {
      this.audio.forEach(((t7) => t7.stop()));
    }, this.processLoaderQueue = an((() => {
      wI.debug("Processing queue"), Object.keys(this.loaderQueue).forEach(((t7) => {
        Array.from(this.loaderQueue[t7]).forEach(((e3) => {
          const i3 = e3;
          this.loader[t7].load(i3, ((e4) => {
            var n2;
            switch (t7) {
              case "object":
                wI.debug("Loaded mesh %s", i3), wI.debug("mesh", e4), (null == e4 ? void 0 : e4.scene) ? this.meshes[i3] = e4.scene.children[0] : this.meshes[i3] = e4.children[0];
                break;
              case "audio":
                wI.debug("Loaded sound %s", i3), this.sounds[i3] = e4;
                break;
              case "texture":
                wI.debug("Loaded texture %s", i3), e4.anisotropy = (null === (n2 = this.renderer) || void 0 === n2 ? void 0 : n2.capabilities) ? Math.min(this.renderer.capabilities.getMaxAnisotropy(), 4) : 4, e4.wrapS = vr, e4.wrapT = vr, this.textures[i3] = e4;
            }
          }));
        })), this.loaderQueue[t7].clear(), this.processQueueRoll();
      }));
    }), 500), this.processQueueRoll = () => {
      if (0 === this.rollQueue.length) return;
      const t7 = this.rollQueue.pop();
      t7 && this.executeRoll(t7);
    }, this.queueResource = (t7, e3) => {
      this.loaderQueue[t7].add(e3), this.processLoaderQueue();
    }, this.queueRoll = (t7) => {
      this.rollQueue.push(t7);
    }, this.resizePhysics = an(((t7, e3) => {
      this.physics.resize(t7, e3);
    }), 50), this.unhideDiceByUuid = (t7) => {
      for (const e3 of t7) {
        const t8 = this.dice.get(e3);
        t8 && (t8.isRollHidden = false);
      }
    }, this.unloadShaderMaterial = (t7) => {
      delete this.shaderMaterials[t7];
    }, this.unloadTheme = (t7) => {
      const e3 = "object" == typeof t7 ? t7.id : t7;
      void 0 !== this.themes[e3] && (this.unloadShaderMaterial(t7), delete this.themes[e3]);
    }, this.update = (t7 = 0) => {
      var e3, i3;
      const n2 = Math.max(0, (t7 - this._lastTime) / 1e3);
      this.updateBoardSize();
      const r2 = 1 === this.dice.size;
      this.previewMode && this._autoRotateEnabled && r2 && !this._pointerDown && (this._lastRotation.x += 0.51 * n2, this._lastRotation.y -= 0.51 * n2), null === (e3 = this.stats) || void 0 === e3 || e3.begin(), this.physics.update(n2), this.controls && this.controls.update();
      const s2 = [], o2 = new Fo(this.pointer.x / this.renderer.domElement.clientWidth * 2 - 1, -this.pointer.y / this.renderer.domElement.clientHeight * 2 + 1);
      this.raycaster.setFromCamera(o2, this.camera), this.dice.forEach(((t8) => {
        var e4;
        if (this.previewMode) {
          const e5 = t8.getObject();
          void 0 === e5._originalScale && (e5._originalScale = e5.scale.clone());
          const i5 = e5._originalScale.x !== e5.scale.x || e5._originalScale.y !== e5.scale.y || e5._originalScale.z !== e5.scale.z;
          r2 ? (e5.rotation.x = this._lastRotation.x, e5.rotation.y = this._lastRotation.y, e5.rotation.z = this._lastRotation.z, t8.updateBodyFromMesh(), this._pointerDown && !r2 ? e5.scale.set(e5._originalScale.x - 1, e5._originalScale.y - 1, e5._originalScale.z - 1) : e5.scale.set(e5._originalScale.x, e5._originalScale.y, e5._originalScale.z)) : i5 && e5.scale.set(e5._originalScale.x, e5._originalScale.y, e5._originalScale.z), s2.push(e5);
        } else t8.updateMeshFromBody();
        const i4 = () => {
          const e5 = t8.getUniformValue("dissolve");
          return t8.shouldFadeOut ? t8.shouldFadeOut && (null == e5 ? void 0 : e5.value) < 1 ? (t8.getObject().material.transparent = true, t8.fadeOutSound(Ei.Always, n2), (null == e5 ? void 0 : e5.value) + 2 * n2) : (this.previewMode || (this.removeDieByUuid(t8.uuid), t8.stopSound(Ei.Always), this.dispatch(vi.RollFadeFinished)), 1) : 0;
        }, o3 = (e5) => t8.shouldFadeOut ? t8.shouldFadeOut && e5 > 0 ? (t8.getObject().material.transparent = true, t8.fadeOutSound(Ei.Always, n2), e5 - 2 * n2) : (this.removeDieByUuid(t8.uuid), t8.stopSound(Ei.Always), this.dispatch(vi.RollFadeFinished), 0) : null != e5 ? e5 : 1, a2 = (e5) => {
          if (t8.shouldFadeOut) return e5 > 0 ? (t8.getObject().material.transparent = true, e5 - 2 * n2) : (this.removeDieByUuid(t8.uuid), this.dispatch(vi.RollFadeFinished), 0);
          if (t8.isRollHidden) return 0;
          if (t8.isRollHidden) return null != e5 ? e5 : 1;
          if (e5 < 1) {
            const i5 = e5 + n2;
            return i5 >= 1 && (this.config.autoClear && setTimeout(this.fadeOutDiceByUuid.bind(this), 1e3 * this.config.autoClear, [t8.uuid]), this.dispatch(vi.RollUnhideFinished)), i5;
          }
          return 1;
        }, l2 = { time: this.clock.getElapsedTime(), hiddenness: (() => {
          const e5 = t8.getUniformValue("hiddenness");
          if (void 0 !== e5) {
            if (t8.isRollHidden) return 1;
            if (!t8.isRollHidden && (null == e5 ? void 0 : e5.value) > 0) {
              const i5 = e5.value - n2;
              return i5 <= 0 && (this.config.autoClear && !this.previewMode && setTimeout(this.fadeOutDiceByUuid.bind(this), 1e3 * this.config.autoClear, [t8.uuid]), this.dispatch(vi.RollUnhideFinished)), i5;
            }
          }
          return 0;
        })(), randomSeed: t8.randomSeed, currentUpsideFace: t8.getShiftedUpsideValue(), velocity: t8.getPhysicsBody().velocity.toArray(), angularVelocity: t8.getPhysicsBody().angularVelocity.toArray(), force: t8.getPhysicsBody().force.toArray(), torque: t8.getPhysicsBody().torque.toArray(), mass: t8.getPhysicsBody().mass };
        if (t8.getObject().material.uniforms) {
          const n3 = t8.getObject().material.uniforms.dissolve ? "dissolve" : "opacity";
          "dissolve" == n3 ? l2.dissolve = i4() : l2.opacity = o3(null === (e4 = t8.getUniformValue("opacity")) || void 0 === e4 ? void 0 : e4.value), t8.updateShader(l2), t8.getObject().customDepthMaterial.uniforms.opacity.value = "dissolve" === n3 ? 1 - l2.dissolve : l2.opacity;
        } else {
          const e5 = a2(t8.getObject().material.opacity);
          t8.getObject().material.opacity = e5, t8.getObject().customDepthMaterial.uniforms.opacity.value = e5;
        }
      })), this._lastTime = t7, null === (i3 = this.stats) || void 0 === i3 || i3.end(), this.renderer && this.camera && this.composer ? this.composer.render(t7) : this.renderer && this.camera && this.renderer.render(this.scene, this.camera), this.shouldAnimate && requestAnimationFrame(this.update), this.previewMode || 0 !== this.dice.size || this.stop();
    }, this.updateBoardSize = () => {
      const t7 = this.scene.getObjectByName("debug");
      t7 && this.camera && t7.scale.set(this.boardWidth(), 1, this.boardHeight());
    }, "undefined" == typeof window) throw new Error("ThreeDDice must be used in a browser context with the window object. For other uses use the ThreeDDiceAPI class instead");
    return this.initialize(t6, e2, i2);
  }
  get autoRotate() {
    return this._autoRotateEnabled;
  }
  set autoRotate(t6) {
    this._autoRotateEnabled = t6;
  }
  get controlsEnabled() {
    return this._controlsEnabled;
  }
  set controlsEnabled(t6) {
    this._controlsEnabled = t6, this.controls.enabled = this._controlsEnabled, this.controls.enableZoom = true, t6 || this.previewMode && this._lastRotation.set(_I.d20.x, _I.d20.y, _I.d20.z);
  }
  get height() {
    var t6;
    return (null === (t6 = this.canvas) || void 0 === t6 ? void 0 : t6.height) || 1;
  }
  get isDiceThrowing() {
    return this._isDiceThrowing;
  }
  get diceCount() {
    return this.dice.size;
  }
  get previewMode() {
    return this._previewMode;
  }
  set previewMode(t6) {
    this._previewMode = t6;
  }
  get version() {
    return ci.APP_VERSION || "v0.0.1";
  }
  get width() {
    var t6;
    return (null === (t6 = this.canvas) || void 0 === t6 ? void 0 : t6.width) || 1;
  }
  initialize(t6, e2, i2, n2) {
    if (!t6 && !e2 && !i2) return this;
    if (e2 && (this.apiKey = e2, Li.remove("dddice_session")), this.api || (this.api = new Ci(this.apiKey, n2)), "object" == typeof i2 ? this.setConfig(i2) : this.setConfig(_MI.DefaultConfig), t6) {
      if (this.config.previewMode && (this.previewMode = true), this.canvas = t6, this.initRenderer(), this.initCamera(), this.initAudioListener(), this.initControls(), this.initScene(), this.initPhysics(), this.initListeners(), this.initWindowListeners(), this.initStats(), this.camera && this.renderer) {
        this.composer = new xx(this.renderer);
        const t7 = new cx(this.scene, this.camera);
        this.composer.addPass(t7);
      }
      const { clientWidth: e3, clientHeight: i3 } = this.canvas;
      this.resize(e3, i3);
    }
    return wI.info("Engine constructed"), this;
  }
  off(t6) {
    return this.events.delete(t6), this;
  }
  on(t6, e2) {
    return this.events.set(t6, e2), this;
  }
  pickUpRollsForUser(t6) {
    return yI(this, void 0, void 0, (function* () {
      if (!this.api || !this.api.roomSlug) throw new hi();
      const e2 = this.getRollsFromDice(t6).map(((t7) => {
        var e3;
        return t7.room = { slug: null === (e3 = this.api) || void 0 === e3 ? void 0 : e3.roomSlug }, t7;
      }));
      e2.length > 0 && (yield this.pickUpRoll(e2));
    }));
  }
  unhideRoll(t6, e2 = []) {
    if (!this.api) throw new hi();
    const i2 = e2.length > 0 ? e2 : t6.values.map((({ uuid: t7 }) => t7));
    return this.unhideDiceByUuid(i2), this.api.roll.update(t6.uuid, { dice: i2.map(((t7) => ({ uuid: t7, is_hidden: false }))), room: t6.room.slug });
  }
  boardHeight() {
    return this.config.camera.distance * Math.tan((function(t6) {
      const e2 = Math.PI;
      return t6 * (e2 / 180);
    })(this.config.camera.fov)) - 1;
  }
  boardWidth() {
    var t6, e2;
    const i2 = ((null === (t6 = this.canvas) || void 0 === t6 ? void 0 : t6.clientWidth) || 1) / ((null === (e2 = this.canvas) || void 0 === e2 ? void 0 : e2.clientHeight) || 1);
    return this.boardHeight() * i2;
  }
  adjustAmbientDiceSoundsVolume() {
    let t6 = 0;
    this.dice.forEach(((e2) => {
      e2.hasSound(Ei.Always) && t6++;
    })), this.dice.forEach(((e2) => {
      e2.setSoundVolume(Ei.Always, 1 / t6);
    }));
  }
  attachSound(t6, e2, i2, n2) {
    var r2;
    if ("string" == typeof t6) {
      const i3 = this.sounds[t6];
      i3 && this._attachSound(e2, i3, n2);
    } else {
      const s2 = this.sounds[t6[null !== (r2 = i2.id) && void 0 !== r2 ? r2 : i2]];
      s2 && this._attachSound(e2, s2, n2);
    }
  }
  _attachSound(t6, e2, i2) {
    t6.addSound(new Ng(this.audioListener).setBuffer(e2), i2);
  }
  fadeOutDiceByUuid(t6) {
    if (this.isDiceThrowing) setTimeout((() => this.fadeOutDiceByUuid(t6)), 300);
    else {
      this.dispatch(vi.RollFadeStarted);
      for (const e2 of t6) {
        const t7 = this.dice.get(e2);
        t7 && (t7.shouldFadeOut = true, this.physics.remove(t7.getPhysicsBody()));
      }
    }
  }
  listen(t6, e2) {
    if (!this.api) throw new hi();
    return this.api.listen(t6, e2), this;
  }
  removeDiceIfOverLimit(t6) {
    if (this.dice.size > t6) {
      let e2 = 0;
      this.dice.forEach(((i2, n2) => {
        ++e2 > t6 && this.removeDieByUuid(n2);
      }));
    }
  }
  removeDieByUuid(t6) {
    var e2;
    const i2 = this.dice.get(t6);
    i2 && (this.outlinePasses[t6] && (null === (e2 = this.composer) || void 0 === e2 || e2.removePass(this.outlinePasses[t6])), i2.removeFromScene(this.scene, this.physics)), this.dice.delete(t6);
  }
};
function TI(t6, e2) {
  let i2;
  if (void 0 !== t6) i2 = Object.assign({}, t6);
  else {
    if (void 0 === e2) return i2;
    i2 = {};
  }
  for (const t7 in e2) i2[t7] = e2[t7];
  return i2;
}
MI.DefaultConfig = { audio: true, bgColor: 0, bgOpacity: 0, camera: { fov: 15, distance: 50, position: { x: 0, y: 50, z: 0 }, rotation: { x: 0, y: 0, z: 0 }, quaternion: { x: 0, y: 0, z: 0, w: 0 } }, drawDebug: { infoPane: false, clearColor: false, collisionMeshes: false }, dice: { size: 1, limit: 25, drawOutlines: true, throw: { directionCone: 30, distance: 0.8, height: 2, maxSpin: 900, posRandom: 0.19, speedHor: 45, speedRandom: 1, speedVert: 35 } }, light: { ambientColor: 16777215, ambientIntensity: 0.5, castShadows: true, direction: { x: 10, y: 50, z: 10 }, directionalColor: 16777215, directionalIntensity: 0.33 }, physics: { gravity: { x: 0, y: -9.82, z: 0 } }, persistRolls: false, autoClear: 10 }, MI.isWebGLAvailable = () => {
  try {
    const t6 = document.createElement("canvas");
    return !(!window.WebGLRenderingContext || !t6.getContext("webgl") && !t6.getContext("experimental-webgl"));
  } catch (t6) {
    return false;
  }
}, MI.compareEventValue = (t6, e2) => {
  const i2 = t6 === Number(e2), n2 = [">=", ">", "<=", "<", "==", "="];
  for (const i3 of n2) if (`${e2}`.indexOf(i3) >= 0) {
    const n3 = t6;
    if (">=" === i3) return n3 >= Number(`${e2}`.replace(i3, ""));
    if (">" === i3) return n3 > Number(`${e2}`.replace(i3, ""));
    if ("<=" === i3) return n3 <= Number(`${e2}`.replace(i3, ""));
    if ("<" === i3) return n3 < Number(`${e2}`.replace(i3, ""));
    if ("=" === i3 || "==" === i3) return n3 === Number(`${e2}`.replace(i3, ""));
  }
  return i2;
};
var EI = class extends Error {
  constructor(t6, e2) {
    super(t6), this.available_dice = e2;
  }
};
function AI(t6, e2, i2) {
  const n2 = LI(e2) ? e2.id : e2, r2 = [], s2 = {}, o2 = (function(t7) {
    const e3 = [];
    let i3 = t7.trim();
    const n3 = /^(\d*)(d\d+)/, r3 = /^(\d+)([d\s]?[a-zA-Z]+\s*)([kd][hl]\d+|[(){}+\-*/,]|$)/, s3 = /^(round\(|ceil\(|floor\()/, o3 = /^([kd])([hl]?\d+)/, a3 = /^([(){}+\-*/,])/, l3 = /^\d+/, c3 = /^\s+/;
    for (; i3.length > 0; ) {
      let t8;
      if (null !== (t8 = n3.exec(i3))) {
        const n4 = t8[1] ? parseInt(t8[1]) : 1;
        e3.push("(");
        for (let i4 = 0; i4 < n4; i4++) e3.push(`${t8[2]}`);
        e3.push(")"), i3 = i3.substring(t8[0].length);
      } else if (null !== (t8 = r3.exec(i3))) {
        const n4 = parseInt(t8[1]);
        e3.push("(");
        for (let i4 = 0; i4 < n4; i4++) e3.push(`${t8[2].trimRight()}`);
        e3.push(")"), i3 = i3.substring(t8[1].length + t8[2].length);
      } else if (null !== (t8 = s3.exec(i3))) e3.push(t8[0]), i3 = i3.substring(t8[0].length);
      else if (null !== (t8 = o3.exec(i3))) e3.push(t8[1]), e3.push(t8[2]), i3 = i3.substring(t8[0].length);
      else if (null !== (t8 = a3.exec(i3))) e3.push(t8[0].replace("{", "(").replace("}", ")")), i3 = i3.substring(t8[0].length);
      else if (null !== (t8 = l3.exec(i3))) {
        if (e3.length > 2 && "-" === e3.at(-1)) {
          const i4 = e3.at(-2);
          "*" === i4 || "/" === i4 ? (e3.pop(), e3.push(`-${t8[0]}`)) : "+" === i4 ? (e3.pop(), e3.pop(), e3.push("-"), e3.push(t8[0])) : "-" === i4 ? (e3.pop(), e3.pop(), e3.push("+"), e3.push(t8[0])) : e3.push(t8[0]);
        } else e3.push(t8[0]);
        i3 = i3.substring(t8[0].length);
      } else {
        if (null === (t8 = c3.exec(i3))) throw new Error(`invalid dice equation starting at: "${i3}"`);
        i3 = i3.substring(t8[0].length);
      }
    }
    return e3;
  })(t6), a2 = [], l2 = [], c2 = [], h2 = [], u2 = i2 ? [...i2] : [];
  for (o2.forEach(((t7) => {
    if ((function(t8) {
      return t8 && t8.length > 1 && t8.endsWith("(");
    })(t7)) a2.push(t7.substring(0, t7.length - 1)), l2.push([]), a2.push("("), l2.push([]);
    else if (PI(t7) && "(" === t7) a2.push(t7), l2.push([]);
    else if (PI(t7) && ")" === t7) {
      for (; "(" != a2.at(-1); ) if (zI(c2, a2, r2, l2), FI(s2, a2, c2, h2.at(-1)), 0 === a2.length) throw new Error("mismatched parentheses");
      "(" == a2.at(-1) && a2.pop();
      const t8 = l2.pop();
      t8 && t8.length > 0 && h2.push(t8);
    } else if ((function(t8) {
      return Object.keys(CI).some(((e3) => e3 === t8));
    })(t7)) {
      for (; void 0 !== a2.at(-1) && "(" != a2.at(-1) && II(a2.at(-1)) <= II(t7); ) zI(c2, a2, r2, l2), FI(s2, a2, c2, h2.at(-1));
      if ("*" === t7 && (1 === r2.length || 1 === a2.length && ("+" === a2[0] || "(" === a2[0]))) {
        const t8 = r2.at(-1);
        t8 && !t8.type && (c2.push(r2.pop()), l2.forEach(((t9) => t9 && t9.pop())));
      }
      a2.push(t7);
    } else if ((function(t8) {
      return RI(t8) || /[hl]\d+/.test(t8);
    })(t7)) l2.forEach(((t8) => t8 && t8.push(r2.length))), r2.push(t7);
    else {
      if (LI(e2)) {
        let i3 = "";
        if ("d100" === t7 ? (DI(e2, "d10") || (i3 = "d10"), DI(e2, "d10x") || (i3 = "d10x")) : DI(e2, t7) || (i3 = t7.startsWith("d") ? `${t7}` : `${t7.trim()} die`), i3) throw new EI(`Theme is missing a ${i3}.`, `Available dice are: ${OI(e2.available_dice)}`);
      }
      l2.forEach(((t8) => t8 && t8.push(r2.length))), "d100" === t7 ? (function(t8, e3) {
        return e3 ? [{ theme: t8, type: "d10", value: (e3 - 1) % 10 + 1 }, { theme: t8, type: "d10x", value: 0 === Math.ceil(e3 / 10 - 1) ? 10 : Math.ceil(e3 / 10 - 1), value_to_display: "" + 10 * Math.ceil(e3 / 10 - 1) }] : [{ theme: t8, type: "d10" }, { theme: t8, type: "d10x" }];
      })(n2, i2 ? parseInt(u2.shift()) : void 0).map(((t8) => {
        r2.push(t8);
      })) : i2 ? r2.push({ theme: n2, type: t7, value: parseInt(u2.shift()) }) : r2.push({ theme: n2, type: t7 });
    }
  })); a2.length > 0; ) {
    if ("(" === a2.at(-1)) throw new Error("mismatched parentheses");
    if (zI(c2, a2, r2, l2), !h2.at(-1)) throw Error(`operator ${a2.at(-1)} expected dice but got none`);
    FI(s2, a2, c2, h2.at(-1));
  }
  for (; c2.length > 0; ) {
    const t7 = c2.pop();
    t7 && r2.push(t7);
  }
  return Object.keys(s2).forEach(((t7) => {
    Object.keys(s2[t7]).forEach(((e3) => {
      s2[t7][e3].length >= r2.length && (s2[t7] = e3);
    }));
  })), { dice: r2.map(((t7) => RI(t7) ? { type: "mod", value: parseFloat(t7) } : t7)), operator: s2 };
}
var CI = { "*": 2, "/": 2, "^": 1, ceil: 2, floor: 2, round: 2, d: 3, k: 3, "+": 4, ",": 4, "-": 4 };
function RI(t6) {
  return !isNaN(parseFloat(t6));
}
function PI(t6) {
  return "string" == typeof t6;
}
function LI(t6) {
  return "object" == typeof t6 && "id" in t6 && "available_dice" in t6 && Array.isArray(t6.available_dice);
}
function II(t6) {
  return CI[t6];
}
var DI = (t6, e2) => t6.available_dice.some(((t7) => {
  var i2, n2, r2;
  return (null === (i2 = t7.notation) || void 0 === i2 ? void 0 : i2.toLowerCase()) === e2.toLowerCase() || (null === (n2 = t7.id) || void 0 === n2 ? void 0 : n2.toLowerCase()) === e2.toLowerCase() || (null === (r2 = t7.type) || void 0 === r2 ? void 0 : r2.toLowerCase()) === e2.toLowerCase() || ("string" == typeof t7 || t7 instanceof String) && t7.toLowerCase() === e2.toLowerCase();
}));
var OI = (t6) => Array.from(new Set(t6.map(((t7) => {
  var e2, i2, n2;
  return null !== (n2 = null !== (i2 = null !== (e2 = t7.notation) && void 0 !== e2 ? e2 : t7.id) && void 0 !== i2 ? i2 : t7.type) && void 0 !== n2 ? n2 : t7;
})))).join(", ");
function zI(t6, e2, i2, n2) {
  let r2;
  switch (e2.at(-1)) {
    case "ceil":
    case "floor":
    case "round": {
      const i3 = e2.pop();
      i3 && (r2 = { ceil: "up", floor: "down", round: "nearest" }[i3], e2.push("round"), t6.push(r2));
      break;
    }
    case "k":
    case "d":
      if (r2 = i2.pop(), !r2) throw new Error(`operator ${e2.at(-1)} missing right hand operand Ex: h1`);
      if (r2.type) throw new Error("right hand side of keep cannot be a die");
      if (!/^[hl]\d+$/.test(r2)) throw new Error(`invalid operand ${r2} to operator ${e2.at(-1)}`);
      t6.push(r2), n2.forEach(((t7) => null == t7 ? void 0 : t7.pop()));
      break;
    case "*":
    case "/":
      r2 = i2.at(-1), r2 && !r2.type && 0 === t6.length && (t6.push(i2.pop()), n2.forEach(((t7) => null == t7 ? void 0 : t7.pop())));
      break;
    case "-":
      r2 = i2.at(-1), r2 && r2.type ? (e2.pop(), e2.push("*"), t6.push(-1)) : i2.push(-1 * i2.pop());
  }
}
function FI(t6, e2, i2, n2, r2 = false) {
  const s2 = e2.pop();
  if (II(s2) != II("+") && i2.length > 0) {
    const e3 = i2.pop();
    r2 ? t6[s2] = e3 : t6[s2] ? t6[s2][e3] ? n2 && t6[s2][e3].push(...n2) : t6[s2][e3] = [...n2] : t6[s2] = { [e3]: [...n2] };
  }
  return t6;
}
"undefined" != typeof window && (window.Pusher = u(), window.ThreeDDice = MI, window.ThreeDDiceAPI = Ci);
var NI = n.JX;
var BI = n.LG;
var kI = n.YL;
var UI = n.zt;
var HI = n.s2;
var VI = n.PA;
var jI = n.af;
var GI = n.xu;
var WI = n.ll;
var qI = n.QH;
var XI = n.P5;
var YI = n.MZ;
var ZI = n.$C;
var JI = n.jB;
var KI = n.wA;
var $I = n.KR;
var QI = n.kS;
var tD = n.cL;
var eD = n.Hu;
var iD = n.RN;
var nD = n.JY;
export {
  NI as APIConnectError,
  BI as APIError,
  kI as APIRoomConnectError,
  UI as ClickBehavior,
  HI as DiceEvent,
  VI as DiceSize,
  jI as IDieType,
  GI as IDirection,
  WI as MissingDieError,
  qI as ParticleSystemStates,
  XI as PickUp,
  YI as RollError,
  ZI as TextSize,
  JI as ThemeSyntaxError,
  KI as ThreeDDice,
  $I as ThreeDDiceAPI,
  QI as ThreeDDiceDiceBoxEvent,
  tD as ThreeDDiceDieEvent,
  eD as ThreeDDiceRollEvent,
  iD as ThreeDDiceRoomEvent,
  nD as parseRollEquation
};
//# sourceMappingURL=dddice-js.js.map
